<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    06_MySQL中的常用锁类型 |
    
    轻松的洛亓
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-06_MySQL中的常用锁类型" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    06_MySQL中的常用锁类型
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/post/06_mysql-commonly-used-lock-type-46hp5.html" class="article-date">
  <time datetime="2023-06-08T17:04:06.296Z" itemprop="datePublished">2023-06-08</time>
</a>
      
<div class="article-category">
  <a class="article-category-link" href="/categories/posts/">_posts</a>
</div>

    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h1 id="06-MySQL中的常用锁类型"><a href="#06-MySQL中的常用锁类型" class="headerlink" title="06_MySQL中的常用锁类型"></a>06_MySQL中的常用锁类型</h1><p>‍</p>
<p>根据加锁的范围，<strong>MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p>
<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，<strong>之后其他线程的以下语句会被阻塞</strong>：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>‍</p>
<p><strong>说一下全局锁的使用场景。</strong></p>
<p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，<strong>然后对整个库做备份</strong>（在备份过程中整个库完全处于只读状态）。</p>
<p>当数据库的默认隔离级别是是可重复读，MySQL 是能够通过MVVC拿到一致性视图的；</p>
<p>但是对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
<p>一般来说对于DBA , 对方会建议MySQL 使用的数据库存储引擎使用的 <strong>InnoDB ​</strong>而不是 MyISAM。</p>
<p>‍</p>
<p><strong>比较一下两种使整个库处于只读的方式。</strong></p>
<p>一种是上面说的 FTWRL的方式，还有一种是<strong>使用 set global readonly&#x3D;true 的方式做到全库只读。</strong></p>
<p>一般还是会建议用 FTWRL 方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</li>
<li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，<strong>那么 MySQL 会自动释放这个全局</strong>锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p>‍</p>
<p>‍</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是对整个表进行锁定，可以保证在操作过程中其他事务不能对表进行修改操作。</p>
<p>表级锁是一种对整个表进行锁定的机制，可以保证数据的一致性和完整性，但也会带来性能上的损失，因为其他事务需要等待锁释放才能进行操作。</p>
<p>在实际应用中，需要根据具体情况选择合适的锁机制来保证数据的安全和性能的平衡。</p>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁是对整个表进行锁定，当一个事务对表进行修改时，其他事务必须等待锁释放才能进行修改。</p>
<p>表锁分为读锁和写锁，当一个事务对表进行读操作时，<strong>其他事务可以同时对表进行读操作，但不能进行写操作</strong>；</p>
<p>当一个事务对表<strong>进行写操作时，其他事务不能对表进行读或写操作</strong>。</p>
<p>‍</p>
<p>表锁是通过 <code>lock tables</code>​ 语法进行设置的(**表锁的语法是 lock tables … read&#x2F;write)**。</p>
<p>语法中可以指定需要锁定的表以及锁的类型（读锁或写锁）。在执行 <code>lock tables</code>​ 后，其他线程对于被锁定的表的写操作或者读写操作将会被阻塞。在该线程释放锁之前，该线程只能对被锁定的表进行读操作或者读写操作，而不能进行写操作，也不能访问其他表。</p>
<p>需要通过 <code>unlock tables</code>​ 来主动释放锁，或者在客户端断开连接时自动释放。</p>
<p>在没有更细粒度的锁机制出现之前，表锁是最常用的处理并发的方式。但是对于支持行锁的引擎（比如InnoDB），一般不使用 <code>lock tables</code>​ 命令来控制并发，因为锁住整个表的影响面太大，而且也不能够实现更好的并发控制。</p>
<p>因此，在使用InnoDB等支持行锁的引擎时，建议使用更细粒度的锁机制来实现并发控制。</p>
<p>‍</p>
<p>‍</p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>元数据锁（MDL）是MySQL5.5版本引入的新锁机制，主要用于保护表结构的修改。</p>
<p>在实际应用中，MDL锁可以有效地保护表结构的一致性和完整性。当一个事务对表进行修改时，需要获取MDL读锁，其他事务可以同时对表进行读操作，<strong>但不能进行写操作</strong>。当一个事务对表进行结构修改时，<strong>需要获取MDL写锁</strong>，此时其他事务不能对表进行读或写操作。</p>
<p>MDL （元数据锁）不需要显式使用，在访问一个表的时候会被自动加上。MDL锁是一种读锁，<strong>它并不会阻塞其他事务对表的读取操作，只会阻塞其他事务对表结构的修改操作</strong>。</p>
<p>在实际应用中，MDL锁可以有效地保护表结构的一致性和完整性。</p>
<p>‍</p>
<p>虽然 MDL 锁是系统默认会加的，但却是不能忽略的一个机制。</p>
<p>比如下面这个例子，经常有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p>
<p>例子A:</p>
<p>我们来看一下下面的操作序列，假设表 t 是一个小表。</p>
<p>​<img src="/assets/7cf6a3bf90d72d1f0fc156ececdfb0ce-20230423000033-8bjm0yp.jpg" alt="img">​</p>
<p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。</p>
<p>由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p>
<p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p>
<p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。</p>
<p>前面我们说了，<strong>所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住</strong>，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的 MDL 锁，<strong>在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到</strong>​<strong>整个事务提交后****再释放。</strong></p>
<p>因此，在实际应用中，<strong>需要注意长事务的问题，及时提交事务以释放MDL锁。</strong></p>
<p>‍</p>
<p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。</p>
<p>如果你要做 DDL 变更的表刚好有长事务在执行，<strong>要考虑先暂停 DDL，或者 kill 掉这个长事务。</strong></p>
<p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候 kill 可能未必管用，因为新的请求马上就来了。</p>
<p>比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>
<p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT&#x2F;WAIT n 这个语法（设置等待时间）。</p>
<p>‍</p>
<p>、</p>
<p>‍</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>在 MySQL 中，行锁是一种粒度更细的锁，它只锁定表中的某一行数据，而不是锁定整个表或某个区间。<strong>行锁可以有效地减少锁的冲突，提高并发性能。</strong></p>
<p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</strong></p>
<p>‍</p>
<p>了解行锁前，我们去了解一下一些常用概念。</p>
<p>数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，<strong>要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong>。我给你举个例子。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。（将最可能造成锁冲突的锁尽量往后放）</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<p>好了，现在由于你的正确设计<strong>，影院余额这一行的行锁在一个事务中不会停留很长时间</strong>。</p>
<p>但是，这并没有完全解决你的困扰。</p>
<p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。</p>
<p>你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？这里，我就要说到死锁和死锁检测了。</p>
<p>‍</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>示例说明：</p>
<p>​<img src="/assets/4d0eeec7b136371b79248a0aed005a52-20230423000033-24hkuyw.jpg" alt="img">​</p>
<p>这时候，事务 A 在等待事务 B 释放 id&#x3D;2 的行锁，而事务 B 在等待事务 A 释放 id&#x3D;1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，<strong>即：主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然<strong>最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</strong></p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，<strong>死锁检测要耗费大量的 CPU 资源。</strong></p>
<p>‍</p>
<p><strong>如何优化死锁检测带来的消耗大量CPU资源问题。</strong></p>
<p><strong>临时把死锁检测关掉</strong></p>
<p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
<p>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
<p>‍</p>
<p><strong>控制并发度</strong></p>
<p>解决由热点行更新导致的性能问题的思路是控制并发度。</p>
<p>可以在客户端或者数据库服务端做并发控制，对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p><strong>此外，</strong>也可以通过将一行改成逻辑上的多行来减少锁冲突。例如，将一行账户改成多个记录，影院的账户总额等于这多个记录的值的总和，每次要给影院账户加金额的时候，随机选其中一条记录来加，<strong>这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗</strong>。但这类方案需要根据业务逻辑做详细设计。</p>
<p>‍</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/06_mysql-commonly-used-lock-type-46hp5.html" data-id="cline1vpx0005e7n47whnfsqz" class="article-share-link">
        分享
      </a>
      
<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MYSQL/" rel="tag">MYSQL</a></li></ul>

    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/post/05_early-explain-the-index-below-1aw7tg.html" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      05_深入浅出索引（下）
      
    </div>
  </a>
  
  
  <a href="/2023/06/08/hello-world/" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">Hello World</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>轻松的洛亓 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="轻松的洛亓"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>