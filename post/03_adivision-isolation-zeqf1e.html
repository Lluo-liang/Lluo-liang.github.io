<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  
  
  
  <title>
    03_事务隔离 |
    
    轻松的洛亓
  </title>
  <!-- Icon -->
  
    <link rel="shortcut icon" href="/favicon.ico">
    
  
<link rel="stylesheet" href="/css/style.css">

  
  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<script src="/js/pace.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <main class="content">
    <section class="outer">
  <article id="post-03_adivision-isolation-zeqf1e" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
      
  
  <h1 class="article-title" itemprop="name">
    03_事务隔离
  </h1>
  
  

    </header>
    

    
    <div class="article-meta">
      <a href="/post/03_adivision-isolation-zeqf1e.html" class="article-date">
  <time datetime="2023-11-10T07:14:27.920Z" itemprop="datePublished">2023-11-10</time>
</a>
      
    </div>
    

    
    
<div class="tocbot"></div>

    

    <div class="article-entry" itemprop="articleBody">
      
      
      
        <h1 id="03-事务隔离"><a href="#03-事务隔离" class="headerlink" title="03_事务隔离"></a>03_事务隔离</h1><p>‍</p>
<p>‍</p>
<h3 id="一，事务隔离"><a href="#一，事务隔离" class="headerlink" title="一，事务隔离"></a>一，事务隔离</h3><p>事务的概念：</p>
<p>事务需要<strong>保证一组数据库操作，要么全部成功，要么全部失败</strong>；</p>
<p>事务的特性：</p>
<p>ACID是MySQL事务的四个特性，其中隔离性是指多个并发事务之间相互隔离，互不干扰，每个事务仅能看到自己的修改，而不能看到其他事务的修改。</p>
<ul>
<li>ACID概念最早由IBM的研究员在20世纪80年代提出，主要是为了解决数据库并发控制和数据一致性的问题，并逐渐成为了数据库事务的标准特性。</li>
<li><strong>ACID</strong>（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</li>
</ul>
<p>事务隔离性：</p>
<p>MySQL事务隔离性是保证数据一致性和并发控制的重要手段之一，它对于多个事务同时访问和修改同一数据的情况下，能够保证事务之间的独立性和隔离性，避免数据的不一致和冲突。</p>
<p>‍</p>
<h3 id="二，隔离级别"><a href="#二，隔离级别" class="headerlink" title="二，隔离级别"></a>二，隔离级别</h3><p>MySQL中有四种隔离级别，包括读未提交、读提交、可重复读和串行化。</p>
<ul>
<li>读未提交（<strong>read uncommitted</strong>）</li>
<li>读提交（<strong>read committed</strong>）</li>
<li>可重复读（<strong>repeatable read</strong>）、</li>
<li>串行化（<strong>serializable</strong> ）</li>
</ul>
<p>其中，读未提交是最低的隔离级别，它允许一个事务读取另一个事务未提交的数据，可能会出现脏读、不可重复读和幻读的问题。</p>
<p>读提交是一个事务提交后才能被其他事务看到，避免了脏读的问题，但可能会出现不可重复读和幻读的问题。</p>
<p>可重复读是MySQL默认的隔离级别，<strong>它保证了在一个事务执行期间，读取的数据是一致的</strong>，不会出现脏读、不可重复读和幻读的问题。</p>
<p>串行化是最高的隔离级别，它通过加锁的方式保证了事务的串行执行，避免了所有并发问题，但会导致性能问题。</p>
<p>‍</p>
<h3 id="三，脏读、不可重复读和幻读"><a href="#三，脏读、不可重复读和幻读" class="headerlink" title="三，脏读、不可重复读和幻读"></a>三，脏读、不可重复读和幻读</h3><p>数据库中由于并发访问可能导致的三种数据读取问题</p>
<h4 id="3-1-脏读"><a href="#3-1-脏读" class="headerlink" title="3.1 脏读"></a>3.1 脏读</h4><p>在隔离级别未提交读中，允许A事务读取另一个B事务未提交的数据，</p>
<p>此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据，这个现象就是脏读。</p>
<p>此时事务A读取到的数据是无效的，这种情况下，读取的数据是不准确的，因为它还没有被提交到数据库中。</p>
<p>‍</p>
<h4 id="3-2-不可重复读"><a href="#3-2-不可重复读" class="headerlink" title="3.2 不可重复读"></a>3.2 不可重复读</h4><p>不可重复读指在一个事务中多次读取同一数据，但是在这个过程中，其他事务插入、更新或删除了这条数据，导致多次读取的数据不一致。</p>
<p>这种情况下，读取的数据可能是不一致的，因为事务之间并发执行，导致数据发生了变化。</p>
<p>‍</p>
<h4 id="3-3-幻读"><a href="#3-3-幻读" class="headerlink" title="3.3 幻读"></a>3.3 幻读</h4><p>幻读指在一个事务中多次读取同一数据，但是在这个过程中，其他事务插入了新的数据，导致多次读取的数据数量不一致。这种情况下，读取的数据可能是不完整的，因为事务之间并发执行，导致数据的数量发生了变化。</p>
<p>‍</p>
<p>‍</p>
<h3 id="四，事务隔离的实现（一）"><a href="#四，事务隔离的实现（一）" class="headerlink" title="四，事务隔离的实现（一）"></a>四，事务隔离的实现（一）</h3><h4 id="4-1-MVCC"><a href="#4-1-MVCC" class="headerlink" title="4.1 MVCC"></a>4.1 MVCC</h4><p>MySQL的事务隔离性是通过多版本并发控制（MVCC）来实现的，它通过为每个事务创建一个独立的视图来保证事务之间的隔离性。</p>
<ul>
<li>在可重复读隔离级别下，<strong>视图是在事务启动时创建的</strong>，整个事务存在期间都使用这个视图。</li>
<li>在读提交隔离级别下，<strong>视图是在每个SQL语句开始执行时创建的。</strong></li>
<li>而在读未提交隔离级别下直接返回记录上的最新值，没有视图概念。</li>
<li>在串行化隔离级别下，直接用加锁的方式来避免并发访问。</li>
</ul>
<p>同时，MySQL在实现MVCC时，每条记录在更新时都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本，回滚日志会在不需要的时候被删除。</p>
<p>需要注意的是，长事务会<strong>导致系统里面存在很老的事务视图</strong>，这些事务可能会访问数据库里面的任何数据，导致大量占用存储空间，因此建议尽量避免使用长事务。</p>
<p>‍</p>
<p>‍</p>
<h4 id="4-2-默认隔离级别"><a href="#4-2-默认隔离级别" class="headerlink" title="4.2 默认隔离级别"></a>4.2 默认隔离级别</h4><p><strong>Oracle</strong> 数据库的默认隔离级别其实是：读提交；</p>
<p>MySQL 数据库的默认隔离级别是：可重复读。</p>
<p>‍</p>
<p>‍</p>
<p>‍</p>
<h3 id="五，事务隔离实现的实现（二）"><a href="#五，事务隔离实现的实现（二）" class="headerlink" title="五，事务隔离实现的实现（二）"></a>五，事务隔离实现的实现（二）</h3><h4 id="5-1-查询视图和一致性读视图"><a href="#5-1-查询视图和一致性读视图" class="headerlink" title="5.1 查询视图和一致性读视图"></a>5.1 查询视图和一致性读视图</h4><p>在 MySQL 里，有两个“视图”的概念：</p>
<ul>
<li>一个是 view。<strong>它是一个用查询语句定义的虚拟表</strong>，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，<strong>即 consistent read view</strong>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>‍</p>
<h4 id="5-2-MVCC-中的快照"><a href="#5-2-MVCC-中的快照" class="headerlink" title="5.2 MVCC 中的快照"></a>5.2 MVCC 中的快照</h4><p><strong>关于行锁与MVCC</strong></p>
<p>06_MySQL中的常用锁类型</p>
<p>前文讲到MySQL中的锁机制，因为锁会造成事务阻塞，导致并发性能会受到一定的影响。</p>
<p>多版本并发控制MVCC 可以使对同一行记录做读写的事务之间不用相互阻塞等待(写写还是要阻塞等待，<strong>因为事务对数据进行更新时会加上排他锁</strong>)，提高了事务的并发能力，可以认为<strong>MVCC是一种解决读写阻塞等待的行级锁。</strong></p>
<p>MVCC是多版本并发控制机制，顾名思义支持MVCC的数据库表中每一行数据都可能存在多个版本，对数据库的<strong>任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存</strong>，<strong>通过读写数据时读不同的版本来避免加锁阻塞</strong>。</p>
<p>‍</p>
<p><strong>InnoDB的MVCC（多版本并发控制）实现中的快照机制</strong></p>
<p>InnoDB的MVCC是通过快照机制来实现的。快照是指在某个时间点上数据库中的数据状态，可以理解为一个数据库的镜像。在InnoDB中，每个事务都有自己的快照，它可以看到在该事务开始之前已经提交的事务所提交的数据。这意味着在同一时刻，不同的事务可能会看到不同的数据状态。</p>
<p>当一个事务开始时，<strong>InnoDB会将当前时间戳记录为该事务的起始时间戳。在该事务执行期间，所有查询都会使用该事务的快照</strong>，而不是实时的数据库状态。这就使得不同的事务可以同时访问同一张表，而不会相互影响。</p>
<p>当一个事务需要修改数据时，<strong>InnoDB会将原始数据复制一份，并将修改后的数据存放在新的位置</strong>。这样做的好处是，在事务提交之前，其他事务仍然可以访问原始数据，保证了数据的一致性。同时，<strong>新的数据版本会被赋予一个更高的时间戳</strong>，以便其他事务在访问数据时可以使用正确的快照。</p>
<p>当一个事务提交时，<strong>InnoDB会将该事务的时间戳记录为提交时间戳，并将该事务所修改的数据版本标记为已提交</strong>。这样，在其他事务执行时，就可以根据事务的时间戳和数据版本信息来确定使用哪个快照，从而保证了数据的一致性。</p>
<p>总之，InnoDB的MVCC通过快照机制实现了高并发的读写操作，保证了数据的一致性，提高了数据库的并发性能</p>
<p>‍</p>
<p><strong>InnoDB的MVCC（多版本并发控制）实现中的快照机制</strong></p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。<strong>每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，</strong>记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p>​<img src="/assets/image-20230609171549-qb4xduy.png" alt="image">​</p>
<p>‍</p>
<p>‍</p>
<p><strong>语句更新产生的回滚日志</strong></p>
<p>语句更新会生成 undo log（回滚日志），在上图中，图 中的三个虚线箭头，就是 undo log；</p>
<p>而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p>
<p>‍</p>
<p>‍</p>
<p>明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>快照的机制</p>
<p>数据表中的一行记录，会生成多个版本 (row)，在隔离级别可重复读中，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“<strong>以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本</strong>”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>‍</p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，<strong>启动了但还没提交。</strong></p>
<p><strong>数组里面事务 ID 的最小值记为低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p>
<p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，<strong>有三种情况：</strong></p>
<ul>
<li><strong>未提交，不可见；</strong></li>
<li><strong>已提交</strong>，但是是在视图创建后提交的，不可见；</li>
<li>已提交，而且是在视图创建前提交的，可见。</li>
</ul>
<p>​<img src="/assets/882114aaf55861832b4270d44507695e-20230423000034-pbtf40t.png" alt="img">​</p>
<p>‍</p>
<p><strong>示例A:</strong></p>
<p>如图 所示，下面是一个记录被多个事务连续更新后的状态。</p>
<p>​<img src="/assets/68d08d277a6f7926a41cc5541d3dfced-20230423000034-qkgya7o.png" alt="img">​</p>
<p>[行状态变更图]</p>
<p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是<strong>被 transaction id 为 25 的事务更新的</strong>，因此它的 row trx_id 也是 25。</p>
<p>比如，对于图 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。</p>
<p>‍</p>
<p>示例B：</p>
<p>​<img src="/assets/823acf76e53c0bdba7beab45e72e90d6-20230423000034-yvp193t.png" alt="img">​</p>
<p>接下来，我们继续看一下图 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k&#x3D;1。</p>
<p>这里，我们不妨做如下假设：</p>
<ol>
<li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li>
<li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li>
<li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li>
</ol>
<p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p>
<p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p>
<p>​<img src="/assets/9416c310e406519b7460437cb0c5c149-20230423000034-eim9woe.png" alt="img">​</p>
<p>图 4 事务 A 查询数据逻辑图</p>
<p>从图中可以看到，**第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)**。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p>
<p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p>
<p>你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p>
<p>好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p>
<ul>
<li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li>
<li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li>
<li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li>
</ul>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p>
<p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p>
<p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<p>现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p>
<ul>
<li>(1,3) 还没提交，属于情况 1，不可见；</li>
<li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li>
<li>(1,1) 是在视图数组创建之前提交的，可见。</li>
</ul>
<p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p>
<p>‍</p>
<hr>
<h3 id="事务到底是隔离的还是不隔离的"><a href="#事务到底是隔离的还是不隔离的" class="headerlink" title="事务到底是隔离的还是不隔离的"></a>事务到底是隔离的还是不隔离的</h3><p>在可重复读级别下，<strong>视图是在事务启动时创建的</strong>，整个事务存在期间都使用这个视图。如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，<strong>事务 T 看到的仍然跟在启动时看到的一样。</strong></p>
<p>在 InnoDB 引擎中，一个事务要更新一行，如果<strong>刚好有另外一个事务拥有这一行的行锁</strong>，它又不能这么操作了，会被锁住，进入等待状态。</p>
<p>问题是，既然进入了等待状态，<strong>那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</strong></p>
<p>‍</p>
<p>示例A: </p>
<p>下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​<img src="/assets/823acf76e53c0bdba7beab45e72e90d6-20230423000034-yvp193t.png" alt="img">​</p>
<p>图 1 事务 A、B、C 的执行流程</p>
<p>这里，我们需要注意的是事务的启动时机。</p>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p>
<blockquote>
<p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p>
</blockquote>
<p>还需要注意的是，这里都是默认 autocommit&#x3D;1 （自动提交事务）。</p>
<p>在这个例子中，事务 C 没有显式地使用 begin&#x2F;commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p>
<p>这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？</p>
<p>‍</p>
<h3 id="视图的概念"><a href="#视图的概念" class="headerlink" title="视图的概念"></a>视图的概念</h3><p>在 MySQL 里，有两个“视图”的概念：</p>
<ul>
<li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>‍</p>
<h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>InnoDB的MVCC（多版本并发控制）实现中的快照机制</p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p>​<img src="/assets/image-20230609171549-qb4xduy.png" alt="image">​</p>
<p>‍</p>
<p>在可重复读隔离级别下，事务在启动的时候会创建一个快照，这个快照是基于整个数据库的。每行数据都有多个版本，每次事务更新数据时会生成一个新的版本，<strong>并把事务ID赋值给这个版本的事务ID</strong>。同时，旧版本的数据要保留，新版本中也要有信息可以直接拿到旧版本的数据。这样，每行数据的每个版本都有自己的事务ID。</p>
<p>InnoDB利用了“所有数据都有多个版本”的特性，实现了“秒级创建快照”的能力。</p>
<p>具体实现是，为每个事务构造一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。</p>
<p><strong>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位</strong>。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：未提交，不可见；已提交，但是是在视图创建后提交的，不可见；已提交，而且是在视图创建前提交的，可见。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/post/03_adivision-isolation-zeqf1e.html" data-id="closa8r4y0001m7ng2twke0rx" class="article-share-link">
        分享
      </a>
      
    </footer>

  </div>

  
  
<nav class="article-nav">
  
  <a href="/post/01_-use-hexo-to-build-a-blog-website-2qcjw6.html" class="article-nav-link">
    <strong class="article-nav-caption">前一篇</strong>
    <div class="article-nav-title">
      
      01_使用Hexo搭建一个博客网站
      
    </div>
  </a>
  
  
  <a href="/post/04_early-simple-index-top-27akdi.html" class="article-nav-link">
    <strong class="article-nav-caption">后一篇</strong>
    <div class="article-nav-title">04_深入浅出索引（上）</div>
  </a>
  
</nav>

  

  
  
  
  

</article>
</section>
    <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>轻松的洛亓 &copy; 2023</li>
      
        <li>
          
            <a href="https://beian.miit.gov.cn/" target="_blank"></a>
            
        </li>
      
      <li>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></li>
      <li>theme  <a target="_blank" rel="noopener" href="https://github.com/zhwangart/hexo-theme-ocean">Ocean</a></li>
    </ul>
    <p><ul class="list-inline">
  
  <li><i class="fe fe-smile-alt tooltip" data-tooltip="UV"></i> <span id="busuanzi_value_site_uv"></span></li>
  
  <li><i class="fe fe-bookmark tooltip" data-tooltip="PV"></i> <span id="busuanzi_value_page_pv"></span></li>
  
</ul></p>
  </div>
</footer>
  </main>
  <aside class="sidebar">
    <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/hexo.svg" alt="轻松的洛亓"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link nav-item-search" title="搜索">
        <i class="fe fe-search"></i>
        搜索
      </a>
    </li>
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      <div class="totop" id="totop">
  <i class="fe fe-rocket"></i>
</div>
    </li>
    <li class="nav-item">
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
  </aside>
  
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/jquery.justifiedGallery.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script src="/fancybox/jquery.fancybox.min.js"></script>





<script src="/js/tocbot.min.js"></script>


<script>
  // Tocbot_v4.7.0  http://tscanlin.github.io/tocbot/
  tocbot.init({
    tocSelector: '.tocbot',
    contentSelector: '.article-entry',
    headingSelector: 'h1, h2, h3, h4, h5, h6',
    hasInnerContainers: true,
    scrollSmooth: true,
    positionFixedSelector: '.tocbot',
    positionFixedClass: 'is-position-fixed',
    fixedSidebarOffset: 'auto',
  });
</script>



<script src="/js/ocean.js"></script>

</body>

</html>