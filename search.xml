<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01_使用Hexo搭建一个博客网站</title>
    <url>//post/01_-use-hexo-to-build-a-blog-website-2qcjw6.html</url>
    <content><![CDATA[<h1 id="01-使用Hexo搭建一个博客网站"><a href="#01-使用Hexo搭建一个博客网站" class="headerlink" title="01_使用Hexo搭建一个博客网站"></a>01_使用Hexo搭建一个博客网站</h1><h3 id="hexo-安装"><a href="#hexo-安装" class="headerlink" title="hexo 安装"></a>hexo 安装</h3><p><a href="https://hexo.io/zh-cn/">hexo 官网</a></p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>使用 npm 安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>

<p>初始化某个项目文件（新建目录）</p>
<p>进入目录后  hexo init</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo init  # 博客初始化 (安装所需要的包)</span><br></pre></td></tr></table></figure>

<p>目录结构</p>
<p>​<code>public</code>​目录下存放的是我们生成的<strong>「静态页面」</strong>；</p>
<p>​<code>source/_posts</code>​目录下存放的是我们写的<strong>「文章」</strong>；</p>
<p>​<code>themes</code>​目录下存放的是<strong>「博客」</strong>的主题；</p>
<p>​<code>_config.yml</code>​是<strong>「博客全局配置」</strong>文件；</p>
<p>​<code>_config.landscape.yml</code>​是<strong>「博客主题配置」</strong>文件</p>
<p>‍</p>
<h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><p>本地运行  hexo s</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s # http://localhost:4000/预览</span><br></pre></td></tr></table></figure>

<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602679.png" alt="image">​</p>
<p>访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:4000/</span><br></pre></td></tr></table></figure>

<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602981.png" alt="image">​</p>
<p>‍</p>
<h4 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h4><p>运行路径下执行命令 hexo n：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo n &quot;第一篇博客&quot; # 新建一个名为第一篇博客.md的文件</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>‍</p>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><h4 id="搭建基于ocean-主题的站点"><a href="#搭建基于ocean-主题的站点" class="headerlink" title="搭建基于ocean 主题的站点"></a>搭建基于ocean 主题的站点</h4><p><a href="https://www.zhwangart.com/">首页（主题网站）</a></p>
<p><a href="https://github.com/zhwangart/hexo-theme-ocean">ocean GiteHub地址</a></p>
<p><a href="https://www.zhwangart.com/2018/11/30/Ocean/">ocean主题安装指导文档</a></p>
<h5 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/zhwangart/hexo-theme-ocean.git themes/ocean</span><br></pre></td></tr></table></figure>

<h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><p>在 <code>root</code>​&#x2F; <code>_config.yml</code>​ 中选择 <code>theme: ocean</code>​</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">theme: ocean</span><br></pre></td></tr></table></figure>

<p><strong>Ocean</strong> 使用了 feathericon 图标库，</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://feathericons.com/</span><br></pre></td></tr></table></figure>

<p>菜单中的图标定义在“CSS source&#x2F;css &#x2F;_partial&#x2F;navbar.styl”中，可根据需要进行更改或添加。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">themes\ocean\source\css\_partial/navbar.styl</span><br></pre></td></tr></table></figure>

<p>如果你不需要开启 相册 与 关于 菜单，需要删除或者注销掉他们的图标，如下边的示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.nav-item</span><br><span class="line">  &amp;:nth-child(1)         // 主页</span><br><span class="line">    .nav-item-link</span><br><span class="line">      &amp;::before</span><br><span class="line">        content &#x27;\f12f&#x27;</span><br><span class="line">  &amp;:nth-child(2)         // 归档</span><br><span class="line">    .nav-item-link</span><br><span class="line">      &amp;::before</span><br><span class="line">        content &#x27;\f12a&#x27;</span><br><span class="line">  //&amp;:nth-child(3)         // 相册</span><br><span class="line">  //  .nav-item-link</span><br><span class="line">  //    &amp;::before</span><br><span class="line">  //      content &#x27;\f1a9&#x27;</span><br><span class="line">  //&amp;:nth-child(4)         // 关于</span><br><span class="line">  //  .nav-item-link</span><br><span class="line">  //    &amp;::before</span><br><span class="line">  //      content &#x27;\f174&#x27;</span><br></pre></td></tr></table></figure>

<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602084.png" alt="image">​</p>
<p>这里 相册和关于如果不需要可以注释一下</p>
<p>这里注释只能将图标取消掉</p>
<p>取消的话需要主题配置这里注释一下</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602148.png" alt="image">​</p>
<p>评论功能，开启标签和分类功能等功能目前跳过，后期再看</p>
<p>‍</p>
<p>‍</p>
<h5 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h5><p>插件安装（关于本地搜索功能）</p>
<p><a href="https://github.com/wzpan/hexo-generator-search">hexo-generator-search</a> 本地检索</p>
<p>安装</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>配置 Hexo 的配置文件 <code>_config.yml</code>​</p>
<p>添加插件配置（注意：不是主题的配置文件）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.xml</span><br><span class="line">  field: post</span><br><span class="line">  content: true</span><br></pre></td></tr></table></figure>

<h5 id="运行-1"><a href="#运行-1" class="headerlink" title="运行"></a>运行</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h5 id="修改标签"><a href="#修改标签" class="headerlink" title="修改标签"></a>修改标签</h5><p>如果需要需求页面的部分标签描述，需要到下面这个文件中改</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602199.png" alt="image">​</p>
<p>不是很理解这个国际化语言设置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">categories: Categories</span><br><span class="line">search: Search</span><br><span class="line">tags: Tags</span><br><span class="line">tagcloud: Tag Cloud</span><br><span class="line">tweets: Tweets</span><br><span class="line">prev: Prev</span><br><span class="line">next: Next</span><br><span class="line">comment: Comments</span><br><span class="line">archive_a: Archives</span><br><span class="line">archive_b: &quot;Archives: %s&quot;</span><br><span class="line">page: Page %d</span><br><span class="line">recent_posts: Recent Posts</span><br><span class="line">newer: Newer</span><br><span class="line">older: Older</span><br><span class="line">share: Share</span><br><span class="line">powered_by: Powered by</span><br><span class="line">rss_feed: RSS Feed</span><br><span class="line">category: Category</span><br><span class="line">tag: Tag</span><br></pre></td></tr></table></figure>

<p>这里的做法是直接用它同一路径下的 zh-CN.yml 文件内容覆盖 defalut.yml 文件内容</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602273.png" alt="image">​</p>
<p>还有部分标签，是直接在主题配置文件中直接改</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602349.png" alt="image">​</p>
<p>主页的这个属性的改变，在 F12 调试中找到是css样式 video-inner text-center text-white 中设置</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602429.png" alt="image">​</p>
<p>搜索文件后会发现这个配置是 config.subtitle 中设置的</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602566.png" alt="image">​</p>
<p>但是在这个过程中，尝试修改了挺多次，找了很多文件，不太清楚如何改</p>
<p>后面想了一下，这个属于配置文件修改，其实不管是主题配置还是项目配置修改都是生效的</p>
<p>但是需要你重启一下服务（有时候也可能是缓存问题）</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602689.png" alt="image">​</p>
<p>再次访问已经OK了</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602738.png" alt="image">​</p>
<p>网上有一些优化内容，这里暂时不参与和研究</p>
<p>‍</p>
<h3 id="部署到-GitHub"><a href="#部署到-GitHub" class="headerlink" title="部署到 GitHub"></a>部署到 GitHub</h3><p>看了一下说 Gitee 不能进行自动更新部署操作，这里还是使用 Github 作为自己的发布平台</p>
<p>安装 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>hexo 的配置文件 <code>_config.yml</code>​,  添加一下以下配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: &lt;repository url&gt; #https://github.com/Github用户名/Github用户名.github.io.git</span><br><span class="line">  branch: [branch] #published</span><br></pre></td></tr></table></figure>

<p>在自己的 Github 账号下新建仓库，</p>
<p>仓库名必须为你的<code>Github用户名.github.io</code>​</p>
<p>‍</p>
<p>在博客根目录打开Git Bash，输入以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当执行 <code>hexo deploy</code>​ 时，Hexo 会将 <code>public</code>​ 目录中的文件和目录推送至 <code>_config.yml</code>​ 中指定的远端仓库和分支中，并且<strong>完全覆盖</strong>该分支下的已有内容。</p>
<p>简单来说该指令集成了git的一部分操作</p>
</blockquote>
<p>或者（建议）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo clean                            #清除缓存       可缩写hexo c</span><br><span class="line">hexo generate                         #生成静态文件    可缩写hexo g</span><br><span class="line">hexo deploy                           #部署到Github   可缩写hexo d</span><br></pre></td></tr></table></figure>

<p>部署后访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">https://Github用户名.github.io/</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h4 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h4><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;`用户名`&quot;</span><br><span class="line">git config --global user.email &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;邮箱&quot;</span><br></pre></td></tr></table></figure>

<p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p>
<p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p>
<p>‍</p>
<p>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global url.&quot;git@github.com:&quot;.insteadOf &quot;https://github.com/&quot;</span><br></pre></td></tr></table></figure>

<p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p>
<p>配置后再部署提交</p>
<p>‍</p>
<h4 id="hexo本地与部署不一致问题"><a href="#hexo本地与部署不一致问题" class="headerlink" title="hexo本地与部署不一致问题"></a>hexo本地与部署不一致问题</h4><blockquote>
<p>这部分不用管，开始搞错了，应该是他自动进行部署了，然后将部署后 public 下内容替换了整个主分支</p>
</blockquote>
<p>一般是分支部署错了</p>
<p>不要在master分支上部署pages服务，master分支是保存代码的，需要用 hexo 编译，生成 public文件夹后，将public文件夹推到另一个分支，然后在这个分支上部署pages服务。</p>
<p>修改为分支部署</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602877.png" alt="image">​</p>
<p>hexo站点配置文件_config.yml中找到branch，将master改为刚刚新建的分支名；</p>
<p>回到站点文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo c</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>‍</p>
<p>‍</p>
<h4 id="将某个目录文件上传到-Github-某个仓库如何操作"><a href="#将某个目录文件上传到-Github-某个仓库如何操作" class="headerlink" title="将某个目录文件上传到 Github 某个仓库如何操作"></a>将某个目录文件上传到 Github 某个仓库如何操作</h4><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 初始化仓库</span><br><span class="line">git init</span><br><span class="line"># 提交到本地git仓库 将文件夹中的内容添加到git仓库</span><br><span class="line">git add .</span><br><span class="line"># 提交到本地git仓库,并添加一条提交信息</span><br><span class="line">git commit -m &quot;Initial commit&quot;</span><br><span class="line">#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联</span><br><span class="line">git remote add origin &lt;Github仓库URL&gt;</span><br><span class="line"># 进行推送</span><br><span class="line">git push -u origin master</span><br><span class="line"># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送</span><br><span class="line">git pull origin master</span><br><span class="line"># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。</span><br><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>‍</p>
<h3 id="hexo完成github-action自动部署"><a href="#hexo完成github-action自动部署" class="headerlink" title="hexo完成github action自动部署"></a>hexo完成github action自动部署</h3><p>这里实现的功能是建立了一个分支 ph-pages ，源项目内容放在 master 主分支下，实现自动部署主分支到分支上（同一个仓库下）</p>
<p>在实现这个前，先获取一个授权 token，这里必须勾选repo 项 和 workflows 项</p>
<p>访问 Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token,</p>
<p>创建的 Token 名称随意，有效期建议无限期限。</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602954.png" alt="image">​</p>
<p>点击生成</p>
<blockquote>
<p>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</p>
</blockquote>
<p>在项目 master 分支下新建文件夹</p>
<p>在 hexo 项目 中新建<code>.github</code>​文件夹,注意开头是有个<code>.</code>​的。然后在<code>.github</code>​ 内新建 <code>workflows</code>​ 文件夹，再在 <code>workflows</code>​ 文件夹内新建 <code>autodeploy.yml</code>​,</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">workflows</span><br><span class="line">autodeploy.yml</span><br></pre></td></tr></table></figure>

<p>在<code>[Blogroot]/.github/workflows/autodeploy.yml</code>​ 里面输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name: 自动部署</span><br><span class="line"># 当有改动推送到master分支时，启动Action</span><br><span class="line">on:</span><br><span class="line">  push:</span><br><span class="line">    branches:</span><br><span class="line">      - master</span><br><span class="line">      # 你提交的主分支名称</span><br><span class="line">  release:</span><br><span class="line">    types:</span><br><span class="line">      - published</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  # 部署执行的自动工作</span><br><span class="line">  deploy:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line">    steps:</span><br><span class="line">      - name: 检查分支</span><br><span class="line">        uses: actions/checkout@v3</span><br><span class="line">        with:</span><br><span class="line">          ref: master</span><br><span class="line"></span><br><span class="line">      - name: 安装 Node</span><br><span class="line">        uses: actions/setup-node@v3</span><br><span class="line">        with:</span><br><span class="line">          node-version: &quot;16.x&quot;</span><br><span class="line"></span><br><span class="line">      - name: 安装 Hexo</span><br><span class="line">        run: |</span><br><span class="line">          export TZ=&#x27;Asia/Shanghai&#x27;</span><br><span class="line">          npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line">      - name: 缓存 Hexo</span><br><span class="line">        id: cache-npm</span><br><span class="line">        uses: actions/cache@v3</span><br><span class="line">        env:</span><br><span class="line">          cache-name: cache-node-modules</span><br><span class="line">        with:</span><br><span class="line">          path: node_modules</span><br><span class="line">          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;</span><br><span class="line">          restore-keys: |</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-build-</span><br><span class="line">            $&#123;&#123; runner.os &#125;&#125;-</span><br><span class="line"></span><br><span class="line">      - name: 安装依赖</span><br><span class="line">        if: $&#123;&#123; steps.cache-npm.outputs.cache-hit != &#x27;true&#x27; &#125;&#125;</span><br><span class="line">        run: |</span><br><span class="line">          npm install gulp-cli -g #全局安装gulp</span><br><span class="line">          npm install --save</span><br><span class="line"></span><br><span class="line">      - name: 生成静态文件</span><br><span class="line">        run: |</span><br><span class="line">          hexo clean</span><br><span class="line">          hexo generate</span><br><span class="line"></span><br><span class="line">      - name: 部署到Github</span><br><span class="line">        uses: JamesIves/github-pages-deploy-action@v4</span><br><span class="line">        with:</span><br><span class="line">          token:  $&#123;&#123; secrets.ACTION_TOKEN &#125;&#125;</span><br><span class="line">          repository-name: Lluo-liang/Lluo-liang.github.io</span><br><span class="line">          branch: ph-pages</span><br><span class="line">          folder: public</span><br><span class="line">          commit-message: &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; Updated By Github Actions&quot;</span><br></pre></td></tr></table></figure>

<p>部署到 Github 下几个配置注意一下，其他内容大差不差</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602033.png" alt="image">​</p>
<p>之后如果需要自己到仓库的 Settings-&gt;Secrets-&gt;actions 下添加环境变量，变量名参考脚本中出现的，依次添加（有些环境变量是GitHub Actions自带的一个环境变量）。</p>
<p>这里配置了一个 ACTION_TOKEN 的环境变量</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602094.png" alt="image">​</p>
<p>这里的GitHub Pages的设置中 是 ph-pages分支。</p>
<p>‍</p>
<p>编辑一下 git 上传的屏蔽项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.DS_Store</span><br><span class="line">Thumbs.db</span><br><span class="line">db.json</span><br><span class="line">*.log</span><br><span class="line">node_modules/</span><br><span class="line">public/</span><br><span class="line">.deploy*/</span><br><span class="line">.deploy_git*/</span><br><span class="line">.idea</span><br><span class="line">themes/ocean/.git</span><br></pre></td></tr></table></figure>

<p>替换最后一行内容为自己当前使用的主题</p>
<p>配置完后进行提交推送</p>
<p>‍</p>
<p>部署进度查看</p>
<p>看实际的一个部署情况，可以在 Action 中 查看</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602171.png" alt="image">​</p>
<p>选择第一个，点击进去看，点击 deploy 可以查看窗口进度和实际完成情况</p>
<p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602232.png" alt="image">​</p>
<p>‍</p>
<p>如果是需要安全方面考虑，不打算将自己的源文件内容泄露，也可以建立另外一个仓库，这个仓库设置为私有，</p>
<p>也可以进行自动部署到这个公共仓库中</p>
<p>‍</p>
]]></content>
      <categories>
        <category>_posts</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>03_事务隔离</title>
    <url>//post/03_adivision-isolation-zeqf1e.html</url>
    <content><![CDATA[<h1 id="03-事务隔离"><a href="#03-事务隔离" class="headerlink" title="03_事务隔离"></a>03_事务隔离</h1><p>‍</p>
<p>‍</p>
<h3 id="一，事务隔离"><a href="#一，事务隔离" class="headerlink" title="一，事务隔离"></a>一，事务隔离</h3><p>事务的概念：</p>
<p>事务需要<strong>保证一组数据库操作，要么全部成功，要么全部失败</strong>；</p>
<p>事务的特性：</p>
<p>ACID是MySQL事务的四个特性，其中隔离性是指多个并发事务之间相互隔离，互不干扰，每个事务仅能看到自己的修改，而不能看到其他事务的修改。</p>
<ul>
<li>ACID概念最早由IBM的研究员在20世纪80年代提出，主要是为了解决数据库并发控制和数据一致性的问题，并逐渐成为了数据库事务的标准特性。</li>
<li><strong>ACID</strong>（Atomicity、Consistency、Isolation、Durability，即原子性、一致性、隔离性、持久性）</li>
</ul>
<p>事务隔离性：</p>
<p>MySQL事务隔离性是保证数据一致性和并发控制的重要手段之一，它对于多个事务同时访问和修改同一数据的情况下，能够保证事务之间的独立性和隔离性，避免数据的不一致和冲突。</p>
<p>‍</p>
<h3 id="二，隔离级别"><a href="#二，隔离级别" class="headerlink" title="二，隔离级别"></a>二，隔离级别</h3><p>MySQL中有四种隔离级别，包括读未提交、读提交、可重复读和串行化。</p>
<ul>
<li>读未提交（<strong>read uncommitted</strong>）</li>
<li>读提交（<strong>read committed</strong>）</li>
<li>可重复读（<strong>repeatable read</strong>）、</li>
<li>串行化（<strong>serializable</strong> ）</li>
</ul>
<p>其中，读未提交是最低的隔离级别，它允许一个事务读取另一个事务未提交的数据，可能会出现脏读、不可重复读和幻读的问题。</p>
<p>读提交是一个事务提交后才能被其他事务看到，避免了脏读的问题，但可能会出现不可重复读和幻读的问题。</p>
<p>可重复读是MySQL默认的隔离级别，<strong>它保证了在一个事务执行期间，读取的数据是一致的</strong>，不会出现脏读、不可重复读和幻读的问题。</p>
<p>串行化是最高的隔离级别，它通过加锁的方式保证了事务的串行执行，避免了所有并发问题，但会导致性能问题。</p>
<p>‍</p>
<h3 id="三，脏读、不可重复读和幻读"><a href="#三，脏读、不可重复读和幻读" class="headerlink" title="三，脏读、不可重复读和幻读"></a>三，脏读、不可重复读和幻读</h3><p>数据库中由于并发访问可能导致的三种数据读取问题</p>
<h4 id="3-1-脏读"><a href="#3-1-脏读" class="headerlink" title="3.1 脏读"></a>3.1 脏读</h4><p>在隔离级别未提交读中，允许A事务读取另一个B事务未提交的数据，</p>
<p>此时如果B事务发生错误并执行回滚操作，那么A事务读取到的数据就是脏数据，这个现象就是脏读。</p>
<p>此时事务A读取到的数据是无效的，这种情况下，读取的数据是不准确的，因为它还没有被提交到数据库中。</p>
<p>‍</p>
<h4 id="3-2-不可重复读"><a href="#3-2-不可重复读" class="headerlink" title="3.2 不可重复读"></a>3.2 不可重复读</h4><p>不可重复读指在一个事务中多次读取同一数据，但是在这个过程中，其他事务插入、更新或删除了这条数据，导致多次读取的数据不一致。</p>
<p>这种情况下，读取的数据可能是不一致的，因为事务之间并发执行，导致数据发生了变化。</p>
<p>‍</p>
<h4 id="3-3-幻读"><a href="#3-3-幻读" class="headerlink" title="3.3 幻读"></a>3.3 幻读</h4><p>幻读指在一个事务中多次读取同一数据，但是在这个过程中，其他事务插入了新的数据，导致多次读取的数据数量不一致。这种情况下，读取的数据可能是不完整的，因为事务之间并发执行，导致数据的数量发生了变化。</p>
<p>‍</p>
<p>‍</p>
<h3 id="四，事务隔离的实现（一）"><a href="#四，事务隔离的实现（一）" class="headerlink" title="四，事务隔离的实现（一）"></a>四，事务隔离的实现（一）</h3><h4 id="4-1-MVCC"><a href="#4-1-MVCC" class="headerlink" title="4.1 MVCC"></a>4.1 MVCC</h4><p>MySQL的事务隔离性是通过多版本并发控制（MVCC）来实现的，它通过为每个事务创建一个独立的视图来保证事务之间的隔离性。</p>
<ul>
<li>在可重复读隔离级别下，<strong>视图是在事务启动时创建的</strong>，整个事务存在期间都使用这个视图。</li>
<li>在读提交隔离级别下，<strong>视图是在每个SQL语句开始执行时创建的。</strong></li>
<li>而在读未提交隔离级别下直接返回记录上的最新值，没有视图概念。</li>
<li>在串行化隔离级别下，直接用加锁的方式来避免并发访问。</li>
</ul>
<p>同时，MySQL在实现MVCC时，每条记录在更新时都会同时记录一条回滚操作，同一条记录在系统中可以存在多个版本，回滚日志会在不需要的时候被删除。</p>
<p>需要注意的是，长事务会<strong>导致系统里面存在很老的事务视图</strong>，这些事务可能会访问数据库里面的任何数据，导致大量占用存储空间，因此建议尽量避免使用长事务。</p>
<p>‍</p>
<p>‍</p>
<h4 id="4-2-默认隔离级别"><a href="#4-2-默认隔离级别" class="headerlink" title="4.2 默认隔离级别"></a>4.2 默认隔离级别</h4><p><strong>Oracle</strong> 数据库的默认隔离级别其实是：读提交；</p>
<p>MySQL 数据库的默认隔离级别是：可重复读。</p>
<p>‍</p>
<p>‍</p>
<p>‍</p>
<h3 id="五，事务隔离实现的实现（二）"><a href="#五，事务隔离实现的实现（二）" class="headerlink" title="五，事务隔离实现的实现（二）"></a>五，事务隔离实现的实现（二）</h3><h4 id="5-1-查询视图和一致性读视图"><a href="#5-1-查询视图和一致性读视图" class="headerlink" title="5.1 查询视图和一致性读视图"></a>5.1 查询视图和一致性读视图</h4><p>在 MySQL 里，有两个“视图”的概念：</p>
<ul>
<li>一个是 view。<strong>它是一个用查询语句定义的虚拟表</strong>，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，<strong>即 consistent read view</strong>，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>‍</p>
<h4 id="5-2-MVCC-中的快照"><a href="#5-2-MVCC-中的快照" class="headerlink" title="5.2 MVCC 中的快照"></a>5.2 MVCC 中的快照</h4><p><strong>关于行锁与MVCC</strong></p>
<p>06_MySQL中的常用锁类型</p>
<p>前文讲到MySQL中的锁机制，因为锁会造成事务阻塞，导致并发性能会受到一定的影响。</p>
<p>多版本并发控制MVCC 可以使对同一行记录做读写的事务之间不用相互阻塞等待(写写还是要阻塞等待，<strong>因为事务对数据进行更新时会加上排他锁</strong>)，提高了事务的并发能力，可以认为<strong>MVCC是一种解决读写阻塞等待的行级锁。</strong></p>
<p>MVCC是多版本并发控制机制，顾名思义支持MVCC的数据库表中每一行数据都可能存在多个版本，对数据库的<strong>任何修改的提交都不会直接覆盖之前的数据，而是产生一个新的版本与老版本共存</strong>，<strong>通过读写数据时读不同的版本来避免加锁阻塞</strong>。</p>
<p>‍</p>
<p><strong>InnoDB的MVCC（多版本并发控制）实现中的快照机制</strong></p>
<p>InnoDB的MVCC是通过快照机制来实现的。快照是指在某个时间点上数据库中的数据状态，可以理解为一个数据库的镜像。在InnoDB中，每个事务都有自己的快照，它可以看到在该事务开始之前已经提交的事务所提交的数据。这意味着在同一时刻，不同的事务可能会看到不同的数据状态。</p>
<p>当一个事务开始时，<strong>InnoDB会将当前时间戳记录为该事务的起始时间戳。在该事务执行期间，所有查询都会使用该事务的快照</strong>，而不是实时的数据库状态。这就使得不同的事务可以同时访问同一张表，而不会相互影响。</p>
<p>当一个事务需要修改数据时，<strong>InnoDB会将原始数据复制一份，并将修改后的数据存放在新的位置</strong>。这样做的好处是，在事务提交之前，其他事务仍然可以访问原始数据，保证了数据的一致性。同时，<strong>新的数据版本会被赋予一个更高的时间戳</strong>，以便其他事务在访问数据时可以使用正确的快照。</p>
<p>当一个事务提交时，<strong>InnoDB会将该事务的时间戳记录为提交时间戳，并将该事务所修改的数据版本标记为已提交</strong>。这样，在其他事务执行时，就可以根据事务的时间戳和数据版本信息来确定使用哪个快照，从而保证了数据的一致性。</p>
<p>总之，InnoDB的MVCC通过快照机制实现了高并发的读写操作，保证了数据的一致性，提高了数据库的并发性能</p>
<p>‍</p>
<p><strong>InnoDB的MVCC（多版本并发控制）实现中的快照机制</strong></p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。<strong>每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，</strong>记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p>​<img src="/assets/image-20230609171549-qb4xduy.png" alt="image">​</p>
<p>‍</p>
<p>‍</p>
<p><strong>语句更新产生的回滚日志</strong></p>
<p>语句更新会生成 undo log（回滚日志），在上图中，图 中的三个虚线箭头，就是 undo log；</p>
<p>而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。</p>
<p>‍</p>
<p>‍</p>
<p>明白了多版本和 row trx_id 的概念后，我们再来想一下，InnoDB 是怎么定义那个“100G”的快照的。</p>
<p>按照可重复读的定义，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>快照的机制</p>
<p>数据表中的一行记录，会生成多个版本 (row)，在隔离级别可重复读中，一个事务启动的时候，能够看到所有已经提交的事务结果。但是之后，这个事务执行期间，其他事务的更新对它不可见。</p>
<p>因此，一个事务只需要在启动的时候声明说，“<strong>以我启动的时刻为准，如果一个数据版本是在我启动之前生成的，就认；如果是我启动以后才生成的，我就不认，我必须要找到它的上一个版本</strong>”。</p>
<p>当然，如果“上一个版本”也不可见，那就得继续往前找。还有，如果是这个事务自己更新的数据，它自己还是要认的。</p>
<p>‍</p>
<p>在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，<strong>启动了但还没提交。</strong></p>
<p><strong>数组里面事务 ID 的最小值记为低水位</strong>，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的 row trx_id 和这个一致性视图的对比结果得到的。</p>
<p>这个视图数组把所有的 row trx_id 分成了几种不同的情况。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，<strong>有三种情况：</strong></p>
<ul>
<li><strong>未提交，不可见；</strong></li>
<li><strong>已提交</strong>，但是是在视图创建后提交的，不可见；</li>
<li>已提交，而且是在视图创建前提交的，可见。</li>
</ul>
<p>​<img src="/assets/882114aaf55861832b4270d44507695e-20230423000034-pbtf40t.png" alt="img">​</p>
<p>‍</p>
<p><strong>示例A:</strong></p>
<p>如图 所示，下面是一个记录被多个事务连续更新后的状态。</p>
<p>​<img src="/assets/68d08d277a6f7926a41cc5541d3dfced-20230423000034-qkgya7o.png" alt="img">​</p>
<p>[行状态变更图]</p>
<p>图中虚线框里是同一行数据的 4 个版本，当前最新版本是 V4，k 的值是 22，它是<strong>被 transaction id 为 25 的事务更新的</strong>，因此它的 row trx_id 也是 25。</p>
<p>比如，对于图 中的数据来说，如果有一个事务，它的低水位是 18，那么当它访问这一行数据时，就会从 V4 通过 U3 计算出 V3，所以在它看来，这一行的值是 11。</p>
<p>‍</p>
<p>示例B：</p>
<p>​<img src="/assets/823acf76e53c0bdba7beab45e72e90d6-20230423000034-yvp193t.png" alt="img">​</p>
<p>接下来，我们继续看一下图 中的三个事务，分析下事务 A 的语句返回的结果，为什么是 k&#x3D;1。</p>
<p>这里，我们不妨做如下假设：</p>
<ol>
<li>事务 A 开始前，系统里面只有一个活跃事务 ID 是 99；</li>
<li>事务 A、B、C 的版本号分别是 100、101、102，且当前系统里只有这四个事务；</li>
<li>三个事务开始前，(1,1）这一行数据的 row trx_id 是 90。</li>
</ol>
<p>这样，事务 A 的视图数组就是 [99,100], 事务 B 的视图数组是 [99,100,101], 事务 C 的视图数组是 [99,100,101,102]。</p>
<p>为了简化分析，我先把其他干扰语句去掉，只画出跟事务 A 查询逻辑有关的操作：</p>
<p>​<img src="/assets/9416c310e406519b7460437cb0c5c149-20230423000034-eim9woe.png" alt="img">​</p>
<p>图 4 事务 A 查询数据逻辑图</p>
<p>从图中可以看到，**第一个有效更新是事务 C，把数据从 (1,1) 改成了 (1,2)**。这时候，这个数据的最新版本的 row trx_id 是 102，而 90 这个版本已经成为了历史版本。</p>
<p>第二个有效更新是事务 B，把数据从 (1,2) 改成了 (1,3)。这时候，这个数据的最新版本（即 row trx_id）是 101，而 102 又成为了历史版本。</p>
<p>你可能注意到了，在事务 A 查询的时候，其实事务 B 还没有提交，但是它生成的 (1,3) 这个版本已经变成当前版本了。但这个版本对事务 A 必须是不可见的，否则就变成脏读了。</p>
<p>好，现在事务 A 要来读数据了，它的视图数组是 [99,100]。当然了，读数据都是从当前版本读起的。所以，事务 A 查询语句的读数据流程是这样的：</p>
<ul>
<li>找到 (1,3) 的时候，判断出 row trx_id&#x3D;101，比高水位大，处于红色区域，不可见；</li>
<li>接着，找到上一个历史版本，一看 row trx_id&#x3D;102，比高水位大，处于红色区域，不可见；</li>
<li>再往前找，终于找到了（1,1)，它的 row trx_id&#x3D;90，比低水位小，处于绿色区域，可见。</li>
</ul>
<p>这样执行下来，虽然期间这一行数据被修改过，但是事务 A 不论在什么时候查询，看到这行数据的结果都是一致的，所以我们称之为一致性读。</p>
<p>这个判断规则是从代码逻辑直接转译过来的，但是正如你所见，用于人肉分析可见性很麻烦。</p>
<p>所以，我来给你翻译一下。一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：</p>
<ol>
<li>版本未提交，不可见；</li>
<li>版本已提交，但是是在视图创建后提交的，不可见；</li>
<li>版本已提交，而且是在视图创建前提交的，可见。</li>
</ol>
<p>现在，我们用这个规则来判断图 4 中的查询结果，事务 A 的查询语句的视图数组是在事务 A 启动的时候生成的，这时候：</p>
<ul>
<li>(1,3) 还没提交，属于情况 1，不可见；</li>
<li>(1,2) 虽然提交了，但是是在视图数组创建之后提交的，属于情况 2，不可见；</li>
<li>(1,1) 是在视图数组创建之前提交的，可见。</li>
</ul>
<p>你看，去掉数字对比后，只用时间先后顺序来判断，分析起来是不是轻松多了。所以，后面我们就都用这个规则来分析。</p>
<p>‍</p>
<hr>
<h3 id="事务到底是隔离的还是不隔离的"><a href="#事务到底是隔离的还是不隔离的" class="headerlink" title="事务到底是隔离的还是不隔离的"></a>事务到底是隔离的还是不隔离的</h3><p>在可重复读级别下，<strong>视图是在事务启动时创建的</strong>，整个事务存在期间都使用这个视图。如果是可重复读隔离级别，事务 T 启动的时候会创建一个视图 read-view，之后事务 T 执行期间，即使有其他事务修改了数据，<strong>事务 T 看到的仍然跟在启动时看到的一样。</strong></p>
<p>在 InnoDB 引擎中，一个事务要更新一行，如果<strong>刚好有另外一个事务拥有这一行的行锁</strong>，它又不能这么操作了，会被锁住，进入等待状态。</p>
<p>问题是，既然进入了等待状态，<strong>那么等到这个事务自己获取到行锁要更新数据的时候，它读到的值又是什么呢？</strong></p>
<p>‍</p>
<p>示例A: </p>
<p>下面是一个只有两行的表的初始化语句。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">mysql<span class="operator">&gt;</span> <span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t` (</span><br><span class="line">  `id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  `k` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB;</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> t(id, k) <span class="keyword">values</span>(<span class="number">1</span>,<span class="number">1</span>),(<span class="number">2</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>​<img src="/assets/823acf76e53c0bdba7beab45e72e90d6-20230423000034-yvp193t.png" alt="img">​</p>
<p>图 1 事务 A、B、C 的执行流程</p>
<p>这里，我们需要注意的是事务的启动时机。</p>
<p>begin&#x2F;start transaction 命令并不是一个事务的起点，在执行到它们之后的第一个操作 InnoDB 表的语句，事务才真正启动。如果你想要马上启动一个事务，可以使用 start transaction with consistent snapshot 这个命令。</p>
<blockquote>
<p>第一种启动方式，一致性视图是在第执行第一个快照读语句时创建的； 第二种启动方式，一致性视图是在执行 start transaction with consistent snapshot 时创建的。</p>
</blockquote>
<p>还需要注意的是，这里都是默认 autocommit&#x3D;1 （自动提交事务）。</p>
<p>在这个例子中，事务 C 没有显式地使用 begin&#x2F;commit，表示这个 update 语句本身就是一个事务，语句完成的时候会自动提交。事务 B 在更新了行之后查询 ; 事务 A 在一个只读事务中查询，并且时间顺序上是在事务 B 的查询之后。</p>
<p>这时，如果我告诉你事务 B 查到的 k 的值是 3，而事务 A 查到的 k 的值是 1，你是不是感觉有点晕呢？</p>
<p>‍</p>
<h3 id="视图的概念"><a href="#视图的概念" class="headerlink" title="视图的概念"></a>视图的概念</h3><p>在 MySQL 里，有两个“视图”的概念：</p>
<ul>
<li>一个是 view。它是一个用查询语句定义的虚拟表，在调用的时候执行查询语句并生成结果。创建视图的语法是 create view … ，而它的查询方法与表一样。</li>
<li>另一个是 InnoDB 在实现 MVCC 时用到的一致性读视图，即 consistent read view，用于支持 RC（Read Committed，读提交）和 RR（Repeatable Read，可重复读）隔离级别的实现。</li>
</ul>
<p>它没有物理结构，作用是事务执行期间用来定义“我能看到什么数据”。</p>
<p>‍</p>
<h3 id="“快照”在-MVCC-里是怎么工作的？"><a href="#“快照”在-MVCC-里是怎么工作的？" class="headerlink" title="“快照”在 MVCC 里是怎么工作的？"></a>“快照”在 MVCC 里是怎么工作的？</h3><p>InnoDB的MVCC（多版本并发控制）实现中的快照机制</p>
<p>在可重复读隔离级别下，事务在启动的时候就“拍了个快照”。注意，这个快照是基于整库的。</p>
<p>InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。</p>
<p>而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。</p>
<p>也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。</p>
<p>​<img src="/assets/image-20230609171549-qb4xduy.png" alt="image">​</p>
<p>‍</p>
<p>在可重复读隔离级别下，事务在启动的时候会创建一个快照，这个快照是基于整个数据库的。每行数据都有多个版本，每次事务更新数据时会生成一个新的版本，<strong>并把事务ID赋值给这个版本的事务ID</strong>。同时，旧版本的数据要保留，新版本中也要有信息可以直接拿到旧版本的数据。这样，每行数据的每个版本都有自己的事务ID。</p>
<p>InnoDB利用了“所有数据都有多个版本”的特性，实现了“秒级创建快照”的能力。</p>
<p>具体实现是，为每个事务构造一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务ID。</p>
<p><strong>数组里面事务ID的最小值记为低水位，当前系统里面已经创建过的事务ID的最大值加1记为高水位</strong>。</p>
<p>这个视图数组和高水位，就组成了当前事务的一致性视图（read-view）。</p>
<p>而数据版本的可见性规则，就是基于数据的row trx_id和这个一致性视图的对比结果得到的。</p>
<p>一个数据版本，对于一个事务视图来说，除了自己的更新总是可见以外，有三种情况：未提交，不可见；已提交，但是是在视图创建后提交的，不可见；已提交，而且是在视图创建前提交的，可见。</p>
]]></content>
  </entry>
  <entry>
    <title>04_深入浅出索引（上）</title>
    <url>//post/04_early-simple-index-top-27akdi.html</url>
    <content><![CDATA[<h1 id="04-深入浅出索引（上）"><a href="#04-深入浅出索引（上）" class="headerlink" title="04_深入浅出索引（上）"></a>04_深入浅出索引（上）</h1><p>‍</p>
<h3 id="索引的概念"><a href="#索引的概念" class="headerlink" title="索引的概念"></a>索引的概念</h3><p>索引的概念：索引是一种数据结构，用于提高数据库查询效率。就像一本书的目录一样，索引可以帮助数据库在大量数据中快速找到需要的数据，减少查询时间和资源消耗。</p>
<p>除了提高查询效率，索引还可以帮助数据库实现唯一性约束、主键约束和外键约束等数据完整性约束。</p>
<p>例如，在一个用户表中，我们可以使用用户ID作为主键，并在ID列上创建一个唯一索引，以保证每个用户ID都是唯一的。</p>
<p>‍</p>
<h3 id="常见索引模型"><a href="#常见索引模型" class="headerlink" title="常见索引模型"></a>常见索引模型</h3><p>常见索引模型：索引模型是指索引的数据结构和组织方式。常见的索引模型有哈希表、有序数组和搜索树等。</p>
<p>哈希表：哈希表是一种将键映射到值的数据结构，它通过哈希函数将键转换为数组的下标，然后将值存储在该下标处。</p>
<p>哈希表适用于等值查询场景，例如在一个存储用户信息的表中，我们可以使用用户ID作为哈希表的键，来快速查找某个用户的信息。</p>
<p>有序数组：有序数组是一种按照元素大小顺序排列的数组，它适用于等值查询和范围查询场景。</p>
<p>例如，在一个按照身份证号排序的用户表中，我们可以使用二分法快速查找某个身份证号对应的用户信息。但是，<strong>有序数组的更新成本较高，适用于静态存储引擎</strong>。</p>
<p>搜索树：搜索树是一种按照元素大小顺序组织的树形结构，它适用于等值查询和范围查询场景。</p>
<p>例如，在一个按照用户ID排序的用户表中，我们可以使用二叉搜索树快速查找某个用户ID对应的用户信息。但是，搜索树的查询效率高，但写入和更新成本高，不适用于大规模数据存储。</p>
<p>扩充例子：在一个电商网站的订单表中，我们可以使用订单ID作为哈希表的键，来快速查找某个订单的信息。在一个按照订单时间排序的订单表中，我们可以使用二分法快速查找某个时间段内的订单信息。在一个按照商品价格排序的商品表中，我们可以使用B树来快速查找某个价格区间内的商品信息。</p>
<p>二叉树虽然是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树，因为索引不仅存在内存中，还要写入磁盘。</p>
<p>为了让查询尽量少地读磁盘，我们需要让查询过程访问尽量少的数据块。因此，我们应该使用“N叉”树来代替二叉树。在“N叉”树中，“N”的大小取决于数据块的大小。</p>
<p>以InnoDB的一个整数字段索引为例，这个“N”大约是1200。当这棵树高为4时，就可以存储1200的3次方个值，这已经达到了17亿。考虑到树根的数据块总是在内存中，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。实际上，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>扩充阐述：在实际的数据库应用中，磁盘I&#x2F;O是非常耗时的操作。因此，我们需要尽量减少磁盘I&#x2F;O的次数，以提高数据库的查询效率。为了实现这个目标，数据库存储引擎通常会采用B树、B+树、R树等数据结构来实现索引。这些数据结构都是基于“N叉”树的结构，能够有效地减少磁盘I&#x2F;O的次数，提高查询效率。</p>
<p>例如，在一个电商网站的商品表中，我们可以使用商品价格作为B+树的键，来快速查找某个价格区间内的商品信息。B+树在叶子节点上保存了所有数据记录的指针，而非像B树那样在每个节点上都保存数据记录，因此能够减少磁盘I&#x2F;O的次数，提高查询效率。</p>
<p>总结：为了提高数据库的查询效率，我们需要选择合适的索引模型，并采用相应的数据结构来实现索引。在选择数据结构时，需要考虑具体的查询场景和存储引擎特点。常见的索引模型有哈希表、有序数组和搜索树等，而常用的数据结构有B树、B+树、R树等。通过选择合适的索引模型和数据结构，可以有效地提高数据库的查询效率，降低磁盘I&#x2F;O的次数，从而提升数据库的整体性能。</p>
<p>‍</p>
<p><strong>数据库底层存储的核心就是基于这些数据模型的。每碰到一个新数据库，我们需要先关注它的数据模型，这样才能从理论上分析出这个数据库的适用场景。</strong></p>
<p>‍</p>
<h3 id="B-树和-B-树"><a href="#B-树和-B-树" class="headerlink" title="B 树和 B+ 树"></a>B 树和 B+ 树</h3><p>B树和B+树都是多路搜索树，是一种常用的数据结构，在数据库、文件系统等领域广泛应用。它们不是二叉树，而是多叉树。</p>
<p>B树和B+树的主要区别在于它们的索引结构和叶子节点的存储方式不同。B树的每个节点都包含键值和指向子节点的指针，而B+树的非叶子节点只包含键值和指向子节点的指针，<strong>而所有的数据都存储在叶子节点中。</strong></p>
<p>B树的搜索过程比较复杂，因为需要在非叶子节点和叶子节点之间不断切换，而B+树的搜索过程更加简单，因为只需要在叶子节点中进行搜索。此外，B+树的叶子节点是通过链表相连的，可以方便地进行范围查询和遍历。</p>
<p>因此，B+树通常比B树更适合在数据库中使用，<strong>因为它能够更快地进行范围查询和遍历</strong>。但是，在某些场景下，B树也可能比B+树更适合使用，例如需要快速插入和删除数据的场景。</p>
<p>‍</p>
<h3 id="InnoDB-的索引模型"><a href="#InnoDB-的索引模型" class="headerlink" title="InnoDB 的索引模型"></a>InnoDB 的索引模型</h3><p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。</p>
<p>InnoDB 使用的是 B+ 树索引模型，所以数据都是存储在 B+ 树中的，每一个索引在 InnoDB 里面对应一棵 B+ 树。</p>
<p><strong>索引类型分为主键索引和非主键索引。</strong></p>
<ul>
<li>主键索引的<strong>叶子节点存的是整行数据</strong>。在 InnoDB 里，主键索引也被称为聚簇索引（clustered index）。</li>
<li>非主键索引的<strong>叶子节点内容是主键的值</strong>。在 InnoDB 里，<strong>非主键索引也被称为二级索引（secondary index）。</strong></li>
</ul>
<p>举个例子来说，假设我们有一个学生表，其中主键为学生ID。如果我们要查询学号为1001的学生的所有信息，如果使用主键索引，则只需要搜索ID这棵B+树，而如果使用非主键索引，则需要先搜索学号这棵B+树得到ID的值为1001，再到ID索引树搜索一次，这个过程称为回表。</p>
<p>因此，使用主键索引查询可以减少一次搜索，提高查询效率。</p>
<p>在应用中我们应该尽量使用主键查询，以减少查询时间和提高性能。</p>
<p>但是，在实际使用中，我们也需要根据具体情况来选择使用哪种索引类型。例如，如果我们需要查询学生的所有信息，而不仅仅是学号，那么使用主键索引就无法满足我们的需求，这时候就需要使用非主键索引。</p>
<p>InnoDB的索引模型是数据库中非常重要的一个概念，不同的索引类型在查询效率和使用场景上都有着不同的优缺点。我们需要根据具体需求来选择使用哪种索引类型，以提高数据库的性能和效率。</p>
<p>‍</p>
<h3 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h3><p>索引维护是数据库中非常重要的一部分，它确保了数据的快速查询和排序。</p>
<p>在B+树中，为了维护索引有序性，在插入新值的时候需要做必要的维护。</p>
<p>这个过程中，当插入的数据页已经满了，就需要进行页分裂操作。这个过程会申请一个新的数据页，并将部分数据挪动过去，影响了性能和数据页的利用率。</p>
<p>不过，有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并，这个过程可以认为是分裂过程的逆过程。</p>
<p>另外，对于<strong>自增主键的使用场景，我们需要分析哪些场景下应该使用自增主键，而哪些场景下不应该。</strong></p>
<p>自增主键的插入数据模式，是递增插入的场景，每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>此外，从存储空间的角度来看，如果用身份证号等字符串类型的字段做主键，那么每个非主键索引的叶子节点上都是主键的值，<strong>占用的空间较大</strong>。因此，自增主键往往是更合理的选择。</p>
<p>但是，对于只有一个索引且必须是唯一索引的场景，可以直接将这个索引设置为业务字段做主键，避免每次查询需要搜索两棵树。</p>
<p>假设你在设计一个订单系统，其中包含订单的ID、用户ID、商品ID、数量、价格等信息。如果你需要在该系统中快速查找某个订单的信息，可以在订单ID字段上建立一个唯一索引，这样就可以快速查找到该订单的信息。但是，如果你需要根据用户ID或商品ID等信息进行查询，那么就需要在这些字段上建立索引，以保证查询的速度和效率。</p>
<p>在这种情况下，如果使用自增主键作为主键，可以保证数据的有序插入和查询，提高了查询效率。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。此外，自增主键的数据类型通常为整型，占用的存储空间相对较小，可以节省存储空间。</p>
<p>但是，如果你的业务场景需要根据用户ID或商品ID等字段进行频繁的查询和排序，那么就应该考虑将这些字段作为主键。在这种情况下，使用自增主键可能会导致数据的插入顺序与查询顺序不一致，降低查询效率。</p>
<p>因此，在设计主键时，需要根据具体业务场景进行选择。</p>
<p>‍</p>
]]></content>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>05_深入浅出索引（下）</title>
    <url>//post/05_early-explain-the-index-below-1aw7tg.html</url>
    <content><![CDATA[<h1 id="05-深入浅出索引（下）"><a href="#05-深入浅出索引（下）" class="headerlink" title="05_深入浅出索引（下）"></a>05_深入浅出索引（下）</h1><h3 id="回表"><a href="#回表" class="headerlink" title="回表"></a>回表</h3><p>通过索引定位到符合条件的主键，再根据主键索引树搜索的过程，称为回表</p>
<p>‍</p>
<h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h3><p>在查询中，使用了一个包含所有需要查询的字段的索引，避免了回表操作，从而可以直接从索引中获取数据，提高查询效率。</p>
<p>例如，我们有一个表 <code>t</code>​，其中有两个字段 <code>a</code>​ 和 <code>b</code>​，如果我们创建了一个组合索引 <code>(a, b)</code>​，那么当我们查询 <code>SELECT a FROM t WHERE a=1</code>​ 的时候，MySQL 可以直接使用索引 <code>(a, b)</code>​ 来定位符合条件的记录，并返回 <code>a</code>​ 和 <code>b</code>​ 的值，这个查询就可以称为覆盖索引查询。</p>
<p>而如果我们没有创建 <code>(a, b)</code>​ 索引，那么 MySQL 就需要先使用索引 <code>(a, b)</code>​ 定位到符合条件的主键，再根据主键回表查询 <code>b</code>​ 的值，这个查询就需要回表操作。</p>
<p>‍</p>
<h3 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h3><p>最左前缀原则指的是，在一个组合索引中，如果要使用索引来查询，那么查询条件必须从索引的最左侧开始，并且不能跳过中间的任何一个索引列。</p>
<p>例如，如果我们创建了一个组合索引 <code>(a, b, c)</code>​，那么以下查询可以使用索引：</p>
<ul>
<li>​<code>SELECT * FROM t WHERE a=1</code>​</li>
<li>​<code>SELECT * FROM t WHERE a=1 AND b=2</code>​</li>
<li>​<code>SELECT * FROM t WHERE a=1 AND b=2 AND c=3</code>​</li>
</ul>
<p>而以下查询不能使用索引：</p>
<ul>
<li>​<code>SELECT * FROM t WHERE b=2</code>​</li>
<li>​<code>SELECT * FROM t WHERE a=1 AND c=3</code>​</li>
</ul>
<h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是 MySQL 5.6 引入的一个优化，在使用覆盖索引查询时，MySQL 可以在索引中直接过滤掉不符合条件的记录，避免回表操作。</p>
<p>例如，如果我们创建了一个组合索引 <code>(a, b, c)</code>​，那么当我们查询 <code>SELECT a, b FROM t WHERE a=1 AND b=2</code>​ 的时候，MySQL 可以使用索引 <code>(a, b, c)</code>​ 定位到符合条件的记录，并在索引中过滤掉不符合条件的 <code>c</code>​ 的值，最后返回 <code>a</code>​ 和 <code>b</code>​ 的值。这个过程就是索引下推。</p>
<p>在 MySQL 5.6 之前，如果我们执行以上查询，MySQL 会使用索引 <code>(a, b, c)</code>​ 定位到符合条件的主键，然后再通过主键回表查询 <code>c</code>​ 的值，这个过程需要多次 IO 操作，效率较低。</p>
<p>而在 MySQL 5.6 引入索引下推之后，MySQL 可以在索引中直接过滤掉不符合条件的 <code>c</code>​ 的值，避免回表操作，从而提高查询效率。</p>
]]></content>
      <tags>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>06_MySQL中的常用锁类型</title>
    <url>//post/06_mysql-commonly-used-lock-type-46hp5.html</url>
    <content><![CDATA[<h1 id="06-MySQL中的常用锁类型"><a href="#06-MySQL中的常用锁类型" class="headerlink" title="06_MySQL中的常用锁类型"></a>06_MySQL中的常用锁类型</h1><p>‍</p>
<p>根据加锁的范围，<strong>MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类</strong>。</p>
<h3 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h3><p>顾名思义，全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。</p>
<p>当你需要让整个库处于只读状态的时候，可以使用这个命令，<strong>之后其他线程的以下语句会被阻塞</strong>：数据更新语句（数据的增删改）、数据定义语句（包括建表、修改表结构等）和更新类事务的提交语句。</p>
<p>‍</p>
<p><strong>说一下全局锁的使用场景。</strong></p>
<p>以前有一种做法，是通过 FTWRL 确保不会有其他线程对数据库做更新，<strong>然后对整个库做备份</strong>（在备份过程中整个库完全处于只读状态）。</p>
<p>当数据库的默认隔离级别是是可重复读，MySQL 是能够通过MVVC拿到一致性视图的；</p>
<p>但是对于 MyISAM 这种不支持事务的引擎，如果备份过程中有更新，总是只能取到最新的数据，那么就破坏了备份的一致性。这时，我们就需要使用 FTWRL 命令了。</p>
<p>一般来说对于DBA , 对方会建议MySQL 使用的数据库存储引擎使用的 <strong>InnoDB ​</strong>而不是 MyISAM。</p>
<p>‍</p>
<p><strong>比较一下两种使整个库处于只读的方式。</strong></p>
<p>一种是上面说的 FTWRL的方式，还有一种是<strong>使用 set global readonly&#x3D;true 的方式做到全库只读。</strong></p>
<p>一般还是会建议用 FTWRL 方式，主要有两个原因：</p>
<ul>
<li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</li>
<li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，<strong>那么 MySQL 会自动释放这个全局</strong>锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li>
</ul>
<p>‍</p>
<p>‍</p>
<h3 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h3><p>表级锁是对整个表进行锁定，可以保证在操作过程中其他事务不能对表进行修改操作。</p>
<p>表级锁是一种对整个表进行锁定的机制，可以保证数据的一致性和完整性，但也会带来性能上的损失，因为其他事务需要等待锁释放才能进行操作。</p>
<p>在实际应用中，需要根据具体情况选择合适的锁机制来保证数据的安全和性能的平衡。</p>
<p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p>
<h4 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h4><p>表锁是对整个表进行锁定，当一个事务对表进行修改时，其他事务必须等待锁释放才能进行修改。</p>
<p>表锁分为读锁和写锁，当一个事务对表进行读操作时，<strong>其他事务可以同时对表进行读操作，但不能进行写操作</strong>；</p>
<p>当一个事务对表<strong>进行写操作时，其他事务不能对表进行读或写操作</strong>。</p>
<p>‍</p>
<p>表锁是通过 <code>lock tables</code>​ 语法进行设置的(**表锁的语法是 lock tables … read&#x2F;write)**。</p>
<p>语法中可以指定需要锁定的表以及锁的类型（读锁或写锁）。在执行 <code>lock tables</code>​ 后，其他线程对于被锁定的表的写操作或者读写操作将会被阻塞。在该线程释放锁之前，该线程只能对被锁定的表进行读操作或者读写操作，而不能进行写操作，也不能访问其他表。</p>
<p>需要通过 <code>unlock tables</code>​ 来主动释放锁，或者在客户端断开连接时自动释放。</p>
<p>在没有更细粒度的锁机制出现之前，表锁是最常用的处理并发的方式。但是对于支持行锁的引擎（比如InnoDB），一般不使用 <code>lock tables</code>​ 命令来控制并发，因为锁住整个表的影响面太大，而且也不能够实现更好的并发控制。</p>
<p>因此，在使用InnoDB等支持行锁的引擎时，建议使用更细粒度的锁机制来实现并发控制。</p>
<p>‍</p>
<p>‍</p>
<h4 id="元数据锁"><a href="#元数据锁" class="headerlink" title="元数据锁"></a>元数据锁</h4><p>元数据锁（MDL）是MySQL5.5版本引入的新锁机制，主要用于保护表结构的修改。</p>
<p>在实际应用中，MDL锁可以有效地保护表结构的一致性和完整性。当一个事务对表进行修改时，需要获取MDL读锁，其他事务可以同时对表进行读操作，<strong>但不能进行写操作</strong>。当一个事务对表进行结构修改时，<strong>需要获取MDL写锁</strong>，此时其他事务不能对表进行读或写操作。</p>
<p>MDL （元数据锁）不需要显式使用，在访问一个表的时候会被自动加上。MDL锁是一种读锁，<strong>它并不会阻塞其他事务对表的读取操作，只会阻塞其他事务对表结构的修改操作</strong>。</p>
<p>在实际应用中，MDL锁可以有效地保护表结构的一致性和完整性。</p>
<p>‍</p>
<p>虽然 MDL 锁是系统默认会加的，但却是不能忽略的一个机制。</p>
<p>比如下面这个例子，经常有人掉到这个坑里：给一个小表加个字段，导致整个库挂了。</p>
<p>例子A:</p>
<p>我们来看一下下面的操作序列，假设表 t 是一个小表。</p>
<p>​<img src="/assets/7cf6a3bf90d72d1f0fc156ececdfb0ce-20230423000033-8bjm0yp.jpg" alt="img">​</p>
<p>我们可以看到 session A 先启动，这时候会对表 t 加一个 MDL 读锁。</p>
<p>由于 session B 需要的也是 MDL 读锁，因此可以正常执行。</p>
<p>之后 session C 会被 blocked，是因为 session A 的 MDL 读锁还没有释放，而 session C 需要 MDL 写锁，因此只能被阻塞。</p>
<p>如果只有 session C 自己被阻塞还没什么关系，但是之后所有要在表 t 上新申请 MDL 读锁的请求也会被 session C 阻塞。</p>
<p>前面我们说了，<strong>所有对表的增删改查操作都需要先申请 MDL 读锁，就都被锁住</strong>，等于这个表现在完全不可读写了。</p>
<p>如果某个表上的查询语句频繁，而且客户端有重试机制，也就是说超时后会再起一个新 session 再请求的话，这个库的线程很快就会爆满。</p>
<p>你现在应该知道了，事务中的 MDL 锁，<strong>在语句执行开始时申请，但是语句结束后并不会马上释放，而会等到</strong>​<strong>整个事务提交后****再释放。</strong></p>
<p>因此，在实际应用中，<strong>需要注意长事务的问题，及时提交事务以释放MDL锁。</strong></p>
<p>‍</p>
<p>基于上面的分析，我们来讨论一个问题，<strong>如何安全地给小表加字段？</strong></p>
<p>首先我们要解决长事务，事务不提交，就会一直占着 MDL 锁。在 MySQL 的 information_schema 库的 innodb_trx 表中，你可以查到当前执行中的事务。</p>
<p>如果你要做 DDL 变更的表刚好有长事务在执行，<strong>要考虑先暂停 DDL，或者 kill 掉这个长事务。</strong></p>
<p>但考虑一下这个场景。如果你要变更的表是一个热点表，虽然数据量不大，但是上面的请求很频繁，而你不得不加个字段，你该怎么做呢？</p>
<p>这时候 kill 可能未必管用，因为新的请求马上就来了。</p>
<p>比较理想的机制是，在 alter table 语句里面设定等待时间，如果在这个指定的等待时间里面能够拿到 MDL 写锁最好，拿不到也不要阻塞后面的业务语句，先放弃。之后开发人员或者 DBA 再通过重试命令重复这个过程。</p>
<p>MariaDB 已经合并了 AliSQL 的这个功能，所以这两个开源分支目前都支持 DDL NOWAIT&#x2F;WAIT n 这个语法（设置等待时间）。</p>
<p>‍</p>
<p>、</p>
<p>‍</p>
<h3 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h3><p>在 MySQL 中，行锁是一种粒度更细的锁，它只锁定表中的某一行数据，而不是锁定整个表或某个区间。<strong>行锁可以有效地减少锁的冲突，提高并发性能。</strong></p>
<p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。<strong>InnoDB 是支持行锁的，这也是 MyISAM 被 InnoDB 替代的重要原因之一。</strong></p>
<p>‍</p>
<p>了解行锁前，我们去了解一下一些常用概念。</p>
<p>数据库中还有一些没那么一目了然的概念和设计，这些概念如果理解和使用不当，容易导致程序出现非预期行为，比如两阶段锁。</p>
<h4 id="两阶段锁"><a href="#两阶段锁" class="headerlink" title="两阶段锁"></a>两阶段锁</h4><p><strong>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。</strong></p>
<p>知道了这个设定，对我们使用事务有什么帮助呢？那就是，如果你的事务中需要锁多个行，<strong>要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放</strong>。我给你举个例子。</p>
<p>假设你负责实现一个电影票在线交易业务，顾客 A 要在影院 B 购买电影票。我们简化一点，这个业务需要涉及到以下操作：</p>
<ol>
<li>从顾客 A 账户余额中扣除电影票价；</li>
<li>给影院 B 的账户余额增加这张电影票价；</li>
<li>记录一条交易日志。</li>
</ol>
<p>也就是说，要完成这个交易，我们需要 update 两条记录，并 insert 一条记录。当然，为了保证交易的原子性，我们要把这三个操作放在一个事务中。那么，你会怎样安排这三个语句在事务中的顺序呢？</p>
<p>试想如果同时有另外一个顾客 C 要在影院 B 买票，那么这两个事务冲突的部分就是语句 2 了。因为它们要更新同一个影院账户的余额，需要修改同一行数据。（将最可能造成锁冲突的锁尽量往后放）</p>
<p>根据两阶段锁协议，不论你怎样安排语句顺序，所有的操作需要的行锁都是在事务提交的时候才释放的。所以，如果你把语句 2 安排在最后，比如按照 3、1、2 这样的顺序，那么影院账户余额这一行的锁时间就最少。这就最大程度地减少了事务之间的锁等待，提升了并发度。</p>
<p>好了，现在由于你的正确设计<strong>，影院余额这一行的行锁在一个事务中不会停留很长时间</strong>。</p>
<p>但是，这并没有完全解决你的困扰。</p>
<p>如果这个影院做活动，可以低价预售一年内所有的电影票，而且这个活动只做一天。于是在活动时间开始的时候，你的 MySQL 就挂了。</p>
<p>你登上服务器一看，CPU 消耗接近 100%，但整个数据库每秒就执行不到 100 个事务。这是什么原因呢？这里，我就要说到死锁和死锁检测了。</p>
<p>‍</p>
<h4 id="死锁和死锁检测"><a href="#死锁和死锁检测" class="headerlink" title="死锁和死锁检测"></a>死锁和死锁检测</h4><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。</p>
<p>示例说明：</p>
<p>​<img src="/assets/4d0eeec7b136371b79248a0aed005a52-20230423000033-24hkuyw.jpg" alt="img">​</p>
<p>这时候，事务 A 在等待事务 B 释放 id&#x3D;2 的行锁，而事务 B 在等待事务 A 释放 id&#x3D;1 的行锁。 事务 A 和事务 B 在互相等待对方的资源释放，就是进入了死锁状态。</p>
<p>当出现死锁以后，有两种策略：</p>
<ul>
<li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。</li>
<li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。</li>
</ul>
<p>在 InnoDB 中，innodb_lock_wait_timeout 的默认值是 50s，意味着如果采用第一个策略，当出现死锁以后，第一个被锁住的线程要过 50s 才会超时退出，然后其他线程才有可能继续执行。对于在线服务来说，这个等待时间往往是无法接受的。</p>
<p>但是，我们又不可能直接把这个时间设置成一个很小的值，比如 1s。这样当出现死锁的时候，确实很快就可以解开，但如果不是死锁，而是简单的锁等待呢？所以，超时时间设置太短的话，会出现很多误伤。</p>
<p>所以，正常情况下我们还是要采用第二种策略，<strong>即：主动死锁检测</strong>，而且 innodb_deadlock_detect 的默认值本身就是 on。主动死锁检测在发生死锁的时候，是能够快速发现并进行处理的，但是它也是有额外负担的。</p>
<p>你可以想象一下这个过程：每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁。</p>
<p>那如果是我们上面说到的所有事务都要更新同一行的场景呢？</p>
<p>每个新来的被堵住的线程，都要判断会不会由于自己的加入导致了死锁，这是一个时间复杂度是 O(n) 的操作。假设有 1000 个并发线程要同时更新同一行，那么死锁检测操作就是 100 万这个量级的。虽然<strong>最终检测的结果是没有死锁，但是这期间要消耗大量的 CPU 资源。因此，你就会看到 CPU 利用率很高，但是每秒却执行不了几个事务。</strong></p>
<p>根据上面的分析，我们来讨论一下，怎么解决由这种热点行更新导致的性能问题呢？问题的症结在于，<strong>死锁检测要耗费大量的 CPU 资源。</strong></p>
<p>‍</p>
<p><strong>如何优化死锁检测带来的消耗大量CPU资源问题。</strong></p>
<p><strong>临时把死锁检测关掉</strong></p>
<p>一种头痛医头的方法，就是如果你能确保这个业务一定不会出现死锁，可以临时把死锁检测关掉。</p>
<p>但是这种操作本身带有一定的风险，因为业务设计的时候一般不会把死锁当做一个严重错误，毕竟出现死锁了，就回滚，然后通过业务重试一般就没问题了，这是业务无损的。而关掉死锁检测意味着可能会出现大量的超时，这是业务有损的。</p>
<p>‍</p>
<p><strong>控制并发度</strong></p>
<p>解决由热点行更新导致的性能问题的思路是控制并发度。</p>
<p>可以在客户端或者数据库服务端做并发控制，对于相同行的更新，在进入引擎之前排队，这样在InnoDB内部就不会有大量的死锁检测工作了。</p>
<p><strong>此外，</strong>也可以通过将一行改成逻辑上的多行来减少锁冲突。例如，将一行账户改成多个记录，影院的账户总额等于这多个记录的值的总和，每次要给影院账户加金额的时候，随机选其中一条记录来加，<strong>这样每次冲突概率变成原来的1&#x2F;10，可以减少锁等待个数，也就减少了死锁检测的CPU消耗</strong>。但这类方案需要根据业务逻辑做详细设计。</p>
<p>‍</p>
]]></content>
      <categories>
        <category>_posts</category>
      </categories>
      <tags>
        <tag>MYSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2023/11/10/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
