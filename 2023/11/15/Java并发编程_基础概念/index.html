

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/Xbox%20L.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luo QI">
  <meta name="keywords" content="">
  
    <meta name="description" content="Java多线程_基础概念">
<meta property="og:type" content="article">
<meta property="og:title" content="Java并发编程_基础概念">
<meta property="og:url" content="https://varcel.luoqi.icu/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/index.html">
<meta property="og:site_name" content="轻松的洛亓">
<meta property="og:description" content="Java多线程_基础概念">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401191403753.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304152134.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304154734.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304162424.png">
<meta property="article:published_time" content="2023-11-15T23:47:00.000Z">
<meta property="article:modified_time" content="2023-11-15T23:47:00.000Z">
<meta property="article:author" content="Luo QI">
<meta property="article:tag" content="java">
<meta property="article:tag" content="thread">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401191403753.png">
  
  
  
  <title>Java并发编程_基础概念 - 轻松的洛亓</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"varcel.luoqi.icu","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  <meta name="baidu-site-verification" content="codeva-Oq0KOjHuD3" />
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>轻松的洛亓</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161042719.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java并发编程_基础概念"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-11-15 23:47" pubdate>
          2023年11月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          19k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          156 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java并发编程_基础概念</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>大纲</p>
</blockquote>
<ul>
<li>线程基础概念</li>
<li>Java 线程</li>
<li>生命周期</li>
<li>创建线程</li>
<li>线程的调用方法</li>
<li>Synchronized 和 Lock</li>
</ul>
<p>线程</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401191403753.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p>
<ul>
<li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li>
<li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li>
</ul>
<blockquote>
<p>面试题：线程和进程的区别？</p>
</blockquote>
<p>进程：</p>
<p>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU,数据加载至内存。</p>
<p>在指令运行过程中还需要用到磁盘、网络等设备。</p>
<p>进程就是用来加载指令、管理内存、管理 IO 的。</p>
<p>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</p>
<p>线程：</p>
<p>一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行，一个进程之内可以分为一到多个线程。</p>
<blockquote>
<p>二者对比</p>
</blockquote>
<ul>
<li>进程是正在运行程序的实例，进程中包含了线程，每个线程执行不同的任务</li>
<li>不同的进程使用不同的内存空间，在当前进程下的所有线程可以共享内存空间</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低（上下文切换指的是从一个线程切换到另一个线程）</li>
</ul>
<hr>
<p>并行和并发的区别</p>
<ul>
<li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li>
<li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li>
</ul>
<p>最关键的点是：是否是 <strong>同时</strong> 执行</p>
<blockquote>
<p>面试题：并行和并发有什么区别？</p>
</blockquote>
<p>单核CPU</p>
<ul>
<li>单核CPU下线程实际还是串行执行的</li>
<li>操作系统中有一个组件叫做任务调度器，将cpu的时间片(windows下时间片最小约为15毫秒)分给不同的程序使用，只是由于cpu在线程间（时间片很短）的切换非常快，人类感觉是同时运行的。</li>
<li>总结为一句话就是：微观串行，宏观并行</li>
</ul>
<p>一般会将这种线程轮流使用 CPU的做法 称为并发(concurrent）</p>
<p>多核 CPU</p>
<p>每个核(core)都可以调度运行线程，这时候线程可以是并行的。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304152134.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>总结</p>
<p>并行和并发有什么区别</p>
<ul>
<li>现在都是多核CPU,在多核CPU下<ul>
<li>并发是同一时间<strong>应对</strong>多件事情的能力，多个线程轮流使用一个或多个CPU</li>
<li>并行是同一时间<strong>动手</strong>做多件事情的能力，4核CPU同时执行4个线程</li>
</ul>
</li>
</ul>
<hr>
<p>同步和异步的区别</p>
<ul>
<li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li>
<li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li>
</ul>
<h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p>
<p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p>
<p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p>
<h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p>
<p>Java线程具有五中基本状态</p>
<ul>
<li>新建状态（New）<ul>
<li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li>
</ul>
</li>
<li>就绪状态（Runnable）<ul>
<li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li>
<li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li>
</ul>
</li>
<li>运行状态（Running）<ul>
<li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li>
<li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li>
</ul>
</li>
<li>阻塞状态（Blocked）<ul>
<li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li>
<li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul>
<li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li>
<li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li>
<li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li>
</ul>
</li>
</ul>
</li>
<li>死亡状态（Dead）<ul>
<li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Java多线程的就绪、运行和死亡状态</p>
</blockquote>
<p>就绪状态转换为运行状态：当此线程得到处理器资源；</p>
<p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p>
<p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p>
<p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p>
<hr>
<p>在 Java 的 Thread 类中，有一个 State 的枚举</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs pf">/**<br> * A thread <span class="hljs-keyword">state</span>.  A thread can be <span class="hljs-keyword">in</span> one of the following states:<br> * <span class="hljs-variable">&lt;ul&gt;</span><br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#NEW&#125;&lt;br&gt;</span><br> *     A thread that has not yet started is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#RUNNABLE&#125;&lt;br&gt;</span><br> *     A thread executing <span class="hljs-keyword">in</span> the Java virtual machine is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#BLOCKED&#125;&lt;br&gt;</span><br> *     A thread that is blocked waiting <span class="hljs-keyword">for</span> a monitor lock<br> *     is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#WAITING&#125;&lt;br&gt;</span><br> *     A thread that is waiting indefinitely <span class="hljs-keyword">for</span> another thread <span class="hljs-keyword">to</span><br> *     perform a particular action is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#TIMED_WAITING&#125;&lt;br&gt;</span><br> *     A thread that is waiting <span class="hljs-keyword">for</span> another thread <span class="hljs-keyword">to</span> perform an action<br> *     <span class="hljs-keyword">for</span> up <span class="hljs-keyword">to</span> a specified waiting time is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#TERMINATED&#125;&lt;br&gt;</span><br> *     A thread that has exited is <span class="hljs-keyword">in</span> this <span class="hljs-keyword">state</span>.<br> *     &lt;/li&gt;<br> * &lt;/ul&gt;<br> *<br> * <span class="hljs-variable">&lt;p&gt;</span><br> * A thread can be <span class="hljs-keyword">in</span> only one <span class="hljs-keyword">state</span> at a given point <span class="hljs-keyword">in</span> time.<br> * These states are virtual machine states which do not reflect<br> * <span class="hljs-literal">any</span> operating system thread states.<br> *<br> * @since   <span class="hljs-number">1.5</span><br> * @see <span class="hljs-comment">#getState</span><br> */<br>public enum State &#123;<br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a thread which has not yet started.<br>     */<br>    NEW,<br><br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a runnable thread.  A thread <span class="hljs-keyword">in</span> the runnable<br>     * <span class="hljs-keyword">state</span> is executing <span class="hljs-keyword">in</span> the Java virtual machine but it may<br>     * be waiting <span class="hljs-keyword">for</span> other resources <span class="hljs-keyword">from</span> the operating system<br>     * such as processor.<br>     */<br>    RUNNABLE,<br><br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a thread blocked waiting <span class="hljs-keyword">for</span> a monitor lock.<br>     * A thread <span class="hljs-keyword">in</span> the blocked <span class="hljs-keyword">state</span> is waiting <span class="hljs-keyword">for</span> a monitor lock<br>     * <span class="hljs-keyword">to</span> enter a synchronized <span class="hljs-built_in">block</span>/method or<br>     * reenter a synchronized <span class="hljs-built_in">block</span>/method after calling<br>     * &#123;@link Object<span class="hljs-comment">#wait() Object.wait&#125;.</span><br>     */<br>    BLOCKED,<br><br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a waiting thread.<br>     * A thread is <span class="hljs-keyword">in</span> the waiting <span class="hljs-keyword">state</span> due <span class="hljs-keyword">to</span> calling one of the<br>     * following methods:<br>     * <span class="hljs-variable">&lt;ul&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link Object<span class="hljs-comment">#wait() Object.wait&#125; with no timeout&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#join() Thread.join&#125; with no timeout&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link LockSupport<span class="hljs-comment">#park() LockSupport.park&#125;&lt;/li&gt;</span><br>     * &lt;/ul&gt;<br>     *<br>     * <span class="hljs-variable">&lt;p&gt;</span>A thread <span class="hljs-keyword">in</span> the waiting <span class="hljs-keyword">state</span> is waiting <span class="hljs-keyword">for</span> another thread <span class="hljs-keyword">to</span><br>     * perform a particular action.<br>     *<br>     * For example, a thread that has called <span class="hljs-variable">&lt;tt&gt;</span>Object.wait()&lt;/tt&gt;<br>     * <span class="hljs-keyword">on</span> an object is waiting <span class="hljs-keyword">for</span> another thread <span class="hljs-keyword">to</span> call<br>     * <span class="hljs-variable">&lt;tt&gt;</span>Object.notify()&lt;/tt&gt; or <span class="hljs-variable">&lt;tt&gt;</span>Object.notifyAll()&lt;/tt&gt; <span class="hljs-keyword">on</span><br>     * that object. A thread that has called <span class="hljs-variable">&lt;tt&gt;</span>Thread.join()&lt;/tt&gt;<br>     * is waiting <span class="hljs-keyword">for</span> a specified thread <span class="hljs-keyword">to</span> terminate.<br>     */<br>    WAITING,<br><br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a waiting thread with a specified waiting time.<br>     * A thread is <span class="hljs-keyword">in</span> the timed waiting <span class="hljs-keyword">state</span> due <span class="hljs-keyword">to</span> calling one of<br>     * the following methods with a specified positive waiting time:<br>     * <span class="hljs-variable">&lt;ul&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#sleep Thread.sleep&#125;&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link Object<span class="hljs-comment">#wait(long) Object.wait&#125; with timeout&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link <span class="hljs-comment">#join(long) Thread.join&#125; with timeout&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link LockSupport<span class="hljs-comment">#parkNanos LockSupport.parkNanos&#125;&lt;/li&gt;</span><br>     *   <span class="hljs-variable">&lt;li&gt;</span>&#123;@link LockSupport<span class="hljs-comment">#parkUntil LockSupport.parkUntil&#125;&lt;/li&gt;</span><br>     * &lt;/ul&gt;<br>     */<br>    TIMED_WAITING,<br><br>    /**<br>     * Thread <span class="hljs-keyword">state</span> <span class="hljs-keyword">for</span> a terminated thread.<br>     * The thread has completed execution.<br>     */<br>    TERMINATED;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>分析流程图</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304154734.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>面试题：1.线程包括哪些状态</p>
</blockquote>
<p>新建(NEW)、可运行(RUNNABLE)、阻塞(BLOCKED)、等待(WAITING)、时间等待(TIMED_WALTING)、终止(TERMINATED)</p>
<blockquote>
<p>面试题：2.线程状态之间是如何变化的</p>
</blockquote>
<ul>
<li>创建线程对象是新建状态</li>
<li>调用了stat()方法转变为<strong>可执行状态</strong></li>
<li>线程获取到了CPU的执行权，执行结束是<strong>终止状态</strong></li>
<li>在可执行状态的过程中，如果没有获取 CPU 的执行权，可能会切换其他状态<ul>
<li>如果没有获取锁(synchronized 或Iock)进入<strong>阻塞状态</strong>，获得锁再切换为可执行状态</li>
<li>如果线程调用了wait()方法进入<strong>等待状态</strong>，其他线程调用notify()唤醒后可切换为可执行状态</li>
<li>如果线程调用了sleep(50)方法，进入<strong>计时等待状态</strong>，到时间后可切换为可执行状态</li>
</ul>
</li>
</ul>
<h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><h4 id="线程创建-🚩"><a href="#线程创建-🚩" class="headerlink" title="线程创建 🚩"></a>线程创建 🚩</h4><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p>
<ol>
<li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure>

<ol start="2">
<li>Runnable 接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure>


<ol start="3">
<li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure>


<ul>
<li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li>
<li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li>
<li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li>
</ul>
<hr>
<p>补充：</p>
<p>Callable + FutureTask</p>
<p><code>Callable</code>接口与<code>Runnable</code>接口类似，但它可以返回执行结果，并且可以抛出异常。使用<code>Callable</code>时通常配合<code>FutureTask</code>或线程池（<code>ExecutorService</code>）来使用。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.Callable;<br><span class="hljs-keyword">import</span> java.util.concurrent.ExecutionException;<br><span class="hljs-keyword">import</span> java.util.concurrent.FutureTask;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">CallableFutureTaskExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建Callable对象</span><br>        Callable&lt;Integer&gt; callableTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                System.out.println(<span class="hljs-string">&quot;开始计算...&quot;</span>);<br>                Thread.sleep(<span class="hljs-number">2000</span>); <span class="hljs-comment">// 模拟耗时计算过程</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>; <span class="hljs-comment">// 返回计算结果</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 将Callable与FutureTask关联</span><br>        FutureTask&lt;Integer&gt; futureTask = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>&lt;&gt;(callableTask);<br><br>        <span class="hljs-comment">// 创建线程执行FutureTask</span><br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>        thread.start();<br><br>        <span class="hljs-comment">// 执行其他任务...</span><br>        System.out.println(<span class="hljs-string">&quot;执行其他任务...&quot;</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 获取计算结果，如果计算未完成则阻塞等待</span><br>            <span class="hljs-type">Integer</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> futureTask.get();<br>            System.out.println(<span class="hljs-string">&quot;计算结果: &quot;</span> + result);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><code>FutureTask</code>是<code>Future</code>接口的一个实现，它封装了<code>Callable</code>任务的执行。</p>
<p>通过将<code>Callable</code>实例传递给<code>FutureTask</code>的构造器,  然后，创建一个新的线程来执行<code>FutureTask</code>。</p>
<hr>
<p>一般在项目中会使用线程池创建线程执行任务</p>
<p>使用线程池执行<code>Runnable</code>任务的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建固定大小的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">2</span>);<br><br>        <span class="hljs-comment">// 提交Runnable任务</span><br>        executor.submit(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;Asynchronous task&quot;</span>);<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">// 另一种提交Runnable任务的方式，使用Java 8的Lambda表达式</span><br>        executor.submit(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;Asynchronous task with lambda&quot;</span>);<br>        &#125;);<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executor.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，我们创建了一个固定大小为2的线程池，并提交了两个<code>Runnable</code>任务。使用线程池的好处是可以重用线程，减少线程创建和销毁的开销，以及可以控制并发线程的数量。</p>
<hr>
<p>共有四种方式可以创建线程，分别是：</p>
<ul>
<li>继承Thread类</li>
<li>实现 runnable 接口</li>
<li>实现 Callable 接口</li>
<li>线程池创建线程（项目中使用方式）</li>
</ul>
<blockquote>
<p>面试题： runnable和callable有什么区别？</p>
</blockquote>
<p>参考回答：</p>
<ul>
<li>1.Runnable接口 run 方法没有返回值</li>
<li>2.Callable接口 call 方法有返回值，是个泛型，和Future、FutureTaski配合可以用来获取异步执行的结果</li>
<li>3.Callable接口的 call() 方法允许抛出异常；而Runnable接口的runO方法的异常只能在内部消化，不能继续上抛</li>
</ul>
<blockquote>
<p>面试题：线程的run() 和start() 有什么区别？</p>
</blockquote>
<ul>
<li>start():用来启动线程，通过该线程调用run方法执行run方法中所定义的逻辑代码。start方法只能被调用一次。</li>
<li>run():封装了要被线程执行的代码，可以被调用多次。</li>
</ul>
<h4 id="写法简化"><a href="#写法简化" class="headerlink" title="写法简化"></a>写法简化</h4><blockquote>
<p>写法简化（Java 8)</p>
</blockquote>
<ul>
<li><strong>方式一：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<p>简化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>方式二：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<p>简化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>方式三：</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure>

<p>简化后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure>


<hr>
<h4 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h4><h5 id="顺序执行"><a href="#顺序执行" class="headerlink" title="顺序执行"></a>顺序执行</h5><p>常见的一道面试题：新建T1、T2、T3三个线程，如何保证它们按顺序执行？</p>
<p>要保证三个线程T1、T2、T3按顺序执行，即先执行T1，T1执行完毕后执行T2，T2执行完毕后执行T3，可以使用多种方法来实现。这里提供三种常见的方法：</p>
<p>方法1：使用<code>join()</code>方法</p>
<p><code>join()</code>方法可以使当前线程等待另一个线程完成后再继续执行。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadOrder</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; System.out.println(<span class="hljs-string">&quot;T1 is running&quot;</span>))</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t2</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; System.out.println(<span class="hljs-string">&quot;T2 is running&quot;</span>))</span>;</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">t3</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; System.out.println(<span class="hljs-string">&quot;T3 is running&quot;</span>))</span>;</span><br><span class="hljs-function">        </span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t1</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>; // 等待<span class="hljs-title">t1</span>执行完毕</span><br><span class="hljs-function">            </span><br><span class="hljs-function">            <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t2</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>; // 等待<span class="hljs-title">t2</span>执行完毕</span><br><span class="hljs-function">            </span><br><span class="hljs-function">            <span class="hljs-title">t3</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t3</span>.<span class="hljs-title">join</span><span class="hljs-params">()</span>; // 等待<span class="hljs-title">t3</span>执行完毕</span><br><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>方法2：使用<code>wait()</code>和<code>notify()/notifyAll()</code>方法</p>
<p>通过对象监视器的<code>wait()</code>和<code>notify()</code>方法来控制线程的执行顺序。这种方法相对复杂，需要确保<code>wait()</code>和<code>notify()</code>调用在同步块中。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs livescript">public <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadOrder</span> &#123;<br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        final <span class="hljs-built_in">Object</span> lock = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br>        Thread t1 = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (lock) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;T1 is running&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                lock.notify(); <span class="hljs-regexp">// 唤醒等待lock对象的一个线程</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">            &#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        &#125;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        </span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        Thread t2 = new Thread(() -&gt; &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">            synchronized (lock) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                try &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                    lock.wait(); //</span> 使当前线程等待直到lock对象被唤醒</span></span><br><span class="hljs-params"><span class="hljs-function">                    System.out.println(<span class="hljs-string">&quot;T2 is running&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                    lock.notify(); <span class="hljs-regexp">// 唤醒等待lock对象的一个线程</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                &#125; catch (InterruptedException e) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                &#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">            &#125;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        &#125;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        </span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">        Thread t3 = new Thread(() -&gt; &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">            synchronized (lock) &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                try &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                    lock.wait(); //</span> 使当前线程等待直到lock对象被唤醒</span></span><br><span class="hljs-params"><span class="hljs-function">                    System.out.println(<span class="hljs-string">&quot;T3 is running&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">t2</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">t3</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">            <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">100</span>)</span>; // 确保<span class="hljs-title">t2</span>和<span class="hljs-title">t3</span>启动并进入<span class="hljs-title">wait</span>状态</span><br><span class="hljs-function">            <span class="hljs-title">t1</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<p>方法3：使用<code>CountDownLatch</code></p>
<p><code>CountDownLatch</code>是一个同步辅助类，用于延迟线程的进度直到其达到终止状态。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.CountDownLatch;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadOrder</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <span class="hljs-type">CountDownLatch</span> <span class="hljs-variable">latch2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CountDownLatch</span>(<span class="hljs-number">1</span>);<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            System.out.println(<span class="hljs-string">&quot;T1 is running&quot;</span>);<br>            latch1.countDown(); <span class="hljs-comment">// 减少计数</span><br>        &#125;);<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                latch1.await(); <span class="hljs-comment">// 等待latch1计数到达0</span><br>                System.out.println(<span class="hljs-string">&quot;T2 is running&quot;</span>);<br>                latch2.countDown(); <span class="hljs-comment">// 减少计数</span><br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                latch2.await(); <span class="hljs-comment">// 等待latch2计数到达0</span><br>                System.out.println(<span class="hljs-string">&quot;T3 is running&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;);<br>        <br>        t1.start();<br>        t2.start();<br>        t3.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这三种方法各有特点，可以根据具体场景选择最适合的一种来保证线程按顺序执行。</p>
<hr>
<blockquote>
<p>面试题：新建T1、T2、T3三个线程，如何保证它们按顺序执行？</p>
</blockquote>
<p>可以使用线程中的 join 方法解决</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304162424.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h5 id="停止线程"><a href="#停止线程" class="headerlink" title="停止线程"></a>停止线程</h5><blockquote>
<p>如何停止一个正在运行的线程？</p>
</blockquote>
<p>有三种方式可以停止线程</p>
<ul>
<li>使用退出标志，使线程正常退出，也就是当 run 方法完成后线程终止</li>
<li>使用stop方法强行终止（不推荐，方法已作废）</li>
<li>使用interrupt方法中断线程<ul>
<li>打断阻塞的线程(sleep,wait,join) 的线程，线程会抛出 InterruptedException 异常</li>
<li>打断正常的线程，可以根据打断状态来标记是否退出线程</li>
</ul>
</li>
</ul>
<h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote>
<p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p>
</blockquote>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
<th>注意事项</th>
</tr>
</thead>
<tbody><tr>
<td>​<code>start()</code>​</td>
<td>启动一个新线程，<br />在新的线程运行 run 方法</td>
<td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td>
</tr>
<tr>
<td>​<code>run()</code>​</td>
<td>新线程启动后会调用的方法</td>
<td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td>
</tr>
<tr>
<td>​<code>join()</code>​</td>
<td>等待线程运行结束</td>
<td></td>
</tr>
<tr>
<td>​<code>join(long n)</code>​</td>
<td>等待线程运行结束，<br />最多等待 n 毫秒</td>
<td></td>
</tr>
<tr>
<td>​<code>getId()</code>​</td>
<td>获取线程长整型的 id</td>
<td>id 唯一</td>
</tr>
<tr>
<td>​<code>getName()</code>​</td>
<td>获取线程名</td>
<td></td>
</tr>
<tr>
<td>​<code>setName(String name)</code>​</td>
<td>修改线程名</td>
<td></td>
</tr>
<tr>
<td>​<code>getPriority()</code>​</td>
<td>获取线程优先级</td>
<td></td>
</tr>
<tr>
<td>​<code>setPriority(int priority)</code>​</td>
<td>修改线程优先级</td>
<td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td>​<code>getState()</code>​</td>
<td>获取线程状态</td>
<td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td>
</tr>
<tr>
<td>​<code>interrupt()</code>​</td>
<td>打断线程</td>
<td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td>
</tr>
<tr>
<td><font color=Coral>interrupted()</font></td>
<td>判断当前线程是否被打断</td>
<td>会清除打断标记</td>
</tr>
<tr>
<td>​<code>isInterrupted()</code>​</td>
<td>判断当前线程是否被打断</td>
<td>不会清除打断标记</td>
</tr>
<tr>
<td>​<code>isAlive()</code>​</td>
<td>判断当前线程是否存活</td>
<td></td>
</tr>
<tr>
<td>​<code>isDaemon()</code>​</td>
<td>判断当前线程是否是守护线程</td>
<td></td>
</tr>
<tr>
<td>​<code>setDaemon(boolean on)</code>​</td>
<td>设置当前线程为守护线程</td>
<td></td>
</tr>
<tr>
<td><font color=Coral>currentThread()</font></td>
<td>获取当前正在执行的线程</td>
<td></td>
</tr>
<tr>
<td><font color=Coral>sleep(long n)</font></td>
<td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td>
<td></td>
</tr>
<tr>
<td><font color=Coral>yield()</font></td>
<td>提示线程调度器让出当前线程<br />对 CPU 的使用</td>
<td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="常见面试题-1"><a href="#常见面试题-1" class="headerlink" title="常见面试题"></a>常见面试题</h4><blockquote>
<p>面试题：notify()和notifyAll()有什么区别？</p>
</blockquote>
<ul>
<li>notifyAll:唤醒所有wait的线程</li>
<li>notify:只随机唤醒一个wait线程</li>
</ul>
<h5 id="wait-和-sleep"><a href="#wait-和-sleep" class="headerlink" title="wait 和 sleep"></a>wait 和 sleep</h5><blockquote>
<p>面试题：在java中wait和sleep方法的不同？</p>
</blockquote>
<ul>
<li>共同点<ul>
<li>wait(),wait(long)和sleep(long)的效果都是让当前线程暂时放弃CPU的使用权，进入阻塞状态</li>
</ul>
</li>
<li>不同点<ul>
<li>1.方法归属不同<ul>
<li>sleep(long)是Thread的静态方法</li>
<li>而wait(),wait(long)都是Object的成员方法，每个对象都有</li>
</ul>
</li>
<li>2、醒来时机不同<ul>
<li>执行sleep(long)和wait(long)的线程都会在等待相应毫秒后醒来</li>
<li>wait(long)和wait0还可以被notify唤醒，wait()如果不唤醒就一直等下去</li>
<li>它们都可以被打断唤醒</li>
</ul>
</li>
<li>3.锁特性不同（重点）<ul>
<li>wait方法的调用必须先获取wait对象的锁，而sleep则无此限制</li>
<li>wait方法执行后会释放对象锁，允许其它线程获得该对象锁（我放弃cpu,但你们还可以用）</li>
<li>而sleep如果在synchronized代码块中执行，并不会释放对象锁（我放弃cpu,你们也用不了）</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WaitSleepExample</span> &#123;<br>    private <span class="hljs-keyword">static</span> final <span class="hljs-built_in">Object</span> LOCK = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><br>    public <span class="hljs-keyword">static</span> <span class="hljs-literal">void</span> main(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-regexp">// 创建一个线程执行等待操作</span><br><span class="hljs-regexp">        Thread waitThread = new Thread(() -&gt; &#123;</span><br><span class="hljs-regexp">            synchronized (LOCK) &#123; //</span> 必须在同步块内调用wait，这表示必须持有对象的锁<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;Wait Thread: Holding lock, now wait&quot;</span>);<br>                    LOCK.wait(); <span class="hljs-regexp">// 调用wait方法后，当前线程会释放LOCK对象上的锁，并进入等待状态</span><br><span class="hljs-regexp">                    System.out.println(&quot;Wait Thread: Exited wait&quot;);</span><br><span class="hljs-regexp">                &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-regexp">                    e.printStackTrace();</span><br><span class="hljs-regexp">                &#125;</span><br><span class="hljs-regexp">            &#125;</span><br><span class="hljs-regexp">        &#125;);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 创建一个线程执行睡眠操作<br>        Thread sleepThread = <span class="hljs-keyword">new</span> Thread<span class="hljs-function"><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (LOCK) &#123; <span class="hljs-regexp">// 进入同步块，持有LOCK对象的锁</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                try &#123;</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                    System.out.println(&quot;Sleep Thread: Holding lock, now sleep&quot;);</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                    Thread.sleep(1000); //</span> 调用sleep方法，但不会释放LOCK对象上的锁</span></span><br><span class="hljs-params"><span class="hljs-function">                    System.out.println(<span class="hljs-string">&quot;Sleep Thread: Exited sleep&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                    e.printStackTrace();</span></span><br><span class="hljs-params"><span class="hljs-function">                &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        // 创建一个线程执行通知操作</span><br><span class="hljs-function">        <span class="hljs-title">Thread</span> <span class="hljs-title">notifyThread</span> = <span class="hljs-title">new</span> <span class="hljs-title">Thread</span><span class="hljs-params">(() -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            synchronized (LOCK) &#123; <span class="hljs-regexp">// 进入同步块，持有LOCK对象的锁</span></span></span><br><span class="hljs-regexp"><span class="hljs-params"><span class="hljs-function">                //</span> 发送通知，告诉等待在LOCK对象上的线程可以继续执行</span></span><br><span class="hljs-params"><span class="hljs-function">                LOCK.notifyAll();</span></span><br><span class="hljs-params"><span class="hljs-function">                System.out.println(<span class="hljs-string">&quot;Notify Thread: Sent notification&quot;</span>);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">waitThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>; // 启动等待线程</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span>; // 确保<span class="hljs-title">waitThread</span>先执行</span><br><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        <span class="hljs-title">sleepThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>; // 启动睡眠线程</span><br><span class="hljs-function">        <span class="hljs-title">try</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">Thread</span>.<span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">500</span>)</span>; // 确保<span class="hljs-title">sleepThread</span>有机会执行</span><br><span class="hljs-function">        &#125; <span class="hljs-title">catch</span> <span class="hljs-params">(InterruptedException e)</span> &#123;</span><br><span class="hljs-function">            <span class="hljs-title">e</span>.<span class="hljs-title">printStackTrace</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        <span class="hljs-title">notifyThread</span>.<span class="hljs-title">start</span><span class="hljs-params">()</span>; // 启动通知线程</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>关于锁的不同处理</strong>：<ul>
<li><strong><code>wait()</code>方法</strong>：调用<code>wait()</code>时，线程必须持有对象的锁（这是通过在<code>synchronized</code>块内调用<code>wait()</code>来保证的）。一旦<code>wait()</code>被调用，线程会释放这个对象上的锁，允许其他线程获取这个锁。当其他线程在这个对象上调用<code>notify()</code>或<code>notifyAll()</code>时，等待的线程才有机会重新获取锁并继续执行。</li>
<li><strong><code>sleep()</code>方法</strong>：与<code>wait()</code>不同，调用<code>sleep()</code>时线程不会释放任何持有的锁。即使是在<code>synchronized</code>块内调用<code>sleep()</code>，当前线程仍然会保持对锁的持有，直到<code>sleep()</code>完成。这意味着，如果一个线程在持有某个对象锁的同时调用了<code>sleep()</code>，其他想要访问这个同步块的线程会被阻塞，直到睡眠线程醒来并退出同步块，释放锁。</li>
</ul>
</li>
</ul>
<p>→  使用 sleep 的时候同步块代码线程会被阻塞。</p>
<h3 id="6、Synchronized-和-Lock-的使用"><a href="#6、Synchronized-和-Lock-的使用" class="headerlink" title="6、Synchronized 和 Lock 的使用"></a>6、Synchronized 和 Lock 的使用</h3><p>并发编程中，锁是经常需要用到的。这里讲述一下 Synchronized 和 Lock 的使用。</p>
<p>Synchronized 是 Java 并发编程 中很重要的关键字，另外一个很重要的是 volatile。</p>
<p>Syncronized 的目的是一次<strong>只允许一个线程进入由他修饰的代码段</strong>，从而允许他们进行自我保护。</p>
<p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要<strong>手动加锁和手动解锁</strong>，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p>
<h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><blockquote>
<p>在方法上使用 Synchronized</p>
</blockquote>
<p>方法声明时使用，放在范围操作符之后,返回类型声明之前。即一次只能有一个线程进入该方法，其他线程要想在此时调用该方法，只能排队等候。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numIncrease</span><span class="hljs-params">()</span>&#123;<br>  number++;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>在某个代码段使用 Synchronized</p>
</blockquote>
<p>可以在某个代码块上使用 Synchronized 关键字，表示只能有一个线程进入某个代码段。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numDecrease</span><span class="hljs-params">(Object num)</span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (num)&#123;<br>    number++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 Synchronized 锁住整个对象</p>
</blockquote>
<p>synchronized后面括号里是一对象，此时线程获得的是对象锁。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，相关方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>常用方法</p>
<ul>
<li>lock()<ul>
<li>用来获取锁。如果锁被其他线程获取，则进行等待。</li>
<li>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁</li>
</ul>
</li>
<li>tryLock()<ul>
<li>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，</li>
<li>这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li>
</ul>
</li>
<li>tryLock(long time, TimeUnit unit)<ul>
<li>和tryLock()方法是类似</li>
<li>在拿不到锁时<strong>会等待一定的时间</strong>，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li>
</ul>
</li>
<li>lockInterruptibly()<ul>
<li>去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即<strong>中断线程的等待状态</strong>。</li>
<li>当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用 threadB.interrupt() 方法能够中断线程B的等待过程。</li>
<li>由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在try块中或者在调用lockInterruptibly() 的方法外声明抛出 InterruptedException。</li>
</ul>
</li>
</ul>
<blockquote>
<p>代码示例：</p>
</blockquote>
<p>lock()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>tryLock()</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Lock</span> lock = ...;<br><span class="hljs-keyword">if</span>(lock.<span class="hljs-title function_">tryLock</span>()) &#123;<br>     <span class="hljs-keyword">try</span>&#123;<br>         <span class="hljs-comment">//处理任务</span><br>     &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-title class_">Exception</span> ex)&#123;<br>         <br>     &#125;<span class="hljs-keyword">finally</span>&#123;<br>         lock.<span class="hljs-title function_">unlock</span>();   <span class="hljs-comment">//释放锁</span><br>     &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不能获取锁，则直接做其他事情</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>lockInterruptibly()</strong> </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>    lock.<span class="hljs-title function_">lockInterruptibly</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//.....</span><br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        lock.<span class="hljs-title function_">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将<strong>释放锁的操作放在finally块中进行</strong>，以保证锁一定被被释放，防止死锁的发生。</p>
<blockquote>
<p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能<strong>中断阻塞过程中的线程</strong>。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，<strong>只有进行等待的情况下，是可以响应中断的</strong>。<br>而<strong>用synchronized修饰的话</strong>，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p>
</blockquote>
<hr>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li>
<li><a target="_blank" rel="noopener" href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1497476">https://cloud.tencent.com/developer/article/1497476</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Java%E5%9F%BA%E7%A1%80/" class="category-chain-item">Java基础</a>
  
  
    <span>></span>
    
  <a href="/categories/Java%E5%9F%BA%E7%A1%80/Thread/" class="category-chain-item">Thread</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/thread/" class="print-no-link">#thread</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java并发编程_基础概念</div>
      <div>https://varcel.luoqi.icu/2023/11/15/Java并发编程_基础概念/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luo QI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年11月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Dokcer入门_基础概念">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Dokcer入门_基础概念</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">
                        <span class="hidden-mobile">Java集合_HashMap学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
