

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/Xbox%20L.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luo QI">
  <meta name="keywords" content="">
  
    <meta name="description" content="Spring学习_Spring_Bean的生命周期">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring学习_Spring_Bean的生命周期">
<meta property="og:url" content="https://varcel.luoqi.icu/2023/12/15/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/index.html">
<meta property="og:site_name" content="轻松的洛亓">
<meta property="og:description" content="Spring学习_Spring_Bean的生命周期">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312160247944.png">
<meta property="article:published_time" content="2023-12-15T00:19:49.000Z">
<meta property="article:modified_time" content="2023-12-15T00:19:49.000Z">
<meta property="article:author" content="Luo QI">
<meta property="article:tag" content="java">
<meta property="article:tag" content="spring">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png">
  
  
  
  <title>Spring学习_Spring_Bean的生命周期 - 轻松的洛亓</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"varcel.luoqi.icu","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  <meta name="baidu-site-verification" content="codeva-Oq0KOjHuD3" />
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>轻松的洛亓</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150024266.jpeg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Spring学习_Spring_Bean的生命周期"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-15 00:19" pubdate>
          2023年12月15日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          17k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          142 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Spring学习_Spring_Bean的生命周期</h1>
            
            
              <div class="markdown-body">
                
                <p>本篇讲述一下关于Bean的生命周期。</p>
<p>bean的作用域有很多种，这里讨论一下完全被 IOC容器控制的单例 Bean。</p>
<h3 id="1、Spring-Bean-生命周期的四个阶段"><a href="#1、Spring-Bean-生命周期的四个阶段" class="headerlink" title="1、Spring Bean 生命周期的四个阶段"></a>1、Spring Bean 生命周期的四个阶段</h3><blockquote>
<p>普通的 Java 对象</p>
</blockquote>
<p>对于普通的 Java 对象来说，它们的生命周期是：</p>
<ul>
<li>实例化</li>
<li>该对象不再被使用时通过垃圾回收机制进行回收</li>
</ul>
<blockquote>
<p>Spring Bean</p>
</blockquote>
<p>而对于 Spring Bean 的生命周期来说，可以分为四个阶段：</p>
<ul>
<li>实例化 Instantiation</li>
<li>属性赋值 Populate</li>
<li>初始化 Initialization</li>
<li>销毁 Destruction</li>
</ul>
<p>其中初始化完成之后，就代表这个 Bean 可以使用了</p>
<p>上述四个阶段的大概的一个逻辑</p>
<p>前面三个阶段的操作（先大概了解有这个印象，具体内容继续往下面看）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = (BeanWrapper)<span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    	<span class="hljs-comment">// 实例化阶段</span><br>        instanceWrapper = <span class="hljs-built_in">this</span>.createBeanInstance(beanName, mbd, args);<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    	<span class="hljs-comment">// 属性赋值阶段</span><br>        <span class="hljs-built_in">this</span>.populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化阶段</span><br>        exposedObject = <span class="hljs-built_in">this</span>.initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>


<p>销毁操作，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p>
<p>需要看 Bean 创建流程入口 源码的话，需要看 AbstractApplicationContext#refresh() 方法的 finishBeanFactoryInitialization(beanFactory) 这个方法。</p>
<p>具体可以看一下 下面的这个章节内容  “Bean 创建流程入口 refresh()”。</p>
<h3 id="2、Spring-Bean-的生命周期的扩展点"><a href="#2、Spring-Bean-的生命周期的扩展点" class="headerlink" title="2、Spring Bean 的生命周期的扩展点"></a>2、Spring Bean 的生命周期的扩展点</h3><p>上面讲述到Bean的生命周期有四个阶段，分别是：实例化  →  属性赋值  →  初始化  →  销毁；</p>
<p>在不同阶段中间，Spring 框架会进行一些功能的扩展点，</p>
<ul>
<li>Bean 自身方法</li>
<li>容器级别方法</li>
<li>工厂后处理器方法</li>
<li>Bean 级生命周期方法</li>
</ul>
<h4 id="2-1-Bean-自身的方法"><a href="#2-1-Bean-自身的方法" class="headerlink" title="2.1  Bean 自身的方法"></a>2.1  Bean 自身的方法</h4><p>在Bean的生命周期中，Bean自身是有一些特定方法是能够被调用的，以便完成其生命周期过程。</p>
<p>比如构造函数、getter&#x2F;setter 以及 init-method 和 destory-method 所指定的方法等，而这些方法又分别对应着上文说的四个阶段：例化、属性赋值、初始化和销毁。</p>
<p>这些Bean自身的方法一般是我们在配置Bean的时候就已经定义好的，下面我们通过一个简单 Bean 的使用来看一下其用法。</p>
<blockquote>
<p>Bean 示例</p>
</blockquote>
<p>我们定义一个简单的 Bean，名为 <code>MyBean</code>，</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-comment">// 构造函数 - 实例化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBean</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean Constructor: Bean is being instantiated.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Setter 方法 - 属性赋值阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">String <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean setValue: Setting property value.&quot;</span>);<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化方法 - 初始化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean init: Bean is being initialized.&quot;</span>);<br>        <span class="hljs-comment">// 执行初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 销毁方法 - 销毁阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean destroy: Bean is being destroyed.&quot;</span>);<br>        <span class="hljs-comment">// 执行清理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后我们通过注解或者xml 配置声明  init-method 和 destory-method  对应的方法。</p>
<blockquote>
<p>xml 配置</p>
</blockquote>
<p><strong>在 Spring 配置中定义 Bean</strong></p>
<p>在 Spring 的 XML 配置文件中，如下配置这个 Bean，并指定 <code>init-method</code> 和 <code>destroy-method</code>：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.MyBean&quot;</span> init-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;init&quot;</span> destroy-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;destroy&quot;</span>&gt;<br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;value&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;Some value&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注解配置</p>
</blockquote>
<p>在基于 Java 的配置中，可以使用 <code>@Bean</code> 注解：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;init&quot;</span>, destroyMethod = <span class="hljs-string">&quot;destroy&quot;</span>)<br>    <span class="hljs-keyword">public</span> MyBean myBean() &#123;<br>        MyBean myBean = <span class="hljs-keyword">new</span> <span class="hljs-type">MyBean</span>();<br>        myBean.setValue(<span class="hljs-string">&quot;Some value&quot;</span>);<br>        <span class="hljs-keyword">return</span> myBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>使用 Bean</p>
</blockquote>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;appContext.xml&quot;</span>);<br>        SimpleBean simpleBean = context.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;myBean&quot;</span>, MyBean.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 使用 simpleBean ...</span><br>        ((ClassPathXmlApplicationContext) context).<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭上下文以触发销毁方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<blockquote>
<p>四个主要阶段以及代码解释</p>
</blockquote>
<p>通过注解或者xml配置的方式，我们指定了初始化和销毁方法，并在 <code>MyBean</code> 定义了 Setter 方法，具体在容器执行的时候，会进行以下的操作：</p>
<ol>
<li><strong>实例化阶段</strong>:<ul>
<li>当 Spring 容器创建 <code>MyBean</code> 的实例时，首先调用其构造函数。</li>
</ul>
</li>
<li><strong>属性赋值阶段</strong>:<ul>
<li>接着，Spring 容器通过调用 <code>setValue</code> 方法来注入属性值。</li>
</ul>
</li>
<li><strong>初始化阶段</strong>:<ul>
<li>在所有属性都设置之后，Spring 容器调用指定的 <code>init</code> 方法。</li>
</ul>
</li>
<li><strong>销毁阶段</strong>:<ul>
<li>当 Spring 容器关闭时，它会调用 <code>destroy</code> 方法。</li>
</ul>
</li>
</ol>
<h4 id="2-2-容器级别方法"><a href="#2-2-容器级别方法" class="headerlink" title="2.2  容器级别方法"></a>2.2  容器级别方法</h4><p>将这个容器级别方法理解为阶段中间容器会进行的一些操作，这些方法一般是 BeanPostProcessor 的一系列接口。</p>
<p>在上述讲到的Bean 四个阶段，在这四个阶段的执行过程中，进行一些前置或者后置的操作。</p>
<p>这些操作独立于 Bean 之外，并且会注册到 Spring 容器中，在Spring 容器创建Bean的时候，会进行一些处理。</p>
<p>具体的一个关系看下图（比较清晰）：</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>你可以理解  <code>InstantiationAwareBeanPostProcessor</code> 接口方法是 作为 实例化阶段的”产前产后护理”；<code>BeanPostProcessor</code> 是 初始化阶段的 “关键调整和增强”。</p>
<h5 id="源码内容分析（容器级别方法）"><a href="#源码内容分析（容器级别方法）" class="headerlink" title="源码内容分析（容器级别方法）"></a>源码内容分析（容器级别方法）</h5><p>需要去了解Bean的生命周期，这个源码对应的方法是必须去了解和看的。</p>
<h5 id="InstantiationAwareBeanPostProcessor-接口分析"><a href="#InstantiationAwareBeanPostProcessor-接口分析" class="headerlink" title="InstantiationAwareBeanPostProcessor 接口分析"></a>InstantiationAwareBeanPostProcessor 接口分析</h5><p>查看源码，可以看到 InstantiationAwareBeanPostProcessor 接口是继承  BeanPostProcessor</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">InstantiationAwareBeanPostProcessor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BeanPostProcessor</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>BeanPostProcessor</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>AbstractAutowireCapableBeanFactory#createBean</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建Bean实例的方法，接收Bean的名称、RootBeanDefinition（Bean的定义信息）和参数数组</span><br>protected Object createBean(<span class="hljs-keyword">String</span> beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable Object[] args) throws BeanCreationException &#123;</span><br>    <span class="hljs-comment">// 如果启用了跟踪日志，输出创建Bean实例的跟踪信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析Bean的类信息，如果已经有解析过的类信息，使用之前解析得到的类信息</span><br>    RootBeanDefinition mbdToUse = mbd;<br>    Class&lt;?&gt; resolvedClass = <span class="hljs-built_in">this</span>.resolveBeanClass(mbd, beanName, <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 如果解析得到的类信息不为空，且当前Bean的定义信息没有指定类信息，则更新Bean的定义信息</span><br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-type">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 准备处理方法的覆盖，即准备解析方法注解</span><br>        mbdToUse.prepareMethodOverrides();<br>    &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException var9) &#123;<br>        <span class="hljs-comment">// 如果方法注解解析失败，抛出BeanDefinitionStoreException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, var9);<br>    &#125;<br><br>    Object beanInstance;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在实例化Bean之前，尝试调用BeanPostProcessor的beforeInstantiation方法</span><br>        beanInstance = <span class="hljs-built_in">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-comment">// 如果beforeInstantiation方法返回非空，表示已经创建了Bean实例，直接返回该实例</span><br>        <span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> beanInstance;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>        <span class="hljs-comment">// 如果beforeInstantiation方法抛出异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var10);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行真正的Bean创建逻辑，包括实例化、属性注入等过程</span><br>        beanInstance = <span class="hljs-built_in">this</span>.doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">// 如果启用了跟踪日志，输出Bean实例创建完成的跟踪信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 返回创建的Bean实例</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125; <span class="hljs-keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了异常，抛出异常</span><br>        <span class="hljs-keyword">throw</span> var7;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了未捕获的异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, var8);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="2-3-工厂后处理器方法"><a href="#2-3-工厂后处理器方法" class="headerlink" title="2.3 工厂后处理器方法"></a>2.3 <strong>工厂后处理器方法</strong></h4><p><strong>BeanFactoryProcessor 一系列接口</strong></p>
<p>包括 AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor 等。这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能</p>
<blockquote>
<p>BeanFactoryProcessor 接口 vs  BeanPostProcessor接口</p>
</blockquote>
<p><code>BeanFactoryPostProcessor</code> 接口和 <code>BeanPostProcessor</code> 接口都是 Spring 框架中用于定制和扩展 Bean 的关键接口，但它们的作用和时机略有不同。</p>
<p>BeanFactoryPostProcessor 接口：</p>
<ol>
<li><p><strong>作用：</strong> <code>BeanFactoryPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 之前修改或定制 BeanFactory 的配置。</p>
</li>
<li><p><strong>时机：</strong> 在 Spring 容器读取了 Bean 的定义（配置元数据）但在实例化任何 Bean 之前，<code>BeanFactoryPostProcessor</code> 接口提供了机会来修改 Bean 的定义，例如修改属性值、添加属性等。</p>
</li>
<li><p><strong>实现方法：</strong> 实现 <code>postProcessBeanFactory</code> 方法，该方法传递了 BeanFactory 对象，可以在此方法中修改 BeanFactory 的配置。</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">ConfigurableListableBeanFactory</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistryPostProcessor</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistry</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanFactory</span>(<span class="hljs-params">ConfigurableListableBeanFactory beanFactory</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以修改 BeanFactory 的配置</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span>(<span class="hljs-params">BeanDefinitionRegistry registry</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以注册新的 BeanDefinition</span><br>        <span class="hljs-title class_">BeanDefinitionBuilder</span> builder = <span class="hljs-title class_">BeanDefinitionBuilder</span>.<span class="hljs-title function_">genericBeanDefinition</span>(<span class="hljs-title class_">MyBean</span>.<span class="hljs-property">class</span>);<br>        registry.<span class="hljs-title function_">registerBeanDefinition</span>(<span class="hljs-string">&quot;myBean&quot;</span>, builder.<span class="hljs-title function_">getBeanDefinition</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<blockquote>
<p>BeanPostProcessor 接口</p>
</blockquote>
<ol>
<li><p><strong>作用：</strong> <code>BeanPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 后，在 Bean 的初始化前后执行一些自定义的逻辑。</p>
</li>
<li><p><strong>时机：</strong> 当 Bean 被实例化后，但在调用其初始化方法（如果有的话）之前，<code>BeanPostProcessor</code> 提供了 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code> 方法用于在初始化阶段进行定制操作。</p>
</li>
<li><p><strong>实现方法：</strong> 实现 <code>BeanPostProcessor</code> 接口的两个方法，可以在这两个方法中添加定制逻辑。</p>
</li>
</ol>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">BeanPostProcessor</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之前的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之后的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>总结</p>
<ul>
<li><code>BeanFactoryPostProcessor</code> 主要用于修改整个 BeanFactory 的配置，它在 Bean 实例化之前执行。</li>
<li><code>BeanPostProcessor</code> 主要用于在每个 Bean 的初始化阶段添加自定义逻辑，它在 Bean 实例化后，初始化方法调用前后执行。</li>
</ul>
<p>在实际应用中，可以同时使用这两个接口来完成更复杂的定制需求。</p>
<h4 id="2-4-Bean-级生命周期方法"><a href="#2-4-Bean-级生命周期方法" class="headerlink" title="2.4  Bean 级生命周期方法"></a>2.4  <strong>Bean 级生命周期方法</strong></h4><p>关于 Bean 级生命周期方法的理解：</p>
<ul>
<li>这些方法提供了针对 Bean 实例的<strong>个性化行为</strong>，允许 Bean 在其生命周期的关键点做出响应。</li>
</ul>
<p>通过这些方法，是可以对于某个Bean实例进行个性化操作的。</p>
<p>可以理解为 Bean 类直接实现接口的方法，比如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等方法，这些方法只对当前 Bean 生效。</p>
<p>Aware 类型的接口</p>
<p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。</p>
<p>基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。</p>
<p>调用时机需要注意：所有的 Aware 方法都是在初始化阶段之前调用的。</p>
<p>to be contined…</p>
<h3 id="2、Spring-Bean-详细生命周期"><a href="#2、Spring-Bean-详细生命周期" class="headerlink" title="2、Spring Bean 详细生命周期"></a>2、Spring Bean 详细生命周期</h3><blockquote>
<p>Bean 的生命周期</p>
</blockquote>
<ul>
<li>Bean 容器找到配置文件中 Spring Bean 的定义。</li>
<li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li>
<li>如果涉及到一些属性值 利用 set() 方法设置一些属性值。</li>
<li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName() 方法，传入 Bean 的名字。</li>
<li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader() 方法，传入 ClassLoader 对象的实例。</li>
<li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory() 方法，传入 BeanFactory 对象的实例。</li>
<li>与上面的类似，如果实现了其他 * .Aware 接口，就调用相应的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessBeforeInitialization() 方法</li>
<li>如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法。</li>
<li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li>
<li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessAfterInitialization() 方法</li>
<li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li>
<li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li>
</ul>
<h3 id="3、Bean-创建流程入口-refresh"><a href="#3、Bean-创建流程入口-refresh" class="headerlink" title="3、Bean 创建流程入口 refresh()"></a>3、Bean 创建流程入口 refresh()</h3><h4 id="相关概念回顾"><a href="#相关概念回顾" class="headerlink" title="相关概念回顾"></a>相关概念回顾</h4><h5 id="Spring上下文"><a href="#Spring上下文" class="headerlink" title="Spring上下文"></a>Spring上下文</h5><p>从代码级别来说，就是指Spring Context</p>
<p>从源码级别，我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境。</p>
<h5 id="Spring-初始化操作"><a href="#Spring-初始化操作" class="headerlink" title="Spring 初始化操作"></a>Spring 初始化操作</h5><p>具体操作可以见下#ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用</p>
<p>使用前需要引入 spring-context 相关的依赖，初始化Bean可以通过注解的方式也可以通过xml的方式。</p>
<h5 id="BeanFactory-与-ApplicationContext"><a href="#BeanFactory-与-ApplicationContext" class="headerlink" title="BeanFactory  与  ApplicationContext"></a><code>BeanFactory</code>  与  <code>ApplicationContext</code></h5><p>先了解一下  <code>BeanFactory</code> 与  <code>ApplicationContext</code> 接口两个的作用与概念：</p>
<ul>
<li><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是Spring Framework的IoC容器的基础。 </li>
<li><code>BeanFactory</code> 提供了配置框架和基本功能，提供了一种高级配置机制，能够管理任何类型的对象。</li>
<li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子接口，相比于 <code>BeanFactory</code>  来说，增加了更多的企业特定功能, 是 <code>BeanFactory</code> 的一个完整的超集。</li>
<li><code>BeanFactory</code> 实现了<strong>延迟</strong>加载（懒加载），只有在请求获取Bean时（例如，通过<code>getBean()</code>方法），容器才会创建该Bean。这意味着如果应用中未使用某个Bean，它就不会被实例化。</li>
<li><code>ApplicationContext</code>其下管理的 Bean 是<strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li>
</ul>
<h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。</p>
<h5 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a><code>AbstractApplicationContext</code></h5><p><code>AbstractApplicationContext</code> 实现了 <code>ApplicationContext</code> 接口，提供了这个接口的大部分通用功能。</p>
<p>它是实际应用上下文类（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>）的父类</p>
<p>通过继承和扩展 <code>AbstractApplicationContext</code>，Spring 允许开发者自定义应用上下文的行为，以满足特定的业务需求。</p>
<h5 id="ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？"><a href="#ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？" class="headerlink" title="ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？"></a>ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？</h5><p>以下是几个典型场景，其中可能会加载并使用 <code>ClassPathXmlApplicationContext</code> 的构造方法：</p>
<ol>
<li>Java 应用的主方法 (main)</li>
</ol>
<p>在一个标准的 Java 应用程序中，你可以在 <code>main</code> 方法中创建 <code>ClassPathXmlApplicationContext</code> 的实例来启动 Spring 容器。这是最常见的用法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">// 使用 context 获取 Bean 实例...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个例子中，<code>ClassPathXmlApplicationContext</code> 用于加载名为 “applicationContext.xml” 的配置文件。</p>
<ol start="2">
<li>Web 应用程序</li>
</ol>
<p>在基于 Servlet 的传统 Web 应用程序中，可以在 Servlet 的 <code>init</code> 方法中创建 <code>ClassPathXmlApplicationContext</code>，或者使用 Spring 的 <code>ContextLoaderListener</code> 在 Web 应用启动时自动加载 Spring 上下文。</p>
<ol start="3">
<li>单元测试</li>
</ol>
<p>在编写 Spring 应用的单元测试时，可以在测试类中创建 <code>ClassPathXmlApplicationContext</code> 来加载所需的 Spring 配置，并进行测试。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;testContext.xml&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        <span class="hljs-comment">// 执行测试...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这里，测试使用了单独的配置文件 “testContext.xml”。</p>
<ol start="4">
<li>Spring Boot 应用</li>
</ol>
<p>使用 Spring Boot 时通常不直接使用 <code>ClassPathXmlApplicationContext</code></p>
<p> Spring Boot 提供了基于注解的配置和自动配置的能力，一般是使用注解配置的方式进行声明Bean操作 ，但在一些旧的或特殊的情况下，可能仍然需要手动加载 XML 配置的方式。</p>
<hr>
<h4 id="Bean-创建流程入口"><a href="#Bean-创建流程入口" class="headerlink" title="Bean 创建流程入口"></a>Bean 创建流程入口</h4><p>这里直接跟一下源码看一下相关内容</p>
<p>下面的代码是从 spring-context-5.2.4.RELEASE 版本中的 AbstractApplicationContext 抽象类下相关方法和内容说明。</p>
<p>在实际应用上下文类中（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>），他们的构造方法中会调用这个 refresh() 方法类进行初始化 Spring 容器。</p>
<p>因此可以判断出  Bean 创建流程入口 是定义在 AbstractApplicationContext 抽象类下 refresh() 方法。</p>
<h5 id="refressh方法"><a href="#refressh方法" class="headerlink" title="refressh方法"></a>refressh方法</h5><p>这里实际看一下相关代码 AbstractApplicationContext#refresh()</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void refresh() throws BeansException, IllegalStateException &#123;<br>    <span class="hljs-comment">// 同步锁确保容器刷新时的线程安全</span><br>    synchronized (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br><br>        <span class="hljs-comment">// 准备刷新，设置启动日期和活跃状态等</span><br>        <span class="hljs-keyword">this</span>.prepareRefresh();<br><br>        <span class="hljs-comment">// 获取新的 BeanFactory，初始化 BeanFactory，并加载 Bean 定义</span><br>        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 配置 BeanFactory，设置类加载器、事件处理器等</span><br>        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 允许在 BeanFactory 标准初始化之后进行定制修改</span><br>            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// 调用在容器中注册的 BeanFactoryPostProcessor</span><br>            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 注册 BeanPostProcessor，这些处理器影响所有 Bean 的创建</span><br>            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 初始化 MessageSource 组件，用于国际化处理</span><br>            <span class="hljs-keyword">this</span>.initMessageSource();<br><br>            <span class="hljs-comment">// 初始化 ApplicationEventMulticaster，用于事件广播</span><br>            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 特定于 ApplicationContext 的刷新操作</span><br>            <span class="hljs-keyword">this</span>.onRefresh();<br><br>            <span class="hljs-comment">// 注册监听器到事件广播器</span><br>            <span class="hljs-keyword">this</span>.registerListeners();<br><br>            <span class="hljs-comment">// 初始化所有剩余的非懒加载单例</span><br>            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 完成刷新过程，通知生命周期处理器以及发布相应的事件</span><br>            <span class="hljs-keyword">this</span>.finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;<br>            <span class="hljs-comment">// 在上下文初始化过程中捕获并处理异常</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);<br>            &#125;<br><br>            <span class="hljs-comment">// 销毁已创建的 Bean，以防有些 Bean 已经初始化了，但后续的初始化过程失败了</span><br>            <span class="hljs-keyword">this</span>.destroyBeans();<br><br>            <span class="hljs-comment">// 取消刷新操作，重置上下文的同步标志</span><br>            <span class="hljs-keyword">this</span>.cancelRefresh(var9);<br><br>            <span class="hljs-comment">// 重新抛出异常，通知外部调用者</span><br>            <span class="hljs-keyword">throw</span> var9;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 重置公共缓存（例如 Reflection 缓存）</span><br>            <span class="hljs-keyword">this</span>.resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>可以看到初始化单例这步操作是在 this.finishBeanFactoryInitialization(beanFactory); 这里进行的</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 BeanFactory 包含名为 &quot;conversionService&quot; 的 Bean，并且这个 Bean 适配于 ConversionService 类型</span><br>    <span class="hljs-keyword">if</span> (beanFactory.<span class="hljs-built_in">containsBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>) &amp;&amp; beanFactory.<span class="hljs-built_in">isTypeMatch</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>)) &#123;<br>        <span class="hljs-comment">// 将这个 Bean 设置为容器的 ConversionService</span><br>        beanFactory.<span class="hljs-built_in">setConversionService</span>((ConversionService)beanFactory.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 BeanFactory 还没有嵌入的值解析器</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.<span class="hljs-built_in">hasEmbeddedValueResolver</span>()) &#123;<br>        <span class="hljs-comment">// 添加一个嵌入的值解析器，用于解析占位符</span><br>        beanFactory.<span class="hljs-built_in">addEmbeddedValueResolver</span>(strVal -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getEnvironment</span>().<span class="hljs-built_in">resolvePlaceholders</span>(strVal);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有实现 LoadTimeWeaverAware 接口的 Bean 的名称</span><br>    <span class="hljs-type">String</span>[] weaverAwareNames = beanFactory.<span class="hljs-built_in">getBeanNamesForType</span>(LoadTimeWeaverAware.<span class="hljs-keyword">class</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 遍历这些 Bean 名称</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> weaverAwareName : weaverAwareNames) &#123;<br>        <span class="hljs-comment">// 初始化相应的 Bean，以确保它们能够执行加载时织入（Load Time Weaving）的相关逻辑</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getBean</span>(weaverAwareName);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 BeanFactory 的临时类加载器设置为 null</span><br>    beanFactory.<span class="hljs-built_in">setTempClassLoader</span>(null);<br><br>    <span class="hljs-comment">// 冻结所有的 Bean 定义，表示注册的 Bean 定义将不再被修改或任何进一步的处理</span><br>    beanFactory.<span class="hljs-built_in">freezeConfiguration</span>();<br><br>    <span class="hljs-comment">// 预实例化单例，确保所有非懒加载的单例都被实例化</span><br>    beanFactory.<span class="hljs-built_in">preInstantiateSingletons</span>();<br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>下述待整理</p>
</blockquote>
<blockquote>
<p>实例化 Instantiation</p>
</blockquote>
<p>其中第一阶段 —— 实例化 Instantiation，</p>
<p>Bean 实例化的时机分为两种，一种是 BeanFactory，还有一种是  ApplicationContext；</p>
<p>下面是两者差别：</p>
<ul>
<li>BeanFactory<ul>
<li>其下管理的Bean <strong>在使用到Bean的时候</strong> 才会进行实例化Bean操作（懒加载策略）</li>
</ul>
</li>
<li>ApplicationContext  <ul>
<li>其下管理的 Bean <strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li>
<li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，复杂程度更高一些。</li>
<li>如<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>等，提供了多种方便的方式来创建ApplicationContext实例</li>
</ul>
</li>
</ul>
<hr>
<p>视频地址：  <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1584y1r7n6/">https://www.bilibili.com/video/BV1584y1r7n6/</a></p>
<p>Spring Bean 的生命周期</p>
<p>1.加载Bean定义</p>
<p>通过 loadBeanDefinitions 扫描所有xml配置、注解将Bean记录在 beanDefinitionMap 中</p>
<p>2.创建Bean对象</p>
<p>通过 createBean 遍历 beanDefinitionMap 创建bean</p>
<p>2.1.构建对象</p>
<p>容器通过 createBeanInstance 进行对象构造</p>
<p>获取构造方法：@Autowired</p>
<p>准备参数 根据类查找&gt;参数名查找</p>
<p>构造对象</p>
<p>无参对象直接实例化</p>
<p>2.2.填充属性</p>
<p>通过populateBean方法为Bean内部所需的属性进行赋值</p>
<p>通常是 @Autowired 注解的变量</p>
<p>2.3.初始化Bean对象</p>
<p>通过initializeBean对填充后的实例进行初始化</p>
<p>填充初始化容器相关信息</p>
<p>通过 invokeAwareMethods 方法：为实现aware接口【信息感知接口】的Bean 设置注入beanName、beanFactory等容器信息</p>
<p>初始化构造方法</p>
<p>通过 invokeInitMethods 方法进行初始化：</p>
<p>如果Bean实现InitializingBean接口进行处理【未实现则不进行】</p>
<p>afterPropertiesSet方法【bean填充属性后执行】<br>initMethod 方法<br>Bean的后置处理<br>在invokeInitMethods 的前后进行</p>
<p>applyBeanPostProcessorsBeforeInitialization<br>invokeInitMethods<br>applyBeanPostProcessorsAfterInitialization<br>在后置处理中处理了包括：AOP【AnnotationAwareAspectJAutoProxyCreator】</p>
<p>负责 构造后@PostConstruct 和 销毁前@PreDestroy 的  InitDestoryAnnotationBeanPostProcessor 等</p>
<p>注册销毁</p>
<p>通过reigsterDisposableBean处理实现了DisposableBean接口的Bean的注册</p>
<p>3.添加到单例池</p>
<p>通过 addSingleton 方法，将Bean 加入到单例池 singleObjects </p>
<h3 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h3><p>4.1.销毁前</p>
<p>调用 bean中@PreDestory 注解的方法</p>
<p>通过 postProcessBeforeDestruction 方法调用destoryBean逐一销毁Bean</p>
<p>4.2.销毁</p>
<p>调用 destoryBeans</p>
<p>4.3.执行客户自定义销毁</p>
<p>调用 invokeCustomDestoryMethod</p>
<blockquote>
<p>使用示例</p>
</blockquote>
<p>to be contined…</p>
<h3 id="4、Spring-Bean-生命周期流程图"><a href="#4、Spring-Bean-生命周期流程图" class="headerlink" title="4、Spring Bean 生命周期流程图"></a>4、<strong>Spring Bean 生命周期流程图</strong></h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312160247944.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<hr>
<p>参考</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html">https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html</a></li>
<li><a target="_blank" rel="noopener" href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li>
<li><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1584y1r7n6">https://www.bilibili.com/video/BV1584y1r7n6</a></li>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_20021569/article/details/109178816">https://blog.csdn.net/qq_20021569/article/details/109178816</a></li>
<li><a target="_blank" rel="noopener" href="https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></li>
<li><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/2216932">https://cloud.tencent.com/developer/article/2216932</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%A1%86%E6%9E%B6/" class="category-chain-item">框架</a>
  
  
    <span>></span>
    
  <a href="/categories/%E6%A1%86%E6%9E%B6/Spring/" class="category-chain-item">Spring</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/spring/" class="print-no-link">#spring</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Spring学习_Spring_Bean的生命周期</div>
      <div>https://varcel.luoqi.icu/2023/12/15/Spring学习_Spring_Bean的生命周期/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luo QI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
