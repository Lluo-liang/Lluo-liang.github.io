

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/Xbox%20L.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luo QI">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试煎熬成蛋_Redis">
<meta property="og:type" content="article">
<meta property="og:title" content="面试煎熬成蛋_Redis">
<meta property="og:url" content="https://varcel.luoqi.icu/2024/03/10/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B_Redis/index.html">
<meta property="og:site_name" content="轻松的洛亓">
<meta property="og:description" content="面试煎熬成蛋_Redis">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150024266.jpeg">
<meta property="article:published_time" content="2024-03-10T19:57:18.000Z">
<meta property="article:modified_time" content="2024-03-10T19:57:18.000Z">
<meta property="article:author" content="Luo QI">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150024266.jpeg">
  
  
  
  <title>面试煎熬成蛋_Redis - 轻松的洛亓</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"varcel.luoqi.icu","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  <meta name="baidu-site-verification" content="codeva-Oq0KOjHuD3" />
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>轻松的洛亓</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311131716524.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试煎熬成蛋_Redis"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-03-10 19:57" pubdate>
          2024年3月10日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          10k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          87 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">面试煎熬成蛋_Redis</h1>
            
            
              <div class="markdown-body">
                
                <p>常见面试题：</p>
<ul>
<li>Redis 的数据类型</li>
<li>谈一下布隆过滤器</li>
<li>Redis 为什么这么快</li>
<li>Redis 为什么要引入多线程</li>
<li>什么是 IO 多路复用</li>
<li>讲一下 Redis 的 Reactor 模型</li>
<li>Redis 如何获取所有 key</li>
<li>讲一下 Redis 持久化</li>
<li>Redis 怎么实现高可用的</li>
<li>Redisi主从复制（同步）原理</li>
<li>哨兵选主过程</li>
<li>Redis Cluster主从选举过程</li>
<li>主从选举的脑裂问题</li>
<li>缓存雪崩、缓存击穿、缓存穿透</li>
<li>热点缓存并发重建</li>
<li>数据库和缓存双写不一致</li>
<li>Redis分布式锁实现</li>
<li>过期键的删除策略</li>
<li>内存淘汰策略有哪些</li>
</ul>
<h4 id="Redis-在你项目中是怎么使用的"><a href="#Redis-在你项目中是怎么使用的" class="headerlink" title="Redis 在你项目中是怎么使用的"></a>Redis 在你项目中是怎么使用的</h4><p>讲一下 Redis 的用法</p>
<p>缓冲、分布式锁</p>
<p>缓冲  →  Jwt </p>
<h4 id="常用的缓存读写策略"><a href="#常用的缓存读写策略" class="headerlink" title="常用的缓存读写策略"></a>常用的缓存读写策略</h4><p>缓存常用的三种读写策略：Cache Aside Pattern（旁路缓存模式）、Read&#x2F;Write Through Pattern（读写穿透）、Write Behind Pattern（异步缓存写入）</p>
<h4 id="讲一下-Redis-事务"><a href="#讲一下-Redis-事务" class="headerlink" title="讲一下 Redis 事务"></a>讲一下 Redis 事务</h4><p>不是很推荐使用Redis事务，跟我们常见的关系型数据库事务不同：</p>
<ul>
<li>1、Redis 事务是不支持回滚（roll back）操作的，Redis 事务不满足原子性。</li>
<li>2、Redis 事务的持久性是没办法保证的</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202402261559889.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<blockquote>
<p>Lua 脚本</p>
</blockquote>
<p>与事务相对的话，更推荐使用 Lua 脚本执行批量任务；</p>
<ul>
<li>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</li>
</ul>
<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<hr>
<p>Redis的Lua脚本功能是其强大特性之一，提供了在Redis服务器端执行脚本的能力。这允许执行一系列操作，这些操作作为一个整体原子地执行，而不是由客户端逐一发送命令然后由服务器逐一执行。</p>
<p>Lua是一种轻量级的编程语言，被嵌入到Redis中用于执行复杂的逻辑，这在多个命令需要作为单个原子操作执行时特别有用。</p>
<blockquote>
<p>使用示例：</p>
</blockquote>
<p>假设我们需要更新一个计数器，但只有在另一个键存在时才进行更新。不使用Lua脚本，我们可能需要先检查键是否存在，然后再更新计数器，这两步操作不能保证原子性。</p>
<p>使用Lua脚本，我们可以这样做：</p>
<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">if</span> redis.<span class="hljs-keyword">call</span>(&quot;EXISTS&quot;, KEYS[<span class="hljs-number">1</span>]) == <span class="hljs-number">1</span> <span class="hljs-keyword">then</span><br>    <span class="hljs-keyword">return</span> redis.<span class="hljs-keyword">call</span>(&quot;INCR&quot;, KEYS[<span class="hljs-number">2</span>])<br><span class="hljs-keyword">else</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<ul>
<li>这个脚本接受两个键作为输入：<code>KEYS[1]</code>用于检查存在性，<code>KEYS[2]</code>是需要增加的计数器。如果<code>KEYS[1]</code>存在，脚本将增加<code>KEYS[2]</code>的值并返回新值；如果不存在，返回0。</li>
</ul>
<p>执行脚本操作(使用<code>EVAL</code>命令执行Lua脚本)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">EVAL <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-handlebars"><span class="language-xml"> <span class="hljs-tag">&lt;<span class="hljs-name">numkeys</span>&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">key</span>&gt;</span> [<span class="hljs-tag">&lt;<span class="hljs-name">key2</span>&gt;</span> ...] [<span class="hljs-tag">&lt;<span class="hljs-name">arg</span>&gt;</span> [<span class="hljs-tag">&lt;<span class="hljs-name">arg2</span>&gt;</span> ...]]</span></span><br></code></pre></td></tr></table></figure>

<ul>
<li><code>&lt;script&gt;</code>：Lua脚本文本。</li>
<li><code>&lt;numkeys&gt;</code>：脚本中将要处理的键的数量。</li>
<li><code>&lt;key&gt;</code>：脚本中用到的Redis键。</li>
<li><code>&lt;arg&gt;</code>：传递给脚本的其他参数。</li>
</ul>
<h4 id="Redis-的常用命令"><a href="#Redis-的常用命令" class="headerlink" title="Redis 的常用命令"></a>Redis 的常用命令</h4><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><h4 id="Redis-常见的数据结构"><a href="#Redis-常见的数据结构" class="headerlink" title="Redis 常见的数据结构"></a>Redis 常见的数据结构</h4><ul>
<li>String<ul>
<li>string 主要是⽤来存储字符串，底层是基于 动态字符串sds 实 现的，sds 通过动态调整⻓度来节省内存</li>
<li>应⽤场景 <ul>
<li>分布式session </li>
<li>分布式锁</li>
</ul>
</li>
<li>常用指令：<ul>
<li>set、get、setnx、setex ..</li>
</ul>
</li>
</ul>
</li>
<li>hash<ul>
<li>hash 类似于 Map，底层采⽤两种⽅式来实现，当数据量较少 并且元素占⽤内存少(⼩整数或短字符串)时，采⽤ ziplist(压缩 列表)，反之采⽤ hashtable(哈希表)，两种⽅式都是为了节省 内存<ul>
<li>ziplist 是⼀个连续的内存空间，通过紧凑的存储来节省空 间</li>
<li>hashtable 是基于dict(字典)实现，采⽤拉链法解决hash冲 突</li>
</ul>
</li>
<li>应用场景<ul>
<li>实现购物⻋</li>
</ul>
</li>
<li>常用指令<ul>
<li>hset、hget、hgetall、hdel、hincrby ..</li>
</ul>
</li>
</ul>
</li>
<li>list<ul>
<li>list 是⼀个有序可重复集合，底层采⽤两种⽅式实现，当数据 量较少并且元素占⽤内存少(⼩整数或短字符串)时，采⽤ ziplist(压缩列表)，反之采⽤ quicklist(快速列表)，两种⽅式都 是为了节省内存<ul>
<li>ziplist 是⼀个连续的内存空间，通过紧凑的存储来节省空 间</li>
<li>quicklist 是基于 ziplist 和 双向链表 实现的，可以在节省空 间的同时保证⾼效增删</li>
</ul>
</li>
<li>应用场景<ul>
<li>栈(lpush + lpop) </li>
<li>队列(lpush + rpop) </li>
<li>阻塞队列(lpush + brpop) </li>
<li>发布订阅</li>
</ul>
</li>
<li>常用指令<ul>
<li>lpush、lpop、rpush、rpop、blpop、brpop、lrange ..</li>
</ul>
</li>
</ul>
</li>
<li>set<ul>
<li>set 是⼀个⽆序不可重复集合，底层采⽤两种⽅式实现，当数 据量较少且元素为整数时，采⽤ intset(整数集合)，反之采⽤ hashtable(哈希表)，两种⽅式都是为了节省内存<ul>
<li>intset 是⼀个有序的整数数组，通过紧凑的存储来节省空 间</li>
<li>hashtable 是基于dict(字典)实现，采⽤拉链法解决hash冲 突</li>
</ul>
</li>
<li>应用场景<ul>
<li>抽奖(srandmember) </li>
<li>点赞收藏关注(sadd) </li>
<li>共同关注(sinter) </li>
<li>可能认识的⼈(sdiff)</li>
</ul>
</li>
<li>常用指令<ul>
<li>sadd、srem、smembers、scard、srandmember、 sismember、spop、sinter、sunion、sdiff、sinterstore、 sdiffstore</li>
</ul>
</li>
</ul>
</li>
<li>zset(sorted set)<ul>
<li>zset 是⼀个有序不可重复集合，底层采⽤两种⽅式实现，当数 据量较少并且元素占⽤内存少(⼩整数或短字符串)，采⽤ ziplist(压缩列表)，反之采⽤skiplist(跳表) + dict(字典)，两种 ⽅式都是为了节省内存，另外skiplist主要是为了提升score查 询效率<ul>
<li>ziplist 是⼀个连续的内存空间，通过紧凑的存储来节省空 间</li>
<li>skiplist 是⼀个有序链表配上多级索引，通过多级索引位置 的跳转来实现快速查找元素，主要⽤于按照分值对元素进 ⾏排序，同样也⽀持范围查询<ul>
<li>跳表如何定位元素<ul>
<li>每隔⼀个元素建⽴⼀个索引，通过建⽴多个索引， 利⽤⼀次索引定位到需要查询的元素，如果觉得 慢，可以在⼀级索引的基础上建⽴⼆级索引，依次 类推，在多级索引之间来回转跳实现快速定位，当 数据量特别⼤的时候，查找时间复杂度为O(logN)， 因为它本身的思想就类似⼆分查找</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>应用场景<ul>
<li>排⾏榜(zrange&#x2F;zreverange&#x2F;zunionscore)</li>
</ul>
</li>
<li>常用指令<ul>
<li>zadd、zrem、zsore、zincrby、zrange、zreverange、 zrangebyscore、zreverangescore、zunionscore、 zinterscore</li>
</ul>
</li>
</ul>
</li>
<li>bitmap<ul>
<li>bitmap是⼀个位图</li>
<li>应⽤场景 <ul>
<li>⽉打卡、⽉活跃 <ul>
<li>⽉打卡可以通过将 当前第⼏天 作为 偏移量，如果打卡 对应的位置为1，反之为0</li>
</ul>
</li>
<li>布隆过滤器</li>
</ul>
</li>
</ul>
</li>
<li>stream<ul>
<li>stream 是参考kafka设计的消息队列，⽀持持久化，适合⼩基 数的消息队列场景</li>
</ul>
</li>
</ul>
<h4 id="String-数据类型在项目中的实际使用"><a href="#String-数据类型在项目中的实际使用" class="headerlink" title="String 数据类型在项目中的实际使用"></a>String 数据类型在项目中的实际使用</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240311220409.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="ZSet-为什么使用跳表"><a href="#ZSet-为什么使用跳表" class="headerlink" title="ZSet 为什么使用跳表"></a>ZSet 为什么使用跳表</h4><h4 id="谈一下布隆过滤器"><a href="#谈一下布隆过滤器" class="headerlink" title="谈一下布隆过滤器"></a>谈一下布隆过滤器</h4><p>布隆过滤器 是基于bitmap实现的，主要⽤于粗略的数据过滤 </p>
<ul>
<li>添加数据时，经过hash运算得到对应的 bit位，将该 bit位 置为1 <ul>
<li>bit位为1 表示可能存在 </li>
<li>bit位为0 表示⼀定不存在</li>
</ul>
</li>
</ul>
<h3 id="内存、读写"><a href="#内存、读写" class="headerlink" title="内存、读写"></a>内存、读写</h3><h4 id="讲一下-Redis-持久化-🚩"><a href="#讲一下-Redis-持久化-🚩" class="headerlink" title="讲一下 Redis 持久化  🚩"></a>讲一下 Redis 持久化  🚩</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312171845.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Redis-为什么这么快-🚩"><a href="#Redis-为什么这么快-🚩" class="headerlink" title="Redis 为什么这么快  🚩"></a>Redis 为什么这么快  🚩</h4><ul>
<li>1、主要还是基于内存操作</li>
<li>2、是单线程的，避免了不必要的上下文切换可竞争条件，多线程需要考虑线程安全问题</li>
<li>3、使用 IO 多路复用模型，非阻塞 IO</li>
<li>4、Redis 的每种数据结构进行了优化处理</li>
</ul>
<h4 id="什么是-IO-多路复用"><a href="#什么是-IO-多路复用" class="headerlink" title="什么是 IO 多路复用"></a>什么是 IO 多路复用</h4><p>Rdis是纯内存操作，执行速度非常快，它的性能瓶颈是网络延迟而不是执行速度，</p>
<p>I&#x2F;O多路复用模型主要就是实现了高效的网络请求</p>
<ul>
<li>用户空间和内核空间</li>
<li>常见的  IO 模型<ul>
<li>阻塞IO(Blocking IO)</li>
<li>非阻塞IO(Nonblocking IO)</li>
<li>IO多路复用(IO Multiplexing)</li>
</ul>
</li>
<li>Redis网络模型</li>
</ul>
<p>阻塞IO 是常见 的IO 操作模型，但是它实际的效率并不是很高；用户态在内核读取数据和从内核拷贝到用户缓冲区的两个阶段都需要等待阻塞运行。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317144125.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>非阻塞IO，在内核态读取这一阶段，用户阶段并不会持续阻塞等待，而是自旋询问是否数据准备就绪，如果未就绪，就循环尝试读取。</p>
<p>阶段二仍然会被阻塞，但由于忙等机制实际效率并没有提高很多。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317144427.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>IO 多路复用</p>
<p>监听了多个 socker，并且其中只要有一个 socket 就绪，就可以进行系统调用 recvfrom</p>
<p>和前者最大的区别是：非阻塞 iO 或者 阻塞 IO  需要等待它目前在读取的 socket 数据准备就绪才可以下一步操作（而实际上可能它后面的 socket 是已经准备就绪了）</p>
<p>通过这个监听机制，可以有效提高效率</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317145015.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>常见 的 IO  多路复用模式有： select、poll、epoll；</p>
<p>然后前两个的机制：select 和 poll 会有一个监听，然后只是监听里面有没有就绪的，如果有，遍历逐个来判断；<br>而 epoll 机制能够精确定位到具体是哪一个，而不用遍历。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317145752.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>Reids 网络模型：IO多路复用 + 事件派发机制</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317150021.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Redis-为什么要引入多线程"><a href="#Redis-为什么要引入多线程" class="headerlink" title="Redis 为什么要引入多线程"></a>Redis 为什么要引入多线程</h4><p>影响效率最大的是 网络 IO</p>
<p>Redis 多线程 在命令回复处理器和 接受参数数据，转换Redis 命令 （网络IO 方面的内容）进行了优化（加入了多线程）</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317150227.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>Redis引⼊多线程主要想发挥多核处理器的能⼒，处理在⼤数据量下 ⽹络IO读写速度慢的问题，但是指令的执⾏依旧采⽤的是单线程</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317150349.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>面试官：Redis是单线程的，但是为什么还那么快？</p>
<p>候选人：</p>
<p>嗯，这个有几个原因吧~~~<br>1、完全基于内存的，C语言编写<br>2、采用单线程，避免不必要的上下文切换可竞争条件<br>3、使用多路1&#x2F;0复用模型，非阻塞I0</p>
<p>例如：bgsave和bgrewriteaof都是在后台执行操作，不影响主线程的正常使用，不会产生阻塞</p>
<p>面试官：能解释一下1&#x2F;O多路复用模型？</p>
<p>候选人：嗯~，I&#x2F;O多路复用是指利用单个线程来同时监听多个Socket,并在某个Socketi可读、可写时<br>得到通知，从而避免无效的等待，充分利用CPU资源。目前的1&#x2F;O多路复用都是采用的epo模式实现，<br>它会在通知用户进程Socket就绪的同时，把己就绪的Socket写入用户空间，不需要挨个遍历Socket来判<br>断是否就绪，提升了性能。<br>其中Redis的网络模型就是使用I&#x2F;O多路复用结合事件的处理器来应对多个Socketi请求，比如，提供了连<br>接应答处理器、命令回复处理器，命令请求处理器：<br>在Redis6.0之后，为了提升更好的性能，在命令回复处理器使用了多线程来处理回复事件，在命令请求<br>处理器中，将命令的转换使用了多线程，增加命令转换速度，在命令执行的时候，依然是单线程</p>
<h4 id="讲一下-Redis-的-Reactor-模型"><a href="#讲一下-Redis-的-Reactor-模型" class="headerlink" title="讲一下 Redis 的 Reactor 模型"></a>讲一下 Redis 的 Reactor 模型</h4><h4 id="过期键的删除策略"><a href="#过期键的删除策略" class="headerlink" title="过期键的删除策略"></a>过期键的删除策略</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312184918.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>假如redis的 key 过期之后，会立即删除吗？  set name heima 10</p>
<ul>
<li>Redis 对数据设置数据的有效时间，数据过期以后，就需要将数据从内存中删除掉。</li>
<li>可以按照不同的规则进行删除，这种删除规则就被称之为数据的删除策略（数据过期策略）。</li>
</ul>
<p>常见的过期策略</p>
<ul>
<li>惰性删除<ul>
<li>只有当访问一个key的时候，才会判断的当前key是否已过期，已过期就会删除</li>
<li>这个策略可以节省CPU资源，但是占用内存，可能因为大量的key不被再次访问，导致一直不清除从而占用内存</li>
</ul>
</li>
<li>定期删除<ul>
<li>每隔一段时间会扫描一定数量的过期key,并且清除已过期的key。</li>
<li>这个策略属于折中方案，可以有效的平衡CPU资源以及内存资源</li>
<li>定期清理有两种模式：<ul>
<li>SLOW 模式是定时任务，执行频率默认为10hz,每次不超过25ms,以通过修改配置文件redis.conf的hz选项来调整这个次数</li>
<li>FAST 模式执行频率不固定，但两次间隔不低于2ms,每次耗时不超过1ms</li>
</ul>
</li>
</ul>
</li>
<li>强制删除<ul>
<li>当已使用内存超过Redis:最大允许内存，会触发内存淘汰策略</li>
</ul>
</li>
<li>Redis中<strong>同时使用了惰性删除和定期删除</strong></li>
</ul>
<h4 id="内存淘汰策略有哪些"><a href="#内存淘汰策略有哪些" class="headerlink" title="内存淘汰策略有哪些"></a>内存淘汰策略有哪些</h4><p>数据的淘汰策略：当Redis中的内存不够用时，此时在向Redisr中添加新的key,那么Redis 就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p>
<ul>
<li>默认策略noeviction，当内存不⾜以容纳新写⼊数据时，新写⼊操作 会报错</li>
<li>针对设置过期时间的key<ul>
<li>volatile-lru，按照LRU算法删除 </li>
<li>volatile-lfu，按照LFU算法删除 </li>
<li>volatile-radom，随机删除 </li>
<li>volatile-ttl，按过期时间顺序删除</li>
</ul>
</li>
<li>针对所有key<ul>
<li>allkeys-random，随机删除 </li>
<li>allkeys-lru，按照LRU算法删除 </li>
<li>allkeys-lfu，按照LFU算法删除</li>
</ul>
</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312171303.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>关于数据淘汰策略其他的面试问题</p>
<ul>
<li>1.数据库有1000万数据，Redis只能缓存20w数据，如何保证Redis 中的数据都是热点数据？<ul>
<li>使用allkeys-lru(挑选最近最少使用的数据淘汰)淘汰策略，留下来的都是经常访问的热点数据</li>
</ul>
</li>
<li>2.Redis的内存用完了会发生什么？<ul>
<li>主要看数据淘汰策略是什么？如果是默认的配置(noeviction),会直接报错</li>
</ul>
</li>
</ul>
<p>记忆点：</p>
<p>数据淘汰策略</p>
<ul>
<li>1.Redis提供了8种不同的数据淘汰策略，默认是 noeviction 不删除任何数据，内存不足直接报错</li>
<li>2.LRU: 最少最近使用。用当前时间减去最后一次访问时间，这个值越大则淘汰优先级越高。</li>
<li>3.LFU:最少频率使用。会统计每个key的访问频率，值越小淘汰优先级越高</li>
</ul>
<p>平时开发过程中用的比较多的就是allkeys-lru(结合自己的业务场景)</p>
<h3 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h3><h4 id="Redis-怎么实现高可用的"><a href="#Redis-怎么实现高可用的" class="headerlink" title="Redis 怎么实现高可用的"></a>Redis 怎么实现高可用的</h4><h4 id="Redisi主从复制（同步）原理"><a href="#Redisi主从复制（同步）原理" class="headerlink" title="Redisi主从复制（同步）原理"></a>Redisi主从复制（同步）原理</h4><ul>
<li>通过 RDB 日志文件和偏移量操作</li>
</ul>
<p>全量同步操作</p>
<ul>
<li>1、从节点发起同步请求</li>
<li>2、主节点判断是否是第一次同步，如果是第一次，进行全量同步，如果不是，判断 数据集 replid 是否一致<ul>
<li>是，第一次，会返回 master 的数据版本信息 replid、offset</li>
</ul>
</li>
<li>3、从节点会保存版本信息</li>
<li>4、主节点会生成 RDB 文件进行发送操作</li>
<li>5、从节点会清空本地数据，加载 RDB 文件</li>
<li>6、从节点加载过程会主节点会生成一个 repl_baklog 的文件（中间执行操作），并发送到从节点</li>
<li>7、从节点再进行加载进行同步</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317151632.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>增量同步操作</p>
<ul>
<li>从 reol_baklog 获取数据发送到从节点</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152226.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>参考</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152304.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="讲一下-哨兵选主过程"><a href="#讲一下-哨兵选主过程" class="headerlink" title="讲一下 哨兵选主过程"></a>讲一下 哨兵选主过程</h4><p>哨兵：高可用，提供监控范围和自动故障恢复与通知</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152413.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>选取操作</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152506.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>哨兵模式中会遇到一个问题：脑裂问题</p>
<h4 id="讲一下-主从选举的脑裂问题"><a href="#讲一下-主从选举的脑裂问题" class="headerlink" title="讲一下 主从选举的脑裂问题"></a>讲一下 主从选举的脑裂问题</h4><p>集群脑裂是由于主节点和从节点和sentinel处于不同的网络分区，使得sentinel没有能够心跳感知到主节点，所以通过选举的方式提升了一个从节点为主，这样就存在了两个master,就像大脑分裂了一样，这样会导致客户端还在老的主节点那里写入数据，新节点无法同步数据，当网络恢复后，sentinel会将老的主节点降为从节点，这时再从新master 同步数据，就会导致数据丢失</p>
<p>解决：我们可以修改rds的配置，可以设置最少的从节点数量以及缩短主从数据同步的延迟时间，达不到要求就拒绝请求就可以避免大量的数据丢失。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152818.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>参考</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317152938.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="分片集群"><a href="#分片集群" class="headerlink" title="分片集群"></a>分片集群</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317153141.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>参考</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317153308.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="讲一下Redis-Cluster主从选举过程"><a href="#讲一下Redis-Cluster主从选举过程" class="headerlink" title="讲一下Redis Cluster主从选举过程"></a>讲一下Redis Cluster主从选举过程</h4><h3 id="生产问题"><a href="#生产问题" class="headerlink" title="生产问题"></a>生产问题</h3><h4 id="数据一致性"><a href="#数据一致性" class="headerlink" title="数据一致性"></a>数据一致性</h4><ul>
<li>查询<ul>
<li>当需要获取数据时，首先查询缓存。</li>
<li>如果缓存中有数据（缓存命中），则直接返回缓存中的数据。</li>
<li>如果缓存中没有数据（缓存未命中），则查询数据库，将查询结果存入缓存，并返回数据。</li>
<li>设置合理的缓存过期时间，以保证数据的时效性。</li>
</ul>
</li>
<li>更新<ul>
<li>遇到写请求的时候是先更新数据库，再删除 cache</li>
</ul>
</li>
<li>删除<ul>
<li>当数据需要被删除时，首先删除数据库中的数据。</li>
<li>然后删除缓存中对应的数据，保持数据库和缓存的一致性。</li>
</ul>
</li>
</ul>
<p>缓存读写策略一般选择使用旁路缓存模式</p>
<p>常用的缓存读写策略</p>
<ul>
<li>Cache Aside Pattern（旁路缓存模式）<ul>
<li>读<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
</li>
<li>写<ul>
<li>先更新 db，然后直接删除 cache</li>
</ul>
</li>
</ul>
</li>
<li>Read&#x2F;Write Through Pattern（读写穿透）<ul>
<li>读<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
</li>
<li>写<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
</li>
</ul>
</li>
<li>Write Behind Pattern（异步缓存写入）<ul>
<li>读</li>
<li>写<ul>
<li>**Read&#x2F;Write Through 是同步更新 cache 和 db，</li>
<li>Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>保持数据库和缓存数据一致性</p>
<ul>
<li>1、数据库中数据中全量刷写到缓存中，不设置失效时间 + 定时任务</li>
<li>2、保留热数据（都设置一个合理的过期时间）</li>
<li>3、旁路缓存模式 + 保证删除操作非异常执行（MQ异步 + 订阅日志机制）</li>
</ul>
<h4 id="怎么保存缓存和数据库数据一致（数据一致性怎么保证）"><a href="#怎么保存缓存和数据库数据一致（数据一致性怎么保证）" class="headerlink" title="怎么保存缓存和数据库数据一致（数据一致性怎么保证）"></a>怎么保存缓存和数据库数据一致（数据一致性怎么保证）</h4><p>延迟双删 + 定时刷新</p>
<p>策略</p>
<ul>
<li>1、数据库中数据中全量刷写到缓存中，不设置失效时间 + 定时任务</li>
<li>2、保留热数据</li>
</ul>
<p>旁路缓存模式 + 保证删除操作非异常执行（MQ异步 + 订阅日志机制）</p>
<p>思考：</p>
<ul>
<li>一旦我们决定使用缓存，那必然要面临一致性问题。性能和一致性就像天平的两端，无法做到都满足要求。</li>
<li>既然决定使用缓存，就必须容忍「一致性」问题，我们只能尽可能地去降低问题出现的概率。</li>
</ul>
<blockquote>
<p>缓存和数据库不一致</p>
</blockquote>
<p>一般是采用：Cache Aside Pattern（旁路缓存模式）: 遇到写请求的时候是先更新数据库，再删除 cache</p>
<p>这种情况下发生数据不一致的情况比较小，</p>
<p>在这种情况下，在数据库更新和缓存删除之间有读取请求，它也只会读到旧的数据，一旦缓存被删除，下一个读取请求将从数据库中获取最新的数据，并更新缓存，从而保持了一致性。</p>
<p>需要避免缓存和数据库不一致需要考虑的点：避免第二步操作【删除 cache】失败</p>
<p>解决方案：</p>
<ol>
<li>缓存失效时间变短（不推荐，治标不治本）<ol>
<li>我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。</li>
</ol>
</li>
<li>增加 cache 更新重试机制（常用）<ol>
<li>如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，</li>
<li>重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
</li>
</ol>
<blockquote>
<p>第二种方式采用方案：</p>
</blockquote>
<ol>
<li>引入消息队列来进行异步重试操作（将删除 cache 操作放在消费者这步操作） </li>
<li>订阅数据库变更日志，再操作缓存</li>
</ol>
<hr>
<p>当缓存操作失败时，通过设置重试机制来确保缓存最终能够与数据库数据保持一致。具体步骤包括：</p>
<p>A. <strong>直接重试</strong></p>
<p>在缓存操作（如删除、更新）失败时，立即进行重试。可以设定一个最大重试次数，避免无限重试。</p>
<p>B. <strong>延时重试</strong></p>
<p>如果直接重试仍然失败，可以将失败的操作延时一段时间后再重试，延时重试可以通过定时任务或延时队列实现。</p>
<p>C. <strong>失败队列</strong></p>
<p>如果重试多次后仍然失败，将更新失败的key存入一个特定的队列中。等到缓存服务恢复正常后，再统一处理这些失败的操作。</p>
<blockquote>
<p>具体实施方案</p>
</blockquote>
<p>引入消息队列（异步重试）</p>
<ul>
<li><strong>消息队列保证可靠性</strong>：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li>
<li><strong>消息队列保证消息成功投递</strong>：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li>
</ul>
<p>使用消息队列作为异步处理机制，<strong>将需要更新或删除的缓存操作</strong>作为消息发送到队列中，由消费者负责执行实际的缓存更新任务。这样即使缓存服务暂时不可用，也不会影响主业务流程，待缓存服务恢复后再通过消费消息来同步缓存。</p>
<p>订阅数据库变更日志</p>
<p>另一个高级的方案是直接订阅数据库的变更日志（如果数据库支持），如MySQL的binlog。通过解析变更日志，对相关缓存进行更新或删除操作。这种方法可以确保缓存数据的最终一致性，但实现复杂，对数据库和缓存系统的要求较高。</p>
<h4 id="数据双写不一致（数据一致性）"><a href="#数据双写不一致（数据一致性）" class="headerlink" title="数据双写不一致（数据一致性）"></a>数据双写不一致（数据一致性）</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317223928.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="讲一下延迟双删"><a href="#讲一下延迟双删" class="headerlink" title="讲一下延迟双删"></a>讲一下延迟双删</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317223544.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="缓存雪崩、缓存击穿、缓存穿透"><a href="#缓存雪崩、缓存击穿、缓存穿透" class="headerlink" title="缓存雪崩、缓存击穿、缓存穿透"></a>缓存雪崩、缓存击穿、缓存穿透</h4><ul>
<li>缓存穿透<ul>
<li>缓存穿透是指当请求的数据既不在缓存中也不存在于数据库中时，导致请求直接到达数据库层的现象。</li>
<li>成因：频繁查询不存在的数据（可能是由于错误的输入或恶意攻击）</li>
<li>解决方案<ul>
<li><strong>空对象缓存</strong>（缓存空结果）<ul>
<li>即使某个值在数据库中不存在，也可以在缓存中存储一个特殊的空对象或空值，并设置较短的过期时间。</li>
<li>这样，相同的无效请求在这个过期时间内会直接得到缓存中的空结果，而不会再次查询数据库。</li>
<li>缺点：可能会导致期间使用内存较高，缓存资源浪费</li>
</ul>
</li>
</ul>
</li>
<li><strong>布隆过滤器</strong><ul>
<li>在查询之前使用布隆过滤器判断数据是否可能存在。布隆过滤器是一种空间效率高但可能有一定误判率的数据结构。</li>
</ul>
</li>
</ul>
</li>
<li>缓存击穿<ul>
<li>缓存击穿是指缓存中某个热点key突然失效（过期），导致大量并发请求直接落到数据库上，造成数据库短时间内压力剧增的现象。</li>
<li>与缓存穿透不同，缓存击穿是针对原本就存在于缓存中的热点数据。</li>
<li>成因：热点数据在缓存中突然过期，而此时正有大量并发请求这些数据。</li>
<li>解决方案<ul>
<li><ul>
<li><strong>设置热点数据永不过期</strong><ul>
<li>对于一些热点数据，可以设置其缓存永不过期，或者设置一个非常长的过期时间，从而避免缓存击穿问题。</li>
<li>但这种方法需要定期手动或通过程序更新缓存，以保证数据的新鲜度</li>
</ul>
</li>
</ul>
</li>
<li><strong>互斥锁</strong><ul>
<li>在缓存失效的瞬间，使用互斥锁或分布式锁，确保只有一个请求去数据库查询数据并重新缓存。</li>
<li>其他请求等待缓存加载完成后再访问缓存</li>
</ul>
</li>
<li>提前预热<ul>
<li>在缓存即将过期前，后台异步程序提前更新缓存中的数据，这样可以确保热点数据在缓存中始终是可用的</li>
</ul>
</li>
<li><strong>二级缓存策略</strong><ul>
<li>为热点数据设置两级缓存，第一级缓存正常设置过期时间；第二级缓存设置较长的过期时间。当第一级缓存失效时，请求可以访问第二级缓存，同时异步更新第一级缓存和第二级缓存数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>缓存雪崩<ul>
<li>缓存雪崩是指缓存中<strong>大量数据同时过期</strong>，导致所有的请求都直接访问数据库，可能会使数据库压力过大甚至崩溃。</li>
<li>成因<ul>
<li>缓存设置了相同的过期时间，导致大量数据同时过期。</li>
<li>缓存服务崩溃，所有数据丢失。</li>
</ul>
</li>
<li>解决方案<ul>
<li><ul>
<li><strong>不同的过期时间</strong>：为缓存数据设置不同的过期时间，避免同时过期。（可以在设置缓存过期时间时加入随机值）</li>
</ul>
</li>
<li><strong>缓存数据预热</strong>：系统启动时预先加载热点数据到缓存中。</li>
<li>限流降级：在系统入口处使用限流降级策略，避免在缓存失效时，突发流量直接打到数据库。</li>
<li>使用多级缓存策略</li>
<li><strong>使用高可用的缓存架构</strong>：比如使用Redis集群，提高缓存系统的稳定性和容错能力。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结一下上面的三个常见的生产问题：缓存穿透、缓存击穿、缓存雪崩；</p>
<ul>
<li>1、缓存穿透指的不存在的数据进行访问缓存，并打到数据库中，解决方案一般有：空对象缓存、布隆过滤器</li>
<li>2、缓存击穿和缓存雪崩有点像，都是缓存失效，但前者一般是热点数据，后者是大量数据同时过期；<ul>
<li>热点数据建议做一下预热处理，在快要过期的时候进行处理一下；或者说常用的两种处理方案：<ul>
<li>设置热点数据不过期，不过后续需要手动进行更新缓存或者程序更新</li>
<li>设置互斥锁，保证同一时刻访问缓存的数据（缓存中不存在的数据），此时只有一个</li>
</ul>
</li>
<li>大量数据过期建议使用随机过期时间，同时可以设置一下限流，防止大量数据同时请求；也可以设置多级的一个缓存策略操作。</li>
</ul>
</li>
</ul>
<h4 id="Redis分布式锁实现-🚩"><a href="#Redis分布式锁实现-🚩" class="headerlink" title="Redis分布式锁实现 🚩"></a>Redis分布式锁实现 🚩</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312113112.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>使用 Redis 可以实现分布式情况下对访问资源进行加锁</p>
<ul>
<li>1、通过 setnx 命令进行加锁</li>
<li>2、是否锁通过 del 命令删除对应的key<ul>
<li>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</li>
<li>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性</li>
</ul>
</li>
<li>3、优化项<ul>
<li>考虑为了避免锁无法释放，一个解决方法是：给这个锁加一个过期时间</li>
<li><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！！！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</li>
<li>因为这个引入了现成的一个解决方案：Redission</li>
</ul>
</li>
<li>4、Redission<ul>
<li>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</li>
</ul>
</li>
<li>5、如何实现可重入锁（锁里面又需要获取到另外一个需要锁的方法）<ul>
<li><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁</strong></li>
<li>实际实现中，Redission 是提供了实现方案的<ul>
<li><strong>Redisson</strong> ，内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>在面对高并发的库存扣减问题时，除了使用Redis分布式锁外，还可以考虑以下一些策略：</p>
<ol>
<li><strong>乐观锁</strong>：在数据表中使用版本号（或时间戳）字段，每次更新时检查版本号是否一致，如果一致则更新并增加版本号。这种方式减少了锁的使用，但在高冲突环境下可能导致大量的重试。</li>
<li><strong>消息队列</strong>：将库存扣减操作异步化，通过消息队列来控制对库存的操作序列。这样可以平滑高峰期的请求，但需要处理好消息的可靠性和消费顺序。</li>
<li><strong>令牌桶或漏斗算法</strong>：通过限流算法控制对库存操作的并发量，保证系统的稳定性。</li>
<li><strong>分段锁</strong>：如果库存数据可以分段（例如不同的商品或仓库），可以对每一段使用独立的锁或Redis key，从而减少锁的竞争。</li>
<li><strong>预扣减与补偿机制</strong>：在用户下单时先进行库存预扣减，然后异步处理订单，如果订单处理失败则进行库存补偿。这种方式可以快速响应用户请求，但需要处理好补偿逻辑。</li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B/" class="category-chain-item">面试煎熬成蛋</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="print-no-link">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试煎熬成蛋_Redis</div>
      <div>https://varcel.luoqi.icu/2024/03/10/面试煎熬成蛋_Redis/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luo QI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年3月10日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/03/10/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B_MQ/" title="面试煎熬成蛋_MQ">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">面试煎熬成蛋_MQ</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2024/03/10/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B_MySQL/" title="面试煎熬成蛋_MySQL">
                        <span class="hidden-mobile">面试煎熬成蛋_MySQL</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
