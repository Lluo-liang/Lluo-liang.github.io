

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/Xbox%20L.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luo QI">
  <meta name="keywords" content="">
  
    <meta name="description" content="面试题_JVM">
<meta property="og:type" content="article">
<meta property="og:title" content="面试题_JVM">
<meta property="og:url" content="https://varcel.luoqi.icu/2024/01/02/%E8%87%AA%E6%B5%8B%E9%A2%98_JVM/index.html">
<meta property="og:site_name" content="轻松的洛亓">
<meta property="og:description" content="面试题_JVM">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/wallpaper1704370845322.jpg">
<meta property="article:published_time" content="2024-01-02T17:08:29.000Z">
<meta property="article:modified_time" content="2024-01-02T17:08:29.000Z">
<meta property="article:author" content="Luo QI">
<meta property="article:tag" content="java">
<meta property="article:tag" content="面试题">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/wallpaper1704370845322.jpg">
  
  
  
  <title>面试题_JVM - 轻松的洛亓</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"varcel.luoqi.icu","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  <meta name="baidu-site-verification" content="codeva-Oq0KOjHuD3" />
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>轻松的洛亓</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311131716524.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试题_JVM"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-01-02 17:08" pubdate>
          2024年1月2日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          8.9k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          75 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">面试题_JVM</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="面试自测题"><a href="#面试自测题" class="headerlink" title="面试自测题"></a>面试自测题</h3><p>下面的面试题主要针对的是 HotSpot VM。</p>
<ul>
<li>类加载<ul>
<li>讲述一下 Java 的类加载过程。</li>
<li>描述一下 JVM 加载 Class 文件的原理机制?</li>
<li>什么是类加载器，类加载器有哪些？</li>
<li>类加载器双亲委派模型机制？</li>
<li>什么是字节码，类文件结构的组成了解吗</li>
<li>类的生命周期？类加载的过程了解吗？加载这一步主要做了什么事情？初始化阶段中有哪几种情况必须对类初始化。</li>
<li>双亲委派模型了解吗，如果我们不想用双亲委派模型怎么办。</li>
<li>双亲委派模型有什么好处，双亲委派模型是为了一个保证一个 Java 类 在 JVM 中是唯一的？</li>
<li>JDK 中有哪些 默认的类加载器。</li>
<li>讲一下 Java 对象的创建过程。</li>
</ul>
</li>
<li>运行时数据区<ul>
<li>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享。哪些区域可能会出现 OutOfMemoryError ？ 哪些区域不会出现 OutOfMemoryError ？</li>
<li>讲一下 JDK 1.8 之前和 JDK1.8 JVM的区别。</li>
<li>方法区和永久代的关系。</li>
<li>堆空间的基本结构了解吗？什么情况下对象会进入老年代。</li>
<li>讲一下Java 内存分配。</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>定位对象是否存活<ul>
<li>对象的访问定位的两种方式知道吗，各有什么优缺点。</li>
<li>如何判断一个对象是否存活？（或者 GC 对象的判定方法）</li>
<li>如何判断对象是否死亡（两种方法）</li>
</ul>
</li>
<li>基础概念<ul>
<li>在 Java 中，对象什么时候可以被垃圾回收？</li>
<li>GC 是什么? 为什么要有 GC？</li>
<li>简述 Java 垃圾回收机制</li>
<li>垃圾回收的优点和原理。并讲一下其中的 2 种回收机制</li>
<li>深拷贝和浅拷贝。</li>
<li>System.gc() 和 Runtime.gc() 会做什么事情？</li>
<li>finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？</li>
<li>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？</li>
<li>串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？</li>
<li>讲一下 CMS 垃圾收集器的四个步骤。CMS 有什么缺点。</li>
<li>并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？</li>
<li>G1 垃圾收集器的步骤。有什么缺点？</li>
</ul>
</li>
<li>其他<ul>
<li>什么是分布式垃圾回收（DGC）？它是如何工作的？</li>
<li>简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。</li>
<li>Java 中垃圾收集的方法有哪些？</li>
<li>讲一下可达性分析算法的流程。哪些对象可以作为 GC Roots ？</li>
<li>对象可以被回收，就代表一定会被回收吗？</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>有哪些常见的 GC？ 谈谈你对 Minor GC，还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发生？ Minor GC 会发生 stop the world 现象吗？</li>
<li>ZGC 了解吗。</li>
</ul>
</li>
</ul>
</li>
<li>基础概念<ul>
<li>JVM 的永久代中会发生垃圾回收么？</li>
<li>JDK 中有几种引用类型？分别的特点是什么？</li>
<li>JVM 中的安全点和安全区各代表什么？</li>
</ul>
</li>
<li>JVM 调优<ul>
<li>虚拟机基础故障处理工具有哪些？（性能调优 &amp; 问题排查）</li>
<li>堆内存相关的 JVM 参数有哪些？你在项目中实际配置过了吗?</li>
<li>你在项目中遇到过 GC 问题吗， 怎么分析和解决的？</li>
<li>GC 性能指标了解吗，调优原则呢</li>
<li>如何降低 Full FC 的频率。</li>
<li>项目中实践过 JVM 调优吗，怎么做的？</li>
</ul>
</li>
</ul>
<hr>
<h3 id="面试解答篇"><a href="#面试解答篇" class="headerlink" title="面试解答篇"></a>面试解答篇</h3><ul>
<li>类加载<ul>
<li>讲述一下 Java 的类加载过程。<ul>
<li>Java类加载过程包括加载（Loading）、链接（Linking）、初始化（Initialization）三个主要阶段。；<ul>
<li>加载阶段读取Class文件到内存；</li>
<li>链接阶段验证Class文件格式、准备分配内存并解析引用；</li>
<li>初始化阶段执行类构造器<code>&lt;clinit&gt;</code>方法，初始化类变量和静态代码块。</li>
</ul>
</li>
</ul>
</li>
<li>描述一下 JVM 加载 Class 文件的原理机制?<ul>
<li>JVM通过类加载器（ClassLoader）加载Class文件。</li>
<li>类加载器首先检查请求加载的类是否已经加载过，如果没有，则根据类的全限定名查找对应的Class文件，然后读取和转换成运行时数据结构（如方法区中的类信息），最后在堆上分配对象的内存空间。</li>
</ul>
</li>
<li>什么是类加载器，类加载器有哪些？<ul>
<li>类加载器是负责加载Java类到JVM中的组件。</li>
<li>主要有三种类加载器：<ul>
<li><ol>
<li>启动类加载器（Bootstrap ClassLoader），加载JRE的核心库；</li>
</ol>
</li>
<li><ol start="2">
<li>扩展类加载器（Extension ClassLoader），加载<code>jre/lib/ext</code>目录下的扩展类；</li>
</ol>
</li>
<li><ol start="3">
<li>应用程序类加载器（Application ClassLoader），加载用户类路径（Classpath）上的类。</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>类加载器双亲委派模型机制？<ul>
<li>双亲委派模型要求除了顶层的启动类加载器外，一个类加载器在加载类时，先委派给其父类加载器尝试加载，直到顶层。如果父类加载器无法加载该类，才由自身尝试加载。这种机制保证了Java类的唯一性和安全性。</li>
</ul>
</li>
<li>什么是字节码，类文件结构的组成了解吗<ul>
<li>字节码是Java源代码经过编译器编译后的中间代码，用于在JVM上运行。类文件结构主要包括魔数、版本号、常量池、访问标志、类索引、父类索引、接口索引集、字段表集合、方法表集合、属性表集合等。</li>
</ul>
</li>
<li>类的生命周期？类加载的过程了解吗？加载这一步主要做了什么事情？初始化阶段中有哪几种情况必须对类初始化。<ul>
<li>类的生命周期包括加载、验证、准备、解析、初始化、使用和卸载。加载阶段主要做的是通过类的全限定名来获取定义此类的二进制字节流。初始化阶段必须对类初始化的情况包括实例化类的对象、访问类的静态方法、访问类或接口的静态字段、使用<code>java.lang.reflect</code>包的方法反射类的方法时、初始化类的子类等</li>
</ul>
</li>
<li>双亲委派模型了解吗，如果我们不想用双亲委派模型怎么办。<ul>
<li>了解。如果不想使用双亲委派模型，可以通过自定义类加载器覆盖<code>ClassLoader</code>的<code>loadClass()</code>方法来改变类加载的委派行为，实现自定义的加载逻辑。</li>
</ul>
</li>
<li>双亲委派模型有什么好处，双亲委派模型是为了一个保证一个 Java 类 在 JVM 中是唯一的？<ul>
<li>双亲委派模型的好处是保证了Java平台核心类的安全性和Java类的唯一性，避免类的重复加载，同时也保护了核心API不被随意篡改。</li>
</ul>
</li>
<li>JDK 中有哪些 默认的类加载器。<ul>
<li>JDK中默认的类加载器包括启动类加载器（Bootstrap ClassLoader）、扩展类加载器（Extension ClassLoader）和应用程序类加载器（Application ClassLoader）。</li>
</ul>
</li>
<li>讲一下 Java 对象的创建过程。<ul>
<li>Java对象的创建过程主要包括类加载检查、分配内存、初始化零值、设置对象头、执行<code>&lt;init&gt;</code>方法五个主要步骤。</li>
<li>首先检查对象对应的类是否已经加载、链接、初始化，然后在堆内存中分配空间，对属性进行默认初始化，设置对象头（包括类的元数据信息、对象的哈希码等），最后调用构造器方法执行初始化。</li>
</ul>
</li>
</ul>
</li>
<li>运行时数据区<ul>
<li>运行时数据区中包含哪些区域？哪些线程共享？哪些线程独享。哪些区域可能会出现 OutOfMemoryError ？ 哪些区域不会出现 OutOfMemoryError ？<ul>
<li>运行时数据区包括堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register）。堆和方法区是线程共享的；虚拟机栈、本地方法栈和程序计数器是线程独享的。堆和方法区可能会出现<code>OutOfMemoryError</code>。程序计数器不会出现<code>OutOfMemoryError</code>，因为其内存分配在JVM启动时确定。</li>
</ul>
</li>
<li>讲一下 JDK 1.8 之前和 JDK1.8 JVM的区别。<ul>
<li>JDK 1.8之前，JVM使用永久代（PermGen）来存储类的元数据；而在JDK 1.8中，永久代被元空间（MetaSpace）替代。元空间使用本地内存来存储类的元数据，这样可以动态调整空间大小，减少<code>OutOfMemoryError</code>的可能性。</li>
</ul>
</li>
<li>方法区和永久代的关系。<ul>
<li>在JDK 1.7及之前的版本中，方法区的实现就是永久代。方法区用于存储被虚拟机加载的类信息、常量、静态变量等数据。从JDK 1.8开始，永久代被元空间替代，方法区逻辑上还存在，但已不再使用永久代来实现。</li>
</ul>
</li>
<li>堆空间的基本结构了解吗？什么情况下对象会进入老年代。<ul>
<li>堆空间主要分为新生代（Young Generation）和老年代（Old Generation）。新生代进一步分为一个Eden区和两个Survivor区。大部分情况下，对象首先在新生代的Eden区分配。当新生代空间不足时，进行Minor GC，存活的对象会根据年龄阈值和空间大小晋升到老年代。对象直接在老年代分配的情况包括大对象直接分配和长期存活的对象</li>
</ul>
</li>
<li>讲一下Java 内存分配。<ul>
<li>Java内存分配主要发生在堆上。对象首先在新生代的Eden区分配。当Eden区满时，触发Minor GC，存活的对象移动到Survivor区；经过多次GC后，如果对象仍然存活，会根据设定的年龄阈值晋升到老年代。大对象（如大数组）可能会直接在老年代分配，以避免频繁的GC。在方法执行时，方法的局部变量和部分临时数据分配在虚拟机栈中</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收<ul>
<li>定位对象是否存活<ul>
<li>对象的访问定位的两种方式知道吗，各有什么优缺点。<ul>
<li>对象的访问定位主要有两种方式：句柄访问和直接指针访问。<ul>
<li><strong>句柄访问</strong>：Java堆中会分配一个句柄池，句柄中包含了对象实例数据与类型数据各自的具体地址。优点是句柄池中的对象移动时只需要修改句柄中的地址；缺点是访问对象需要经过两次跳转，影响效率。</li>
<li><strong>直接指针访问</strong>：每个对象的实例数据中直接包含了类型数据的地址。优点是访问速度快，只需一次指针跳转；缺点是对象移动时需要更新所有的直接指针，成本较高。</li>
</ul>
</li>
</ul>
</li>
<li>如何判断一个对象是否存活？（或者 GC 对象的判定方法）<ul>
<li>垃圾收集器判断对象是否存活主要依赖于可达性分析算法。从一系列的“GC Roots”出发，如果一个对象到GC Roots没有任何引用链相连（即从GC Roots到该对象不可达），则对象被判定为不可达，即可被GC回收。GC Roots包括类静态属性引用的对象、活动线程的局部变量引用的对象等。</li>
</ul>
</li>
<li>如何判断对象是否死亡（两种方法）<ul>
<li><ol>
<li><strong>引用计数法</strong>：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。但是，主流的Java虚拟机不采用这种方法，因为它无法解决对象间相互循环引用的问题。</li>
</ol>
</li>
</ul>
<ol>
<li><strong>可达性分析</strong>：这是主流JVM使用的方法，通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可达的，即判断对象死亡。</li>
</ol>
</li>
</ul>
</li>
<li>基础概念<ul>
<li>在 Java 中，对象什么时候可以被垃圾回收？<ul>
<li>对象可以在不再被程序中的任何线程所引用时被垃圾回收。这通常是通过可达性分析（GC Roots Tracing）来确定的。当对象不可从任何GC Roots达到时，它被认为是可回收的。</li>
</ul>
</li>
<li>GC 是什么? 为什么要有 GC？<ul>
<li>GC（Garbage Collection）是自动内存管理的过程，它可以自动监测和释放不再使用的对象占用的内存。GC的存在减少了内存泄漏和手动内存管理的复杂性，使得程序员可以更专注于业务逻辑的实现。</li>
</ul>
</li>
<li>简述 Java 垃圾回收机制<ul>
<li>GC（Garbage Collection）是自动内存管理的过程，它可以自动监测和释放不再使用的对象占用的内存。GC的存在减少了内存泄漏和手动内存管理的复杂性，使得程序员可以更专注于业务逻辑的实现。</li>
</ul>
</li>
<li>垃圾回收的优点和原理。并讲一下其中的 2 种回收机制<ul>
<li><strong>优点</strong>：自动管理内存，减少内存泄漏和溢出的风险，简化程序开发。 <strong>原理</strong>：通过标记不再使用的对象并自动回收其占用的内存空间。</li>
<li><strong>两种回收机制</strong>：<ul>
<li><strong>标记-清除（Mark-Sweep）</strong>：标记所有不再使用的对象，然后统一回收这些对象占用的内存。</li>
<li><strong>复制（Copying）</strong>：将存活的对象复制到另一个区域，之后一次性清理掉旧区域的所有对象，适用于新生代。</li>
</ul>
</li>
</ul>
</li>
<li>深拷贝和浅拷贝。<ul>
<li><strong>浅拷贝</strong>只复制对象的引用，不复制对象本身，拷贝和原对象共享子对象。 </li>
<li><strong>深拷贝</strong>会复制对象及其所有子对象，拷贝和原对象完全独立。</li>
</ul>
</li>
<li>System.gc() 和 Runtime.gc() 会做什么事情？<ul>
<li><code>System.gc()</code> 和 <code>Runtime.gc()</code> 都是用来请求JVM进行垃圾回收。这两个方法的调用并不保证JVM立即进行垃圾回收，只是向JVM提出了请求。</li>
</ul>
</li>
<li>finalize() 方法什么时候被调用？析构函数 (finalization) 的目的是什么？<ul>
<li><code>finalize()</code> 方法在垃圾收集器准备回收对象所占用的内存之前被调用，用于清理资源。其目的是在对象被销毁前允许开发者进行最后的资源释放操作，如关闭文件流等。</li>
</ul>
</li>
<li>如果对象的引用被置为 null，垃圾收集器是否会立即释放对象占用的内存？<ul>
<li>不会。对象的引用被置为 null 只是意味着对象变得可回收，但实际的回收时间取决于GC算法和GC运行时机，不是立即发生的。</li>
</ul>
</li>
</ul>
</li>
<li>垃圾回收器<ul>
<li>垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？<ul>
<li>垃圾回收器的基本原理是识别并回收不再被程序使用的内存资源。</li>
<li>垃圾回收器通常不能马上回收内存，其执行时机由JVM的垃圾回收算法和系统状态决定。可以通过调用<code>System.gc()</code>或<code>Runtime.getRuntime().gc()</code>方法来建议JVM执行垃圾回收，但JVM可以忽略这一请求。</li>
</ul>
</li>
<li>串行（serial）收集器和吞吐量（throughput）收集器的区别是什么？<ul>
<li>串行收集器是一个单线程的收集器，适用于单CPU环境和小堆内存，它在进行垃圾收集时会暂停所有用户线程（Stop-The-World），适合客户端模式。</li>
<li>吞吐量收集器（Parallel Collector）使用多线程进行垃圾收集，以达到缩短垃圾收集时间的目的，适用于多CPU环境和需要高吞吐量的应用。</li>
</ul>
</li>
<li>讲一下 CMS 垃圾收集器的四个步骤。CMS 有什么缺点。<ul>
<li>CMS（Concurrent Mark Sweep）收集器的四个步骤包括：1) 初始标记（STW），标记GC Roots能直接关联到的对象；2) 并发标记，从GC Roots的直接对象开始遍历整个对象图；3) 重新标记（STW），修正并发标记期间因程序运行导致标记发生变动的部分；4) 并发清除，清除未被标记的对象。缺点包括：并发执行时CPU资源占用较高，无法处理浮动垃圾，可能会出现<code>Concurrent Mode Failure</code>导致另一次Full GC。</li>
</ul>
</li>
<li>并发标记要解决什么问题？并发标记带来了什么问题？如何解决并发扫描时对象消失问题？<ul>
<li>并发标记旨在减少垃圾收集时的停顿时间，允许垃圾收集线程与应用线程同时工作。它带来的问题包括标记期间应用线程对对象的修改可能会导致标记结果不准确。为了解决这个问题，CMS和G1收集器采用了重新标记（Remark）阶段，使用诸如卡表（Card Table）等机制来记录并发阶段引用变动的区域，确保准确标记。</li>
</ul>
</li>
<li>G1 垃圾收集器的步骤。有什么缺点？<ul>
<li>G1收集器将堆内存分为多个区域（Region），收集步骤包括：1) 初始标记（STW）；2) 并发标记；3) 最终标记（STW）；4) 筛选回收。G1的目标是提供可预测的停顿时间，特别适合大堆内存。缺点包括在某些情况下（如小堆内存或大量数据更新操作）性能不如CMS，以及在实现可预测停顿时间目标时可能需要细致的调优。</li>
</ul>
</li>
</ul>
</li>
<li>其他<ul>
<li>什么是分布式垃圾回收（DGC）？它是如何工作的？<ul>
<li>分布式垃圾回收（DGC）是用于管理在分布式系统中对象生命周期的机制。它通过跟踪网络上的对象引用和使用情况来确定对象是否可被回收。DGC通常依赖于引用计数和可达性分析等技术，以确保不再被任何分布式节点引用的对象能够被回收。</li>
</ul>
</li>
<li>简述 Java 内存分配与回收策率以及 Minor GC 和 Major GC。<ul>
<li>Java内存分配主要在堆上进行，堆被划分为新生代和老年代。新对象通常在新生代的Eden区分配。Minor GC清理新生代，当对象在新生代中存活足够久后，会被晋升到老年代。Major GC（或Full GC）涉及整个堆的回收，包括新生代和老年代，清理工作更彻底但耗时更长。</li>
</ul>
</li>
<li>Java 中垃圾收集的方法有哪些？<ul>
<li>Java中垃圾收集的方法主要包括标记-清除、标记-整理、复制算法。标记-清除标记所有不可达对象然后统一回收；标记-整理在标记基础上，将存活对象向一端移动，清理端边界外内存；复制算法将可达对象复制到另一块区域，然后清理旧空间。</li>
</ul>
</li>
<li>讲一下可达性分析算法的流程。哪些对象可以作为 GC Roots ？<ul>
<li>可达性分析算法通过从一组称为GC Roots的对象开始，遍历引用链，标记所有从GC Roots可达的对象。GC Roots包括在方法区中的类静态属性引用的对象、活动线程的局部变量表中引用的对象、Java虚拟机栈（栈帧中的本地变量表）中引用的对象等。</li>
</ul>
</li>
<li>对象可以被回收，就代表一定会被回收吗？<ul>
<li>不一定。对象可被回收意味着它已经满足垃圾收集的条件（如不可达），但具体是否被回收以及何时被回收取决于垃圾收集器的策略和系统状态。</li>
</ul>
</li>
<li>垃圾收集有哪些算法，各自的特点？<ul>
<li><strong>标记-清除</strong>：简单直观，缺点是会产生内存碎片。</li>
<li><strong>标记-整理</strong>：解决内存碎片问题，移动存活对象，但移动成本高。</li>
<li><strong>复制</strong>：将内存分为两块，每次只使用一块，GC时复制活对象到未使用的块，清理旧块，适合新生代，但内存利用率低。</li>
</ul>
</li>
<li>有哪些常见的 GC？ 谈谈你对 Minor GC，还有 Full GC 的理解。Minor GC 与 Full GC 分别在什么时候发生？ Minor GC 会发生 stop the world 现象吗？<ul>
<li>常见的GC有Serial、Parallel、CMS、G1、ZGC等。Minor GC清理新生代，频繁发生，速度较快，会引起短暂的停顿（Stop-The-World）。Full GC清理整个堆空间，包括新生代和老年代，不频繁但耗时较长，会引起较长时间的停顿。Minor GC也会发生Stop-The-World现象。</li>
</ul>
</li>
<li>ZGC 了解吗。<ul>
<li>ZGC（Z Garbage Collector）是JDK 11引入的一种低延迟垃圾收集器，目标是在大堆内存上提供低暂停时间。ZGC工作在并发阶段，几乎不会停顿应用线程，使用彩色指针和读屏障技术来处理并发收集时的内存访问问题，适用于需要大内存和低延迟的应用。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>基础概念<ul>
<li>JVM 的永久代中会发生垃圾回收么？<ul>
<li>是的，永久代中会发生垃圾回收，但频率较堆内存中的垃圾回收要低。永久代主要存储类信息、常量等，当卸载类或常量池中的常量不再被引用时，这些数据就成为垃圾，可以被回收。不过，从JDK 8开始，永久代已被元空间（MetaSpace）所取代。</li>
</ul>
</li>
<li>JDK 中有几种引用类型？分别的特点是什么？<ul>
<li>JDK中有四种引用类型：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。<ul>
<li><strong>强引用</strong>：最常见的引用类型，只要强引用还存在，垃圾回收器永远不会回收被引用的对象。</li>
<li><strong>软引用</strong>：内存不足时，垃圾回收器会回收这些对象，适合实现内存敏感的缓存。</li>
<li><strong>弱引用</strong>：只能生存到下一次垃圾回收之前，无论内存是否足够。</li>
<li><strong>虚引用</strong>：无法通过虚引用获取对象，它仅仅提供了一种确保对象被finalize以后，做某些事情的机制。</li>
</ul>
</li>
</ul>
</li>
<li>JVM 中的安全点和安全区各代表什么？<ul>
<li><strong>安全点（Safepoint）</strong>：是程序执行中的特定位置，在这些点上JVM可以确保所有引用都是准确的，从而可以停止所有线程进行垃圾回收或其他运行时操作。</li>
<li><strong>安全区（Safe Region）</strong>：是指程序执行的一段区域，线程执行在此区域内时，如果GC发生，线程不需要停顿转入安全点，只需在离开安全区时进行检查。</li>
</ul>
</li>
</ul>
</li>
<li>JVM 调优<ul>
<li>虚拟机基础故障处理工具有哪些？（性能调优 &amp; 问题排查）<ul>
<li>JVM故障处理和性能调优工具包括：JConsole、VisualVM、JProfiler、JStack、JMap、JHeap、GCViewer、MAT（Memory Analyzer Tool）等。这些工具可以帮助监视和调优JVM性能，分析堆内存、线程、类、CPU占用等信息。</li>
</ul>
</li>
<li>堆内存相关的 JVM 参数有哪些？你在项目中实际配置过了吗?<ul>
<li>堆内存相关的JVM参数主要有：</li>
<li><code>-Xms</code>：设置堆内存的初始大小。</li>
<li><code>-Xmx</code>：设置堆内存的最大大小。</li>
<li><code>-Xmn</code>：设置新生代大小（不常用）。</li>
<li><code>-XX:NewRatio</code>：设置老年代和新生代的比例。</li>
<li><code>-XX:SurvivorRatio</code>：设置新生代中Eden区与Survivor区的比例。 在实际项目中，通常会根据应用的需求和资源限制，调整<code>-Xms</code>和<code>-Xmx</code>来优化性能。</li>
</ul>
</li>
<li>你在项目中遇到过 GC 问题吗， 怎么分析和解决的？<ul>
<li>遇到GC问题时，首先使用JVM监控工具（如JConsole、VisualVM）观察GC日志和内存使用情况，分析Full GC频繁或GC暂停时间过长的原因。然后，根据分析结果，可能的解决方案包括增加堆内存大小、调整新生代和老年代的比例、优化代码以减少内存泄漏或不必要的对象创建。具体操作取决于问题的原因。</li>
</ul>
</li>
<li>GC 性能指标了解吗，调优原则呢<ul>
<li>GC性能指标包括GC频率、GC暂停时间、吞吐量等。调优原则包括：<ul>
<li>尽量减少Full GC发生的频率和时长。</li>
<li>保持合理的堆大小，避免过大或过小。</li>
<li>选择合适的垃圾回收器。</li>
<li>避免产生过多的短命对象。</li>
</ul>
</li>
</ul>
</li>
<li>如何降低 Full FC 的频率。<ul>
<li>降低Full GC频率的方法包括：增加堆内存大小、优化代码减少内存泄漏、调整新生代与老年代的比例、使用更适合应用场景的垃圾回收器、减少大对象或长生命周期对象的创建。</li>
</ul>
</li>
<li>项目中实践过 JVM 调优吗，怎么做的？<ul>
<li>在项目中实践JVM调优通常从监控和分析JVM性能开始，使用工具如VisualVM、JConsole监控内存使用情况、GC活动等。根据分析结果调整JVM参数，如堆内存大小、选择合适的垃圾回收器。在调优过程中，重点关注GC频率、暂停时间及应用吞吐量，通过反复测试确保调优效果。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a target="_blank" rel="noopener" href="https://javaguide.cn/java/jvm/jvm-in-action.html">https://javaguide.cn/java/jvm/jvm-in-action.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/snailclimb/mf2z3k/xkhs3e">https://www.yuque.com/snailclimb/mf2z3k/xkhs3e</a></li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="category-chain-item">面试题</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
        <a href="/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/" class="print-no-link">#面试题</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试题_JVM</div>
      <div>https://varcel.luoqi.icu/2024/01/02/自测题_JVM/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luo QI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年1月2日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
