

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/Xbox%20L.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
    <meta http-equiv="Content-Security-Policy" content="upgrade-insecure-requests">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Luo QI">
  <meta name="keywords" content="">
  
    <meta name="description" content="针对后续的面试，仍然总结出仍然需要出一个简易的文字版本面试文档，同时多总结和优化自己的表达能力">
<meta property="og:type" content="article">
<meta property="og:title" content="面试煎熬成蛋_面试速刷版_第二版">
<meta property="og:url" content="https://varcel.luoqi.icu/2024/05/15/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B_%E9%9D%A2%E8%AF%95%E9%80%9F%E5%88%B7%E7%89%88_%E7%AC%AC%E4%BA%8C%E7%89%88/index.html">
<meta property="og:site_name" content="轻松的洛亓">
<meta property="og:description" content="针对后续的面试，仍然总结出仍然需要出一个简易的文字版本面试文档，同时多总结和优化自己的表达能力">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240311195612.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240407222040.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240407222700.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240326205410.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312224915.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304154734.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240313111136.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512172606.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512173029.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512173427.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240315210151.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240531174218.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240315154746.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202402290943468.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202402290944546.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240325175422.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240314214559.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240529215235.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240311230336.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240228060325.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/31a84718a5ffd47cc8e2f691ad3bd9e.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240324235306.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240324235131.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240330222111.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240601084552.png">
<meta property="og:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317102553.png">
<meta property="article:published_time" content="2024-05-15T23:16:11.000Z">
<meta property="article:modified_time" content="2024-05-15T23:16:11.000Z">
<meta property="article:author" content="Luo QI">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png">
  
  
  
  <title>面试煎熬成蛋_面试速刷版_第二版 - 轻松的洛亓</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"varcel.luoqi.icu","root":"/","version":"1.9.5-a","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  <meta name="baidu-site-verification" content="codeva-Oq0KOjHuD3" />
<meta name="generator" content="Hexo 7.0.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>轻松的洛亓</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311131716524.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="面试煎熬成蛋_面试速刷版_第二版"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-05-15 23:16" pubdate>
          2024年5月15日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          37k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          310 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">面试煎熬成蛋_面试速刷版_第二版</h1>
            
            
              <div class="markdown-body">
                
                <blockquote>
<p>作者简介：⼤家好，我是 洛亓，Java摆烂选⼿一枚，很⾼兴认 识⼤家<br>CSDN&#x2F;掘⾦&#x2F;B站: 轻松的洛亓<br>实时更新地址：暂无<br>如果感觉博主的⽂章还不错的话，请点赞⽀持⼀下哦</p>
</blockquote>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><h4 id="双层循环中的作用-continue、break、return-的区别"><a href="#双层循环中的作用-continue、break、return-的区别" class="headerlink" title="双层循环中的作用 continue、break、return 的区别"></a>双层循环中的作用 continue、break、return 的区别</h4><ul>
<li>**<code>continue</code>**：只会影响当前所在的内层循环，继续内层循环的下一次迭代</li>
<li>**<code>break</code>**：只会影响当前所在的内层循环，跳出内层循环。</li>
<li>**<code>return</code>**：终止整个方法的执行，直接返回到方法调用点。</li>
</ul>
<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">continue</span>; <span class="hljs-comment">// 结束当前内层循环的当前迭代，继续下一次迭代</span><br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>        <span class="hljs-keyword">if</span> (j == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// 终止内层循环</span><br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exampleMethod</span>()</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">5</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (j == <span class="hljs-number">2</span>) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 终止方法执行，返回到调用点</span><br>            &#125;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;i = &quot;</span> + i + <span class="hljs-string">&quot;, j = &quot;</span> + j);<br>        &#125;<br>    &#125;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;This will not be printed if j == 2&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>    <span class="hljs-keyword">new</span> MyClass().exampleMethod();<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Method has returned&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的"></a>String 为什么是不可变的</h4><ul>
<li><code>String</code> 类内部使用 <code>private final char[]</code> 或 <code>private final byte[]</code> 来存储字符串数据。</li>
<li>好处<ul>
<li>防止被恶意更改</li>
<li>作为HashMap的key可以保证不可变性</li>
<li>可以实现字符串常量池，在Java中，创建字符串对象的⽅式<ul>
<li>通过字符串常量进⾏创建<ul>
<li>在字符串常量池判断是否存在，如果存在就返回，不存 在就在字符串常量池创建后返回</li>
</ul>
</li>
<li>通过new字符串对象进⾏创建<ul>
<li>在字符串常量池中判断是否存在，如果不存在就创建， 再判断堆中是否存在，如果不存在就创建，然后返回该 对象，总之要保证字符串常量池和堆中都有该对象</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>是不是 String 使用 final 修饰  ，它才是不可变的；被 final 修饰的常量，是不可变的吗</p>
</blockquote>
<p>当一个变量被 <code>final</code> 修饰时，它是不可变的，即它的引用不能被改变，但如果这个变量是一个对象的引用，那么对象本身还是可以被改变的（除非这个对象本身也是不可变的）</p>
<p><code>final</code> 关键字用于修饰变量、方法和类，其作用如下：</p>
<ol>
<li><strong>修饰变量</strong>：表示该变量只能被赋值一次，赋值后不能被重新赋值。</li>
<li><strong>修饰方法</strong>：表示该方法不能被子类重写。</li>
<li><strong>修饰类</strong>：表示该类不能被继承。</li>
</ol>
<p><code>String</code> 类本身是不可变的，这是因为：</p>
<ol>
<li><code>String</code> 类是由 <code>final</code> 修饰的类，因此不能被继承。</li>
<li><code>String</code> 类中的字符数组 <code>value</code> 是私有的，并且没有提供任何修改字符数组的方法。</li>
<li><code>String</code> 类的方法不会修改字符串对象本身，而是返回一个新的字符串对象。</li>
</ol>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><ul>
<li>常见的一些问题<ul>
<li>主要还是围绕 HashMap 去问的，相关的 put 流程和扩容机制需要掌握</li>
</ul>
</li>
<li>概念前提<ul>
<li>ArrayList的数组默认⻓度10，1.5倍数组扩容，扩容通过开辟新数 组进⾏转移⽼数组元素</li>
<li>HashMap、ConcurrentHashMap的数组默认⻓度16，2倍数组扩 容，扩容通过开辟新数组进⾏转移⽼数组元素</li>
</ul>
</li>
<li>核⼼思想<ul>
<li>读写分离<ul>
<li>CopyOnWriteArrayList底层实现、处理快速失败</li>
</ul>
</li>
<li>分散热点<ul>
<li>ConcurrentHashMap底层addCount计算</li>
</ul>
</li>
<li>索引优化<ul>
<li>HashMap&#x2F;ConcurrentHashMap 从数组-&gt;链表-&gt;红⿊树</li>
</ul>
</li>
</ul>
</li>
<li>考察重点<ul>
<li>集合底层实现以及设计思想</li>
</ul>
</li>
<li>注意点<ul>
<li>对于存放⼤量元素到ArrayList 或 HashMap中时，建议提前初始化 好容量避免扩容导致性能损耗</li>
</ul>
</li>
</ul>
<h4 id="成员关系"><a href="#成员关系" class="headerlink" title="成员关系"></a>成员关系</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul>
<li>1.7 头插法会导致循环链表问题<ul>
<li>由于每次插入都会改变链表的顺序，这可能会导致长时间的性能下降</li>
</ul>
</li>
<li>1.8 改为了尾插法，在并发修改时减少了循环链表出现的风险</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240311195612.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>头插</li>
<li>尾插</li>
<li>扩容</li>
</ul>
<h4 id="HashMap-的-put-流程讲一下"><a href="#HashMap-的-put-流程讲一下" class="headerlink" title="HashMap 的 put 流程讲一下"></a>HashMap 的 put 流程讲一下</h4><ul>
<li>1、计算数组下标：首先基于键（Key）的 hash 值计算得到数组下标。</li>
<li>2、如果数组下标为空<ul>
<li>如果下标位置为空：<ul>
<li>在 JDK 7 中，会将键值对（K-V）封装成 Entry 对象。</li>
<li>在 JDK 8 中，会将键值对封装成 Node 对象。</li>
</ul>
</li>
<li>然后将该对象放到数组对应的槽位中。</li>
</ul>
</li>
<li>3、如果数组下标不为空<ul>
<li>如果下标位置不为空：<ul>
<li><strong>JDK 7</strong>:<ul>
<li>先判断是否需要扩容，如果需要扩容就先进行扩容。</li>
<li>然后采用头插法将新的节点插入当前槽位的链表上。</li>
<li>如果键相同，就更新对应的值（Value）。</li>
</ul>
</li>
<li><strong>JDK 8</strong>:<ul>
<li>不会先判断是否需要扩容，而是先判断节点类型（链表节点或红黑树节点）。</li>
<li>如果是链表节点：<ul>
<li>将键值对封装成链表节点，采用尾插法插入当前槽位的链表上。</li>
<li>如果键相同，就更新对应的值（Value）。</li>
<li>当数组长度达到 64 且链表长度达到 8 时，会将链表转化为红黑树以提升查询速度。</li>
</ul>
</li>
<li>如果是红黑树节点：<ul>
<li>将键值对封装成红黑树节点，放到红黑树上。</li>
<li>如果键相同，就更新对应的值（Value）。</li>
<li>当红黑树节点数减少到 6 时，会退化成链表</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="HashMap-的-get-流程"><a href="#HashMap-的-get-流程" class="headerlink" title="HashMap 的 get 流程"></a>HashMap 的 get 流程</h4><ol>
<li><strong>计算数组下标</strong><ul>
<li>基于键（Key）的 hash 值计算得到数组的下标。</li>
</ul>
</li>
<li><strong>查找元素</strong><ul>
<li>遍历下标位置的每个槽位（链表&#x2F;红黑树）。</li>
<li>通过 <code>equals</code> 方法查找与键相同的元素。</li>
</ul>
</li>
</ol>
<h4 id="HashMap-的扩容流程-🚩"><a href="#HashMap-的扩容流程-🚩" class="headerlink" title="HashMap 的扩容流程  🚩"></a>HashMap 的扩容流程  🚩</h4><p>参考： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV14r4y1R7e6">https://www.bilibili.com/video/BV14r4y1R7e6</a></p>
<p>扩容操作：</p>
<ul>
<li>1、每次扩容是两倍</li>
<li>2、当元素个数 &gt; 槽位数组长度 * 负载因子，进行扩容操作</li>
<li>3、JDK 7  是数组 + 链表，JDK 8 是 数组 + 链表 + 红黑树，JDK7 链表是头插法，JDK8 是尾插法</li>
<li>4、resize 的时候会重新哈希计算，红黑树的话会进行拆分操作，当当数组长度达到 64 且链表长度达到 8 时，会将链表转化为红黑树，当红黑树元素个数减少到 6 时，会退化成链表</li>
<li>JDK 7 头插法存在并发情况下循环链表问题，JDK8 通过尾插进行解决。</li>
</ul>
<hr>
<p>HashMap 的扩容实质上是数组的扩容，会重新开辟一份容量为原数组两倍的新数组，并将老数组的元素转移过来。</p>
<ul>
<li>扩容条件<ul>
<li>当插入新元素后，HashMap 中元素的数量超过当前数组容量的负载因子（默认是 0.75）时，HashMap 会触发扩容</li>
</ul>
</li>
<li>扩容过程<ul>
<li>JDK7<ul>
<li>新数组容量为原数组容量的两倍。</li>
<li>将老数组中的元素重新计算哈希值，得到新数组的下标。</li>
<li>将元素放到新数组对应槽位的链表上。</li>
<li>扩容的主要目的是解决链表过长的问题</li>
</ul>
</li>
<li>JDK8<ul>
<li>新数组容量为原数组容量的两倍。</li>
<li>重新计算老数组中元素的数组下标。</li>
<li><strong>红黑树槽位</strong>:<ul>
<li>通过低位和高位（老位置的元素和新位置的元素）拆分成两个子链表，存放到不同的槽位。</li>
<li>当数组长度达到 64 且链表长度达到 8 时，会将链表转化为红黑树。</li>
</ul>
</li>
<li><strong>链表槽位</strong>:<ul>
<li>操作与 JDK 7 相同，将元素放到新数组对应槽位的链表上</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>低位和高位的概念</p>
<p>在扩容过程中，重新计算数组下标时，会出现两种情况：</p>
<ol>
<li><strong>低位</strong>：元素在新数组中的位置与在旧数组中的位置相同。</li>
<li><strong>高位</strong>：元素在新数组中的位置是旧数组位置加上旧数组的容量。</li>
</ol>
<p>这两种情况取决于元素的哈希值与旧数组容量进行按位与操作的结果：</p>
<ul>
<li>低位：<code>index = oldIndex</code></li>
<li>高位：<code>index = oldIndex + oldCapacity</code></li>
</ul>
<h4 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h4><p>ConcurrentHashMap 是一种线程安全的高效Map集合</p>
<ul>
<li>ConcurrentHashMap<ul>
<li>底层数据结构<ul>
<li>1.7：底层采用分段 Segment，每一个 Segment 是由 数组 + 链表实现</li>
<li>1.8：采用的数据结构跟 HashMap 1.8 的结构一样，Node 数组 + 链表&#x2F;红黑二叉树</li>
</ul>
</li>
<li>加锁的方式<ul>
<li>1.7：采用 Segment 分段锁，底层使用的是 ReentrantLock</li>
<li>1.8：采用 CAS 添加新节点，采用 synchronized 锁定链表或红黑二叉树的首节点，相对 Segment 分段锁粒度更细，性能更好</li>
</ul>
</li>
<li>新增元素（1.8）<ul>
<li>hash(key)  → 在该数组节点下通过 CAS 操作新增元素操作</li>
<li>采用 synchronized 锁定链表或红黑二叉树的首节点</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>加锁程度</p>
<ul>
<li>1.7  通过对Segment加锁实现，每个 Segment 有自己的锁</li>
<li>1.8  对于链表的修改操作，通过synchronized关键字对 Node 进行加锁；对于新增操作，如果需要更新链表的头部，使用CAS操作来确保原子性。当链表长度达到一定阈值后，链表会转换为红黑树，提高搜索效率</li>
</ul>
<p>1.7 中使用了分段锁的机制，通过对于 HashEntry 数组进行加锁，每一个 Segment 元素都是使用的 ReentrantLock ，用于在高并发环境下对于集合的线程安全保护。</p>
<p>同时为了 hash 冲突的解决，这里是通过拉链法的方式进行解决的。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240407222040.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>锁粒度更细</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240407222700.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Deque-Queue"><a href="#Deque-Queue" class="headerlink" title="Deque&#x2F;Queue"></a>Deque&#x2F;Queue</h4><ul>
<li><p>Queue是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循先进先出(FIFO)规则。</p>
</li>
<li><p>Deque是双端队列，在队列的两端均可以插入或删除元素。</p>
</li>
</ul>
<h4 id="SortedSet-TreeSet"><a href="#SortedSet-TreeSet" class="headerlink" title="SortedSet&#x2F;TreeSet"></a>SortedSet&#x2F;TreeSet</h4><ul>
<li>TreeSet 是 SortedSet 的实现类</li>
<li>一般是两种排序方式：一种是自然排序（实现 Comparable 接口，重写 compareTo 方法）：还有一种是自定义比较器（Comparator）</li>
</ul>
<p>[[Java集合_基础概念#四、Set]]</p>
<p>TreeSet ：<code>TreeSet</code> 是通过 <code>TreeMap</code> 来实现的（内部结构）</p>
<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList 的底层原理是什么样的</p>
<ul>
<li><code>CopyOnWriteArrayList</code> 是 Java 中的一种线程安全的 List 实现，它通过在每次修改操作（如添加、删除、更新）时，创建一个新数组来保证线程安全。这种设计使得它非常适合读多写少的场景</li>
<li><code>CopyOnWriteArrayList</code> 内部使用一个 <code>volatile</code> 修饰的数组来存储数据，这个数组确保了内存可见性</li>
<li>所有的读取操作都是基于这个 <code>volatile</code> 数组的，由于数组被 <code>volatile</code> 修饰，保证了读取操作的最新性和线程安全性。读取操作不会进行加锁，因为读取时不会改变数组的状态。</li>
<li>写入操作是 <code>CopyOnWriteArrayList</code> 的核心，它通过对数组进行复制来实现线程安全<ul>
<li><strong>加锁</strong>：写入操作需要加锁以确保线程安全。</li>
<li><strong>复制数组</strong>：在进行修改操作前，首先复制一份当前数组。</li>
<li><strong>修改数组</strong>：在复制的数组上进行修改操作。</li>
<li><strong>替换数组</strong>：将修改后的数组替换掉原来的数组</li>
</ul>
</li>
</ul>
<h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><ul>
<li>ThreadLocal主要是保存线程变量副本的，⼀般可以⽤来缓存⽤户信 息、连接等，通过保证每个线程变量隔离来实现线程安全<ul>
<li>ThreadLocal 会对线程维护⼀个以 ThreadLocal 作为 Key 的 Map(ThreadLocalMap，Value对应的是当前线程变量的副本，Key 是弱引⽤所以GC时会回收，但是Value是强引⽤，所以如果不⼿动 清除，Value会⼀直霸占⽼年代空间导致内存泄露(ML)</li>
</ul>
</li>
<li>对于ThreadLocal只能保证线程内部的通信，如果想要进⾏⽗⼦线程 通信，可以使⽤InheritableThreadLocal，它实现原理是⽗线程在创建 ⼦线程时会将当前的变量副本拷⻉⼀份给⼦线程，但是 InheritableThreadLocal遇到线程池就不能完成⽗⼦通信了，因为线程 池⼀旦创建完线程就会进⾏复⽤，所以可以使⽤ TransmittableThreadLocal，它实现原理就是在线程池中不管线程是 否是新建都会在调⽤时抓取⽗线程的上下⽂给⼦线程</li>
<li>另外 ThreadLocal 内部  ThreadLocalMap 使⽤线性探测法实现的哈希 表，所以⾯临⼤量线程绑定数据时性能较低，所以 Netty  引出了 FastThreadLocal，底层直接通过更⼤数组空间的开辟，通过数组索引 进⾏定位，避免线性探测，采⽤⽤空间换时间，并且  FastThreadLocal  在任务执⾏完之后会对Value清除避免内存泄露<ul>
<li>哈希冲突的解决⽅法<ul>
<li>拉链法 </li>
<li>红⿊树 </li>
<li>线性探测法<ul>
<li>寻找最靠近的下⼀个空槽</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="遍历集合你一般使用什么方式"><a href="#遍历集合你一般使用什么方式" class="headerlink" title="遍历集合你一般使用什么方式"></a>遍历集合你一般使用什么方式</h4><ul>
<li>增强 for 循环</li>
<li>迭代器</li>
<li>for 循环</li>
<li>stream</li>
</ul>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><h4 id="阻塞队列长度设置"><a href="#阻塞队列长度设置" class="headerlink" title="阻塞队列长度设置"></a>阻塞队列长度设置</h4><ul>
<li>如果任务执行时间较长，建议设置较大的队列长度，以防止过多的任务被拒绝。</li>
</ul>
<h4 id="什么是-CAS"><a href="#什么是-CAS" class="headerlink" title="什么是 CAS"></a>什么是 CAS</h4><ul>
<li>比较并交换</li>
</ul>
<h4 id="线程池中，如果一个线程没有捕获异常，发送异常后会发生什么情况"><a href="#线程池中，如果一个线程没有捕获异常，发送异常后会发生什么情况" class="headerlink" title="线程池中，如果一个线程没有捕获异常，发送异常后会发生什么情况"></a>线程池中，如果一个线程没有捕获异常，发送异常后会发生什么情况</h4><ul>
<li><p>当线程在执行任务时抛出未捕获的异常，该线程会立即终止。这意味着任务没有正确完成，并且该线程将不再继续执行后续代码。</p>
</li>
<li><p>线程池（如 <code>ThreadPoolExecutor</code>）有一个内部机制来捕获线程抛出的异常。默认情况下，线程池会记录这个异常，但不会重新抛出或进行其他特殊处理。任务的提交者（调用 <code>submit</code> 方法的线程）不会直接感知到异常，除非通过 <code>Future</code> 获取任务的执行结果。</p>
</li>
<li><p>线程池会创建一个新的线程来替换抛出异常并终止的线程，从而保证线程池中的线程数量维持在配置的核心线程数或最大线程数。线程池本身不会因为一个线程的异常而崩溃或停止工作。</p>
</li>
<li><p>使用 <code>Future.get()</code> 可以捕获任务抛出的异常</p>
</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>volatile 保证</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240326205410.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><ul>
<li>这里 synchronized 的描述优点问题，是先有 偏向锁，再有轻量级锁，再有自旋锁，然后是重量级锁</li>
<li>如果问 AQS 的话，其实是有一个 acquire 方法之类的进行加锁和放锁的操作</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240312224915.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li><p>改一下：原子性一般是线程通过对资源加锁的方式来实现的，这里可以引入 synchronized 和 ReetrantLock 的相关内容</p>
</li>
<li><p>synchronized 的重量级锁</p>
</li>
</ul>
<h4 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240304154734.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>阻塞：没有获取到资源（没有获取到锁）</p>
<ul>
<li>线程状态</li>
</ul>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><ul>
<li><p>使用场景 </p>
<ul>
<li>1、异步</li>
<li>2、记录日志</li>
<li>3、定时任务</li>
</ul>
</li>
<li><p>线程池的核心线程数可以设置为 0 （通过非核心线程去处理任务）</p>
</li>
<li><p>阻塞队列</p>
<ul>
<li>Array  单个锁</li>
<li>Linked  两个锁，加锁</li>
</ul>
</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240313111136.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>callable 接口回调：</p>
<p><code>FutureTask</code> 提供了 <code>Future</code> 接口的基本实现，常用来封装 <code>Callable</code> 和 <code>Runnable</code>，具有取消任务、查看任务是否执行完成以及获取任务执行结果的方法</p>
<blockquote>
<p>为什么不建议使用 Execution 创建线程池</p>
</blockquote>
<p><code>Executors</code> 返回线程池对象的弊端如下(后文会详细介绍到)：</p>
<ul>
<li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
<li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li>
<li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li>
</ul>
<p>说白了就是：<strong>使用有界队列，控制线程创建数量。</strong></p>
<p>除了避免 OOM 的原因之外，不推荐使用 <code>Executors</code>提供的两种快捷的线程池的原因还有：</p>
<ul>
<li>实际使用中需要根据自己机器的性能、业务场景来<strong>手动配置线程池的参数比如核心线程数、使用的任务队列、饱和策略</strong>等等。</li>
<li>我们应该显示地给我们的线程池命名，这样有助于我们定位问题</li>
</ul>
<blockquote>
<p>线程池参数定义</p>
</blockquote>
<p>核心线程数</p>
<ul>
<li>IO密集型： CPU核数 * 2 </li>
<li>CPU计算性：CPU核心 + 1</li>
</ul>
<p>最大线程数</p>
<ul>
<li>一个常见的做法是设置最大线程数为核心线程数的2到4倍</li>
</ul>
<p>阻塞队列</p>
<ul>
<li>队列大小的设置取决于你期望的任务处理模式。如果希望能够缓冲大量的请求，那么可以设置较大的队列。如果希望减少等待时间，可以设置较小的队列</li>
<li>IO密集型： 设置多一些（会有网络阻塞等，等待线程可能会多）</li>
<li>CPU计算性：可以设置小一点（任务可以迅速完成，不需要太大的等待队列）</li>
</ul>
<hr>
<p><strong>理解有一个问题改一下（线程池的执行流程）</strong></p>
<ul>
<li>1、提交任务</li>
<li>2、核心线程处理任务</li>
<li>3、核心线程忙碌，放入新任务到阻塞队列</li>
<li>4、阻塞队列满了之后，再来一个任务，线程池会创建一个非核心线程去处理新的任务。当非核心线程完成它们的任务后，如果阻塞队列中还有待处理的任务，这些非核心线程也会从阻塞队列中取任务来执行。</li>
<li>5、如果 核心线程数 + 非核心线程数 &gt; 最大线程数，才会进行触发拒绝策略</li>
</ul>
<p>拒绝策略方式</p>
<ul>
<li>1.AbortPolicy:直接抛出异常，默认策略：</li>
<li>2.CallerRunsPolicy:用调用者所在的线程来执行任务；</li>
<li>3.DiscardOldestPolicy:丢弃阻塞队列中靠最前的任务，并执行当前任务：</li>
<li>4.DiscardPolicy:直接丢弃任务：</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512172606.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>线程计算公式</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512173029.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>假设：核数 12、CPU 利用率 90%，等待时间 50ms，计算时间51ms</p>
<p>N &#x3D; 12 * 0.9 * (1 + 50&#x2F;51) ≈ 22</p>
<p>设置核心线程数 22 是比较符合预期的值</p>
<p>在真实的程序中，<strong>一般很难获得准确的等待时间和计算时间，因为程序很复杂，不只是“计算”</strong>。一段代码中会有很多的内存读写，计算，I&#x2F;O 等复合操作，精确的获取这两个指标很难，所以光靠公式计算线程数过于理想化。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240512173427.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h4><p>线程死锁：通过 JVM 排查工具去排查到具体原因，然后定位现象</p>
<p>MySQL：一般有监控信息，可以看到，看到后进行处理，通过现象分析死锁原因，然后去进行事务或者SQL的优化</p>
<h4 id="使用-synchronized-修饰类和方法的区别"><a href="#使用-synchronized-修饰类和方法的区别" class="headerlink" title="使用 synchronized 修饰类和方法的区别"></a>使用 synchronized 修饰类和方法的区别</h4><ul>
<li><code>synchronized</code>修饰代码块（类锁）<ul>
<li>当使用<code>synchronized</code>修饰代码块时，需要指定一个锁对象。如果指定的是类的<code>Class</code>对象，那么这个<code>synchronized</code>代码块就相当于对这个类进行了锁定。</li>
</ul>
</li>
<li><code>synchronized</code>修饰方法<ul>
<li>当<code>synchronized</code>修饰一个实例方法时，<ul>
<li>它锁定的是当前实例对象。</li>
<li>这意味着，同一时间内，<strong>只有一个线程能够访问这个对象的所有<code>synchronized</code>实例方法</strong>。如果一个线程访问该对象的一个<code>synchronized</code>实例方法，其他线程试图访问该对象的任何其他<code>synchronized</code>实例方法将会被阻塞，直到第一个线程完成方法的执行。</li>
</ul>
</li>
<li>当<code>synchronized</code>修饰一个静态方法时，<ul>
<li>它锁定的是这个类的所有实例。因为静态方法是属于类的，而不是任何实例对象的，所以此时锁定的是类的<code>Class</code>对象本身。这意味着，同一时间内，<strong>只有一个线程能够访问这个类的所有<code>synchronized</code>静态方法。</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="死锁问题如何排查定位"><a href="#死锁问题如何排查定位" class="headerlink" title="死锁问题如何排查定位"></a>死锁问题如何排查定位</h4><ul>
<li><strong>排查定位</strong>：使用线程转储、监控工具和日志分析来识别死锁。</li>
<li><strong>解决</strong>：通过调整锁顺序、使用 <code>tryLock</code>、破坏死锁条件等方法来解决死锁问题。</li>
<li><strong>避免</strong>：避免嵌套锁定、使用超时锁定、采用高层次锁定机制、排序和定期检测等方法来避免死锁。</li>
</ul>
<p>tryLock：ReentrantLock 的加锁方法，一般为了避免死锁可以用它并设置下超时时间</p>
<p>如何排查：一般需要查看当前死锁的进程是哪个，然后通过 jstack 之类的操作进行生成转储文件，通过  VisualVM  工具之类的进行查看，生产情况下可能需要通过适当时间重启并优化程序的方式来进行解决；</p>
<p>如何避免：可以使用数据库锁、分布式锁来避免代码的显示问题</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><ul>
<li>类加载过程<ul>
<li>加载、验证、准备、解析、初始化</li>
</ul>
</li>
<li>类加载器<ul>
<li>**引导类加载器 (Bootstrap ClassLoader)**：加载 JRE 核心库，<code>jre/lib</code> 目录下的包。</li>
<li>**拓展类加载器 (Extension ClassLoader)**：加载扩展库，<code>jre/lib/ext</code> 目录下的包。</li>
<li>**应用程序类加载器 (Application ClassLoader)**：加载用户类路径下的包。</li>
<li>**自定义类加载器 (Custom ClassLoader)**：加载自定义路径下的包，开发者可以通过继承 <code>ClassLoader</code> 类实现。</li>
</ul>
</li>
<li>双亲委派机制<ul>
<li>⾃上⽽下的类加载过程，⾸先会委托⽗加载器去 加载⽬标类，如果能找到⽬标类就加载，如果找不到就继续委托它的 ⽗加载器去加载，如果⽗加载器都加载不了，就⾃⼰去加载</li>
</ul>
</li>
<li>如何打破双亲委派机制<ul>
<li>可以继承ClassLoader，重写 loadClass 以及  findClass ⽅法<ul>
<li>loadClass主要使⽤来加载类的，findClass主要是⽤来寻找⽬标类 的</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="JVM-运行区区域"><a href="#JVM-运行区区域" class="headerlink" title="JVM 运行区区域"></a>JVM 运行区区域</h4><ul>
<li>堆</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
<li>程序计数器</li>
<li>方法区<ul>
<li>JDK8  本地内存  →  元空间   →    方法区</li>
<li>JDK8 之前   →  堆中（永久代）   →    方法区</li>
</ul>
</li>
</ul>
<h4 id="在1-8-中，运行时常量池是放置在哪个区域？-🚩"><a href="#在1-8-中，运行时常量池是放置在哪个区域？-🚩" class="headerlink" title="在1.8 中，运行时常量池是放置在哪个区域？  🚩"></a>在1.8 中，运行时常量池是放置在哪个区域？  🚩</h4><p>在Java 8中，<strong>字符串常量池</strong>已经被移动到了<strong>堆内存</strong>中，以提高性能和减少内存溢出的风险。</p>
<p>而<strong>运行时常量池</strong>除了字符串常量外的部分，仍然存储在方法区中，但方法区的实现已从永久代变更为<strong>元空间</strong>。</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240315210151.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="栈上分配-💣"><a href="#栈上分配-💣" class="headerlink" title="栈上分配   💣"></a>栈上分配   💣</h4><p>栈上分配是一种优化技术，用于减少堆内存分配和垃圾回收的压力。通常情况下，通过 <code>new</code> 关键字创建的对象都是分配在堆上的，但在某些情况下，JVM 可以通过逃逸分析（Escape Analysis）将一些临时对象分配到栈上。这意味着这些对象会随着栈帧的出栈而被销毁，从而减少对垃圾回收器（GC）的压力。</p>
<blockquote>
<p>逃逸分析</p>
</blockquote>
<p>逃逸分析是一种静态代码分析技术，用于确定对象的引用范围，即对象是否会逃逸出方法或线程。根据逃逸分析的结果，JVM 可以对对象进行不同的优化处理。</p>
<ul>
<li><strong>方法逃逸</strong>：如果对象被返回或传递到方法外部，则认为它逃逸出了方法。</li>
<li><strong>线程逃逸</strong>：如果对象被共享到其他线程中，则认为它逃逸出了当前线程。</li>
</ul>
<p>如果对象没有逃逸出方法或线程，JVM 可以进行进一步优化，比如栈上分配或标量替换。</p>
<blockquote>
<p>标量替换</p>
</blockquote>
<p>标量替换是逃逸分析优化的一部分。它将对象的成员变量拆分为单独的标量（例如，基本类型或引用），而不是将整个对象分配到堆上。通过这种方式，可以避免不必要的对象创建。</p>
<blockquote>
<p>栈上分配的原理</p>
</blockquote>
<ul>
<li><strong>对象分配到栈上</strong>：如果通过逃逸分析确定对象没有逃逸出方法，则可以将该对象分配到栈上。栈上分配的对象在栈帧出栈时自动销毁，不需要GC。</li>
<li><strong>减少GC压力</strong>：栈上分配避免了临时对象在堆上的分配和回收，从而减轻了GC的压力，提高了性能。</li>
</ul>
<h4 id="判断垃圾回收"><a href="#判断垃圾回收" class="headerlink" title="判断垃圾回收"></a>判断垃圾回收</h4><ul>
<li>引用计数法</li>
<li>可达性分析算法</li>
</ul>
<h4 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h4><ul>
<li>标记整理</li>
<li>标记清除</li>
<li>复制</li>
</ul>
<h4 id="对象的分配策略"><a href="#对象的分配策略" class="headerlink" title="对象的分配策略"></a>对象的分配策略</h4><p>在 Java 虚拟机（JVM）中，对象的分配和回收策略有助于提升内存管理效率和系统性能。以下是 JVM 对象分配的具体策略：</p>
<ol>
<li>对象优先在 Eden 区进行分配</li>
</ol>
<ul>
<li><strong>新对象分配</strong>：新创建的对象会被分配到 Eden 区。当 Eden 区内存不足时，会触发 Minor GC。</li>
<li><strong>Minor GC 后对象移动</strong>：每次 Minor GC 后，存活的对象会被移动到 Survivor 区的一个区域。在下一次 Minor GC 时，Eden 区和 Survivor 区存活的对象会被移动到 Survivor 区的另一个区域，同时对象的分代年龄会增加 1。</li>
<li><strong>对象晋升</strong>：当对象分代年龄达到一定次数后（默认 15 次，CMS 为 6 次），对象会被晋升到老年代。如果老年代使用空间达到阈值，会进行 Full GC。如果 Full GC 无法回收足够的内存，则会导致内存溢出（OOM）。</li>
</ul>
<ol start="2">
<li>大对象直接进入老年代</li>
</ol>
<ul>
<li><strong>大对象处理</strong>：由于复制算法对大对象的来回复制会带来性能开销，JVM 可以设置一个阈值，当新创建的对象大小超过这个阈值时，会直接分配到老年代。</li>
</ul>
<ol start="3">
<li>长期存活的对象进入老年代</li>
</ol>
<ul>
<li><strong>分代年龄机制</strong>：对象在年轻代存活一定次数（分代年龄）后，会被晋升到老年代。</li>
<li><strong>动态年龄判断机制</strong>：<ul>
<li><strong>机制</strong>：经过 Minor GC 后，如果 Survivor 区中存活的前 N 代对象的内存总和超过 Survivor 区内存的一半，会将 N 代及以上的对象直接移动到老年代。</li>
<li><strong>目的</strong>：尽可能将长期存活的对象直接进入老年代，避免频繁的 GC。</li>
</ul>
</li>
</ul>
<ol start="4">
<li>老年代空间分配担保机制</li>
</ol>
<ul>
<li><strong>Minor GC 前的计算</strong>：在每次 Minor GC 之前，JVM 会计算老年代剩余可用空间。<ul>
<li><strong>触发 Full GC 条件</strong>：<ol>
<li>如果老年代剩余可用空间小于年轻代所有对象的内存，会触发 Minor GC。</li>
<li>如果老年代剩余可用空间不小于年轻代所有对象的内存，会检查是否配置了担保参数。</li>
<li>如果配置了担保参数，并且老年代剩余可用空间小于历史上每次 Minor GC 进入老年代对象的内存大小，会触发 Full GC。</li>
<li>如果老年代剩余可用空间不小于历史上每次 Minor GC 进入老年代对象的内存大小，则触发 Minor GC。</li>
<li>如果没有担保参数，直接触发 Full GC。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h4 id="垃圾收集器-🚩"><a href="#垃圾收集器-🚩" class="headerlink" title="垃圾收集器  🚩"></a>垃圾收集器  🚩</h4><ul>
<li>Serial 、Serial Old<ul>
<li>Serial 和 Serial Old 是 单线程垃圾收集器，在GC时，只允许⼀个 线程进⾏</li>
<li>Serial ⽤在年轻代采⽤的是 复制算法、Serial Old ⽤在⽼年代采⽤ 的是 标记整理算法</li>
<li>在单核处理器的情况下，简单⾼效，但是多核处理器下⽆法发挥 多核的性能不推荐使⽤，适合 100M以内 内存</li>
</ul>
</li>
<li>Parallel、Parallel Old<ul>
<li>Parallel 和 Parallel Old 是 多线程垃圾收集器，是serial系列的多线 程版本</li>
<li>Parallel ⽤在年轻代采⽤的是 <strong>复制算法</strong>，Parallel Old采⽤的是 <strong>标 记整理算法</strong></li>
<li>关注点在于吞吐量，⽐较适合CPU密集型场景，⼀般 4G以下 内存 推荐使⽤</li>
</ul>
</li>
<li>ParNew 、CMS<ul>
<li>ParNew 与 Parallel类似，只是为了配合 CMS 才出现的</li>
<li>ParNew ⽤在年轻代采⽤的是 复制算法， CMS ⽤在⽼年代采⽤的 是 <strong>标记清除算法</strong></li>
<li>CMS关注点是最⼤停顿时间，也就是<strong>⽤户的体验度，⽐较适合 4~8G 内存的情况使⽤</strong></li>
</ul>
</li>
<li>G1<ul>
<li>分区模型</li>
</ul>
</li>
</ul>
<p>CMS</p>
<ul>
<li><p>初始标记  →  并发标记  →  重新标记  →   并发清理  →   并发重置</p>
</li>
<li><p>并发标记会产生多标、漏标问题，漏标主要的解决方案是三色标记</p>
</li>
<li><p>CMS的运作步骤</p>
<ul>
<li>初始标记<ul>
<li>STW，从GC Root出发，<strong>只标记直接引⽤对象</strong>(不包含内部 成员变量相关的间接引⽤对象)</li>
</ul>
</li>
<li>并发标记<ul>
<li>从GC Root的直接引⽤对象出发，遍历整个对象图进⾏标 记，耗时较⻓，由于⽤户线程和GC线程都在运⾏着，所以 会有多标、漏标的问题</li>
<li>多标<ul>
<li>多标 就是本应该是垃圾对象，但是由于⽤户线程还 在运⾏，所以没来及去清除标记</li>
</ul>
</li>
<li>漏标<ul>
<li>漏标 就是 新来的对象引⽤了GC Root链上的对象， 但是由于⽤户线程还在运⾏，没来得及标记为⾮垃 圾，被GC误清除</li>
<li>漏标 的处理⽅案主要是 三⾊标记算法，主要分为 增量更新 和 原始快照<ul>
<li>三⾊标记主要是分为三种颜⾊，分别是⿊⾊、⽩ ⾊、灰⾊<ul>
<li>⿊⾊对象 表示 当前对象的引⽤对象图都扫描 完了</li>
<li>灰⾊对象 表示 当前对象的引⽤对象图只扫描 了⼀部分</li>
<li>⽩⾊对象 表示 当前对象的引⽤对象图没扫描</li>
</ul>
</li>
<li>增量更新 是通过 记录下⿊⾊对象新增的⽩⾊对 象引⽤关系，将⿊⾊对象回退到灰⾊对象，重新 深度扫描⼀次</li>
<li>原始快照 是通过 记录下灰⾊对象删除的⽩⾊对 象的引⽤关系，以灰⾊对象为根简单扫描⼀下， 将⽩⾊对象标记为⿊⾊对象，当作浮动垃圾处 理，等待下⼀轮GC<ul>
<li>浮动垃圾<ul>
<li>浮动垃圾 就是在 并发标记 和 并发清理 阶 段产⽣的垃圾，对GC最终效果影响不 ⼤，只要等待下⼀轮GC处理就⾏</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>重新标记<ul>
<li>STW，对 并发标记 过程中产⽣状态改变的对象进⾏修正， 这⾥对于 漏标 的问题采⽤的是 三⾊标记算法 中的 增量更 新 来做的重新标记</li>
</ul>
</li>
<li>并发清理<ul>
<li>对未标记的对象进⾏清理，这⾥因为没有进⾏STW，所以 对于新增对象会被标记为⿊⾊对象</li>
</ul>
</li>
<li>并发重置<ul>
<li>将对象的标记位进⾏重置，进⾏下⼀轮GC</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="触发-Full-GC-的一些情况-🚩"><a href="#触发-Full-GC-的一些情况-🚩" class="headerlink" title="触发 Full GC 的一些情况  🚩"></a>触发 Full GC 的一些情况  🚩</h4><h4 id="哪些对象可以作为-GC-Root-？"><a href="#哪些对象可以作为-GC-Root-？" class="headerlink" title="哪些对象可以作为 GC Root ？"></a>哪些对象可以作为 GC Root ？</h4><ul>
<li>虚拟机栈中（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈中 JNI 引用的对象</li>
</ul>
<h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><h4 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h4><ul>
<li>原子性<ul>
<li>要么全部成功，要么全部失败</li>
</ul>
</li>
<li>一致性<ul>
<li>数据在事务的开始到结束的过程中要保持⼀致</li>
</ul>
</li>
<li>隔离性<ul>
<li>每个事务要互相隔离</li>
</ul>
</li>
<li>持久性<ul>
<li>事务完成后数据会被持久化下来</li>
</ul>
</li>
</ul>
<h4 id="脏写、脏读、不可重复读、幻读"><a href="#脏写、脏读、不可重复读、幻读" class="headerlink" title="脏写、脏读、不可重复读、幻读"></a>脏写、脏读、不可重复读、幻读</h4><ul>
<li>脏写<ul>
<li>操作同⼀数据时，⼀个事务的修改被另外⼀个事务的修改覆盖</li>
</ul>
</li>
<li>脏读<ul>
<li>⼀个事务读取了另⼀个事务尚未提交的数据时</li>
</ul>
</li>
<li>不可重复读<ul>
<li>同⼀事务下，由于其他事务的修改导致同⼀数据被读取两次的结 果不⼀致</li>
</ul>
</li>
<li>幻读<ul>
<li>⼀个事务读取到另外⼀个事务已提交的新增数据</li>
</ul>
</li>
</ul>
<h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><ul>
<li>读未提交</li>
<li>读已提交</li>
<li>可重复读</li>
<li>串行化<ul>
<li>解决幻读</li>
<li>所有读操作后⾯加读锁 lock in share mode，因为读锁、写锁 互斥，所以不能同时发⽣</li>
</ul>
</li>
</ul>
<h4 id="常见的索引结构"><a href="#常见的索引结构" class="headerlink" title="常见的索引结构"></a>常见的索引结构</h4><ul>
<li>二叉树</li>
<li>红黑树</li>
<li>哈希表</li>
<li>B-Tree</li>
<li>B+Tree</li>
</ul>
<h4 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h4><h4 id="聚簇索引和⾮聚簇索引"><a href="#聚簇索引和⾮聚簇索引" class="headerlink" title="聚簇索引和⾮聚簇索引"></a>聚簇索引和⾮聚簇索引</h4><h4 id="MySQL-的性能优化"><a href="#MySQL-的性能优化" class="headerlink" title="MySQL 的性能优化"></a>MySQL 的性能优化</h4><ul>
<li>1、建表，字段<ul>
<li>选择合适的字段和属性，尽量遵循范式原则，尽量选择合适索引</li>
</ul>
</li>
<li>2、业务字段设计<ul>
<li>业务方面，违反范式，避免连表查询</li>
</ul>
</li>
<li>3、查询SQL优化<ul>
<li>添加索引：选择区分度比较高的列，建立唯一索引和联合索引等</li>
<li>注意事项<ul>
<li>写 SQL 的时候避免索引失效</li>
<li>尽量避免使用子查询，而使用连接查询</li>
<li>修改语句中经常作为判断的话考虑添加索引，避免行锁</li>
</ul>
</li>
</ul>
</li>
<li>4、架构优化<ul>
<li>主从集群，读写分离</li>
<li>读写多的表，进行水平分表或者垂直分表</li>
<li>考虑使用缓存</li>
<li>集群优化</li>
</ul>
</li>
</ul>
<h4 id="MySQL的执⾏计划怎么看"><a href="#MySQL的执⾏计划怎么看" class="headerlink" title="MySQL的执⾏计划怎么看"></a>MySQL的执⾏计划怎么看</h4><ul>
<li>MySQL的执⾏计划可以通过explain关键字去查看，主要看type、 key_len、extra<ul>
<li>type 会显示关联类型，⼀般优化到range就可以了<ul>
<li>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all</li>
</ul>
</li>
<li>key_len 会显示索引列占⽤的字节数，可以辅助判断⾛了哪些索 引列</li>
<li>extra 会显示解析查询的额外信息，⽐如临时表、⽂件排序等</li>
</ul>
</li>
<li>对于索引优化，当遇到 type 为 all 时，说明我们需要添加索引或优化索 引，对于整个优化过程要多次使⽤explain去分析</li>
</ul>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><ul>
<li>对于组合索引 没有⾛ 左前缀原则 会导致索引失效</li>
<li>进⾏like模糊查询时，%放在索引字段之前⾛不了索引下推会导致索 引失效，倘若数据量过⼤，索引下推会失效</li>
<li>查询条件的类型为字符串时，没有加单引号，可能因为类型不同导致 索引失效</li>
<li>对索引列进⾏计算会导致索引失效</li>
<li>查询条件使⽤or连接会导致索引失效</li>
<li>判断索引列不等于某个值时会导致索引失效</li>
</ul>
<h4 id="索引优化原则"><a href="#索引优化原则" class="headerlink" title="索引优化原则"></a>索引优化原则</h4><ul>
<li>不要基于使⽤频率较低的列加索引</li>
<li>组合索引列、排序要遵循 左前缀原则</li>
<li>where 和 order by冲突时优先使⽤where，能⽤where过滤就不要 使⽤having<ul>
<li>不要对索引列进⾏运算，⽐如使⽤函数<ul>
<li>MySQL 8&#x2F;Oracle⽀持函数索引，但是数据量过⼤时，索引 列维护成本较⾼</li>
</ul>
</li>
</ul>
</li>
<li>不要⽤or连接索引列<ul>
<li>对于like的使⽤，尽量使⽤右模糊匹配，让索引可以⾛索引下 推<ul>
<li>%A%、%A不⾛索引</li>
<li>A%⼀般情况下可以⾛索引下推，但是数据量过⼤时会导致 失效</li>
</ul>
</li>
</ul>
</li>
<li>索引列判空，⽐如is null、is not null不⾛索引<ul>
<li>join要做到小表驱动⼤表<ul>
<li>left join 左⼩右⼤</li>
<li>right join 右⼩左⼤</li>
<li>inner join 优化器会处理</li>
</ul>
</li>
<li>in、exists要做到小表驱动⼤表<ul>
<li>in 适合 ⼦表小于主表的，exists反之</li>
</ul>
</li>
</ul>
</li>
<li>索引列建议都设置为not null，可以节省1字节</li>
<li>对于获取总数count优先使⽤count( * ) 或 count(1)，如果数据量过 ⼤建议采⽤ES进⾏记录<ul>
<li>倘若count字段有索引，count(* ) &#x3D; count(1) &gt; count(字段) &gt; count(主键)<ul>
<li>count(字段)效率⽐count(主键)好的原因是⾛了覆盖索引， ⼆级索引树⽐主键索引树数据量⼩</li>
</ul>
</li>
<li>倘若count字段⽆索引，count( * ) &#x3D; count(1) &gt; count(主键) &gt; count(字段)</li>
</ul>
</li>
<li>频繁增删改的字段不要加索引，数据量⼀⼤维护成本会很⾼</li>
<li>⻓字符串可以采纳左20字符作为索引，满⾜90%场景</li>
<li>查询字段时，能采⽤覆盖索引的地⽅就去使⽤，避免查全部字段</li>
</ul>
<p>流程</p>
<ul>
<li>根据业务完成sql代码之后，可以先评估有哪些字段需要索引，尽 量使⽤组合索引</li>
<li>后续根据线上 skywalking&#x2F;grafana&#x2F;监控告警&#x2F;耗时⽇志 去观察接 ⼝以及定位慢SQL，再通过explain⼯具以及DBA建议进⾏优化， ⼀般情况下都能处理，如果索引优化已经满⾜不了业务场景了， 可以使⽤ES作为查询⼯具(将数据的关键字段 通过MQ + canal&#x2F;ogg 同步到ES)</li>
</ul>
<h4 id="SQL-的执行流程"><a href="#SQL-的执行流程" class="headerlink" title="SQL 的执行流程"></a>SQL 的执行流程</h4><ul>
<li>客户端 通过 连接器 进⾏权限验证，⽼版本的先去判断有没有开启缓 存，如果开启了，先从缓存中查询数据返回，如果没有开启，就通过 词法分析器去 进⾏词法分析，然后通过 优化器 去进⾏SQL优化，然 后再通过 执⾏器 去选择 存储引擎 去进⾏SQL执⾏<ul>
<li>客户端 -&gt; (缓存) -&gt; 词法分析器 -&gt; 优化器 -&gt; 执⾏器 -&gt; 存储引擎</li>
</ul>
</li>
</ul>
<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><h4 id="日志-🚩"><a href="#日志-🚩" class="headerlink" title="日志  🚩"></a>日志  🚩</h4><ul>
<li>undolog<ul>
<li>数据的快照⽇志，可以⽤于数据回滚</li>
<li>基于MVCC机制实现，通过创建多个版本的数据，从⽽使并发事务 互不影响，对于每个事务都会对应⾃⼰的版本链，读写操作都是 基于各⾃的版本去进⾏</li>
<li>undo log innerdb 储存引擎层面的日志，提供回滚和多版本并发控制下的读(MVCC)；</li>
</ul>
</li>
<li>redolog<ul>
<li>InnoDB级别的，主要⽤于BufferPool数据恢复的</li>
<li>redo log 数据备份和数据提交</li>
</ul>
</li>
<li>binlog<ul>
<li>会记录所有操作的⽇志，可⽤于数据归档</li>
<li>binlog 是 MySQ 服务层维护的一种二进制日志，主要做主从复制、数据恢复和备份</li>
</ul>
</li>
</ul>
<h4 id="redo-log-与-binlog-的区别"><a href="#redo-log-与-binlog-的区别" class="headerlink" title="redo log 与 binlog 的区别"></a>redo log 与 binlog 的区别</h4><ul>
<li>redo log 是在 InnoDB 存储引擎层产生，而 binlog 是 MySQL 数据库的上层产生的</li>
<li>写入磁盘的时间点不同，binlog 在事务提交完成后进行一次写入。而 redo log 在事务进行中不断地被写入</li>
<li>binlog 在写满或者重启之后，会生成新的 binlog 文件，redo log 是循环使用</li>
</ul>
<h4 id="正常我们使用-ORM-框架，从-ORM-框架-到-SQL-执行的这个过程你了解多少。"><a href="#正常我们使用-ORM-框架，从-ORM-框架-到-SQL-执行的这个过程你了解多少。" class="headerlink" title="正常我们使用 ORM 框架，从 ORM  框架 到 SQL 执行的这个过程你了解多少。"></a>正常我们使用 ORM 框架，从 ORM  框架 到 SQL 执行的这个过程你了解多少。</h4><ul>
<li>实体类映射</li>
<li>会话工厂</li>
<li>持久化操作</li>
<li>生成执行操作</li>
</ul>
<h4 id="常见编码和字符集"><a href="#常见编码和字符集" class="headerlink" title="常见编码和字符集"></a>常见编码和字符集</h4><ul>
<li><strong>UTF-8</strong>：最常用的字符编码，支持所有的 Unicode 字符。</li>
<li><strong>UTF-8MB4</strong>：UTF-8 的扩展版本，支持 4 字节 Unicode 字符（如表情符号）</li>
</ul>
<h4 id="VARCHAR-和-CHAR-的区别"><a href="#VARCHAR-和-CHAR-的区别" class="headerlink" title="VARCHAR 和 CHAR 的区别"></a><code>VARCHAR</code> 和 <code>CHAR</code> 的区别</h4><ul>
<li><strong>VARCHAR</strong><ul>
<li>可变长度字符数据类型。</li>
<li>存储时仅保存实际字符串的长度，并在前面加上一个或两个字节来存储字符串的长度（长度 &lt;&#x3D; 255 时使用一个字节，长度 &gt; 255 时使用两个字节）</li>
<li>可变长度，节省空间，适用于存储长度不确定或变化较大的字符串。</li>
<li><code>VARCHAR</code> 类型可以存储的最大字符数是 65535 字节</li>
</ul>
</li>
<li><strong>CHAR</strong><ul>
<li>固定长度字符数据类型。</li>
<li>固定长度，性能稳定，适用于存储长度固定或变化较小的字符串。</li>
</ul>
</li>
</ul>
<h4 id="数据库死锁问题怎么解决"><a href="#数据库死锁问题怎么解决" class="headerlink" title="数据库死锁问题怎么解决"></a>数据库死锁问题怎么解决</h4><p>排查：一般可以通过 SQL语句或者监控平台看到死锁现象，一般是资源争夺或者资源等待的问题，比如同时更新某一行等，事务长时间不释放锁，其他事务进行等待，也会导致死锁的现象。</p>
<p>解决：</p>
<ul>
<li>手动干预<ul>
<li>手动终止一个或多个导致死锁的事务，使其他事务可以继续执行。可以使用数据库管理工具或命令终止事务</li>
</ul>
</li>
<li>自动处理<ul>
<li>大多数现代数据库系统可以自动检测到死锁，并选择一个事务进行回滚以解除死锁。例如，MySQL 的 InnoDB 引擎会自动回滚最小的事务</li>
</ul>
</li>
</ul>
<p>优化建议：</p>
<ul>
<li>建议一些长事务，可以将它改为多个短事务去执行，避免事务一直没执行完，下一个事务又来了，导致死锁等待</li>
<li>使用数据库特性<ul>
<li><strong>使用悲观锁和乐观锁</strong>：根据业务场景选择适合的锁策略，悲观锁确保严格的并发控制，而乐观锁则适用于减少锁冲突的场景。</li>
<li><strong>设置死锁检测和超时时间</strong>：配置数据库的死锁检测和锁等待超时时间，确保死锁能及时被检测和处理。</li>
</ul>
</li>
</ul>
<h4 id="行锁什么情况下会升级为表锁"><a href="#行锁什么情况下会升级为表锁" class="headerlink" title="行锁什么情况下会升级为表锁"></a>行锁什么情况下会升级为表锁</h4><p>在 MySQL 的 InnoDB 存储引擎中，行锁（Row Lock）是默认的锁机制，</p>
<ul>
<li>大量行锁导致内存耗尽</li>
<li>表扫描导致锁定所有行</li>
<li>锁升级<ul>
<li>多个行锁导致的锁升级。</li>
<li>当多个行锁导致死锁或锁冲突时，InnoDB 可能会选择将行锁升级为表锁以简化锁管理。</li>
</ul>
</li>
</ul>
<p>为避免行锁升级为表锁，可以采取以下策略：</p>
<ul>
<li>使用合适的索引。</li>
<li>分批处理大数据量操作。</li>
<li>控制事务长度，减少锁的持有时间。</li>
<li>使用合适的隔离级别，降低锁冲突</li>
</ul>
<h4 id="间隙锁"><a href="#间隙锁" class="headerlink" title="间隙锁"></a>间隙锁</h4><p>间隙锁主要是在索引记录之间的间隙加锁，从而保证某个间隙内的数据在锁定情况下不会发生任何变化</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><h4 id="将数据库用户表的信息存入到缓存中，建议使用什么数据结构"><a href="#将数据库用户表的信息存入到缓存中，建议使用什么数据结构" class="headerlink" title="将数据库用户表的信息存入到缓存中，建议使用什么数据结构"></a>将数据库用户表的信息存入到缓存中，建议使用什么数据结构</h4><p>一般使用 Hash 就可以了，如果数据量少的话；</p>
<p>数据量多的时候需要考虑通过哈希或者其他方式将数据分散存入到多个 Key 中</p>
<p>如果是存入一些用户信息，比如用户相关联的信息，一对多的时候，可以考虑 List 或者 Set 存入</p>
<h4 id="Redis-的一些常用命令"><a href="#Redis-的一些常用命令" class="headerlink" title="Redis 的一些常用命令"></a>Redis 的一些常用命令</h4><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#Key 操作</span><br><span class="hljs-meta">#设置键的值</span><br>SET <span class="hljs-built_in">key</span> value<br><span class="hljs-meta">#获取键的值</span><br>GET <span class="hljs-built_in">key</span><br><span class="hljs-meta">#删除键</span><br>DEL <span class="hljs-built_in">key</span><br><span class="hljs-meta">#设置键的过期时间</span><br>EXPIRE <span class="hljs-built_in">key</span> seconds<br><span class="hljs-meta">#获取键的数据类型</span><br><span class="hljs-built_in">TYPE</span> <span class="hljs-built_in">key</span><br><br><span class="hljs-meta">#String 操作</span><br><span class="hljs-meta">#设置键的值，并设置过期时间</span><br>SETEX <span class="hljs-built_in">key</span> seconds value<br><span class="hljs-meta">#追加字符串到现有键值</span><br>APPEND <span class="hljs-built_in">key</span> value<br><span class="hljs-meta">#获取字符串长度</span><br><span class="hljs-built_in">STRLEN</span> <span class="hljs-built_in">key</span><br><span class="hljs-meta">#设置并返回键的旧值</span><br>GETSET <span class="hljs-built_in">key</span> value<br><span class="hljs-meta">#批量设置多个键值对</span><br>MSET key1 value1 key2 value2<br><span class="hljs-meta">#批量获取多个键值</span><br>MGET key1 key2<br><br><span class="hljs-meta">#Hash 操作</span><br>HSET <span class="hljs-built_in">key</span> field value                <span class="hljs-meta">#设置哈希字段的值</span><br>HGET <span class="hljs-built_in">key</span> field                <span class="hljs-meta">#获取哈希字段的值</span><br>HDEL <span class="hljs-built_in">key</span> field1 field2                <span class="hljs-meta">#删除一个或多个哈希字段</span><br>HGETALL <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取哈希中的所有字段和值</span><br>HKEYS <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取哈希中的所有字段</span><br>HVALS <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取哈希中的所有值</span><br>HEXISTS <span class="hljs-built_in">key</span> field                <span class="hljs-meta">#判断哈希字段是否存在</span><br><br><span class="hljs-meta">#List 操作</span><br>LPUSH <span class="hljs-built_in">key</span> value1 value2                <span class="hljs-meta">#从列表左端推入元素</span><br>RPUSH <span class="hljs-built_in">key</span> value1 value2                <span class="hljs-meta">#从列表右端推入元素</span><br>LPOP <span class="hljs-built_in">key</span>                <span class="hljs-meta">#从列表左端弹出元素</span><br>RPOP <span class="hljs-built_in">key</span>                <span class="hljs-meta">#从列表右端弹出元素</span><br>LLEN <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取列表长度</span><br>LRANGE <span class="hljs-built_in">key</span> start <span class="hljs-keyword">stop</span>                <span class="hljs-meta">#获取列表中指定范围的元素</span><br>LREM <span class="hljs-built_in">key</span> count value                <span class="hljs-meta">#移除列表中等于 value 的元素</span><br><br><span class="hljs-meta">#Set 操作</span><br>SADD <span class="hljs-built_in">key</span> member1 member2                <span class="hljs-meta">#向集合添加一个或多个元素</span><br>SREM <span class="hljs-built_in">key</span> member1 member2                <span class="hljs-meta">#移除集合中的一个或多个元素</span><br>SISMEMBER <span class="hljs-built_in">key</span> member                <span class="hljs-meta">#检查集合中是否包含指定元素</span><br>SMEMBERS <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取集合中的所有元素</span><br>SCARD <span class="hljs-built_in">key</span>                <span class="hljs-meta">#获取集合的元素个数</span><br>SRANDMEMBER <span class="hljs-built_in">key</span>                <span class="hljs-meta">#随机返回集合中的一个元素</span><br><br><span class="hljs-meta"># Sorted Set 操作</span><br>ZADD <span class="hljs-built_in">key</span> score1 member1 score2 member2                <span class="hljs-meta">#向有序集合添加元素及其分数</span><br>ZRANGE <span class="hljs-built_in">key</span> start <span class="hljs-keyword">stop</span>                <span class="hljs-meta">#获取有序集合中指定范围内的元素(按分数升序）</span><br>ZREVRANGE <span class="hljs-built_in">key</span> start <span class="hljs-keyword">stop</span>                <span class="hljs-meta">#获取有序集合中指定范围内的元素（按分数降序）</span><br>ZRANGEBYSCORE <span class="hljs-built_in">key</span> min max                <span class="hljs-meta">#按分数范围获取有序集合中的元素</span><br>ZREM <span class="hljs-built_in">key</span> member1 member2                <span class="hljs-meta">#移除有序集合中的一个或多个元素</span><br>ZCARD <span class="hljs-built_in">key</span>                 <span class="hljs-meta">#获取有序集合中的元素个数</span><br><br><span class="hljs-meta">#事务操作</span><br>MULTI                  <span class="hljs-meta">#开始事务</span><br><span class="hljs-built_in">EXEC</span>                <span class="hljs-meta">#执行事务</span><br>DISCARD                <span class="hljs-meta">#放弃事务</span><br></code></pre></td></tr></table></figure>

<h4 id="更新-hash-中某个-field-值的数据"><a href="#更新-hash-中某个-field-值的数据" class="headerlink" title="更新 hash 中某个 field 值的数据"></a>更新 hash 中某个 field 值的数据</h4><ol>
<li><strong>增加用户信息</strong>：使用 <code>HSET key field value</code> 将用户对象序列化后存储到 Redis 哈希表中。</li>
<li><strong>查询用户信息</strong>：使用 <code>HGET key field</code> 根据用户ID查询对应的值，并反序列化为用户对象。</li>
<li><strong>更新用户信息</strong>：再次使用 <code>HSET key field value</code> 更新用户信息。</li>
<li><strong>删除用户信息</strong>：使用 <code>HDEL key field</code> 删除指定用户ID的信息。</li>
<li><strong>获取所有用户信息</strong>：使用 <code>HGETALL key</code> 获取哈希表中的所有字段和值。</li>
<li><strong>获取所有用户ID</strong>：使用 <code>HKEYS key</code> 获取哈希表中的所有字段。</li>
<li><strong>获取所有用户对象</strong>：使用 <code>HVALS key</code> 获取哈希表中的所有值。</li>
<li><strong>判断用户是否存在</strong>：使用 <code>HEXISTS key field</code> 判断哈希字段是否存在</li>
</ol>
<h4 id="常用的缓存读写策略"><a href="#常用的缓存读写策略" class="headerlink" title="常用的缓存读写策略"></a>常用的缓存读写策略</h4><p>缓存常用的三种读写策略：Cache Aside Pattern（旁路缓存模式）、Read&#x2F;Write Through Pattern（读写穿透）、Write Behind Pattern（异步缓存写入）</p>
<ul>
<li>常用的缓存读写策略<ul>
<li>Cache Aside Pattern（旁路缓存模式）<ul>
<li>读<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
</li>
<li>写<ul>
<li>先更新 db</li>
<li>然后直接删除 cache</li>
</ul>
</li>
</ul>
</li>
<li>Read&#x2F;Write Through Pattern（读写穿透）<ul>
<li>读<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
</li>
<li>写<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
</li>
</ul>
</li>
<li>Write Behind Pattern（异步缓存写入）<ul>
<li>读</li>
<li>写<ul>
<li>**Read&#x2F;Write Through 是同步更新 cache 和 db，</li>
<li>Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="内存淘汰策略有哪些"><a href="#内存淘汰策略有哪些" class="headerlink" title="内存淘汰策略有哪些"></a>内存淘汰策略有哪些</h4><p>数据的淘汰策略：当Redis中的内存不够用时，此时在向Redisr中添加新的key,那么Redis 就会按照某一种规则将内存中的数据删除掉，这种数据的删除规则被称之为内存的淘汰策略。</p>
<ul>
<li>默认策略noeviction，当内存不⾜以容纳新写⼊数据时，新写⼊操作 会报错</li>
<li>针对设置过期时间的key<ul>
<li>volatile-lru，按照LRU算法删除 </li>
<li>volatile-lfu，按照LFU算法删除 </li>
<li>volatile-radom，随机删除 </li>
<li>volatile-ttl，按过期时间顺序删除</li>
</ul>
</li>
<li>针对所有key<ul>
<li>allkeys-random，随机删除 </li>
<li>allkeys-lru，按照LRU算法删除 </li>
<li>allkeys-lfu，按照LFU算法删除</li>
</ul>
</li>
</ul>
<h4 id="缓存加载和更新策略"><a href="#缓存加载和更新策略" class="headerlink" title="缓存加载和更新策略"></a>缓存加载和更新策略</h4><ul>
<li>缓存加载<ul>
<li>预加载（Cache Warming）</li>
<li>惰性加载（Lazy Loading）</li>
<li>定时加载（Scheduled Loading）</li>
</ul>
</li>
<li>缓存更新<ul>
<li>过期时间（TTL）</li>
<li>写通（Write Through）<ul>
<li>在更新数据源的同时，也同步更新缓存</li>
</ul>
</li>
<li>写回（Write Back &#x2F; Write Behind）<ul>
<li>首先更新缓存，然后异步地将数据更新到数据源</li>
</ul>
</li>
<li>失效（Cache Invalidation）<ul>
<li>在数据源更新后，立即使缓存中的对应数据失效</li>
<li>当数据源更新时，删除缓存中的旧数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>这里讲一下一般什么情况下会使用定时加载，一般来说我们会使用旁路缓存模式，比如先读缓存，如果缓存没有再读数据库，这里可以避免减少数据的负担，可以通过定时操作，先进行定时刷写到缓存中，避免读数据的时候再往数据库中查。</p>
<p>这里定时加载并不需要说每次全部更新缓存数据，你也可以设置修改数据库的时候同时更新缓存的数据，然后定时的时候再将数据库中有的数据而缓存中没有的数据，放入到缓存中。</p>
<h3 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h3><h4 id="Spring-的生命周期"><a href="#Spring-的生命周期" class="headerlink" title="Spring 的生命周期"></a>Spring 的生命周期</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240531174218.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="Spring-的传播事务-🚩"><a href="#Spring-的传播事务-🚩" class="headerlink" title="Spring 的传播事务   🚩"></a>Spring 的传播事务   🚩</h4><p>Service 中进行事务调用的时候，一般是需要注意一下事务传播行为，默认的 Spring 事务传播行为是：PROPAGATION_REQUIRED</p>
<ul>
<li>PROPAGATION_REQUIRED  ✈<ul>
<li>默认传播行为</li>
<li>存在则加入，否则创建新的事务</li>
</ul>
</li>
<li>PROPAGATION_SUPPORTS   ✈<ul>
<li>存在则加入，否则以非事务方式执行</li>
</ul>
</li>
<li>PROPAGATION_MANDATORY<ul>
<li>如果当前不存在事务就报错，否则就加 ⼊前事务</li>
</ul>
</li>
<li>PROPAGATION_REQUIRES_NEW           ✈<ul>
<li>每次都会创建新事务，外部事务可以进行捕获新事务的异常，再决定是否回滚事务</li>
<li>外事务发出异常进行回滚，不会影响内事务（独立事务）</li>
</ul>
</li>
<li>PROPAGATION_NOT_SUPPORTED<ul>
<li>，如果当前存在事务，就将当前事 务挂起，否则以⾮事务运⾏</li>
</ul>
</li>
<li>PROPAGATION_NEVER<ul>
<li>如果当前存在事务就报错，否则以⾮事务运 ⾏</li>
</ul>
</li>
<li>PROPAGATION_NESTED<ul>
<li>如果当前存在事务，就嵌套事务内运⾏， 如果不存在事务就按照PROPAGATION_REQUIRED运⾏</li>
<li>外事务发出异常进行回滚，内事务也进行回滚</li>
</ul>
</li>
</ul>
<p>propagation   传播 （朴 r 朴  ga tion）</p>
<table>
<thead>
<tr>
<th>传播行为</th>
<th>描述</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>PROPAGATION_REQUIRED</td>
<td>存在则加入，否则创建新的事务</td>
<td>默认行为，适用于绝大多数情况</td>
</tr>
<tr>
<td>PROPAGATION_SUPPORTS</td>
<td>存在则加入，否则以非事务方式执行</td>
<td>可选的事务，不强制要求</td>
</tr>
<tr>
<td>PROPAGATION_MANDATORY</td>
<td>存在则加入，否则抛出异常</td>
<td>强制要求必须在事务中执行</td>
</tr>
<tr>
<td>PROPAGATION_REQUIRES_NEW</td>
<td>总是创建新事务，挂起当前事务</td>
<td>需要独立事务的场景</td>
</tr>
<tr>
<td>PROPAGATION_NOT_SUPPORTED</td>
<td>以非事务方式执行，挂起当前事务</td>
<td>不需要事务的操作，或者事务会导致问题的场景</td>
</tr>
<tr>
<td>PROPAGATION_NEVER</td>
<td>以非事务方式执行，如果有事务则抛出异常</td>
<td>强制要求不在事务中执行</td>
</tr>
<tr>
<td>PROPAGATION_NESTED</td>
<td>在嵌套事务内执行，如果没有则创建新事务</td>
<td>需要嵌套事务的场景，支持内外事务单独回滚</td>
</tr>
</tbody></table>
<p>这种传播行为主要是用来精准控制事务行为，可以看一下下面的示例</p>
<p>第一种是默认情况，默认情况是 Propagation_REQUEST：加入到同一个事务中</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br>public class OrderService &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private PaymentService paymentService;<br><br>    <span class="hljs-variable">@Transactional</span>(propagation = Propagation.REQUIRED)<br>    public void <span class="hljs-built_in">placeOrder</span>(Order order) &#123;<br>        <span class="hljs-comment">// 保存订单</span><br>        <span class="hljs-selector-tag">saveOrder</span>(order);<br><br>        <span class="hljs-comment">// 调用支付服务</span><br>        <span class="hljs-selector-tag">paymentService</span><span class="hljs-selector-class">.processPayment</span>(order.<span class="hljs-built_in">getPayment</span>());<br>    &#125;<br><br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">saveOrder</span>(Order order) &#123;<br>        <span class="hljs-comment">// 保存订单逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-variable">@Service</span><br>public class PaymentService &#123;<br>    <span class="hljs-variable">@Transactional</span>(propagation = Propagation.REQUIRED)<br>    public void <span class="hljs-built_in">processPayment</span>(Payment payment) &#123;<br>        <span class="hljs-comment">// 支付处理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>OrderService.placeOrder</code> 方法和 <code>PaymentService.processPayment</code> 方法都使用 <code>PROPAGATION_REQUIRED</code> 传播行为。如果 <code>placeOrder</code> 方法已经在一个事务中执行，那么 <code>processPayment</code> 方法将加入到同一个事务中。这确保了订单和支付要么同时成功，要么同时失败。</p>
<hr>
<p>示例2：<code>PROPAGATION_REQUIRES_NEW</code> 用于在现有事务中执行一个完全独立的事务</p>
<p>例如记录日志或处理独立的业务逻辑。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br>public class OrderService &#123;<br>    <span class="hljs-variable">@Autowired</span><br>    private PaymentService paymentService;<br><br>    <span class="hljs-variable">@Transactional</span>(propagation = Propagation.REQUIRED)<br>    public void <span class="hljs-built_in">placeOrder</span>(Order order) &#123;<br>        <span class="hljs-comment">// 保存订单</span><br>        <span class="hljs-selector-tag">saveOrder</span>(order);<br><br>        <span class="hljs-comment">// 独立的事务处理支付</span><br>        <span class="hljs-selector-tag">paymentService</span><span class="hljs-selector-class">.processPayment</span>(order.<span class="hljs-built_in">getPayment</span>());<br>    &#125;<br><br>    <span class="hljs-selector-tag">private</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">saveOrder</span>(Order order) &#123;<br>        <span class="hljs-comment">// 保存订单逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-variable">@Service</span><br>public class PaymentService &#123;<br>    <span class="hljs-variable">@Transactional</span>(propagation = Propagation.REQUIRES_NEW)<br>    public void <span class="hljs-built_in">processPayment</span>(Payment payment) &#123;<br>        <span class="hljs-comment">// 支付处理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>PaymentService.processPayment</code> 方法使用 <code>PROPAGATION_REQUIRES_NEW</code>。即使 <code>placeOrder</code> 方法回滚，<code>processPayment</code> 方法所做的更改也不会被回滚，因为它们是在一个独立的事务中执行的。</p>
<hr>
<p>示例 3：<code>PROPAGATION_NESTED</code> 用于在现有事务中执行嵌套事务，嵌套事务可以独立回滚。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderService</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">PaymentService</span> paymentService;<br><br>    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">REQUIRED</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">placeOrder</span>(<span class="hljs-params">Order order</span>) &#123;<br>        <span class="hljs-comment">// 保存订单</span><br>        <span class="hljs-title function_">saveOrder</span>(order);<br><br>        <span class="hljs-comment">// 嵌套事务处理支付</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            paymentService.<span class="hljs-title function_">processPayment</span>(order.<span class="hljs-title function_">getPayment</span>());<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-comment">// 处理支付异常</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">saveOrder</span>(<span class="hljs-params">Order order</span>) &#123;<br>        <span class="hljs-comment">// 保存订单逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PaymentService</span> &#123;<br>    <span class="hljs-meta">@Transactional</span>(propagation = <span class="hljs-title class_">Propagation</span>.<span class="hljs-property">NESTED</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">processPayment</span>(<span class="hljs-params">Payment payment</span>) &#123;<br>        <span class="hljs-comment">// 支付处理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在这个示例中，如果 <code>processPayment</code> 方法抛出异常，嵌套事务将回滚，但外部的 <code>placeOrder</code> 事务可以根据需要选择继续或回滚。</p>
<p><code>nested</code> 嵌套的</p>
<h4 id="常见的Spring事务失效场景"><a href="#常见的Spring事务失效场景" class="headerlink" title="常见的Spring事务失效场景"></a>常见的Spring事务失效场景</h4><ul>
<li>@Transactional注解应用于非public方法，事务将不会生效</li>
<li>当一个类的方法调用同一个类中的另一个带有@Transactional注解的方法时，事务将不会生效。<ul>
<li>自调用现象，解决方案是通过<code>self</code>代理调用</li>
</ul>
</li>
<li>事务只会在未被捕获的<code>RuntimeException</code>或<code>Error</code>类型的异常时回滚。如果抛出的是<code>CheckedException</code>，事务不会自动回滚，除非明确指定。</li>
<li>数据库不支持事务</li>
<li>Spring的事务管理依赖于线程绑定。如果在事务中切换线程（例如通过异步调用），事务将失效</li>
<li>错误的事务传播行为配置</li>
</ul>
<p><strong>自调用</strong></p>
<p>当一个类的方法调用同一个类中的另一个带有@Transactional注解的方法时，事务将不会生效。Spring AOP是通过代理实现的，self-invocation绕过了代理对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MyService</span> self;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 方法B的事务将不会生效</span><br>        <span class="hljs-title function_">methodB</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 事务性代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li><code>methodA</code> 的事务会生效，因为它是由外部调用的，Spring 会通过代理对象来处理事务。</li>
<li><code>methodB</code> 的事务不会生效，因为它是通过 <code>this.methodB()</code> 调用的，没有经过 Spring 的代理对象。</li>
</ul>
<p>解决方案是通过<code>self</code>代理调用：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MyService</span> self;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodA</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 方法B的事务将生效</span><br>        self.<span class="hljs-title function_">methodB</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">methodB</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-comment">// 事务性代码</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>异常类型抛出</strong></p>
<p>to be contined….</p>
<h4 id="编程式事务和声明式事务的优缺点"><a href="#编程式事务和声明式事务的优缺点" class="headerlink" title="编程式事务和声明式事务的优缺点"></a>编程式事务和声明式事务的优缺点</h4><h4 id="谈一下对于-AOP-的理解"><a href="#谈一下对于-AOP-的理解" class="headerlink" title="谈一下对于 AOP 的理解"></a>谈一下对于 AOP 的理解</h4><ul>
<li>AOP就是⾯向切⾯编程，跟OOP⾯向过程编程相对，AOP⼀般⽤于将 公共逻辑和业务逻辑进⾏拆分，可以减少代码间的耦合性</li>
<li>AOP的实现⽅式主要有基于CGLIB动态代理和基于JDK动态代理<ul>
<li>基于CGLIB动态代理是<strong>基于⽗⼦类</strong>实现的，主要是通过被代理的 类⽣成⼀个代理⼦类，代理⼦类重写⽗类⽅法，并且将被代理类 赋值给内部属性target，当执⾏完切⾯逻辑后，通过target执⾏被 代理类⽅法</li>
<li>基于JDK动态代理是<strong>基于接⼝</strong>实现的，实现InvocationHandler和 Proxy接⼝就⾏</li>
</ul>
</li>
<li>AOP在我们业务中应⽤场景主要有⽇志处理、限流处理、事务、异 步、缓存等</li>
</ul>
<p><del>Spring AOP默认使用JDK动态代理。如果目标类没有实现任何接口，Spring会自动切换到使用CGLIB代理</del></p>
<p>默认代理方式，参考： <a target="_blank" rel="noopener" href="https://blog.csdn.net/myli92/article/details/127586235">https://blog.csdn.net/myli92/article/details/127586235</a></p>
<p>SpringBoot 2.x 版本默认使用的 AOP 动态代理方式是  CGLIB代理</p>
<h4 id="循环依赖问题如何解决"><a href="#循环依赖问题如何解决" class="headerlink" title="循环依赖问题如何解决"></a>循环依赖问题如何解决</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240315154746.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>循环依赖是多个对象之间存在属性相互依赖的问题，例如 A 类依赖 B 类，而 B 类又依赖 A 类。解决循环依赖的方法包括使用 <code>@Lazy</code> 注解和 Spring 提供的三级缓存机制。</p>
<p>解决循环依赖的方法</p>
<ol>
<li><strong>使用 <code>@Lazy</code> 注解</strong>：解决构造方法造成的循环依赖问题，延迟加载依赖。</li>
<li><strong>使用 Spring 的三级缓存</strong>：<ul>
<li><strong>一级缓存（<code>singletonObjects</code>）</strong>：存放完整生命周期的对象，使用 <code>ConcurrentHashMap</code>。</li>
<li><strong>二级缓存（<code>earlySingletonObjects</code>）</strong>：存放半成品对象，使用 <code>ConcurrentHashMap</code>。</li>
<li><strong>三级缓存（<code>singletonFactories</code>）</strong>：存放 <code>ObjectFactory</code>，用于创建对象的工厂，使用 <code>HashMap</code>。</li>
</ul>
</li>
</ol>
<p>处理普通循环依赖</p>
<ul>
<li>实例化对象放入二级缓存中。</li>
<li>完成生命周期的对象放入一级缓存，其他依赖该对象的对象也能完成生命周期。</li>
</ul>
<p>处理有 AOP 的循环依赖</p>
<ul>
<li>三级缓存保存对象的代理配置信息。</li>
<li>通过 <code>ObjectFactory</code> 创建动态代理类进行 AOP 处理。</li>
<li>一级缓存存放代理对象。</li>
</ul>
<p>核心代码</p>
<p>三级缓存机制的核心代码在 <code>DefaultSingletonBeanRegistry#getSingleton</code> 方法中</p>
<h4 id="Autowire-和-Resource-的区别"><a href="#Autowire-和-Resource-的区别" class="headerlink" title="Autowire 和 Resource 的区别"></a>Autowire 和 Resource 的区别</h4><ul>
<li>@Resouce在没有指定别名的情况下，@Autowired和@Resource都是 先byType再byName </li>
<li>@Resouce在指定别名的情况下是先byName再byType</li>
</ul>
<h4 id="synchronized-关键字和-Transactional-注解-一起使用的话需要注意什么"><a href="#synchronized-关键字和-Transactional-注解-一起使用的话需要注意什么" class="headerlink" title="synchronized 关键字和 @Transactional 注解 一起使用的话需要注意什么"></a><code>synchronized</code> 关键字和 <code>@Transactional</code> 注解 一起使用的话需要注意什么</h4><p><code>synchronized</code> 关键字和 <code>@Transactional</code> 注解可以在同一个方法中使用，但它们的作用和行为是不同的</p>
<ul>
<li>synchronized<ul>
<li>加锁操作，防止资源争抢</li>
<li><strong>线程同步</strong>：<code>synchronized</code> 确保一个方法或代码块在同一时间只能被一个线程执行。它主要解决线程之间的并发问题，防止多个线程同时操作共享资源导致数据不一致。</li>
</ul>
</li>
<li>@Transcational<ul>
<li>确保被注解的方法在一个事务中执行，如果方法抛出一个未被捕获的运行时异常，事务将被回滚</li>
<li><strong>事务管理</strong>：<code>@Transactional</code> 确保方法在一个事务中执行，解决数据库操作的原子性、一致性、隔离性和持久性（ACID）</li>
<li><strong>事务延迟</strong>：使用 <code>synchronized</code> 关键字会导致线程等待，这可能会延长事务的执行时间。如果一个方法被 <code>synchronized</code> 修饰并且同时包含数据库操作，事务可能会因为等待其他线程释放锁而保持更长时间，从而潜在地影响性能。</li>
<li><strong>锁和数据库资源</strong>：长时间持有 <code>synchronized</code> 锁和数据库连接可能导致资源竞争和死锁问题。在设计时需要特别注意这种情况，确保不会长时间持有锁或占用数据库连接</li>
</ul>
</li>
</ul>
<h3 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h3><h4 id="执行流程"><a href="#执行流程" class="headerlink" title="执行流程"></a>执行流程</h4><ul>
<li>前端控制器</li>
<li>处理器映射器</li>
<li>处理器适配器</li>
<li>处理器</li>
<li>视图解析器</li>
<li>视图</li>
</ul>
<p>SpringMVC 的执行流程可以分为两种方式：前后端分离和前后端不分离。</p>
<ul>
<li>前后端不分离的视图阶段（JSP）</li>
</ul>
<ol>
<li><strong>请求接收</strong>: 前端向前端控制器 <code>DispatcherServlet</code> 发起请求。</li>
<li><strong>处理器映射</strong>: <code>DispatcherServlet</code> 收到请求，调用处理器映射器 <code>HandlerMapping</code>，根据 URL 请求映射到具体的某一个 <code>Controller</code> 类。</li>
<li><strong>查找处理器</strong>: <code>HandlerMapping</code> 根据请求 URI 找到具体的处理器，并生成处理器和处理器拦截器（返回处理器执行链 <code>HandlerExecutionChain</code>），然后返回给前端控制器 <code>DispatcherServlet</code>。<ul>
<li>拦截器可以在处理请求之前、之后以及视图渲染之前和之后执行额外的逻辑。</li>
</ul>
</li>
<li><strong>处理请求</strong>: 前端控制器根据处理器执行链向处理器适配器 <code>HandlerAdapter</code> 发起请求，<code>HandlerAdapter</code> 会找到对应的处理器（<code>Handler</code>）并发起请求（调用具体的页面控制器 <code>Controller</code>）。处理器根据请求生成对应的响应并返回到处理器适配器，处理器适配器再返回 <code>ModelAndView</code> 到前端控制器。</li>
<li><strong>视图解析</strong>: 前端控制器根据响应的 <code>ModelAndView</code>，发送到视图解析器 <code>ViewResolver</code>。<code>ViewResolver</code> 会解析并返回对应的 <code>View</code> 实例对象到前端控制器，前端控制器再根据 <code>View</code> 进行渲染视图，从而进行视图展示。</li>
</ol>
<ul>
<li>前后端分离阶段</li>
</ul>
<ol>
<li><strong>请求接收</strong>: 前端控制器 <code>DispatcherServlet</code> 收到前端发起的请求后，会根据请求调用处理器映射器 <code>HandlerMapping</code>。</li>
<li><strong>查找处理器</strong>: <code>HandlerMapping</code> 返回处理器执行链 <code>HandlerExecutionChain</code> 到前端控制器，前端控制器再发送处理器执行链到处理器适配器。</li>
<li><strong>处理请求</strong>: <code>HandlerAdapter</code> 会找到对应的处理器（<code>Handler</code>）并发起请求。通常，<code>Controller</code> 上的方法会添加 <code>@ResponseBody</code> 注解，这样响应结构会转换为 JSON 并返回。</li>
</ol>
<p>核心组件：前端控制器、处理器映射器、处理器、处理器适配器、处理器、视图解析器</p>
<ul>
<li>前端控制器（DispatcherServlet）<ul>
<li>请求首先到达前端控制器 <code>DispatcherServlet</code>。<code>DispatcherServlet</code> 是整个流程的核心，它负责协调请求处理的各个组件</li>
</ul>
</li>
<li>处理器映射器（Handler Mapping）<ul>
<li><code>DispatcherServlet</code> 调用处理器映射器（<code>HandlerMapping</code>）来查找处理该请求的处理器（Controller）。<code>HandlerMapping</code> 根据请求 URL 和配置来确定哪个 Controller 来处理该请求</li>
</ul>
</li>
<li>处理器（Handler &#x2F; Controller）<ul>
<li>找到处理器后，<code>DispatcherServlet</code> 将请求发送到该处理器。处理器通常是一个带有 <code>@Controller</code> 注解的类，并包含处理请求的方法，这些方法上带有 <code>@RequestMapping</code> 注解来映射请求路径</li>
</ul>
</li>
<li>处理器适配器（Handler Adapter）<ul>
<li>为了使处理器独立于具体的实现方式，<code>DispatcherServlet</code> 使用处理器适配器（<code>HandlerAdapter</code>）来调用处理器。<code>HandlerAdapter</code> 负责执行处理器的方法并返回一个 <code>ModelAndView</code> 对象</li>
</ul>
</li>
<li>视图解析器</li>
</ul>
<p>简化版本</p>
<ul>
<li>前端控制器（DispatcherServlet）：接收请求，响应结果，相当于电脑的CPU。</li>
<li>处理器映射器（HandlerMapping）：根据URL去查找处理器。</li>
<li>处理器（Handler）：需要程序员去写代码处理逻辑的。</li>
<li>处理器适配器（HandlerAdapter）：会把处理器包装成适配器，这样就可以支持多种类型的处理器，类比笔记本的适配器（适配器模式的应用）。</li>
<li>视图解析器（ViewResovler）：进行视图解析，多返回的字符串，进行处理，可以解析成对应的页面。</li>
</ul>
<p>视图阶段（JSP)<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202402290943468.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<p>前后端分离阶段（接口开发，异步请求）<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202402290944546.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h4><ul>
<li><strong>@Controller</strong><ul>
<li>用于标识一个类为 SpringMVC 控制器（Controller），用于处理 HTTP 请求。</li>
</ul>
</li>
<li><strong>@RestController</strong><ul>
<li>是 <code>@Controller</code> 和 <code>@ResponseBody</code> 的组合注解。标识一个类为控制器，并且该类中所有方法的返回值都会直接写入 HTTP 响应体</li>
</ul>
</li>
<li><code>@RequestMapping</code><ul>
<li>用于映射请求到控制器类或处理器方法上。可以映射 URL 路径、请求方法、请求参数等</li>
</ul>
</li>
<li><strong>@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, @PatchMapping</strong><ul>
<li>这些注解是 <code>@RequestMapping</code> 的快捷方式，用于简化处理特定 HTTP 请求方法的映射。</li>
</ul>
</li>
<li><strong>@RequestParam</strong><ul>
<li>用于将请求参数绑定到控制器方法的参数上</li>
</ul>
</li>
<li><strong>@PathVariable</strong><ul>
<li>用于将 URL 路径中的变量绑定到控制器方法的参数上。</li>
</ul>
</li>
<li><strong>@RequestBody</strong><ul>
<li>用于将 HTTP 请求体绑定到控制器方法的参数上，常用于处理 JSON 请求</li>
</ul>
</li>
<li><strong>@ResponseBody</strong><ul>
<li>用于将控制器方法的返回值直接写入 HTTP 响应体，而不是解析为视图。</li>
</ul>
</li>
</ul>
<h4 id="过滤器和拦截器"><a href="#过滤器和拦截器" class="headerlink" title="过滤器和拦截器"></a>过滤器和拦截器</h4><ul>
<li><p><strong>过滤器（Filter）</strong>：</p>
<ul>
<li>适用于需要对请求和响应进行全局过滤和处理的场景。</li>
<li>例如：安全检查、日志记录、字符编码设置、跨域处理等。</li>
</ul>
</li>
<li><p><strong>拦截器（Interceptor）</strong>：</p>
<ul>
<li>适用于需要在控制器方法执行前后进行特定处理的场景。</li>
<li>例如：权限验证、事务管理、日志记录、性能监控</li>
</ul>
</li>
</ul>
<h3 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h3><h4 id="动态SQL标签"><a href="#动态SQL标签" class="headerlink" title="动态SQL标签"></a>动态SQL标签</h4><ol>
<li><strong><code>&lt;if&gt;</code></strong> 标签</li>
<li><strong><code>&lt;choose&gt;</code>、<code>&lt;when&gt;</code>、<code>&lt;otherwise&gt;</code></strong> 标签</li>
<li><strong><code>&lt;where&gt;</code></strong> 标签</li>
<li><strong><code>&lt;set&gt;</code></strong> 标签</li>
<li><strong><code>&lt;trim&gt;</code></strong> 标签</li>
<li><strong><code>&lt;foreach&gt;</code></strong> 标签</li>
<li><strong><code>&lt;bind&gt;</code></strong> 标签</li>
</ol>
<h4 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h4><ul>
<li>一级缓存<ul>
<li>sqlsession</li>
</ul>
</li>
<li>二级缓存<ul>
<li>namespace</li>
</ul>
</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240325175422.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="JDBC-的执行流程"><a href="#JDBC-的执行流程" class="headerlink" title="JDBC 的执行流程"></a>JDBC 的执行流程</h4><ul>
<li><ol>
<li>加载数据库驱动</li>
</ol>
</li>
<li><ol start="2">
<li>建立连接</li>
</ol>
</li>
<li><ol start="3">
<li>创建Statement或PreparedStatement</li>
</ol>
</li>
<li><ol start="4">
<li>执行SQL语句</li>
</ol>
</li>
<li><ol start="5">
<li>处理结果</li>
</ol>
</li>
<li><ol start="6">
<li>关闭连接</li>
</ol>
</li>
</ul>
<h4 id="Mapper-常用的标签"><a href="#Mapper-常用的标签" class="headerlink" title="Mapper 常用的标签"></a>Mapper 常用的标签</h4><ul>
<li>基本标签<ul>
<li><code>&lt;configuration&gt;</code></li>
<li><code>&lt;mapper&gt;</code></li>
</ul>
</li>
<li>SQL 操作标签<ul>
<li><code>&lt;select&gt;</code></li>
<li><code>&lt;insert&gt;</code></li>
<li><code>&lt;update&gt;</code></li>
<li><code>&lt;delete&gt;</code></li>
</ul>
</li>
<li>动态 SQL 标签<ul>
<li><code>&lt;if&gt;</code></li>
<li><code>&lt;trim&gt;</code>, <code>&lt;where&gt;</code>, <code>&lt;set&gt;</code></li>
<li><code>&lt;foreach&gt;</code></li>
<li><code>&lt;bind&gt;</code></li>
</ul>
</li>
<li>SQL 片断标签<ul>
<li><code>&lt;sql&gt;</code> 和 <code>&lt;include&gt;</code></li>
</ul>
</li>
<li>ResultMap 标签<ul>
<li><code>&lt;resultMap&gt;</code></li>
</ul>
</li>
</ul>
<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><h4 id="自动配置原理"><a href="#自动配置原理" class="headerlink" title="自动配置原理"></a>自动配置原理</h4><ul>
<li>SpringBootApplication<ul>
<li>SpringBootConfiguration</li>
<li>ComponentScan</li>
<li>EnableAutoConfiguration<ul>
<li>@Import</li>
<li>spring-factries</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240314214559.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h5 id="starter"><a href="#starter" class="headerlink" title="starter"></a>starter</h5><p>在项目的资源目录中创建一个 <code>META-INF/spring.factories</code> 文件，并指定自动配置类。</p>
<h4 id="内置的-Tomcat-替换为其他嵌入式服务器"><a href="#内置的-Tomcat-替换为其他嵌入式服务器" class="headerlink" title="内置的 Tomcat 替换为其他嵌入式服务器"></a>内置的 Tomcat 替换为其他嵌入式服务器</h4><p>在 <code>pom.xml</code> 文件中排除默认的 Tomcat 依赖，并添加所需的嵌入式服务器依赖</p>
<p>示例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Exclude Tomcat --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <br>    <span class="hljs-comment">&lt;!-- Add Jetty --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jetty<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><h4 id="Ribbon"><a href="#Ribbon" class="headerlink" title="Ribbon"></a>Ribbon</h4><h4 id="分布式事务的不同方案"><a href="#分布式事务的不同方案" class="headerlink" title="分布式事务的不同方案"></a>分布式事务的不同方案</h4><h4 id="限流"><a href="#限流" class="headerlink" title="限流"></a>限流</h4><ul>
<li>Nginx<ul>
<li>漏桶算法</li>
</ul>
</li>
<li>Gateway<ul>
<li>令牌桶</li>
</ul>
</li>
</ul>
<h3 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h3><h4 id="RocketMQ-的主要组件-🚩"><a href="#RocketMQ-的主要组件-🚩" class="headerlink" title="RocketMQ 的主要组件   🚩"></a>RocketMQ 的主要组件   🚩</h4><p>待完善一下</p>
<ul>
<li>NameServer<ul>
<li>作为服务注册以及Broker 路由</li>
</ul>
</li>
<li>Broker<ul>
<li>作为消息存储，转发的服务</li>
</ul>
</li>
<li>Producer<ul>
<li>发送消息到 Broker 端</li>
</ul>
</li>
<li>Consumer<ul>
<li>接收 Broker 端推送的消息或主动 从 Broker 端拉取消息</li>
</ul>
</li>
<li>Topic<ul>
<li>RocketMQ 根据主题进行消息分类，生产端发送消息时需要指定主题</li>
</ul>
</li>
<li>MessageQueue<ul>
<li>相当于 Topic 的分区，一个 Topic 默认四个 MessageQueue</li>
</ul>
</li>
</ul>
<h4 id="RocketMQ的推、拉模式，以及广播、集群模式怎么理解的"><a href="#RocketMQ的推、拉模式，以及广播、集群模式怎么理解的" class="headerlink" title="RocketMQ的推、拉模式，以及广播、集群模式怎么理解的"></a>RocketMQ的推、拉模式，以及广播、集群模式怎么理解的</h4><ul>
<li>分配策略<ul>
<li>广播模式和集群模式是可以在消费者端进行设置的</li>
<li>集群模式<ul>
<li>消费者默认开启的是集群模式</li>
<li>集群模式下的消费者会和同一个 Consumer Group 中的其他同样开启了集群模式的消费者（如果有）一起分摊消费消息。如果没有其他消费者在同一个 Consumer Group 中，消费者 A 将独自消费所有消息。</li>
</ul>
</li>
<li>广播模式<ul>
<li>当消费者开启的是广播模式，它会接收所有消息，不管是否有其他消费者存在。</li>
</ul>
</li>
</ul>
</li>
<li>处理方式<ul>
<li>消费者对于消息从 Broker 获取消息的方式：拉模式 vs 推模式</li>
<li>针对推、拉模式，是消费者如何进行处理消息的一种策略，推模式是自动推送，实时消费，拉模式是主动拉取，理解推模式其实也是一种拉模式，只不过开启了定时监听。</li>
<li>推模式在实现上是通过客户端定期向 Broker 拉取消息，然后触发回调函数进行消息处理。换句话说，推模式是一种高频拉取，并在消息到达时立即处理的模式</li>
</ul>
</li>
</ul>
<h4 id="消息队列如何保证消息可靠传输"><a href="#消息队列如何保证消息可靠传输" class="headerlink" title="消息队列如何保证消息可靠传输"></a>消息队列如何保证消息可靠传输</h4><ul>
<li>可靠传输，需要保证的点，避免消息丢失 + 避免消息重复消费</li>
<li>开启消息持久化（避免消息丢失）<ul>
<li>RocketMQ 使用文件存储（CommitLog）来持久化消息<ul>
<li>同步刷盘</li>
<li>异步刷盘</li>
</ul>
</li>
</ul>
</li>
<li>集群模式（提高可靠性，高可用）<ul>
<li>主从复制<ul>
<li>同步复制</li>
<li>异步复制</li>
</ul>
</li>
</ul>
</li>
<li>重试机制（提高可靠性，高可用）<ul>
<li><strong>Producer 端重试</strong>：Producer 在发送消息失败时，自动进行重试</li>
<li><strong>Consumer 端重试</strong>：Consumer 在消费消息失败时，RocketMQ 会将消息重新放回队列，稍后再重试消费。</li>
</ul>
</li>
<li>消息重复消费<ul>
<li>消息幂等性<ul>
<li>消费者应在消费消息时，检查消息是否已被处理。可以使用消息的唯一 ID（例如 Message ID 或自定义业务 ID）来进行去重</li>
</ul>
</li>
</ul>
</li>
<li>监控预警<ul>
<li>通过 <strong>定时任务与监控</strong>，保持对系统状态的实时监控和告警</li>
</ul>
</li>
</ul>
<p>说一下这里的重试机制</p>
<ul>
<li><strong>生产者端重试</strong>：如果消息发送失败，生产者可以配置自动重试，确保消息最终发送成功。</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">#在生产者端设置重试次数</span><br>DefaultMQProducer producer = <span class="hljs-keyword">new</span> <span class="hljs-type">DefaultMQProducer</span>(<span class="hljs-string">&quot;ProducerGroupName&quot;</span>);<br>producer.setRetryTimesWhenSendFailed(<span class="hljs-number">3</span>);<br>producer.start();<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>消费者端重试</strong>：如果消费者处理消息失败，RocketMQ 会将消息重新放回队列，稍后重新投递给消费者。</li>
</ul>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs typescript">consumer.<span class="hljs-title function_">registerMessageListener</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageListenerConcurrently</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ConsumeConcurrentlyStatus</span> <span class="hljs-title function_">consumeMessage</span>(<span class="hljs-params">List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context</span>) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 处理消息</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ConsumeConcurrentlyStatus</span>.<span class="hljs-property">CONSUME_SUCCESS</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-title class_">Exception</span> e) &#123;<br>            <span class="hljs-comment">// 处理异常，返回稍后重新消费状态</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ConsumeConcurrentlyStatus</span>.<span class="hljs-property">RECONSUME_LATER</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>同时需要注意的是：RocketMQ 默认是开启持久化的，默认使用异步刷盘（<code>ASYNC_FLUSH</code>）策略。</p>
<h4 id="RocketMQ-为什么要放弃-Zookeeper"><a href="#RocketMQ-为什么要放弃-Zookeeper" class="headerlink" title="RocketMQ 为什么要放弃 Zookeeper"></a>RocketMQ 为什么要放弃 Zookeeper</h4><ul>
<li>RocketMQ 主要是保障最终一致性，他只需要一个轻量级的元数据服务就行</li>
<li>ZK 是作为强一致性的解决方案，同时减少一个中间件使用可以减少维护成本</li>
</ul>
<h4 id="RocketMQ-的消息模型"><a href="#RocketMQ-的消息模型" class="headerlink" title="RocketMQ 的消息模型"></a>RocketMQ 的消息模型</h4><ul>
<li>顺序消息<ul>
<li>顺序消息只能保证局部消息有序，不能保证全局有序，实现全局 有序 可以 ⽣产端将⼀批消息有序发往MessageQueue，消费端通 过锁队列的⽅式，每次只拿⼀个MessageQueue⾥的消息</li>
</ul>
</li>
<li>广播消息<ul>
<li>⼴播消息并没有特定的消费者，因为这涉及到消费者的集群消费 模式，默认是集群模式</li>
</ul>
</li>
<li>延迟消息<ul>
<li>默认提供了18个延迟级别，延迟消息的难点其实是性能，需要不 断进⾏定时轮询，全部扫描所有消息是不可能的</li>
</ul>
</li>
<li>批量消息<ul>
<li>只能对同⼀topic下的消息进⾏批量发送，不⽀持延迟消息，以及 批量消息的⼤⼩不超过1MB，超过了需要⾃⾏拆分</li>
</ul>
</li>
<li>过滤消息<ul>
<li>消费端可以通过⼀定规则匹配topic下需要的消息，⽀持简单过滤 以及SQL过滤 </li>
<li>消息过滤在消费者端和Broker端都可以做，消费者端进⾏过滤可 以保障消息过滤的可控性，⽽Broker端过滤可以减少不必要数据 的⽹络IO(只把消费者端需要的消息发送出去就⾏)</li>
</ul>
</li>
<li>事务消息<ul>
<li>通过事务消息可以确保上下游的数据⼀致性</li>
<li>实现思路<ul>
<li>⽣产者端将消息发往MQ服务，MQ服务将消息持久化后，向⽣ 产端反馈已收到，此时消息为半消息(半事务消息状态)</li>
<li>⽣产端执⾏完本地事务后，会将执⾏结果向MQ服务进⾏⼆次 确认，判断是否提交或回滚<ul>
<li>如果提交，MQ服务将半消息标记为可投递，然后转发给消 费端</li>
<li>如果回滚，MQ服务会将半消息删除</li>
</ul>
</li>
<li>如果MQ服务没有收到⼆次确认，会对⽣产端进⾏消息回查， 查看事务执⾏结果继续进⾏⼆次确认</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="RocketMQ-分布式原理的理解讲一下"><a href="#RocketMQ-分布式原理的理解讲一下" class="headerlink" title="RocketMQ 分布式原理的理解讲一下"></a>RocketMQ 分布式原理的理解讲一下</h4><ul>
<li>分布式事务 就是在分布式环境下，需要保证不同服务的数据⼀致性</li>
<li>分布式事务的实现⽅式可以基于2PC两阶段提交<ul>
<li>准备阶段，协调者通知参与者准备提交各⾃的事务</li>
<li>提交阶段，参与者反馈，协调者通过反馈去决定执⾏事务提交或 回滚</li>
</ul>
</li>
<li>RocketMQ分布式事务也是基于2PC实现的，实现思路<ul>
<li>⽣产端将消息发往MQ服务，MQ服务将消息持久化后，向⽣产端 反馈已收到，此时消息为半消息</li>
<li>⽣产端执⾏完本地事务后，会将执⾏结果向MQ服务进⾏⼆次确 认，判断是否提交或回滚<ul>
<li>如果提交，MQ服务将半消息标记为可投递，然后转发给消费 端</li>
<li>如果回滚，MQ服务会将半消息删除</li>
</ul>
</li>
<li>如果MQ服务没有收到⼆次确认，会对⽣产端进⾏消息回查，查看 事务执⾏结果继续进⾏⼆次确认</li>
</ul>
</li>
</ul>
<h4 id="RocketMQ-生产端的发送模式了解吗"><a href="#RocketMQ-生产端的发送模式了解吗" class="headerlink" title="RocketMQ 生产端的发送模式了解吗"></a>RocketMQ 生产端的发送模式了解吗</h4><p>一共有三种发送模式</p>
<ul>
<li>同步发送<ul>
<li>必须等到Broker反馈之后才能继续发，安全性最⾼但发消息最 慢</li>
</ul>
</li>
<li>单向发送<ul>
<li>不管消息是否发成功都能继续发，所以吞吐量最⾼，但是安全 性低，容易丢消息</li>
</ul>
</li>
<li>异步发送<ul>
<li>发送消息的同时回注册⼀个回调去处理响应，安全性低，容易 丢消息</li>
</ul>
</li>
</ul>
<h4 id="RocketMQ-消费端的消费模式"><a href="#RocketMQ-消费端的消费模式" class="headerlink" title="RocketMQ 消费端的消费模式"></a>RocketMQ 消费端的消费模式</h4><ul>
<li>推拉模式</li>
<li>推其实也是一种监听方式的拉模式</li>
</ul>
<h4 id="如何防止消息重复消费"><a href="#如何防止消息重复消费" class="headerlink" title="如何防止消息重复消费"></a>如何防止消息重复消费</h4><h4 id="消息堆积问题怎么解决"><a href="#消息堆积问题怎么解决" class="headerlink" title="消息堆积问题怎么解决"></a>消息堆积问题怎么解决</h4><ul>
<li>增加一个中转的消息 topic ，然后配置足够多的 Queue ，增长对应的消费者数量</li>
<li>如果仍然消费不过来，可以建议一个消息重试的表，将消息进行放入到这个处理表，后面定时任务根据状态去跑任务</li>
<li>将生产者限流，服务降级</li>
<li>服务保证幂等的操作</li>
</ul>
<p>消息堆积在消息队列系统中是一个常见问题，不同系统的处理方式和性能影响有所不同。以下是 RocketMQ 处理消息堆积的方法及其具体步骤：</p>
<p>消息堆积对性能的影响</p>
<ul>
<li><strong>Kafka 和 RocketMQ</strong>：消息堆积对性能影响不大。</li>
<li><strong>RabbitMQ</strong>：消息堆积会导致性能直线下降。</li>
</ul>
<p>确定 RocketMQ 消息堆积的方法</p>
<p>可以通过 RocketMQ 控制台查看消息的积压情况，以确定是否存在大量消息堆积。</p>
<p>处理大量积压消息的方法</p>
<ol>
<li>增加消费者</li>
</ol>
<p>通过增加消费者来加快消息的消费速度。</p>
<ul>
<li><p><strong>多个 MessageQueue</strong>：</p>
<ul>
<li>如果 Topic 下的 <code>MessageQueue</code> 数量充足，每个消费者会分配多个 <code>MessageQueue</code> 进行消费。</li>
<li>增加消费者数量可以加快消息的消费速度。</li>
</ul>
</li>
<li><p><strong>消费者数 &#x3D; MessageQueue 数</strong>：</p>
<ul>
<li>如果消费者数量等于 <code>MessageQueue</code> 数量，增加额外的消费者不会提高消费效率。</li>
<li>在这种情况下，可以通过新建一个新的 Topic 并配置足够的 <code>MessageQueue</code>，将旧 Topic 中的消息转移到新 Topic 中，并指定对应数量的消费者去平摊新 Topic 的 <code>MessageQueue</code> 进行消费。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>新建 Topic 进行消息转移</li>
</ol>
<ul>
<li><p><strong>步骤</strong>：</p>
<ol>
<li><strong>创建新 Topic</strong>：创建一个新的 Topic，并配置足够的 <code>MessageQueue</code>。</li>
<li><strong>消息转移</strong>：将旧 Topic 中的消息转移到新 Topic 中。</li>
<li><strong>增加消费者</strong>：为新 Topic 配置对应数量的消费者，以平摊新 Topic 的 <code>MessageQueue</code> 进行消费。</li>
<li><strong>恢复原有情况</strong>：根据情况，处理完堆积消息后可以恢复原有的 Topic 和消费者配置。</li>
</ol>
</li>
<li><p><strong>示例流程</strong>：</p>
<ul>
<li><strong>原始配置</strong>：<code>Topic_A -&gt; Consumer_A</code></li>
<li><strong>消息转移和新增消费者</strong>：<ul>
<li><code>Topic_A -&gt; Consumer_A</code></li>
<li><code>Topic_A -&gt; Consumer_A -&gt; Topic_B -&gt; Consumer_B</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<p>总结</p>
<ol>
<li><strong>监控消息堆积</strong>：通过 RocketMQ 控制台查看消息积压情况。</li>
<li><strong>增加消费者</strong>：通过增加消费者数量加快消息消费速度，前提是 <code>MessageQueue</code> 数量充足。</li>
<li><strong>新建 Topic 转移消息</strong>：在消费者数量等于 <code>MessageQueue</code> 数量时，通过新建 Topic 和增加消费者来处理堆积消息。</li>
</ol>
<h4 id="谈谈对RocketMQ零拷⻉的理解"><a href="#谈谈对RocketMQ零拷⻉的理解" class="headerlink" title="谈谈对RocketMQ零拷⻉的理解"></a>谈谈对RocketMQ零拷⻉的理解</h4><p>零拷贝（Zero Copy）是一种通过避免数据在用户态和内核态之间来回拷贝来提升文件传输速度的技术。其核心思想是减少用户态与内核态之间的拷贝次数，从而提高传输效率。</p>
<p>RocketMQ 主要使用 <code>mmap</code> 技术：</p>
<p>mmap是Linux提供的一种内存映射文件的机制，它实现了将内核中读缓冲区地址与用户空间缓冲区地址进行映射，从而实现内核缓冲区与用户缓冲区的共享。</p>
<p>这样就减少了一次用户态和内核态的CPU拷贝，但是在内核空间内仍然有一次CPU拷贝。</p>
<ul>
<li>**<code>mmap</code>**：<ul>
<li>RocketMQ 在处理消息时采用 <code>mmap</code> 技术。</li>
<li><code>mmap</code> 使得 RocketMQ 能够直接访问文件内容，这不仅提升了消息传输速度，还支持处理消息的顺序和消息过滤功能。</li>
</ul>
</li>
</ul>
<p>方式不止 Mmap 一种</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240529215235.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="RocketMQ如何保证消息有序"><a href="#RocketMQ如何保证消息有序" class="headerlink" title="RocketMQ如何保证消息有序"></a>RocketMQ如何保证消息有序</h4><p>在 RocketMQ 中，消息的有序性分为局部有序和全局有序两种：</p>
<p>局部有序</p>
<ul>
<li><strong>定义</strong>：只保证一部分消息链路的消费有序。</li>
<li><strong>实现</strong>：生产端可以通过消息选择器指定发送到某个特定的 <code>MessageQueue</code>，从而保证这部分消息的消费顺序。</li>
</ul>
<p>全局有序</p>
<ul>
<li><strong>定义</strong>：整个消息链路严格按照先进先出的顺序进行消费。</li>
<li><strong>实现</strong>：为了保证全局有序，需要牺牲吞吐量。即，一个 <code>topic</code> 只能有一个 <code>MessageQueue</code> 被消费（默认是 4 个 <code>MessageQueue</code>）。可以通过锁定队列的方式进行消费，确保消息的全局有序性。</li>
</ul>
<p>总结</p>
<ul>
<li><strong>局部有序</strong>：通过生产端指定 <code>MessageQueue</code> 来保证。</li>
<li><strong>全局有序</strong>：通过限制一个 <code>topic</code> 只能有一个 <code>MessageQueue</code> 被消费来实现，尽管这样会影响系统的吞吐量。</li>
</ul>
<h4 id="RocketMQ-如果客户端发生消息超时的情况该如何排查"><a href="#RocketMQ-如果客户端发生消息超时的情况该如何排查" class="headerlink" title="RocketMQ 如果客户端发生消息超时的情况该如何排查"></a>RocketMQ 如果客户端发生消息超时的情况该如何排查</h4><h3 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h3><h4 id="讲一下RabbitMQ的组成部分"><a href="#讲一下RabbitMQ的组成部分" class="headerlink" title="讲一下RabbitMQ的组成部分"></a>讲一下RabbitMQ的组成部分</h4><p>核心概念</p>
<ul>
<li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。<ul>
<li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li>
<li>Queue：消息队列，存储消息的队列。</li>
</ul>
</li>
<li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li>
<li>Consumer：消息消费者。消费队列中存储的消息。</li>
</ul>
<h4 id="说一下-RabbitMQ-的工作流程"><a href="#说一下-RabbitMQ-的工作流程" class="headerlink" title="说一下 RabbitMQ 的工作流程"></a>说一下 RabbitMQ 的工作流程</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240311230336.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>建立连接</li>
<li>生产者<ul>
<li>声明交换机类型、名称、是否持久化等</li>
<li>发送消息</li>
</ul>
</li>
<li>交换机<ul>
<li>交换机接收消息，进行消息路由</li>
</ul>
</li>
<li>消费者<ul>
<li>订阅消息（监听队列）</li>
<li>接收消息，业务处理</li>
</ul>
</li>
</ul>
<h4 id="讲一下-RabbitMQ-中常用的交换机类型"><a href="#讲一下-RabbitMQ-中常用的交换机类型" class="headerlink" title="讲一下 RabbitMQ 中常用的交换机类型"></a>讲一下 RabbitMQ 中常用的交换机类型</h4><p>（交换机 →  队列）</p>
<ul>
<li>Direct Exchange<ul>
<li><code>binding key</code> 与消息的 <code>routing key</code> 完全匹配队列</li>
</ul>
</li>
<li>Topic Exchange<ul>
<li>模糊匹配</li>
</ul>
</li>
<li>Fanout Exchange<ul>
<li>广播（忽略 <code>routing key</code> ）</li>
</ul>
</li>
<li>Headers Exchange<ul>
<li>不依赖 <code>routing key</code>，头部属性匹配</li>
</ul>
</li>
</ul>
<h4 id="RabbitMQ的死信队列和延迟队列"><a href="#RabbitMQ的死信队列和延迟队列" class="headerlink" title="RabbitMQ的死信队列和延迟队列"></a>RabbitMQ的死信队列和延迟队列</h4><ul>
<li>死信交换机<ul>
<li>死信交换机（Dead-Letter Exchange, DLX）是RabbitMQ中用于处理无法正常投递的消息的一种机制。</li>
<li>当消息在队列中变成死信（Dead Letter）后，可以被自动重新路由到另一个交换机，这个交换机就是所谓的死信交换机。</li>
<li>消息变成死信的情况通常包括：<ul>
<li><ol>
<li>消息被拒绝（Basic.Reject&#x2F;Basic.Nack）并且设置了requeue参数为false，不重新入队。</li>
</ol>
</li>
<li><ol start="2">
<li>消息TTL过期（消息设置了生存时间，超过这个时间还未被消费），超时无人消费</li>
</ol>
</li>
<li><ol start="3">
<li>队列达到最大长度（队列满了，无法再添加更多消息到队列中），最早的消息可能成为死信</li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>延迟队列<ul>
<li>RabbitMQ本身并不直接支持延迟队列，但可以通过以下几种方式间接实现：<ul>
<li>一种方式是：RabbitMQ 的延迟队列通过死信交换机 + TTL （生存时间）来实现的；</li>
<li>还有一种方式是使用 RabbitMQ 的延迟队列相关的一个插件，叫做：DelayExchange，通过这种方式的话只需要在声明交互机的时候，指定这个就是死信交换机，然后在发送消息的时候直接指定超时时间就行。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<p>延迟队列插件使用</p>
<p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240228060325.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="高可用"><a href="#高可用" class="headerlink" title="高可用"></a>高可用</h4><p>一般会使用集群模式，在 RabbitMQ 中，分为了普通集群模式、镜像集群模式、仲裁队列模式</p>
<p>普通集群模式（标准集群）</p>
<ul>
<li>1、在集群的各个节点共享部分数据</li>
<li>2、当访问集群某个节点，如果队列不在该节点，会从数据所在节点传递到当前节点并返回</li>
<li>3、队列所在节点宕机，队列中的消息就会丢失<ul>
<li>这种模式并不能包括高可用</li>
<li>实际上还是为了提高吞吐量的</li>
</ul>
</li>
</ul>
<p>镜像集群：</p>
<ul>
<li>本质上是主从模式<ul>
<li>交换机、队列、队列中的消息会在各个 mq 的镜像节点之间同步备份。</li>
<li>创建队列的节点被称为该队列的<strong>主节点</strong>，备份到的其它节点叫做该队列的镜像节点。</li>
<li>一个队列的主节点可能是另一个队列的镜像节点</li>
<li>所有操作都是主节点完成，然后同步给镜像节点</li>
<li>主宕机后，镜像节点会替代成新的主</li>
</ul>
</li>
</ul>
<p>仲裁队列</p>
<ul>
<li>和镜像模式不同的是，他添加了一个主从基于 Raft 协议的方式，使得消息同步变为了强一致性。</li>
</ul>
<h4 id="如何保证消息不丢失"><a href="#如何保证消息不丢失" class="headerlink" title="如何保证消息不丢失"></a>如何保证消息不丢失</h4><ul>
<li>发送消息过程中不丢失：消息 →  队列；队列本身，队列 →  消费者<ul>
<li>开启生产者确认机制，确保生产者的消息能到达队列</li>
<li>开启持久化功能，确保消息末消费前在队列中不会丢失</li>
<li>开启消费者确认机制为auto,由spring确认消息处理成功后完成ack</li>
<li>开启消费者失数重试机别（重试次数一般设置为3），多次重试失数后将消息投递到异常交换机，交由人工处理</li>
</ul>
</li>
</ul>
<h4 id="消息重复消费问题怎么解决"><a href="#消息重复消费问题怎么解决" class="headerlink" title="消息重复消费问题怎么解决"></a>消息重复消费问题怎么解决</h4><p>出现消息重复消费的问题一般是在网络抖动或者消息者挂掉，由于开启了消费者确认机制，导致消息重发</p>
<p>一般解决方式有两种：</p>
<ul>
<li>一种是每条消息设置一个唯一的标识 ID 从而避免重发消费</li>
<li>也可以考虑幂等性设计问题，考虑使用分布式锁、数据库锁（悲观锁、乐观锁）等，但锁会对性能有影响，使用的时候需要考虑使用</li>
</ul>
<h4 id="消息堆积问题怎么解决-1"><a href="#消息堆积问题怎么解决-1" class="headerlink" title="消息堆积问题怎么解决"></a>消息堆积问题怎么解决</h4><p>RabbitMQ 如果有100万消息堆积在MQ，如何解决？</p>
<p>当生产者发送消息的速度超过了消费者处理消息的速度，就会导致队列中的消息堆积，直到队列存储消息达到上限。之后发送的消息就会成为死信，可能会被丢弃，这就是消息堆积问题。</p>
<p>解决消息堆积有三种种思路：</p>
<ul>
<li>增加更多消费者，提高消费速度</li>
<li>在消费者内开启线程池加快消息处理速度</li>
<li>扩大队列容积，提高堆积上限，采用惰性队列<ul>
<li>在声明队列的时候可以设置属性x-queue-mode为lazy,即为惰性队列</li>
<li>基于磁盘存储，消息上限高</li>
<li>性能比较稳定，但基于磁盘存储，受限于磁盘 IO,时效性会降低</li>
</ul>
</li>
</ul>
<p>惰性队列：惰性队列通过改变消息存储的策略，将消息尽可能地存储在磁盘上，而不是保留在内存中，从而减轻对内存的压力。</p>
<h3 id="系统设计"><a href="#系统设计" class="headerlink" title="系统设计"></a>系统设计</h3><h4 id="中台的概念"><a href="#中台的概念" class="headerlink" title="中台的概念"></a>中台的概念</h4><p>中台是一个平台化、服务化的系统架构层，聚合和沉淀企业内部共用的业务能力和技术服务。中台的目标是通过复用和共享，提高系统的灵活性、可扩展性和响应速度。</p>
<blockquote>
<p>主要功能</p>
</blockquote>
<ol>
<li><strong>业务中台</strong>：提供业务领域的共性能力，如用户管理、订单处理、库存管理等，支持前台业务应用的快速开发和迭代。</li>
<li><strong>数据中台</strong>：聚合和管理企业的数据资源，提供数据分析、数据治理和数据服务等功能。</li>
<li><strong>技术中台</strong>：提供技术基础设施服务，如微服务框架、消息队列、缓存等。</li>
</ol>
<h4 id="分库分表的概念，什么时候适合分库"><a href="#分库分表的概念，什么时候适合分库" class="headerlink" title="分库分表的概念，什么时候适合分库"></a>分库分表的概念，什么时候适合分库</h4><ul>
<li>分表<ul>
<li>主要解决单个表的数据量和查询性能问题，通过增加表的数量来减少单个表的数据量。</li>
</ul>
</li>
<li>分库<ul>
<li>主要解决数据库实例的存储和处理能力瓶颈问题，通过增加数据库实例的数量来提升系统性能。</li>
</ul>
</li>
</ul>
<h3 id="场景题"><a href="#场景题" class="headerlink" title="场景题"></a>场景题</h3><h4 id="后端给前端推送消息有哪几种方式"><a href="#后端给前端推送消息有哪几种方式" class="headerlink" title="后端给前端推送消息有哪几种方式"></a>后端给前端推送消息有哪几种方式</h4><p>一般我们会使用 websockets 的方式</p>
<h4 id="服务迁移如何做到无感知的"><a href="#服务迁移如何做到无感知的" class="headerlink" title="服务迁移如何做到无感知的"></a>服务迁移如何做到无感知的</h4><p>一般是灰度发布或者 AB 发布</p>
<p>滚动发布，蓝绿发布</p>
<h4 id="如何切流"><a href="#如何切流" class="headerlink" title="如何切流"></a>如何切流</h4><ul>
<li>前端<ul>
<li>Nginx</li>
</ul>
</li>
<li>后端<ul>
<li>Nacos，动态配置，轮询，添加对应的服务（对外提高的接口字段对应是相同的）</li>
</ul>
</li>
</ul>
<p>慢切开关</p>
<h4 id="什么是服务网格"><a href="#什么是服务网格" class="headerlink" title="什么是服务网格"></a>什么是服务网格</h4><h4 id="如果你在开发中，一个接口报错，你的排查思路有哪些"><a href="#如果你在开发中，一个接口报错，你的排查思路有哪些" class="headerlink" title="如果你在开发中，一个接口报错，你的排查思路有哪些"></a>如果你在开发中，一个接口报错，你的排查思路有哪些</h4><p>排查接口报错问题需要系统化的思维，从重现问题、查看日志、检查请求和响应、验证代码实现、环境检查、网络问题、数据库操作、安全问题等方面逐一排查。通过这种系统化的排查方法，可以有效定位并解决接口报错问题。</p>
<h4 id="如果一个接口很慢，有什么思路去排查"><a href="#如果一个接口很慢，有什么思路去排查" class="headerlink" title="如果一个接口很慢，有什么思路去排查"></a>如果一个接口很慢，有什么思路去排查</h4><ul>
<li>网络</li>
<li>下游接口响应</li>
<li>SQL 查询性能</li>
</ul>
<h4 id="水平分表的话，如果短时间内有大量数据产生，单表性能仍然不太行，你有什么策略去做。"><a href="#水平分表的话，如果短时间内有大量数据产生，单表性能仍然不太行，你有什么策略去做。" class="headerlink" title="水平分表的话，如果短时间内有大量数据产生，单表性能仍然不太行，你有什么策略去做。"></a>水平分表的话，如果短时间内有大量数据产生，单表性能仍然不太行，你有什么策略去做。</h4><ul>
<li>动态分表<ul>
<li><strong>根据时间或数据量分表</strong><ul>
<li>按时间段分表，例如按天、周、月等。</li>
<li>按数据量分表，例如每当表中的数据达到一定数量时，自动创建新表。</li>
</ul>
</li>
</ul>
</li>
<li>读写分离</li>
</ul>
<h4 id="水平分表后，你们之前的数据是如何清除到新的数据库表"><a href="#水平分表后，你们之前的数据是如何清除到新的数据库表" class="headerlink" title="水平分表后，你们之前的数据是如何清除到新的数据库表"></a>水平分表后，你们之前的数据是如何清除到新的数据库表</h4><ul>
<li>批量查，再通过接口插入</li>
<li>或者先根据条件查询出需要插入的数据，再进行批量查</li>
</ul>
<h4 id="MVC-与-DDD"><a href="#MVC-与-DDD" class="headerlink" title="MVC  与 DDD"></a>MVC  与 DDD</h4><p>MVC</p>
<ul>
<li><strong>模型（Model）</strong>：代表应用程序的数据结构，通常包含数据的处理逻辑。</li>
<li><strong>视图（View）</strong>：展示数据（即模型）的用户界面，不包含业务逻辑。</li>
<li><strong>控制器（Controller）</strong>：接收用户的输入并调用模型和视图来完成用户的请求</li>
</ul>
<p>DDD</p>
<ul>
<li>基于领域模型（Domain Model）</li>
<li>实体（Entity）、值对象（Value Object）、聚合（Aggregate）、领域事件（Domain Event）、领域服务（Domain Service）等</li>
</ul>
<h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/31a84718a5ffd47cc8e2f691ad3bd9e.png" srcset="/img/loading.gif" lazyload alt="31a84718a5ffd47cc8e2f691ad3bd9e.png"></p>
<h4 id="授权认证"><a href="#授权认证" class="headerlink" title="授权认证"></a>授权认证</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240324235306.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="加密算法"><a href="#加密算法" class="headerlink" title="加密算法"></a>加密算法</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240324235131.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="使用账号密码访问流程（JWT-方式）"><a href="#使用账号密码访问流程（JWT-方式）" class="headerlink" title="使用账号密码访问流程（JWT 方式）"></a>使用账号密码访问流程（JWT 方式）</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240330222111.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<ul>
<li>SpringSecurity：matches 方法（提取盐操作，生成哈希值，比较哈希值）</li>
</ul>
<h4 id="会员批量过期方案"><a href="#会员批量过期方案" class="headerlink" title="会员批量过期方案"></a>会员批量过期方案</h4><p>参考： <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1cQ4y1W7Wo">https://www.bilibili.com/video/BV1cQ4y1W7Wo</a></p>
<ul>
<li>场景：如果在会员订阅的情况下，当会员过期的时候向用户进行提醒<ul>
<li>有一张200W数据量的会员表，每个会员会有长短不一的到期时间，现在想在快到期之前发送邮件通知提醒续费，该如何实现？</li>
</ul>
</li>
<li>操作<ul>
<li>1、系统不主动轮询。而是等用户登绿到系统以后,触发一次检查<ul>
<li>判断会员过期时间 &lt; 设定阈值，进行提醒</li>
<li>缺点：不登陆无法提醒</li>
</ul>
</li>
<li>2、使用搜索引擎，将会员 ID  和 过期时间存入</li>
<li>3、使用 Redis 来实现<ul>
<li>设置 redis 的过期时间，使用它的 redis 提醒功能<ul>
<li>修改配置项：notify-keyspace-events  改为notify-keyspace-events “Ex”</li>
<li>会触发一个 key 过期事件</li>
<li>通过在应用程序中监听这个事件进行处理</li>
</ul>
</li>
</ul>
</li>
<li>4、使用 MQ 中的延迟队列<ul>
<li>计算过期时间，发送消息到延迟队列，过期时间过期，消费者进行消费操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="在2G大小的文件中-找出高频-top100的单词"><a href="#在2G大小的文件中-找出高频-top100的单词" class="headerlink" title="在2G大小的文件中 找出高频 top100的单词"></a>在2G大小的文件中 找出高频 top100的单词</h4><ul>
<li>1、把2G的文件进行分割成大小为512KB小文件，总共得到2048个小文件，避兔一次性读入整个文件，造成内存不足</li>
<li>2、定义一个长度为2048的hash表数组，用来统计每个小文件中单词出现的频率</li>
<li>3、使用多线程并行遍历2048个小文件，针对每个单词进行hash取模运算分别存储到长度为2048的hash表数组中 <img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240601084552.png" srcset="/img/loading.gif" lazyload alt="image.png"></li>
<li>4、接着再遍历这2048个hash表，把频率前 100的单词存入小顶堆中</li>
<li>5、小顶堆中最终得到的 100个单词，就是top 100 了</li>
</ul>
<h4 id="对接第三方接口需要考虑什么"><a href="#对接第三方接口需要考虑什么" class="headerlink" title="对接第三方接口需要考虑什么"></a>对接第三方接口需要考虑什么</h4><ul>
<li>1、安全性问题<ul>
<li>通信协议 https</li>
<li>数据安全，认证签名</li>
</ul>
</li>
<li>2、接口的稳定性和可靠性</li>
<li>3、接口释放存在访问限制或者费用</li>
</ul>
<h4 id="表数据量大的时候，影响查询效率的主要原因有哪些"><a href="#表数据量大的时候，影响查询效率的主要原因有哪些" class="headerlink" title="表数据量大的时候，影响查询效率的主要原因有哪些"></a>表数据量大的时候，影响查询效率的主要原因有哪些</h4><ul>
<li>1、磁盘 IO </li>
<li>2、索引失效</li>
<li>3、数据分页</li>
<li>4、锁竞争</li>
<li>5、内存使用</li>
</ul>
<h4 id="数据量达到多少的时候要开始分库分表"><a href="#数据量达到多少的时候要开始分库分表" class="headerlink" title="数据量达到多少的时候要开始分库分表"></a>数据量达到多少的时候要开始分库分表</h4><ul>
<li>结合具体业务场景和系统架构考虑</li>
<li></li>
</ul>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240317102553.png" srcset="/img/loading.gif" lazyload alt="image.png"></p>
<h4 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h4><p>观察者模式允许对象在状态发生变化时通知其他依赖对象</p>
<h4 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h4><p>装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。</p>
<p>重在功能的加强</p>
<h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><ul>
<li>ls：列出所有文件及文件夹。</li>
<li>Pwd：找出当前所在的文件目录。</li>
<li>ps-ef|grep 名称，找出这个应用进程。</li>
<li>rm -rf 递归删除，</li>
<li>cp -rf 递归复制。</li>
<li>Chmod：给文件改权限。</li>
<li>lsof -i:端口号 查看端口是否被占用。</li>
<li>cat 文件名 | grep 关键字，从文件中查找该关键字的记录。</li>
<li>tail -f 文件名查看文件里面的内容，实时打印。</li>
<li>vi：编辑文件</li>
<li>set nu:给文件标识行数。</li>
<li>Linux 创建文件的几种方式：touch 文件名，vi 和 vim，echo</li>
</ul>
<h3 id="回答技巧"><a href="#回答技巧" class="headerlink" title="回答技巧"></a>回答技巧</h3><ul>
<li>1、当时遇到的场景，难点在什么地方，你怎么解决的，相关的技术选型</li>
<li>2、结合项目场景去回答一些问题</li>
</ul>
<h3 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h3><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><p>冒泡排序是一种简单的排序算法。它重复地遍历待排序的序列，一次比较两个元素，如果它们的顺序错误就交换它们。遍历序列的工作重复进行，直到没有需要交换的元素为止。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BubbleSort</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = arr.length;<br>        <span class="hljs-type">boolean</span> swapped;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>            swapped = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n - <span class="hljs-number">1</span> - i; j++) &#123;<br>                <span class="hljs-keyword">if</span> (arr[j] &gt; arr[j + <span class="hljs-number">1</span>]) &#123;<br>                    <span class="hljs-comment">// 交换 arr[j] 和 arr[j+1]</span><br>                    <span class="hljs-type">int</span> temp = arr[j];<br>                    arr[j] = arr[j + <span class="hljs-number">1</span>];<br>                    arr[j + <span class="hljs-number">1</span>] = temp;<br>                    swapped = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 如果没有发生交换，说明数组已经有序</span><br>            <span class="hljs-keyword">if</span> (!swapped) <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>&#125;;<br>        <span class="hljs-built_in">bubbleSort</span>(arr);<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-string">&quot;Sorted array:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            System.out.<span class="hljs-built_in">print</span>(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><p>快速排序是一个高效的排序算法，采用分治法策略。它的基本思想是选择一个“基准”元素，然后将待排序的序列分成两个子序列，一个比基准元素小，一个比基准元素大，然后递归地对这两个子序列进行排序。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickSort</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">quickSort</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-keyword">if</span> (low &lt; high) &#123;<br>            <span class="hljs-comment">// pi 是分割点索引，arr[pi] 已经在正确的位置</span><br>            <span class="hljs-type">int</span> <span class="hljs-variable">pi</span> <span class="hljs-operator">=</span> partition(arr, low, high);<br><br>            <span class="hljs-comment">// 递归地对左右子数组排序</span><br>            quickSort(arr, low, pi - <span class="hljs-number">1</span>);<br>            quickSort(arr, pi + <span class="hljs-number">1</span>, high);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">partition</span><span class="hljs-params">(<span class="hljs-type">int</span>[] arr, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">pivot</span> <span class="hljs-operator">=</span> arr[high];<br>        <span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> (low - <span class="hljs-number">1</span>); <span class="hljs-comment">// 较小元素的索引</span><br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> low; j &lt; high; j++) &#123;<br>            <span class="hljs-comment">// 如果当前元素小于或等于 pivot</span><br>            <span class="hljs-keyword">if</span> (arr[j] &lt;= pivot) &#123;<br>                i++;<br><br>                <span class="hljs-comment">// 交换 arr[i] 和 arr[j]</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i];<br>                arr[i] = arr[j];<br>                arr[j] = temp;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 交换 arr[i+1] 和 arr[high] (或 pivot)</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> arr[i + <span class="hljs-number">1</span>];<br>        arr[i + <span class="hljs-number">1</span>] = arr[high];<br>        arr[high] = temp;<br><br>        <span class="hljs-keyword">return</span> i + <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">int</span>[] arr = &#123;<span class="hljs-number">64</span>, <span class="hljs-number">34</span>, <span class="hljs-number">25</span>, <span class="hljs-number">12</span>, <span class="hljs-number">22</span>, <span class="hljs-number">11</span>, <span class="hljs-number">90</span>&#125;;<br>        quickSort(arr, <span class="hljs-number">0</span>, arr.length - <span class="hljs-number">1</span>);<br>        System.out.println(<span class="hljs-string">&quot;Sorted array:&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : arr) &#123;<br>            System.out.print(num + <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>


<h4 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h4><p>略</p>
<h3 id="编程题"><a href="#编程题" class="headerlink" title="编程题"></a>编程题</h3><h3 id="Hr"><a href="#Hr" class="headerlink" title="Hr"></a>Hr</h3><h4 id="你对我们公司有什么想问的吗"><a href="#你对我们公司有什么想问的吗" class="headerlink" title="你对我们公司有什么想问的吗"></a>你对我们公司有什么想问的吗</h4><p>常规回答：谈公司的历史，产品 </p>
<p>想必，绝大多数的求职者，在面试前会做准备功课。而对公司历史、产品的了解，则是必须掌握的 一项内容。如果你真的不知道该如何回答“你对公司有什么想法”这样的问题的话，不妨先说一说你 了解的公司概况，让面试官知道，你是有备而来，而不是来打酱油的</p>
<h4 id="你有什么优缺点"><a href="#你有什么优缺点" class="headerlink" title="你有什么优缺点"></a>你有什么优缺点</h4><p>优点：对工作认真负责，对自己的代码整洁程度和功能性有要求，测试比较充分，对待工作比较认真；</p>
<p>缺点：有时候会自己会对某个工作想着要做完可能搞的比较晚，自己的作息不是太规律；（尽量说生活的缺点）不太会做饭。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E9%9D%A2%E8%AF%95%E7%85%8E%E7%86%AC%E6%88%90%E8%9B%8B/" class="category-chain-item">面试煎熬成蛋</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>面试煎熬成蛋_面试速刷版_第二版</div>
      <div>https://varcel.luoqi.icu/2024/05/15/面试煎熬成蛋_面试速刷版_第二版/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Luo QI</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年5月15日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <div style="font-size: 0.85rem"> <span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
