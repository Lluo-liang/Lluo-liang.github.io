<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Dubbo基础使用</title>
    <link href="/2024/02/08/Dubbo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/02/08/Dubbo%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://cn.dubbo.apache.org/zh-cn/overview/quickstart/java/brief/">https://cn.dubbo.apache.org/zh-cn/overview/quickstart/java/brief/</a></li></ul><h3 id="一、基本介绍"><a href="#一、基本介绍" class="headerlink" title="一、基本介绍"></a>一、基本介绍</h3><p>基本的一些介绍：</p><p>Apache Dubbo 是一个高性能、轻量级的开源 Java RPC（Remote Procedure Call，远程过程调用）框架。</p><p>它提供了三大核心能力： 面向接口的远程方法调用、智能容错和负载均衡以及服务自动注册和发现。</p><p> 以下是 Dubbo 的基础使用方法，包括服务提供者（Provider）和服务消费者（Consumer）的配置。</p><h4 id="基础使用示例"><a href="#基础使用示例" class="headerlink" title="基础使用示例"></a>基础使用示例</h4><blockquote><ol><li>添加 Dubbo 依赖</li></ol></blockquote><p>首先，需要在项目的 <code>pom.xml</code> 文件中添加 Dubbo 和 Zookeeper 的依赖（Zookeeper 作为服务注册和发现的中间件）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Dubbo --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Zookeeper client --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>服务提供者（Provider）配置</li></ol></blockquote><p>服务提供者需要暴露接口供消费者调用。这通常涉及到定义服务接口和实现该接口的类，然后配置 Dubbo 使其暴露服务。</p><p><strong>定义服务接口</strong>：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>实现服务接口：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">GreetingService</span></span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置服务提供者</strong>：</p><p>可以在 Spring 配置文件中配置 Dubbo 服务提供者，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 提供者的应用信息配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;provider-test&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用 Zookeeper 注册中心暴露服务地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 配置协议 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:protocol</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dubbo&quot;</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;20880&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 暴露服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:service</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;GreetingService&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;greetingServiceImpl&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 定义服务实现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;greetingServiceImpl&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;GreetingServiceImpl&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>服务消费者（Consumer）配置</li></ol></blockquote><p>服务消费者通过 Dubbo 调用远程服务。这涉及到引用远程服务接口并通过 Dubbo 框架进行调用。</p><p><strong>配置服务消费者</strong>：</p><p>同样，在 Spring 配置文件中配置 Dubbo 服务消费者，如下所示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 消费者的应用信息配置 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:application</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;consumer-test&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 使用 Zookeeper 注册中心发现服务地址 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:registry</span> <span class="hljs-attr">address</span>=<span class="hljs-string">&quot;zookeeper://127.0.0.1:2181&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 引用远程服务 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dubbo:reference</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;greetingService&quot;</span> <span class="hljs-attr">interface</span>=<span class="hljs-string">&quot;GreetingService&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>启动和调用</li></ol></blockquote><p>服务提供者启动后，会向 Zookeeper 注册中心注册服务。服务消费者启动时，从 Zookeeper 获取服务提供者的地址，并通过 Dubbo 框架调用远程服务。</p><p><strong>服务消费者调用服务示例</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Consumer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;consumer.xml&quot;</span>);<br>        <span class="hljs-type">GreetingService</span> <span class="hljs-variable">greetingService</span> <span class="hljs-operator">=</span> (GreetingService)context.getBean(<span class="hljs-string">&quot;greetingService&quot;</span>);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">hello</span> <span class="hljs-operator">=</span> greetingService.sayHello(<span class="hljs-string">&quot;Dubbo&quot;</span>);<br>        System.out.println(hello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li>确保 Zookeeper 服务已启动并且配置正确。</li><li>版本兼容性：注意 Dubbo 和 Zookeeper 客户端库的版本兼容性问题。</li><li>Dubbo 配置可以通过 XML 文件、注解或者外部化配置（比如 Spring Boot 的 <code>application.properties</code> 或 <code>application.yml</code> 文件）进行。</li></ul><hr><p>SpringBoot 项目使用示例：</p><p>在 Spring Boot 项目中使用 Dubbo 进行远程服务调用涉及到几个步骤：定义服务接口、创建服务提供者（Provider）、创建服务消费者（Consumer）以及配置 Dubbo 和注册中心（通常使用 Zookeeper）。</p><p>以下是一个具体的示例：</p><blockquote><ol><li>添加依赖</li></ol></blockquote><p>首先，确保在服务提供者和服务消费者的 <code>pom.xml</code> 文件中添加了必要的依赖。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Spring Boot Starter --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Dubbo Spring Boot Starter --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- Zookeeper Starter --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-dependencies-zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>定义服务接口</li></ol></blockquote><p>在一个公共模块中定义服务接口，这样服务提供者和消费者都能访问到它。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">GreetingService</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>创建服务提供者</li></ol></blockquote><p>服务提供者实现了服务接口，并使用 <code>@Service</code> 注解将其注册为 Dubbo 服务。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.apache.dubbo.config.annotation.DubboService;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Value;<br><br><span class="hljs-meta">@DubboService</span>(version = <span class="hljs-string">&quot;1.0.0&quot;</span>, interfaceClass = GreetingService.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">GreetingServiceImpl</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">GreetingService</span></span> </span>&#123;<br>    <span class="hljs-meta">@Value</span>(<span class="hljs-string">&quot;$&#123;dubbo.application.name&#125;&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">String</span> serviceName;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">String</span>.format(<span class="hljs-string">&quot;[%s]: Hello, %s&quot;</span>, serviceName, name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>application.properties</code> 中配置服务提供者的 Dubbo 和 Zookeeper 信息。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Dubbo application name</span><br><span class="hljs-attr">dubbo.application.name</span>=provider-service<br><span class="hljs-comment"># Registry center address</span><br><span class="hljs-attr">dubbo.registry.address</span>=zookeeper://localhost:<span class="hljs-number">2181</span><br><span class="hljs-comment"># Dubbo protocol</span><br><span class="hljs-attr">dubbo.protocol.name</span>=dubbo<br><span class="hljs-attr">dubbo.protocol.port</span>=<span class="hljs-number">20880</span><br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>创建服务消费者</li></ol></blockquote><p>服务消费者使用 <code>@DubboReference</code> 注解来引用远程服务。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.apache.dubbo.config.<span class="hljs-keyword">annotation</span>.DubboReference;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreetingServiceConsumer</span> &#123;<br>    <span class="hljs-meta">@DubboReference(version = <span class="hljs-string">&quot;1.0.0&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> GreetingService greetingService;<br><br>    <span class="hljs-keyword">public</span> String sayHello(String name) &#123;<br>        <span class="hljs-keyword">return</span> greetingService.sayHello(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 <code>application.properties</code> 中配置服务消费者的 Dubbo 和 Zookeeper 信息。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># Dubbo application name</span><br><span class="hljs-attr">dubbo.application.name</span>=consumer-service<br><span class="hljs-comment"># Registry center address</span><br><span class="hljs-attr">dubbo.registry.address</span>=zookeeper://localhost:<span class="hljs-number">2181</span><br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>测试服务调用</li></ol></blockquote><p>最后，在服务消费者项目中，你可以创建一个 REST 控制器或命令行运行器来测试服务调用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">CommandLineRunner</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConsumerApplication</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">CommandLineRunner</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">GreetingServiceConsumer</span> greetingServiceConsumer;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">ConsumerApplication</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">run</span>(<span class="hljs-title class_">String</span>... args) throws <span class="hljs-title class_">Exception</span> &#123;<br>        <span class="hljs-title class_">String</span> hello = greetingServiceConsumer.<span class="hljs-title function_">sayHello</span>(<span class="hljs-string">&quot;Dubbo&quot;</span>);<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">println</span>(hello);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li>确保 Zookeeper 服务已经启动并且监听在正确的端口上。</li><li>服务提供者和消费者都需要在其 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置 Dubbo 和 Zookeeper 的连接信息。</li><li>使用 <code>@DubboService</code> 和 <code>@DubboReference</code> 注解时，确保版本信息一致，以便正确引用服务。</li></ul><hr><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅-二周目</title>
    <link href="/2024/02/01/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85-%E4%BA%8C%E5%91%A8%E7%9B%AE/"/>
    <url>/2024/02/01/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85-%E4%BA%8C%E5%91%A8%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p>面试题自测题</p><ul><li><a href="/2023/12/30/%E8%87%AA%E6%B5%8B%E9%A2%98_Java%E5%9F%BA%E7%A1%80/" title="面试题_Java基础">面试题_Java基础</a></li><li><a href="/2023/12/30/%E8%87%AA%E6%B5%8B%E9%A2%98_Java%E9%9B%86%E5%90%88/" title="面试题_Java集合">面试题_Java集合</a></li><li><a href="/2024/01/02/%E8%87%AA%E6%B5%8B%E9%A2%98_Java%E5%B9%B6%E5%8F%91/" title="面试题_Java并发">面试题_Java并发</a></li><li><a href="/2024/01/02/%E8%87%AA%E6%B5%8B%E9%A2%98_JVM/" title="面试题_JVM">面试题_JVM</a></li><li><a href="/2024/01/16/%E8%87%AA%E6%B5%8B%E9%A2%98_MySQL/" title="面试题_MySQL">面试题_MySQL</a></li><li><a href="/2024/01/02/%E8%87%AA%E6%B5%8B%E9%A2%98_Redis/" title="面试题_Redis">面试题_Redis</a></li><li><a href="/2024/01/17/%E8%87%AA%E6%B5%8B%E9%A2%98_MQ/" title="面试题_MQ">面试题_MQ</a></li><li><a href="/2024/01/31/%E8%87%AA%E6%B5%8B%E9%A2%98_RibbitMQ/" title="自测题_RibbitMQ">自测题_RibbitMQ</a></li><li><a href="/2024/01/25/%E8%87%AA%E6%B5%8B%E9%A2%98_RocketMQ/" title="面试题_RocketMQ">面试题_RocketMQ</a></li></ul><p>框架&#x2F;组件面试题自测题</p><ul><li><a href="/2024/01/18/%E8%87%AA%E6%B5%8B%E9%A2%98_Spring/" title="面试题_Spring">面试题_Spring</a></li><li><a href="/2024/01/18/%E8%87%AA%E6%B5%8B%E9%A2%98_Mybatis/" title="面试题_Mybatis">面试题_Mybatis</a></li><li><a href="/2024/01/18/%E8%87%AA%E6%B5%8B%E9%A2%98_SpringBoot/" title="面试题_SpringBoot">面试题_SpringBoot</a></li><li><a href="/2024/01/18/%E8%87%AA%E6%B5%8B%E9%A2%98_SpringCloud/" title="面试题_SpringCloud">面试题_SpringCloud</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_数据库索引</title>
    <link href="/2024/01/29/MySQL%E5%AD%A6%E4%B9%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/01/29/MySQL%E5%AD%A6%E4%B9%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<p>MySQL 相关的数据库索引这一部分内容单独提出来，然后整理一下相关内容。</p><p>参考：</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-index.html">https://javaguide.cn/database/mysql/mysql-index.html</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/wghadf">https://www.yuque.com/snailclimb/mf2z3k/wghadf</a></li></ul><blockquote><p>大纲</p></blockquote><ul><li>底层数据结构选型</li><li>索引为什么使用 B+ 树</li><li>常用的索引类型有哪些</li><li>覆盖索引和联合索引</li><li>最左前缀匹配原则</li><li>索引下推</li><li>正确使用索引的一些建议</li></ul><h3 id="1、底层数据结构选型"><a href="#1、底层数据结构选型" class="headerlink" title="1、底层数据结构选型"></a>1、底层数据结构选型</h3><p>可以看一下这个： <a href="https://javaguide.cn/database/mysql/mysql-index.html#%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%80%89%E5%9E%8B">MySQL索引详解 | JavaGuide</a></p><p>索引的数据结构选型一般选择方向有： Hash 表、二叉查找树（BST)、AVL 树、红黑树、B 树 &amp; B+ 树 。</p><p>考虑到一些原因，最终 MySQL 的索引选用的数据结构是 B+ 树。</p><blockquote><p>Hash 表</p></blockquote><p>如果采用 Hash 表作为底层数据结构的话，优点是能够快速检索（哈希表能够通过键值对快速定位数据，检索效率接近 O(1)）；但缺点也比较明显，</p><ul><li>一个是哈希冲突<ul><li>不同的键可能会产生相同的哈希值，导致冲突；虽然链地址法等技术可以解决，但会增加复杂度；</li></ul></li><li>还有一个比较重要的是它不支持顺序和范围查询<ul><li>Hash 索引是根据 hash 算法来定位的（基于哈希值而非实际数据顺序）；因此它不适用于那些依赖于数据顺序的操作，如排序；同样因为这个原因 Hash 索引 无法快速定位到特定范围的数据</li></ul></li></ul><hr><blockquote><p>二叉查找树 BST</p></blockquote><p>最坏情况（退化斜树）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291002721.png" alt="image.png"></p><blockquote><p>AVL 树</p></blockquote><p>AVL 树是计算机科学中最早被发明的<strong>自平衡二叉查找树</strong>，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p><p>他有一个比较明显的缺点：由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。</p><blockquote><p>红黑树</p></blockquote><p><strong>红黑树的应用是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异</strong></p><p>但因为树太高，不太适合在磁盘中使用</p><blockquote><p>B 树 &amp; B+ 树</p></blockquote><p>？？？</p><p>参考：</p><ul><li><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></li><li><a href="https://oi-wiki.org/ds/bplus-tree/">https://oi-wiki.org/ds/bplus-tree/</a></li><li><a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ</a></li></ul><p>B+Tree 是一种多叉树，叶子节点才存放数据，非叶子节点只存放索引，而且每个节点里的数据是<strong>按主键值（id）顺序存放</strong>的，每一层父节点的索引值都会出现在下层子节点的索引值中，因此在叶子节点中，包括了所有的索引值信息，并且每一个叶子节点都指向下一个叶子节点，形成一个链表，便于范围查询。</p><p>示例：</p><p>假设有一张商品表，表里有这些数据</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291358064.png" alt="image.png"></p><p>聚簇索引的 B+Tree 如图所示：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291359520.png" alt="image.png"></p><p>假设，执行了  <code>select * from t_product where id = 5</code> 查询语句，该查询语句的条件是找到 id（主键）为 5 的这条记录。因为 B+Tree 是一个<strong>有序</strong>的数据结构，所以可以通过二分查找算法快速定位到这条记录，这也就是我们常说的索引查询，具体过程如下：</p><ul><li>从根节点开始，将 5 与根节点的索引数据 (1，10，20) 比较，5 在 1 和 10 之间，根据二分查找算法，找到第二层的索引数据 (1，4，7)；</li><li>在第二层的索引数据 (1，4，7)中进行查找，因为 5 在 4 和 7 之间，根据二分查找算法，找到第三层的索引数据（4，5，6）；</li><li>在叶子节点的索引数据（4，5，6）中进行查找，然后我们找到了索引值为 5 的这条记录。</li></ul><p><strong>二级索引的叶子节点存放的是主键值，不是实际数据</strong></p><h3 id="2、索引为什么使用-B-树"><a href="#2、索引为什么使用-B-树" class="headerlink" title="2、索引为什么使用 B+ 树"></a>2、索引为什么使用 B+ 树</h3><p>在实际使用中，找到一个平衡点，索引使用 B+ 树能够减少 IO 次数，查询范围更加高效。</p><p>![[MySQL学习_基础内容02#索引(B+树)]]</p><h3 id="3、常用的索引类型有哪些"><a href="#3、常用的索引类型有哪些" class="headerlink" title="3、常用的索引类型有哪些"></a>3、常用的索引类型有哪些</h3><p>按照数据结构维度划分：</p><ul><li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>哈希索引：类似键值对的形式，一次即可定位。</li><li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>按照底层存储方式角度划分：</p><ul><li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p>按照应用维度划分：</p><ul><li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>普通索引：仅加速查询。</li><li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><p>MySQL 8.x 中实现的索引新特性：</p><ul><li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式</li></ul><h4 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引  Primary Key"></a>主键索引  Primary Key</h4><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><ul><li>检查唯一非空索引<ul><li>InnoDB首先检查表中是否存在唯一索引且该索引的所有列都不允许为null。如果找到这样的索引，InnoDB会将其作为主键。</li></ul></li><li>自动创建隐藏的自增主键<ul><li>如果上述条件不满足，即表中没有合适的唯一非空索引，InnoDB会自动创建一个隐藏的、自增的、6字节大小的主键。</li><li>这个隐藏的主键对用户是不可见的，但在InnoDB内部用于唯一地标识每一行。</li><li>这个主键是自增的，意味着每插入一行新数据，主键的值都会自动增加。</li></ul></li></ul><h4 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h4><p>二级索引的作用就是通过索引快速找到主键索引（定位主键的位置）</p><p>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><ul><li><strong>唯一索引(Unique Key)</strong>:唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li><strong>普通索引(Index)</strong>:普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</li><li><strong>前缀索引(Prefix)</strong>:前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，<br>  因为只取前几个字符。</li><li><strong>全文索引(Full Text)</strong>:全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li></ul><hr><h4 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h4><h5 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h5><p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h5 id="非聚簇索引（非聚集索引）"><a href="#非聚簇索引（非聚集索引）" class="headerlink" title="非聚簇索引（非聚集索引）"></a>非聚簇索引（非聚集索引）</h5><p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><hr><p>聚簇索引与非聚簇索引</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291152682.png" alt="image.png"></p><blockquote><p>面试题: 非聚簇索引一定回表查询吗(覆盖索引) ？</p></blockquote><p>在MySQL中，使用非聚簇索引（也称为二级索引或辅助索引）时，并不一定总是需要进行回表查询。是否需要回表查询取决于查询是否为覆盖索引查询。</p><p><strong>回表查询</strong>:</p><ul><li>当一个查询使用了非聚簇索引但是需要获取的数据不完全在索引中时，就会发生回表查询。</li><li>在这种情况下，数据库首先使用非聚簇索引找到对应的主键，然后再使用这个主键去聚簇索引（即数据表）中检索完整的行数据。</li></ul><p><strong>覆盖索引（Covering Index）</strong>:</p><ul><li>如果查询所需的所有数据都包含在非聚簇索引中，这种情况称为覆盖索引。</li><li>当发生覆盖索引查询时，不需要进行回表查询，因为索引已经包含了所有需要的信息。</li><li>覆盖索引可以显著提高查询效率，因为它避免了额外的I&#x2F;O操作去读取数据表。</li></ul><p>例如，如果你有一个包含<code>id</code>（主键），<code>name</code>，和<code>age</code>列的表，且对<code>name</code>列有一个非聚簇索引。<br>如果你的查询只是检索<code>name</code>列（比如<code>SELECT name FROM table WHERE name = &#39;Alice&#39;</code>），那么这个查询就是一个覆盖索引查询，不需要回表查询。但是如果你需要检索<code>age</code>列的信息（如<code>SELECT age FROM table WHERE name = &#39;Alice&#39;</code>），就需要回表查询了。</p><h3 id="4、覆盖索引和联合索引"><a href="#4、覆盖索引和联合索引" class="headerlink" title="4、覆盖索引和联合索引"></a>4、覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `cus_order` <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">INDEX</span> id_score_name(score, <span class="hljs-type">name</span>);<br></code></pre></td></tr></table></figure><p><strong>联合索引的 B+Tree 是先按 score 进行排序，然后再 score 相同的情况再按 name 字段排序。</strong></p><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，</p><ul><li>在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，<ul><li>如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成， </li><li>或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code><strong>、</strong><code>&lt;</code></strong> ）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。</li></ul></li><li>所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据</li></ul><blockquote><p><strong>联合索引的最左匹配原则，在遇到范围查询（如 &gt;、&lt; ）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段后面的字段无法用到联合索引。但是，对于 &gt;&#x3D;、&lt;&#x3D;、BETWEEN、like 前缀匹配这四种范围查询，并不会停止匹配</strong></p></blockquote><hr><p>复习看一下这篇文章： <a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ</a></p><p>看一下这个例子：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-comment">-- 示例: 创建一个包含联合索引的表</span><br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> example_table (<br>    col1 <span class="hljs-type">INT</span>,<br>    col2 <span class="hljs-type">INT</span>,<br>    col3 <span class="hljs-type">INT</span>,<br>    <span class="hljs-keyword">INDEX</span> idx_col1_col2_col3 (col1, col2, col3)<br>);<br></code></pre></td></tr></table></figure><p>只有在 col1 相同的情况才，col2 才是有序的</p><p>联合索引的最左匹配原则会一直向右匹配直到遇到「范围查询」就会停止匹配。</p><blockquote><p>Q1: select * from t_table where a &gt; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 a &gt; 1 条件的二级索引记录肯定是相邻的，于是在进行索引扫描的时候，可以定位到符合 a &gt; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a &gt; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p><p><strong>但是在符合 a &gt; 1 条件的二级索引记录的范围里，b 字段的值是无序的</strong>。</p><p>联合索引的最左匹配原则在遇到 a 字段的范围查询（ &gt;）后就停止匹配了，因此 b 字段并没有使用到联合索引。</p><blockquote><p>Q2: select * from t_table where a &gt;&#x3D; 1 and b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引（二级索引）是先按照 a 字段的值排序的，所以符合 &gt;&#x3D; 1 条件的二级索引记录肯定是相邻，于是在进行索引扫描的时候，可以定位到符合 &gt;&#x3D; 1 条件的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录不符合 a&gt;&#x3D; 1 条件位置。所以 a 字段可以在联合索引的 B+Tree 中进行索引查询。</p><p>虽然在符合 a&gt;&#x3D; 1 条件的二级索引记录的范围里，b 字段的值是「无序」的，<strong>但是对于符合 a &#x3D; 1 的二级索引记录的范围里，b 字段的值是「有序」的</strong>（因为对于联合索引，是先按照 a 字段的值排序，然后在 a 字段的值相同的情况下，再按照 b 字段的值进行排序）。</p><p>于是，在确定需要扫描的二级索引的范围时，当二级索引记录的 a 字段值为 1 时，可以通过 b &#x3D; 2 条件减少需要扫描的二级索引记录范围（b 字段可以利用联合索引进行索引查询的意思）。也就是说，从符合 a &#x3D; 1 and b &#x3D; 2 条件的第一条记录开始扫描，而不需要从第一个 a 字段值为 1 的记录开始扫描。</p><p>所以，<strong>Q2 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><blockquote><p>Q3: SELECT * FROM t_table WHERE a BETWEEN 2 AND 8 AND b &#x3D; 2，联合索引（a, b）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>Q3 查询条件中 a BETWEEN 2 AND 8 的意思是查询 a 字段的值在 2 和 8 之间的记录。</p><p>不同的数据库对 BETWEEN … AND 处理方式是有差异的。在 MySQL 中，BETWEEN 包含了 value1 和 value2 边界值，类似于 &gt;&#x3D; and &#x3D;&lt;。而有的数据库则不包含 value1 和 value2 边界值（类似于 &gt; and &lt;）。</p><p>这里我们只讨论 MySQL。由于 MySQL 的 BETWEEN 包含 value1 和 value2 边界值，</p><p>所以类似于 Q2 查询语句，因此 <strong>Q3 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><blockquote><p>Q4: SELECT * FROM t_user WHERE name like ‘j%’ and age &#x3D; 22，联合索引（name, age）哪一个字段用到了联合索引的 B+Tree？</p></blockquote><p>由于联合索引（二级索引）是先按照 name 字段的值排序的，所以前缀为 ‘j’ 的 name 字段的二级索引记录都是相邻的， 于是在进行索引扫描的时候，可以定位到符合前缀为 ‘j’ 的 name 字段的第一条记录，然后沿着记录所在的链表向后扫描，直到某条记录的 name 前缀不为 ‘j’ 为止。</p><p>所以 a 字段可以在联合索引的 B+Tree 中进行索引查询，形成的扫描区间是<code>[&#39;j&#39;,&#39;k&#39;)</code>。注意， j 是闭区间。</p><p>所以，<strong>Q4 这条查询语句 a 和 b 字段都用到了联合索引进行索引查询</strong>。</p><h3 id="5、索引下推"><a href="#5、索引下推" class="headerlink" title="5、索引下推"></a>5、索引下推</h3><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><ol><li><strong>没有索引下推的情况</strong>:<ul><li>在传统的索引使用中，数据库首先使用索引来找到符合索引部分条件的记录。然后，对于每个找到的索引条目，数据库都会进行“回表”操作，即访问主数据表来获取完整的行数据。</li><li>一旦获取了完整的行数据，数据库才能对WHERE子句中的其他条件进行评估。这意味着即使某些行最终不满足所有查询条件，它们仍然会被从磁盘加载到内存中，导致不必要的I&#x2F;O开销。</li></ul></li><li><strong>有索引下推的情况</strong>:<ul><li>使用索引下推时，数据库在索引遍历过程中就可以对索引中包含的字段进行更多的判断。这意味着，如果一个索引包含了多个列，数据库可以在访问主数据表之前，利用索引中的这些列来过滤掉更多不符合条件的记录。</li><li>例如，如果有一个索引是在<code>first_name</code>和<code>age</code>两个字段上，当查询条件是<code>first_name = &#39;Alice&#39; AND age &gt; 25</code>时，数据库可以在索引层面就利用这两个条件进行筛选，而不仅仅是<code>first_name</code>字段。这减少了回表的次数，因为只有同时满足这两个条件的记录才会被实际加载全行数据进行进一步处理。</li></ul></li></ol><p>看上面这个对比区别，感觉是在使用 <code>&gt;</code>  这种范围查询进行了优化。</p><hr><h3 id="6、正确使用索引的一些建议"><a href="#6、正确使用索引的一些建议" class="headerlink" title="6、正确使用索引的一些建议"></a>6、正确使用索引的一些建议</h3><ul><li>选择合适的字段创建索引</li><li>被频繁更新的字段应该慎重建立索引</li><li>限制每张表上的索引数量（建议单张表索引不超过 5 个）</li><li>尽可能的考虑建立联合索引而不是单列索引</li><li>注意避免冗余索引</li><li>字符串类型的字段使用前缀索引代替普通索引</li><li>避免索引失效</li><li>删除长期未使用的索引</li><li>知道如何分析语句是否走索引查询 EXPLAIN</li><li>…</li></ul><blockquote><p>避免索引失效</p></blockquote><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li><code>SELECT *</code> 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;</li><li>创建了组合索引，但查询条件未准守最左匹配原则;</li><li>在索引列上进行计算、函数、类型转换等操作;</li><li>以 % 开头的 LIKE 查询比如 <code>LIKE &#39;%abc&#39;;</code>;</li><li>查询条件中使用 OR，且 OR 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>IN 的取值范围较大时会导致索引失效，走全表扫描(NOT IN 和 IN 的失效场景相同);</li><li>发生隐式转换</li><li>……</li></ul><p>索引失效场景参考： <a href="https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg">https://mp.weixin.qq.com/s/mwME3qukHBFul57WQLkOYg</a></p><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSL证书安装</title>
    <link href="/2024/01/27/SSL%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85/"/>
    <url>/2024/01/27/SSL%E8%AF%81%E4%B9%A6%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、创建证书"><a href="#1、创建证书" class="headerlink" title="1、创建证书"></a>1、<strong>创建证书</strong></h3><p>SSL 免费的证书，在各个云服务厂商都有提供，可以自己申请。这里以阿里云举例；</p><p>阿里云免费域名证书： <a href="https://yundun.console.aliyun.com/?p=cas#/certExtend/free/cn-hangzhou">https://yundun.console.aliyun.com/?p=cas#/certExtend/free/cn-hangzhou</a></p><ol><li>步骤1；通过免费的方式创建 SSL，之后通过引导的 DNS 方式进行验证。其实就是在你的域名里配置下验证信息。</li><li>步骤2；申请后，3-5分钟左右 DNS 会验证通过，这个时候你直接下载 Nginx 的 SSL 包即可。里面有2个文件【x.key、x.pem】</li></ol><p>SSL证书下发后 ;下载文件完成，在对应的 _ dnsauth主机记录是可以删除(域名解析)</p><p>具体操作看阿里云申请SSL 证书操作文档</p><p>申请完成后,选择对应的服务器进行下载:  Nginx</p><ol><li>把下载好的 SSL 文件解压，你会得到一个文件夹，里面含有 x.key、x.pem 两个文件。</li><li>创建一个 default.conf 这个文件配置的 SSL 信息</li></ol><p>看一下这个操作文档:  <a href="https://help.aliyun.com/zh/ssl-certificate/user-guide/install-ssl-certificates-on-nginx-servers-or-tengine-servers">https://help.aliyun.com/zh/ssl-certificate/user-guide/install-ssl-certificates-on-nginx-servers-or-tengine-servers</a></p><ul><li><ol><li>直接修改 nginx.conf 的文件内容</li></ol></li><li><ol start="2"><li>修改  conf.d 文件夹 下的 defalut.conf 文件</li></ol></li></ul><p>参考文档是第一种,这里演示第二种方式</p><p>之所以第二种方式能生效,是因为在 nginx.conf 的配置文件有这么一句；</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">include</span> <span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d/</span>*.conf; <br></code></pre></td></tr></table></figure><p>那么只要是 conf.d 文件夹下的文件都会被加载。所以直接在 conf.d&#x2F;default.conf 配置 SSL 就会被加载。</p><h4 id="单个证书"><a href="#单个证书" class="headerlink" title="单个证书"></a>单个证书</h4><p>复制conf.d 文件夹 下的 defalut.conf 文件 到本地,进行修改</p><p>注意修改域名和SSL文件路径。</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>  [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  openai.xfg.im;<br><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br><br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span>  openai.xfg.im;<br><br>    <span class="hljs-attribute">ssl_certificate</span>      /etc/nginx/ssl/9740289_openai.xfg.im.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>  /etc/nginx/ssl/9740289_openai.xfg.im.key;<br><br>    <span class="hljs-attribute">ssl_session_cache</span>    shared:SSL:<span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;<br><br>    <span class="hljs-attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>  <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP         <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   Host              <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For   <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意一下这个路径 &#x2F;etc&#x2F;nginx&#x2F;ssl&#x2F;  是容器内的路径; 不是挂载路径.</p><h4 id="多个证书"><a href="#多个证书" class="headerlink" title="多个证书"></a>多个证书</h4><p>如果是多个证书</p><p>如果你需要给1个以上的域名配置SSL，那么可以配置多组 server 如下；</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>  [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  itedus.cn;<br><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br><br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span>  itedus.cn;<br><br>    <span class="hljs-attribute">ssl_certificate</span>      /etc/nginx/ssl/9750021_itedus.cn.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>  /etc/nginx/ssl/9750021_itedus.cn.key;<br><br>    <span class="hljs-attribute">ssl_session_cache</span>    shared:SSL:<span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;<br><br>    <span class="hljs-attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>  <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Real-IP         <span class="hljs-variable">$remote_addr</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   Host              <span class="hljs-variable">$http_host</span>;<br>        <span class="hljs-attribute">proxy_set_header</span>   X-Forwarded-For   <span class="hljs-variable">$proxy_add_x_forwarded_for</span>;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">listen</span>  [::]:<span class="hljs-number">80</span>;<br>    <span class="hljs-attribute">server_name</span>  chatgpt.itedus.cn;<br><br>    <span class="hljs-attribute">rewrite</span><span class="hljs-regexp"> ^(.*)</span> https://<span class="hljs-variable">$server_name</span><span class="hljs-variable">$1</span> <span class="hljs-literal">permanent</span>;<br><br>&#125;<br><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">443</span> ssl;<br>    <span class="hljs-attribute">server_name</span>  chatgpt.itedus.cn;<br><br>    <span class="hljs-attribute">ssl_certificate</span>      /etc/nginx/ssl/9749920_chatgpt.itedus.cn.pem;<br>    <span class="hljs-attribute">ssl_certificate_key</span>  /etc/nginx/ssl/9749920_chatgpt.itedus.cn.key;<br><br>    <span class="hljs-attribute">ssl_session_cache</span>    shared:SSL:<span class="hljs-number">1m</span>;<br>    <span class="hljs-attribute">ssl_session_timeout</span>  <span class="hljs-number">5m</span>;<br><br>    <span class="hljs-attribute">ssl_ciphers</span>  HIGH:!aNULL:!MD5;<br>    <span class="hljs-attribute">ssl_prefer_server_ciphers</span>  <span class="hljs-literal">on</span>;<br><br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span> http://180.76.119.100:3002;<br>        <span class="hljs-attribute">proxy_http_version</span> <span class="hljs-number">1</span>.<span class="hljs-number">1</span>;<br>        <span class="hljs-attribute">chunked_transfer_encoding</span> <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_buffering</span> <span class="hljs-literal">off</span>;<br>        <span class="hljs-attribute">proxy_cache</span> <span class="hljs-literal">off</span>;<br>    &#125;<br><br>    <span class="hljs-attribute">error_page</span>   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /50x.html;<br>    <span class="hljs-section">location</span> = /50x.html &#123;<br>        <span class="hljs-attribute">root</span>   /usr/share/nginx/html;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="重启操作"><a href="#重启操作" class="headerlink" title="重启操作"></a>重启操作</h4><p>一种方式是重启 Nginx 服务<code>nginx -s reload</code> (但是在 Docket 中应该不行,需要删除后重启)</p><p>删除 Nginx 后进行重新安装(多了一个 443 的映射端口)</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino">docker stop nginx<br><br>docker rm nginx<br></code></pre></td></tr></table></figure><p>或者在 Portainer 中操作 ↑</p><p>启动命令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs groovy">docker run \<br>-p <span class="hljs-number">443</span>:<span class="hljs-number">443</span> -p <span class="hljs-number">9002</span>:<span class="hljs-number">80</span> \<br>--name nginx \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.<span class="hljs-attr">conf:</span><span class="hljs-regexp">/etc/</span>nginx/nginx.conf \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>conf.<span class="hljs-attr">d:</span><span class="hljs-regexp">/etc/</span>nginx/conf.d \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/log:/</span><span class="hljs-keyword">var</span><span class="hljs-regexp">/log/</span>nginx \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/ssl:/</span>etc<span class="hljs-regexp">/nginx/</span>ssl \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/html:/</span>usr<span class="hljs-regexp">/share/</span>nginx/html \<br>-d <span class="hljs-attr">nginx:</span>latest<br></code></pre></td></tr></table></figure><p>由于实际访问的时候显示无法访问(需要工信部备案); 这里暂时没看到所谓的 https 证书安全访问</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240128115823.png" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>web</tag>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM入门_基础概念</title>
    <link href="/2024/01/23/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2024/01/23/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>Java Virtual Machine</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401231557879.png" alt="image.png"></p><h3 id="1、什么是-JVM"><a href="#1、什么是-JVM" class="headerlink" title="1、什么是 JVM"></a>1、什么是 JVM</h3><p>JVM 全称是 Java Virtual Machine，中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。</p><p>JVM 充当着一个翻译官的角色，能够将我们编写出的Java程序，翻译给系统“听”，告诉它我们的程序需要做什么操作。</p><p>Java的代码需要经过编译器，生成.Class文件后，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。</p><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机，这里也是以 HotSpot 虚拟机展开，对JVM 基础概念进行阐述。</p><h3 id="2、类加载机制"><a href="#2、类加载机制" class="headerlink" title="2、类加载机制"></a>2、类加载机制</h3><p>上文提到，Java的代码经过编译器，生成.Class文件后，JVM才能识别并运行。</p><blockquote><p>类加载过程</p></blockquote><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>整个类加载的过程中，包括<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p><p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。</p><p>另外注意<strong>这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>类的加载: 查找并加载类的二进制数据</li><li>连接<ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</li><li>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li>卸载： 结束生命周期</li></ul><blockquote><p>类加载的层次</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116234810.png" alt="image.png"></p><ul><li><strong>启动类加载器</strong>: Bootstrap ClassLoader，<ul><li>负责加载存放在<code>JDK\jre\lib</code> (JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.* 开头的类均被Bootstrap ClassLoader加载)。</li><li>启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><strong>扩展类加载器</strong>: Extension ClassLoader，<ul><li>该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库(如javax.* 开头的类)，</li><li>开发者可以直接使用扩展类加载器。</li></ul></li><li><strong>应用程序类加载器</strong>: Application ClassLoader，<ul><li>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，</li><li>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><strong>自定义类加载器</strong>: <ul><li>因为JVM自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:<ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul></li></ul><blockquote><p>Class.forName() 和 ClassLoader.loadClass()区别?</p></blockquote><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li></ul><hr><p>Java的类加载机制是Java虚拟机（JVM）的一个核心组成部分，它负责动态加载、链接和初始化所有的类和接口。类加载机制的工作原理是分阶段进行的，主要包括加载（Loading）、链接（Linking）和初始化（Initialization）三个阶段。</p><ol><li>加载（Loading）</li></ol><p>在加载阶段，JVM会通过类加载器（ClassLoader）读取二进制数据（通常是从<code>.class</code>文件中）并将其转换为<code>java.lang.Class</code>的一个实例。这个实例代表了类在JVM中的一个原始数据结构。</p><p>类加载器类型：</p><ul><li><strong>引导类加载器（Bootstrap ClassLoader）</strong>: 加载JVM的核心类库。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>: 加载<code>jre/lib/ext</code>目录下或者由系统属性<code>java.ext.dirs</code>指定位置中的类库。</li><li><strong>系统类加载器（System ClassLoader）</strong>: 加载系统类路径（<code>classpath</code>）上的类库。</li></ul><ol start="2"><li>链接（Linking）</li></ol><p>链接阶段负责将加载的类或接口的二进制数据合并到JVM的运行状态中。链接阶段分为三个子阶段：</p><ul><li><strong>验证（Verification）</strong>: 确保被加载的类或接口的二进制表示符合JVM规范，没有安全问题。</li><li><strong>准备（Preparation）</strong>: JVM为类变量分配内存并设置默认初始值，这些变量所使用的内存在方法区中进行分配。</li><li><strong>解析（Resolution）</strong>: JVM将常量池内的符号引用替换为直接引用。</li></ul><ol start="3"><li>初始化（Initialization）</li></ol><p>在初始化阶段，JVM负责执行类构造器 <code>&lt;clinit&gt;()</code> 方法的过程。<code>&lt;clinit&gt;()</code> 方法由编译器自动收集类中的所有类变量的赋值动作和静态代码块（static{}块）中的语句合并而成。初始化阶段是执行这些初始化语句和静态代码块的过程。</p><p>类加载机制的特点</p><ul><li><strong>懒加载</strong>: 类加载器采用懒加载策略，即当首次使用某个类时才加载。</li><li><strong>缓存机制</strong>: 加载的类信息会被缓存，同一个类加载器下，一个类型只会被加载一次。</li></ul><p>类比</p><p>可以把类加载机制想象成图书馆的工作流程：</p><ul><li><strong>加载</strong>: 类似于根据书名找到书籍的过程。</li><li><strong>链接</strong>: 类似于检查书籍是否完整、页码是否正确，并准备好放到书架上。</li><li><strong>初始化</strong>: 类似于将书籍放到指定的书架上，标记为可借阅状态。</li></ul><hr><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>双亲委派模型（Parent Delegation Model）是Java类加载器（ClassLoader）中的一个核心概念，用于加载类和接口。这个模型旨在提供一种安全性较高的类加载机制，确保Java核心库的类型安全，避免类的重复加载。</p><p>双亲委派模型的工作原理</p><ol><li><strong>委派过程</strong>: 当一个类加载器尝试加载某个类时，它不会立即尝试加载这个类。相反，它会首先将加载任务委派给父类加载器去完成。</li><li><strong>向上递归</strong>: 这个过程会递归向上进行，直到顶层的启动类加载器（Bootstrap ClassLoader）。</li><li><strong>尝试加载</strong>: 如果父类加载器可以完成类的加载工作，那么就成功返回；如果父类加载器无法完成这个加载（因为类不在其搜索范围内），那么子类加载器会尝试自己去加载这个类。</li></ol><p>双亲委派模型的优势</p><ol><li><strong>避免类的重复加载</strong>: 由于在向上委派的过程中，系统类加载器在加载类时会先检查这个类是否已经被加载过了，这样就可以避免重复加载。</li><li><strong>保护程序安全性</strong>: 防止核心API被随意篡改。例如，用户可以自己写一个名为<code>java.lang.Object</code>的类，但系统类加载器会在用户的类加载器之前加载<code>Object</code>类，因此不会加载到用户自定义的那个类。</li></ol><p>双亲委派模型的例外</p><p>尽管双亲委派模型是Java推荐的类加载机制，但在某些情况下，类加载器可能需要违反这个模型。例如，Java的SPI(Service Provider Interface)机制允许服务提供者在运行时被插入和替换，这就需要用到一种不同于标准双亲委派模型的类加载方式。此外，一些应用服务器也会对Java的双亲委派模型进行修改以满足特定需求。</p><p>类比</p><p>可以将双亲委派模型类比于组织中的任务委托过程。当一个任务到来时，员工会先上报给自己的直接上司，上司再上报给更高层的管理者。管理者层层审批，如果上层可以处理这个任务，就不再往下传递。这样可以确保任务处理的正确性和权威性，同时避免重复处理同一个任务。</p><hr><h4 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h4><p>打破双亲委派机制通常涉及自定义类加载器，并重写其<code>loadClass</code>方法的行为。这通常是出于对特定环境的特殊需求，比如在容器中隔离应用程序、热部署、插件加载等。</p><p>打破双亲委派机制的方法</p><p>要打破双亲委派机制，可以通过创建自定义的类加载器并重写<code>loadClass</code>方法来实现：</p><ol><li><strong>创建自定义类加载器</strong>：继承<code>ClassLoader</code>类。</li><li><strong>重写<code>loadClass</code>方法</strong>：在自定义的<code>loadClass</code>方法中，可以先尝试自己加载类，如果不成功，再根据需要选择是否委托给父加载器。</li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    public <span class="hljs-type">Class</span>&lt;?&gt; loadClass(<span class="hljs-type">String</span> name) <span class="hljs-keyword">throws</span> <span class="hljs-type">ClassNotFoundException</span> &#123;<br>        <span class="hljs-comment">// 首先, 检查请求的类是否已经被加载</span><br>        <span class="hljs-type">Class</span>&lt;?&gt; loadedClass = findLoadedClass(name);<br>        <span class="hljs-keyword">if</span> (loadedClass == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 尝试自己加载类</span><br>                loadedClass = findClass(name);<br>            &#125; <span class="hljs-keyword">catch</span> (<span class="hljs-type">ClassNotFoundException</span> e) &#123;<br>                <span class="hljs-comment">// 如果自己无法加载, 则委托给父加载器</span><br>                loadedClass = <span class="hljs-keyword">super</span>.loadClass(name, <span class="hljs-literal">false</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> loadedClass;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">Class</span>&lt;?&gt; findClass(<span class="hljs-type">String</span> name) <span class="hljs-keyword">throws</span> <span class="hljs-type">ClassNotFoundException</span> &#123;<br>        <span class="hljs-comment">// 实现自己的加载逻辑</span><br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>双亲委派机制的设计理念</p><p>双亲委派机制的设计主要基于以下几个目的：</p><ol><li><strong>安全性</strong>：防止核心API被随意篡改。例如，防止用户自定义的类替换掉核心的类，如<code>java.lang.Object</code>。</li><li><strong>避免类的重复加载</strong>：当父加载器已经加载了该类时，就没有必要子加载器再重新加载一次。</li><li><strong>保持命名空间的清晰</strong>：通过该机制，可以确保在不同的类加载器中加载的类能够相互不见，避免不同类加载器加载相同全名类而引起的冲突。</li></ol><p>打破双亲委派机制的理由</p><p>尽管双亲委派机制在多数情况下是合理的，但在某些场景下可能需要打破这一机制：</p><ol><li><strong>隔离加载</strong>：在容器化的环境中，比如在一个JVM中运行多个应用程序，每个应用程序可能需要使用不同版本的同一库。</li><li><strong>热替换和热部署</strong>：在开发过程中或者某些应用程序中，可能需要重新加载修改过的类，以实现不重启应用程序的更新。</li><li><strong>插件化架构</strong>：应用程序可能需要加载扩展或插件，这些插件与应用程序的类加载器相独立。</li></ol><p>在设计自定义类加载器和考虑是否打破双亲委派模型时，需要仔细权衡安全性、隔离性以及动态加载的需求。</p><hr><blockquote><p>什么是类加载机制，讲一下双亲委派机制，为什么有时候要打破双亲委派机制，怎么打破。</p></blockquote><p>类加载机制是 JVM 的一个核心功能，他能够将类和接口加载；</p><p>类加载主要分为三个阶段，分别是：加载、连接和初始化；</p><p>在第一个阶段中，JVM 会通过类加载器将 .class 文件进行读取二进制数据并转换为 Class 实例；</p><p>其中类加载器主要分为：引导类加载器 Bootstrap ClassLoader 、扩展类加载器 Extension ClassLoader、系统类加载器  System ClassLoader</p><p>在第二个阶段中，连接会将加载的类或者接口的二进制数据合并到 JVM 的运行状态中。</p><p>同时连接又分为三个子阶段，分别是：验证、准备、解析。</p><p>在第三个阶段中，初始化会执行类构造器方法，即执行初始化语句和静态代码块的过程。</p><p>双亲委派机制是类加载器中的一个核心概念，用于加载类和接口。他的一个核心过程是通过向上递归的操作，子加载器会先委派任务给父加载器，直到顶层的类加载器 Bootstrap ClassLoader ，如果父加载器无法完成这个加载，那么此时子加载器才会尝试自己去加载这个类。<br>这种操作可以避免类的重复加载和防止核心API被随意篡改。</p><p>打破双亲委派机制通常是需要创建自定义的类加载器并重写 <code>loadClass</code> 方法来实现。</p><h3 id="3、JVM的结构体系"><a href="#3、JVM的结构体系" class="headerlink" title="3、JVM的结构体系"></a>3、JVM的结构体系</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116235359.png" alt="image.png"></p><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><blockquote><p>运行时数据区根据线程是否私有或者共享进行区分</p></blockquote><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><p>直接内存（Java7的永久代或JDK8的元空间、代码缓存）</p><blockquote><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p></blockquote><p>1.8之前版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000248.png" alt="image.png|600"></p><p>JVM1.8之后版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000319.png" alt="image.png|600"></p><p>1.8之前的版本，线程共享为两个区域：堆与方法区；其中方法区只是JVM虚拟机规范的一部分，不是实际的实现；</p><p>直接内存：是JVM以外的本地内存；</p><p><strong>版本区别介绍</strong></p><ul><li>区别一（方法区）<ul><li>1.8版本之后，使用元数据区实现了方法区，之前是使用永久代来实现方法区，大小是启动时固定好的；</li><li>元空间不在虚拟机中，而是使用本地内存，并且大小可以自动增长，减少了OOM（内存溢出）的几率；</li></ul></li><li>区别二（堆区）<ul><li>Java7之后运行时常量池从方法区移到了这里，为Java8移出永久代做好准备；</li></ul></li></ul><h3 id="4、运行时数据区域"><a href="#4、运行时数据区域" class="headerlink" title="4、运行时数据区域"></a>4、运行时数据区域</h3><h4 id="1-程序计数器（Program-Counter-Register）"><a href="#1-程序计数器（Program-Counter-Register）" class="headerlink" title="1. 程序计数器（Program Counter Register）"></a>1. 程序计数器（Program Counter Register）</h4><ul><li><strong>描述</strong>: 程序计数器是一小块内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</li><li><strong>作用</strong>: <strong>每个线程都有自己的程序计数器，是线程私有的</strong>。它的作用是记住下一条JVM指令的执行位置，如果是执行Java方法，则记录字节码指令的地址；如果是执行本地方法，则为空（Undefined）。</li><li><strong>特点</strong>: 不会发生内存泄漏问题，是唯一一个没有规定任何OutOfMemoryError情况的区域。</li></ul><h4 id="2-虚拟机栈（VM-Stacks）"><a href="#2-虚拟机栈（VM-Stacks）" class="headerlink" title="2. 虚拟机栈（VM Stacks）"></a>2. 虚拟机栈（VM Stacks）</h4><ul><li><strong>描述</strong>: 虚拟机栈是描述Java方法执行的内存模型，每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。</li><li><strong>作用</strong>: 每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</li><li><strong>特点</strong>: 生命周期和线程相同。如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError；如果虚拟机栈可以动态扩展，如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError。</li></ul><h4 id="3-本地方法栈（Native-Method-Stacks）"><a href="#3-本地方法栈（Native-Method-Stacks）" class="headerlink" title="3. 本地方法栈（Native Method Stacks）"></a>3. 本地方法栈（Native Method Stacks）</h4><ul><li><strong>描述</strong>: 本地方法栈与虚拟机栈发挥的作用非常相似，区别是虚拟机栈为执行Java方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的Native方法服务。</li><li><strong>特点</strong>: 和虚拟机栈一样，生命周期也是和线程相同，受到本地方法栈大小的限制，也可能抛出StackOverflowError和OutOfMemoryError。</li></ul><h4 id="4-堆（Heap）"><a href="#4-堆（Heap）" class="headerlink" title="4. 堆（Heap）"></a>4. 堆（Heap）</h4><ul><li><strong>描述</strong>: 堆是Java虚拟机管理的最大一块内存区域，它被所有线程共享，在虚拟机启动时创建。</li><li><strong>作用</strong>: 它的主要目的是存放对象实例，几乎所有的对象实例都在这里分配内存。</li><li><strong>特点</strong>: 堆是垃圾收集器管理的主要区域，因此也被称作“GC堆”。如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将抛出OutOfMemoryError。</li></ul><h4 id="5-方法区（Method-Area）"><a href="#5-方法区（Method-Area）" class="headerlink" title="5. 方法区（Method Area）"></a>5. 方法区（Method Area）</h4><ul><li><strong>描述</strong>: 方法区与Java堆一样，是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量等数据。</li><li><strong>作用</strong>: 存储每一个类的结构信息，例如运行时常量池（Runtime Constant Pool）、字段和方法数据、构造函数和普通方法的字节码内容。</li><li><strong>特点</strong>: 方法区也被称为永久代（PermGen），但从JDK 1.8开始，已经被元空间（MetaSpace）所取代。如果方法区无法满足内存分配需求时，将抛出OutOfMemoryError。</li></ul><p>这些区域各有其特定的用途，它们共同工作以支持JVM的运行。理解这些区域如何交互和管理内存，是深入理解Java运行时环境的关键。</p><blockquote><p>类比</p></blockquote><p>可以将JVM的运行时数据区想象成一家工厂：</p><ul><li><strong>程序计数器</strong>: 工厂中的任务列表，记录下一个任务的位置。</li><li><strong>虚拟机栈</strong>: 工人的工作台，每当开始一个新任务，就会在工作台上准备相应的材料和工具。</li><li><strong>本地方法栈</strong>: 特殊任务的工作台，用于处理一些非标准的任务。</li><li><strong>堆</strong>: 材料仓库，存放所有需要的材料。</li><li><strong>方法区</strong>: 设计图纸存放区，存放产品设计图纸和制造指导。</li></ul><hr><blockquote><p>JVM 的运行时数据区区域有哪些。</p></blockquote><p>JVM 将 .class 文件进行类加载后，数据会到达 运行时数据区。</p><p>区域主要包括：堆（Heap）、方法区（Method Area）、虚拟机栈（VM Stacks）、本地方法栈（Native Method Stacks）和程序计数器（Program Counter Register）</p><p>区分可以看一下这个： [[JVM入门_基础概念#3、JVM的结构体系]]</p><h3 id="5、垃圾回收机制"><a href="#5、垃圾回收机制" class="headerlink" title="5、垃圾回收机制"></a>5、垃圾回收机制</h3><p>Java虚拟机（JVM）的垃圾回收机制是一种自动内存管理系统，它旨在帮助开发者管理应用程序使用的内存。其核心思想是自动发现并释放那些不再被应用程序使用的内存区域，从而避免内存泄露和过度的内存消耗。</p><h4 id="1-垃圾回收的基本原理"><a href="#1-垃圾回收的基本原理" class="headerlink" title="1. 垃圾回收的基本原理"></a>1. 垃圾回收的基本原理</h4><p>垃圾回收的基本原理是确定哪些内存是可达的，即在程序的当前状态下，哪些内存仍然可以被程序访问。</p><p>内存分配给对象时，如果该对象可达，它就会继续占用内存；如果对象不可达，那么它占用的内存就可以被视为垃圾，并由垃圾收集器回收。</p><h4 id="2-判定对象存活的方法"><a href="#2-判定对象存活的方法" class="headerlink" title="2. 判定对象存活的方法"></a>2. 判定对象存活的方法</h4><ul><li><strong>引用计数法</strong>: 每个对象有一个引用计数器，当有一个地方引用它时，计数器就加1；当引用失效时，计数器就减1。任何时刻计数器为0的对象都是不可能再被使用的。但这种方法无法解决对象之间相互循环引用的问题。</li><li><strong>可达性分析算法</strong>（更常用）: 这种算法通过一系列称为“根”的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到根节点没有任何引用链相连时，则证明此对象是不可用的。</li></ul><h5 id="JVM分代年龄为什么是15"><a href="#JVM分代年龄为什么是15" class="headerlink" title="JVM分代年龄为什么是15"></a>JVM分代年龄为什么是15</h5><p>在Java虚拟机（JVM）的分代垃圾回收机制中，”分代年龄”指的是一个对象在新生代中经过多少次垃圾回收（Minor GC）之后还存活的计数。</p><p>当对象的年龄达到一定的阈值时，它就会从新生代晋升到老年代。这个阈值被称为晋升年龄（Promotion Age），默认值通常是15。</p><p>默认值15是JVM设计者根据经验设置的，目的是在内存占用和垃圾回收成本之间寻求平衡。</p><blockquote><p>JVM分代年龄的最大值</p></blockquote><p>JVM分代年龄的最大值 是 15.</p><p>一个对象的GC年龄，是存储在对象头里面的，一个Java对象在JVM内存中的布局由三个部分组成，分别是对象头，实例数据，对齐填充。而对象头(Mark Word)里面有4个bit位来存储GC年龄。而4个bit位能够存储的最大数值是1111(十进制就是15)。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401231135898.png" alt="image.png"></p><h4 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h4><ul><li><strong>标记-清除算法（Mark-Sweep）</strong>: 首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</li><li><strong>复制算法（Copying）</strong>: 将内存分为大小相等的两块，每次只使用其中一块。当这一块的内存用完了，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。</li><li><strong>标记-整理算法（Mark-Compact）</strong>: 类似于标记-清除算法，但在完成标记后，它会将所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li><li><strong>分代收集算法（Generational Collection）</strong>: 将堆内存分为几个区域（如年轻代、老年代），根据各个年龄段的特点采用最适当的收集算法。</li></ul><blockquote><p>类比</p></blockquote><p>可以将垃圾回收比作是清洁工人在城市中收集垃圾的过程：</p><ul><li><strong>可达性分析</strong>就像是确定哪些垃圾桶是空的，哪些是满的。</li><li><strong>标记-清除</strong>就像是标记出所有满的垃圾桶，然后一一清空。</li><li><strong>复制算法</strong>就像是将半满的垃圾桶的内容转移到一个空的垃圾桶中，然后清理原来的垃圾桶。</li><li><strong>标记-整理</strong>就像是将所有的垃圾集中到垃圾场的一角，然后清理掉其余的空间。</li></ul><h4 id="4-JVM中的垃圾收集器"><a href="#4-JVM中的垃圾收集器" class="headerlink" title="4. JVM中的垃圾收集器"></a>4. JVM中的垃圾收集器</h4><p>JVM提供了多种垃圾收集器，每种收集器都有各自的优势，适用于不同类型和性能要求的应用场景。<strong>常见的</strong>垃圾收集器包括：</p><ul><li><strong>Serial GC</strong>: 单线程执行，适合单核处理器。</li><li><strong>Parallel GC</strong>: 多线程执行，关注吞吐量。</li><li><strong>CMS (Concurrent Mark Sweep) GC</strong>: 关注最短停顿时间。</li><li><strong>G1 GC</strong>: 面向服务端应用，将堆内存分为多个区域，并并行执行垃圾回收。</li></ul><p>每种垃圾回收器都有其特定的算法和运行机制，旨在优化不同的性能指标，如吞吐量、暂停时间或内存占用。默认垃圾回收器的选择取决于JVM版本和具体的配置参数。</p><h5 id="1-串行垃圾回收器（Serial-GC）"><a href="#1-串行垃圾回收器（Serial-GC）" class="headerlink" title="1. 串行垃圾回收器（Serial GC）"></a>1. 串行垃圾回收器（Serial GC）</h5><ul><li><strong>运行机制</strong>：串行垃圾回收器使用单个线程执行垃圾回收。在执行垃圾回收时，它会暂停所有的应用程序线程（称为Stop-The-World，STW），直到垃圾回收完成。</li><li><strong>适用场景</strong>：适用于小内存和单核处理器的环境，或者对暂停时间不敏感的应用。</li></ul><h5 id="2-并行垃圾回收器（Parallel-GC）"><a href="#2-并行垃圾回收器（Parallel-GC）" class="headerlink" title="2. 并行垃圾回收器（Parallel GC）"></a>2. 并行垃圾回收器（Parallel GC）</h5><ul><li><strong>运行机制</strong>：并行垃圾回收器使用多个线程并行执行垃圾回收任务。在垃圾回收期间，应用程序的执行也会暂停。</li><li><strong>适用场景</strong>：适用于需要高吞吐量和多核处理器的服务器环境。它能有效利用CPU资源来缩短垃圾回收的时间。</li></ul><h5 id="3-CMS垃圾回收器（Concurrent-Mark-Sweep-GC）"><a href="#3-CMS垃圾回收器（Concurrent-Mark-Sweep-GC）" class="headerlink" title="3. CMS垃圾回收器（Concurrent Mark Sweep GC）"></a>3. CMS垃圾回收器（Concurrent Mark Sweep GC）</h5><ul><li><strong>运行机制</strong>：<ul><li><strong>初始标记（Initial Mark）</strong>：标记GC Roots能直接关联到的对象，需要STW暂停。</li><li><strong>并发标记（Concurrent Mark）</strong>：在应用线程运行的同时，标记GC Roots可达的对象。</li><li><strong>重新标记（Remark）</strong>：修正并发标记期间因应用程序运行而产生变动的标记记录，需要STW暂停。</li><li><strong>并发清除（Concurrent Sweep）</strong>：清除不可达的对象。</li></ul></li><li><strong>适用场景</strong>：适用于对响应时间要求高的应用，因为它减少了垃圾回收时的停顿时间。</li></ul><p>CMS（Concurrent Mark-Sweep）垃圾回收器是JVM中一种以获取最短回收停顿时间为目标的收集器，特别适用于那些对响应时间有很高要求的场景。CMS垃圾回收器主要用于回收老年代（Old Generation）的空间。</p><p>分为几个阶段：</p><blockquote><ol><li>初始标记（Initial Mark）</li></ol></blockquote><ul><li><strong>运行机制</strong>：这个阶段标记所有与GC Roots直接相连的对象。这一步需要”Stop-The-World”（STW），所有的应用线程都会被暂停，但通常这个阶段很快。</li></ul><blockquote><ol start="2"><li>并发标记（Concurrent Mark）</li></ol></blockquote><ul><li><strong>运行机制</strong>：在这一阶段，GC线程标记所有从直接相连的对象可达的对象。这个阶段是并发的，即应用程序和垃圾回收线程同时执行，不需要暂停用户线程。</li></ul><blockquote><ol start="3"><li>重新标记（Remark）</li></ol></blockquote><ul><li><strong>运行机制</strong>：<ul><li>由于在并发标记阶段，应用程序线程仍在运行，可能会有新的对象被分配，或者对象引用关系发生变化。因此，需要一个STW的阶段来修正并发标记期间的变动。</li><li>为了减少这个阶段的停顿时间，CMS使用了一种名为“增量更新”的技术（Card Marking），来记录并发阶段期间引用关系的变化。</li><li>此外，CMS还可以选择使用一种名为“快照算法”（Snapshot-at-the-beginning, SATB）来处理这些变化。</li></ul></li></ul><blockquote><ol start="4"><li>并发清除（Concurrent Sweep）</li></ol></blockquote><ul><li><strong>运行机制</strong>：此阶段回收那些已经标记为不可达的对象占用的空间。这一步是并发的，不需要暂停用户线程。</li></ul><blockquote><ol start="5"><li>并发重置（Concurrent Reset）</li></ol></blockquote><ul><li><strong>运行机制</strong>：这个阶段是清理内部数据结构，为下一次GC循环做准备的过程。这一步是并发的，不需要暂停用户线程。</li></ul><blockquote><p>类比</p></blockquote><p>可以将CMS垃圾回收类比为一个有序的清洁工作：</p><ul><li><strong>初始标记</strong>就像是确定清洁的起始位置。</li><li><strong>并发标记</strong>就像是在日常的清洁过程中标记出需要清洁的区域。</li><li><strong>重新标记</strong>就像是在清洁前再次检查标记的区域，确保没有遗漏。</li><li><strong>并发清除</strong>则是实际的清洁过程。</li><li><strong>并发重置</strong>就像是清理和准备清洁工具，为下一次清洁做准备。</li></ul><p>CMS垃圾回收器的主要目标是<strong>减少垃圾回收时的停顿时间</strong>，从而提高应用程序的响应性。然而，CMS也有一些缺点，比如它对CPU资源的使用较多，且由于并发执行，可能会导致更多的内存碎片。</p><h5 id="4-G1垃圾回收器（G1-GC）"><a href="#4-G1垃圾回收器（G1-GC）" class="headerlink" title="4. G1垃圾回收器（G1 GC）"></a>4. G1垃圾回收器（G1 GC）</h5><ul><li><strong>运行机制</strong>：G1垃圾回收器将堆内存划分为多个区域，并根据每个区域的回收价值和成本来优先回收，目的是在有限的停顿时间内回收尽可能多的内存。</li><li><strong>适用场景</strong>：适用于大内存环境，并且需要更可控的垃圾回收暂停时间。</li></ul><blockquote><p>默认的垃圾回收器</p></blockquote><p>默认的垃圾回收器取决于JVM版本和JVM参数。例如，在较新的Java版本中（如Java 9及之后），默认的垃圾回收器可能是G1 GC。</p><blockquote><p>选择不同垃圾回收器的情况</p></blockquote><p>不同的垃圾回收器适用于不同的场景和需求。以下是选择不同垃圾回收器的一些情况：</p><ul><li><strong>对暂停时间要求严格</strong>：如果需要减少垃圾回收期间的停顿时间，可以考虑使用CMS或G1。</li><li><strong>需要最大化吞吐量</strong>：如果应用需要最大化CPU时间用于执行应用逻辑，可以考虑使用并行垃圾回收器。</li><li><strong>资源受限的环境</strong>：在单核处理器或内存较小的环境中，串行垃圾回收器可能是一个较好的选择。</li></ul><p>选择合适的垃圾回收器需要考虑应用程序的具体需求和运行环境。在实际应用中，可能还需要根据应用程序的行为进行调优以达到最佳性能。</p><hr><blockquote><p>垃圾回收主要是针对哪块区域进行回收的</p></blockquote><p>垃圾回收主要是针对堆内存进行的，这是大部分Java对象存储和回收的地方。</p><p>堆内存是垃圾收集器的主要工作区域，这里是动态分配内存的地方，对象实例和数组在这里创建和回收。</p><blockquote><p>新生代的对象怎么到达老年代的。</p></blockquote><p>在Java虚拟机（JVM）中，对象通常首先在新生代（Young Generation）分配。随着时间的推移和垃圾回收的进行，对象可能会从新生代晋升（Promotion）到老年代（Old Generation）。这个过程是JVM自动内存管理的一部分，主要基于对象的存活周期和垃圾回收机制。以下是对象从新生代到达老年代的过程：</p><ol><li>对象的初始分配</li></ol><p>大部分情况下，新创建的对象首先在新生代的Eden区域分配。这是基于假设大多数对象都是朝生夕死的。</p><ol start="2"><li>Minor GC（小垃圾回收）</li></ol><p>当新生代的Eden区域填满时，JVM会进行一次Minor GC。这次GC会检查Eden区以及两个Survivor区（通常称为From和To，或者S0和S1）：</p><ul><li><strong>存活对象的复制</strong>：存活的对象会被复制到当前的Survivor区（例如，从Eden复制到S1）。</li><li><strong>年龄计数</strong>：每当对象在Minor GC后存活，它的年龄就会增加。当对象在新生代中存活足够长的时间（超过特定的年龄阈值，通常由参数<code>-XX:MaxTenuringThreshold</code>设定）后，它就会被认为足够成熟，可以晋升到老年代。</li></ul><ol start="3"><li>对象的晋升</li></ol><p>对象不是在每次Minor GC后都会晋升到老年代。它们可能会在新生代的Survivor区之间来回复制几次。对象晋升到老年代通常是基于以下几个条件：</p><ul><li><strong>年龄阈值</strong>：当对象的年龄达到预设的阈值时。</li><li><strong>Survivor空间不足</strong>：如果Survivor空间不足以容纳一次Minor GC后存活的对象，这些对象将直接晋升到老年代。</li><li><strong>大对象</strong>：大对象（大于<code>-XX:PretenureSizeThreshold</code>设定的大小）可能直接在老年代分配，以避免在新生代中反复复制。</li></ul><p>类比：一个人的成长</p><p>可以将对象从新生代晋升到老年代类比为一个人的成长过程：</p><ul><li><strong>新生代</strong>：就像儿童时期，个体（对象）在这个阶段快速成长（创建），但许多很快就不再存在（朝生夕死）。</li><li><strong>Minor GC</strong>：就像学校的考试，检验哪些学生（对象）足够强壮（存活）以继续到下一个学期（Survivor区或老年代）。</li><li><strong>晋升到老年代</strong>：个体（对象）通过多次考验（Minor GC）证明了其稳定性（存活率高），因此可以进入更为稳定的成年阶段（老年代）。</li></ul><blockquote><p>分代年龄为什么要设计为 15，默认值是 15， 最大是多少。</p></blockquote><p>在垃圾回收和内存分配之间的一个平衡值,最大值是 15，默认值也是15</p><p>参考：![[JVM入门_基础概念#JVM分代年龄为什么是15]]</p><blockquote><p>垃圾回收器</p></blockquote><p><strong>常见的垃圾回收器有 单线程、多线程、CMS、G1。</strong></p><blockquote><p>哪些对象是可以被看做是 GCRoot</p></blockquote><p>在Java虚拟机（JVM）中，垃圾收集器在回收内存之前需要确定哪些对象是活动的，即不应该被回收的。这是通过可达性分析（Reachability Analysis）来完成的，过程中以一组称为“GC Roots”（垃圾回收根）的对象为起点。以下是常见的GC Root对象：</p><ol><li>在虚拟机栈中引用的对象</li></ol><ul><li><strong>局部变量表</strong>中的引用对象。这些引用来自于各个线程的方法调用栈。每个线程都有自己的虚拟机栈，其中的局部变量表可能引用了其他对象。</li></ul><ol start="2"><li>方法区中的类静态属性引用的对象</li></ol><ul><li><strong>静态属性</strong>（static field）位于方法区，它们引用的对象也作为GC Roots。</li></ul><ol start="3"><li>方法区中常量引用的对象</li></ol><ul><li><strong>常量</strong>，比如字符串常量池（String Constant Pool）中的引用。</li></ul><ol start="4"><li>本地方法栈中JNI（即通常所说的Native方法）引用的对象</li></ol><ul><li>由Java本地接口（JNI）引用的对象，例如在本地代码（C或C++等）中创建并被Java代码使用的对象。</li></ul><ol start="5"><li>活动的Java线程（Thread对象）</li></ol><ul><li>活动的线程也是一个GC Root。</li></ul><p>类比</p><p>可以将GC Roots想象为家族树的根：家族树中的每个成员（对象）都可以通过一系列的关系（引用）追溯到家族的始祖（GC Roots）。如果一个成员（对象）不能通过任何关系（引用链）与始祖（GC Roots）相连，那么可以认为这个成员（对象）已经“离世”（可以被垃圾回收）。</p><blockquote><p>在并发标记过程中，可以会出现一些多标、漏标的过程，CMS是怎么处理的。</p></blockquote><p>在CMS（Concurrent Mark-Sweep）垃圾回收器中，并发标记过程确实可能会面临多标（多次标记同一个对象）或漏标（未标记到应该存活的对象）的问题，特别是因为应用程序的线程在这个阶段是处于活动状态的，对象的引用关系可能会发生变化。CMS采用了几种技术和策略来处理这些问题，确保标记过程的准确性。以下是CMS处理这些问题的一些方法：</p><ol><li>写屏障（Write Barrier）</li></ol><ul><li><strong>写屏障</strong>是一种系统机制，用于监控和拦截对象引用字段的写操作。</li><li>在并发标记阶段，JVM通过写屏障来记录那些被修改的引用。这些信息将在稍后的重新标记阶段被使用，以确保所有存活的对象都被正确标记。</li></ul><ol start="2"><li>增量更新（Incremental Update）</li></ol><ul><li>增量更新是在写屏障的帮助下实现的。它记录了在并发标记阶段和应用程序线程同时运行时，引用关系发生变化的对象。</li><li>在接下来的重新标记阶段，增量更新的信息被用来修正并发标记期间可能出现的漏标问题。</li></ul><ol start="3"><li>重新标记（Remark Phase）</li></ol><ul><li>尽管写屏障和增量更新可以减少漏标的问题，但仍然需要一个STW（Stop-The-World）的阶段来最终确保所有存活的对象都被正确标记。这个阶段就是重新标记。</li><li>在重新标记阶段，CMS收集器会处理所有的增量更新信息，并且通过一种名为“快照算法”（Snapshot-at-the-beginning, SATB）来处理在并发阶段发生的引用变化。</li></ul><p>类比</p><p>可以将CMS的并发标记过程类比为绘制一幅复杂的画作：</p><ul><li><strong>并发标记</strong>就像是为画作勾勒初步的轮廓。画家（垃圾收集器）在绘制的同时，模特（应用程序中的对象）可能会稍微移动，从而使得画作的某些部分需要调整。</li><li><strong>写屏障和增量更新</strong>就像是画家记录下模特的每一个小动作，以便稍后修正画作的细节。</li><li><strong>重新标记</strong>则是画家最终审视画作，根据之前记录的所有小动作调整画作，确保画作的准确性。</li></ul><p>CMS的设计是为了减少垃圾回收时的停顿时间，但为了确保准确性，它需要采用上述机制来处理并发标记过程中可能出现的问题。</p><blockquote><p>三色标记算法有了解过吗</p></blockquote><p>三色标记（Tri-color Marking）算法是垃圾回收中使用的一种标记算法，特别是在支持并发垃圾收集的情况下，例如在CMS（Concurrent Mark-Sweep）和G1（Garbage-First）垃圾回收器中。它的基本思想是在标记过程中，用三种颜色来表示对象的状态，从而确保在并发环境下能够正确地进行垃圾回收。这三种颜色通常是白色、灰色和黑色。</p><p>三色标记算法的工作原理</p><ol><li><strong>白色</strong>：表示对象尚未被访问。初始时，所有对象都标记为白色。</li><li><strong>灰色</strong>：表示对象已被访问，但该对象引用的其他对象还没有全部访问。换句话说，从根集合出发，引用路径上的对象已被访问，但这些对象的子对象还未被全部访问。</li><li><strong>黑色</strong>：表示对象已被访问，且该对象引用的所有其他对象也都已访问。黑色对象是安全的，因为它和它引用的对象都已经被扫描过，不会再引用任何白色对象。</li></ol><p>三色标记的过程</p><ul><li><strong>初始阶段</strong>：所有对象都标记为白色。</li><li><strong>标记阶段</strong>：<ul><li>从根集合开始，访问和标记对象。首先，将根对象标记为灰色。</li><li>遍历灰色对象，将其引用的对象标记为灰色（如果它们是白色的），然后将该对象标记为黑色。</li><li>重复这个过程，直到没有灰色对象为止。</li></ul></li></ul><p>三色标记和并发垃圾回收</p><p>在并发垃圾回收中，应用线程和垃圾收集线程是同时运行的。这可能导致所谓的“浮动垃圾”（Floating Garbage），即在标记过程中由于应用线程的运行产生的新垃圾。三色标记算法通过维护这些颜色的不变性和使用一些技术，如写屏障（Write Barrier）和增量更新（Incremental Update），来确保垃圾收集的正确性。</p><p>类比</p><p>可以将三色标记算法类比为管理一家图书馆的过程：</p><ul><li><strong>白色书籍</strong>：尚未检查的书籍。</li><li><strong>灰色书籍</strong>：检查过，但书籍里面的引用（例如书中的引用文献）还没有全部检查的书籍。</li><li><strong>黑色书籍</strong>：完全检查过的书籍，包括书本及其引用的所有内容。</li></ul><p>图书管理员（垃圾收集器）需要确保所有的书籍都被正确地检查过，同时处理图书馆运营期间新加入或变动的书籍（应用线程的活动）。</p><h3 id="6、堆空间"><a href="#6、堆空间" class="headerlink" title="6、堆空间"></a>6、堆空间</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>Java 的自动内存管理主要是<strong>针对对象内存的回收和对象内存的分配</strong>。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>从垃圾回收的角度来说，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆被划分为了几个不同的区域，这样我们就可以根据各个区域的特点选择合适的垃圾收集算法。</p><blockquote><p>&lt;&#x3D; JDK 7</p></blockquote><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li>新生代内存(Young Generation)</li><li>老生代(Old Generation)</li><li>永久代(Permanent Generation)</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401231042051.png" alt="image.png"></p><p>Eden 区、两个 Survivor 区 S0 和 S1 都属于新生代，中间一层属于老年代，最下面一层属于永久代。</p><blockquote><p>&#x3D; JDK8</p></blockquote><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong></p><h5 id="Survivor-区"><a href="#Survivor-区" class="headerlink" title="Survivor 区"></a>Survivor 区</h5><blockquote><p>对象在GC的时候在新生代的一个活动是怎么样的；元空间&#x2F;永久代有什么用</p></blockquote><p>在Java虚拟机（JVM）中，新生代是堆内存的一部分，主要用于存放新创建的对象。新生代通常分为三个区域：Eden区、两个Survivor区（分别称为S0和S1）。</p><p>对象在新生代的分配和回收是垃圾回收机制的核心部分。此外，元空间（或在Java 8之前的版本中的永久代）也在内存管理中扮演着重要的角色。</p><blockquote><p>新生代的内存区域</p></blockquote><ol><li><strong>Eden区</strong>:<ul><li>当新对象被创建时，它们通常首先在Eden区分配。Eden区占新生代的大部分空间。</li></ul></li><li><strong>两个Survivor区（S0和S1）</strong>:<ul><li>Survivor区用来保存一次Minor GC后仍然存活的对象。在两个Survivor区中，任何时候只有一个是被使用的（活动的），另一个是空闲的。</li></ul></li></ol><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    两个生存区中，只有一个是空闲的，另外一个是活动的。</div><blockquote><p>对象在新生代的GC活动</p></blockquote><p>在垃圾回收过程中，新生代的对象经历以下活动：</p><ol><li><strong>新对象分配</strong>:<ul><li>新对象首先在Eden区分配。</li></ul></li><li><strong>第一次Minor GC</strong>:<ul><li>当Eden区满时，进行一次Minor GC。</li><li>存活的对象从Eden区移动到一个Survivor区（比如S0），并将其年龄设置为1。</li></ul></li><li><strong>后续的Minor GC</strong>:<ul><li>在后续的Minor GC中，Eden区和当前活动的Survivor区（比如S0）中存活的对象被移动到另一个Survivor区（比如S1），对象年龄增加1。</li><li>如果一个对象的年龄超过了一定的阈值（通常是15），它就会被晋升到老年代。</li></ul></li><li><strong>两个Survivor区的交换</strong>:<ul><li>每次Minor GC后，活动的和空闲的Survivor区会交换。这意味着如果S0是上次GC后的活动区，那么下次GC时，S1将成为活动区，反之亦然。</li></ul></li></ol><blockquote><p>类比</p></blockquote><p>可以将新生代的内存管理比作是一个孩子的成长过程：</p><ul><li><strong>Eden区</strong>就像婴儿室，新生的孩子（对象）首先在这里。</li><li><strong>Survivor区</strong>就像学校，经过几次考核（GC）后，表现好的孩子（对象）会转到学校（Survivor区）。</li><li>随着孩子们的成长（对象的年龄增长），一些会转到大学（老年代）。</li></ul><blockquote><p>元空间&#x2F;永久代的作用</p></blockquote><ul><li><p><strong>永久代（PermGen, Java 8之前）</strong>:</p><ul><li>用于存储JVM加载的类信息、常量池、静态变量等数据。</li><li>由于永久代的大小是固定的，它可能会因为类加载器加载了太多的类而导致内存溢出（OutOfMemoryError）。</li></ul></li><li><p><strong>元空间（Metaspace, Java 8及之后）</strong>:</p><ul><li>元空间取代了永久代，用于存储类的元数据。</li><li>元空间使用本地内存（而非JVM内存），因此它的大小只受本地内存限制，这减少了发生内存溢出的风险。</li></ul></li></ul><h4 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h4><p>看一下这个： <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99">https://javaguide.cn/java/jvm/jvm-garbage-collection.html#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E5%88%99</a></p><p>在Java虚拟机（JVM）中，堆空间是对象存储的主要区域。堆空间的内存分配和回收是垃圾回收机制的核心。以下是JVM中堆空间的内存分配和回收原则的详细解释，我们将使用一些简单的类比来帮助理解。</p><h5 id="内存分配策略"><a href="#内存分配策略" class="headerlink" title="内存分配策略"></a>内存分配策略</h5><ul><li><strong>对象优先在Eden分配</strong>：大多数情况下，对象在年轻代的Eden区分配。当Eden区没有足够空间进行分配时，JVM会进行一次Minor GC。</li><li><strong>大对象直接进入老年代</strong>：避免在Eden区及两个Survivor区之间发生大量内存复制。</li><li><strong>长期存活的对象将进入老年代</strong>：对象在年轻代中经过多次GC后仍然存活，会被移动到老年代。</li></ul><blockquote><p>堆空间的内存分配</p></blockquote><ol><li><strong>对象的创建和存储</strong>:<ul><li>当新对象被创建时，JVM首先会检查堆空间是否有足够的空间分配给这个新对象。</li><li>如果有足够空间，对象将被存储在堆内存中；如果没有，JVM会尝试通过垃圾回收来释放空间。</li></ul></li><li><strong>分代分配策略</strong>:<ul><li>大部分JVM使用分代垃圾回收机制，将堆空间分为年轻代（Young Generation）、老年代（Old Generation）等区域。</li><li>新创建的对象首先在年轻代中分配（通常在其中一个称为<code>Eden</code>的区）。当<code>Eden</code>区满时，会进行一次Minor GC，清理年轻代中不再存活的对象。</li></ul></li></ol><blockquote><p>类比：城市建设</p></blockquote><p>可以将堆空间的内存分配想象为城市建设。新建的建筑（对象）需要在城市（堆空间）中找到合适的位置。新建筑首先会在开发区（年轻代）中找地方，随着时间的推移，一些经久耐用的建筑会被迁移到更稳定的区域（老年代）。</p><h5 id="内存回收"><a href="#内存回收" class="headerlink" title="内存回收"></a>内存回收</h5><blockquote><p>堆空间的内存回收</p></blockquote><ol><li><strong>可达性分析</strong>:<ul><li>JVM通过可达性分析算法来判断对象是否存活。从一系列的“根”对象（如线程栈中的局部变量、静态变量等）开始，JVM查找并标记所有可达的对象。不可达的对象可以被认为是垃圾，可以被回收。</li></ul></li><li><strong>垃圾回收算法</strong>:<ul><li><strong>标记-清除（Mark-Sweep）</strong>: 标记所有不可达的对象，然后统一清除。</li><li><strong>复制（Copying）</strong>: 将存活的对象复制到另一块区域，然后清理掉原来的全部空间。</li><li><strong>标记-整理（Mark-Compact）</strong>: 标记所有存活的对象，然后将所有存活的对象都向一端移动，清理掉边界以外的内存。</li><li><strong>分代收集（Generational Collection）</strong>: 根据对象存活的时间不同，将堆分为几块，如年轻代、老年代，各代使用最适合的收集算法。</li></ul></li><li><strong>触发垃圾回收的条件</strong>:<ul><li>当堆空间不足时，例如创建新对象时没有足够的空间。</li><li>System.gc() 被调用时（注意，这只是建议JVM执行GC，不是强制的）。</li><li>JVM的内存管理策略决定执行。</li></ul></li></ol><blockquote><p>类比：城市清洁</p></blockquote><p>垃圾回收可以比作城市的清洁工作。不再使用的建筑（不可达对象）需要被拆除来腾出空间。城市管理者（垃圾收集器）会定期检查哪些建筑不再被使用，并有计划地进行拆除和清理。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98">https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98</a></li><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></li><li><a href="https://blog.csdn.net/fllow_wind/article/details/117027924">https://blog.csdn.net/fllow_wind/article/details/117027924</a></li><li><a href="https://zhuanlan.zhihu.com/p/25713880">https://zhuanlan.zhihu.com/p/25713880</a></li><li><a href="https://blog.csdn.net/xianyun1992/article/details/126555575">https://blog.csdn.net/xianyun1992/article/details/126555575</a></li><li><a href="https://zhuanlan.zhihu.com/p/626321410">https://zhuanlan.zhihu.com/p/626321410</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes</title>
    <link href="/2024/01/22/Kubernetes/"/>
    <url>/2024/01/22/Kubernetes/</url>
    
    <content type="html"><![CDATA[<blockquote><p>复习一下 docker</p></blockquote><p>docker →  进程隔离 ；操作系统层虚拟化（同一个操作系统下隔离软件环境）</p><p>镜像 image →  容器 Container  →  仓库</p><p>查看容器占用资源：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker status</span><br></code></pre></td></tr></table></figure><p>微服务：负载均衡（多节点，实现高可用，平稳过度）</p><p>将一个整体的服务拆分为多个微服务</p><p>考虑的内容：日志收集（多节点），服务监控，资源服务器分配，判断服务的前置依赖</p><p>上面这些考虑的内容可以通过 K8s 来进行处理。</p><ul><li>K8s: 容器编排系统，用于管理和扩展大规模的容器部署</li><li>Portainer: 容器管理工具，提供了一个易于使用的界面来管理 Docker 和 Kubernetes 资源。</li></ul><h3 id="1、K8s-是什么"><a href="#1、K8s-是什么" class="headerlink" title="1、K8s 是什么"></a>1、K8s 是什么</h3><p>Kubernetes（也称 k8s 或 “kube”）是一个开源的容器编排平台，可以自动化在部署、管理和扩展容器化应用过程中涉及的许多手动操作</p><p>建议阅读文档： </p><ul><li><a href="https://www.kubernetes.org.cn/k8s">https://www.kubernetes.org.cn/k8s</a></li><li><a href="https://kubernetes.io/zh-cn/docs/home/">https://kubernetes.io/zh-cn/docs/home/</a></li></ul><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>docker</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Portainer环境配置</title>
    <link href="/2024/01/21/Portainer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/21/Portainer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础安装"><a href="#1、基础安装" class="headerlink" title="1、基础安装"></a>1、基础安装</h3><p>Portainer 是一个轻量级的管理界面，可以让你轻松地管理不同的Docker环境。Portainer 可以运行作为一个容器，允许你管理容器、镜像、网络等。</p><blockquote><p>拉取最新的 Portainer</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker pull portainer/portainer<br></code></pre></td></tr></table></figure><h3 id="2、安装和启动"><a href="#2、安装和启动" class="headerlink" title="2、安装和启动"></a>2、安装和启动</h3><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d -p 9000:9000 <span class="hljs-attribute">--name</span>=portainer <span class="hljs-attribute">--restart</span>=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer<br></code></pre></td></tr></table></figure><ul><li><code>-d</code>: 后台运行容器。</li><li><code>-p 9000:9000</code>: 将容器的 9000 端口映射到主机的 9000 端口。</li><li><code>--name=portainer</code>: 将容器命名为 portainer。</li><li><code>--restart=always</code>: 确保容器总是重新启动。</li><li><code>-v /var/run/docker.sock:/var/run/docker.sock</code>: 将 Docker 的 Unix socket 映射到容器，允许 Portainer 与本地 Docker 守护进程通信。</li><li><code>-v portainer_data:/data</code>: 将 Portainer 数据存储在名为 portainer_data 的卷中。</li></ul><p>开放一下端口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#开放端口</span><br>firewall-cmd <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=9000/tcp</span> <span class="hljs-params">--permanent</span> <br><span class="hljs-comment"># 重启防火墙 </span><br>firewall-cmd <span class="hljs-params">--reload</span><br><span class="hljs-comment"># 查看开放的端口列表 </span><br>firewall-cmd <span class="hljs-params">--list-port</span><br></code></pre></td></tr></table></figure><h3 id="3、使用"><a href="#3、使用" class="headerlink" title="3、使用"></a>3、使用</h3><p>访问： IP:9000</p><p>建议参考一下这篇文章：</p><ul><li><a href="https://blog.csdn.net/bbwangj/article/details/80973219">https://blog.csdn.net/bbwangj/article/details/80973219</a></li><li><a href="https://articles.zsxq.com/id_7fr6g496c05k.html">https://articles.zsxq.com/id_7fr6g496c05k.html</a></li></ul><p>里面是谈到了一个集群的容器管理，不过如果是单机选择本地就可以。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>docker</tag>
      
      <tag>运维</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_ThreadLocal</title>
    <link href="/2024/01/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_ThreadLocal/"/>
    <url>/2024/01/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_ThreadLocal/</url>
    
    <content type="html"><![CDATA[<p>ThreadLocal 一般是用作独立变量副本（线程的变量副本），避免线程共享变量可能导致的并发问题。</p><p>建议先看一下这篇文章： <a href="https://cloud.tencent.com/developer/article/1636025">https://cloud.tencent.com/developer/article/1636025</a></p><p>ThreadLocal包含了四个方法:</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">void</span> <span class="hljs-built_in">set</span>(<span class="hljs-built_in">Object</span> value)设置当前线程的线程局部变量的值。<br><span class="hljs-keyword">public</span> <span class="hljs-built_in">Object</span> <span class="hljs-built_in">get</span>()该方法返回当前线程所对应的线程局部变量。<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">remove</span>()将当前线程局部变量的值删除，其目的是为了减少内存使用，加快内存回收。<br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">initialValue</span>()返回该线程局部变量的初始值，该方法是一个<span class="hljs-keyword">protected</span>的方法，目的是为了让子类覆盖而设计的。<br></code></pre></td></tr></table></figure><p>使用到 ThreadLocal 的三个常用场景：</p><ul><li><ol><li>代替参数的显示传递</li></ol></li><li><ol start="2"><li>全局存储用户信息</li></ol></li><li><ol start="3"><li>解决线程安全问题（比如数据库连接的Connection)</li></ol></li></ul><p>慎用的场景：线程池中线程调用使用ThreadLocal、异步程序；同时注意的是使用完ThreadLocal ，最好手动调用 remove() 方法。</p><hr><p>关于 ThreadLocal 的数据结构，方法源码，扩容机制等可以看一下这篇文章： <a href="https://javaguide.cn/java/concurrent/threadlocal.html">https://javaguide.cn/java/concurrent/threadlocal.html</a></p><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/threadlocal.html">https://javaguide.cn/java/concurrent/threadlocal.html</a></li><li><a href="https://cloud.tencent.com/developer/article/1636025">https://cloud.tencent.com/developer/article/1636025</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenAi生成式服务微服务应用体系构建_Day01</title>
    <link href="/2024/01/16/OpenAi%E7%94%9F%E6%88%90%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA_Day01/"/>
    <url>/2024/01/16/OpenAi%E7%94%9F%E6%88%90%E5%BC%8F%E6%9C%8D%E5%8A%A1%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E4%BD%93%E7%B3%BB%E6%9E%84%E5%BB%BA_Day01/</url>
    
    <content type="html"><![CDATA[<p>学习文档地址： <a href="https://wx.zsxq.com/dweb2/index/columns/48411118851818">https://wx.zsxq.com/dweb2/index/columns/48411118851818</a></p><p>ChatGLM大模型地址： <a href="https://open.bigmodel.cn/login">https://open.bigmodel.cn/login</a></p><p>项目地址： </p><ul><li><a href="https://gitcode.net/KnowledgePlanet/chatgpt">https://gitcode.net/KnowledgePlanet/chatgpt</a></li><li><a href="https://gitcode.net/KnowledgePlanet/chatgpt/chatgpt-data">https://gitcode.net/KnowledgePlanet/chatgpt/chatgpt-data</a></li></ul><h3 id="1、介绍和使用"><a href="#1、介绍和使用" class="headerlink" title="1、介绍和使用"></a>1、介绍和使用</h3><p>这个项目是属于 知识星球-码农会锁  里面的一个项目 《OpenAi(ChatGPT&#x2F;ChatGLM) 微服务应用体系构建》</p><p>Day01 这一部分的文章内容主要是记录一下相关的学习文档地址和学习内容（建议直接加入一下这个星球去看一下相关文件内容）</p><h4 id="这个项目是做什么的"><a href="#这个项目是做什么的" class="headerlink" title="这个项目是做什么的"></a>这个项目是做什么的</h4><p>这个是一个学习使用 chatgpt&#x2F;chatglm 使用的项目，在调用 大模型语言 第三方接口的基础上，加入了 网关、鉴权认证、微信公众号、企业微信、支付包支付相关的服务，并在此基础上面构建了一套微服务应用体系。</p><p>配置环境是基于 Nginx + Docker ，部署和监控在这个项目中也有使用到</p><h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>先是一下这个项目使用到的技术栈和使用工具</p><p>技术栈：SpringBoot、MyBatis、MySQL、Redis</p><p>开发工具： IntelliJ IDEA、WebStorm、Docker、Protainter、Nginx、Git、Maven、Navicat、SSH工具</p><p>前端：Next.js、Typescript</p><p>开发流程：</p><ul><li><ol><li>基础设置的服务搭建</li></ol></li><li><ol start="2"><li>接口鉴权开发</li></ol></li><li><ol start="3"><li>API-SDK 的开发，网页的简单开发</li></ol></li><li><ol start="4"><li>ChatGPT-WEB-UI -&gt; API-SDK -&gt; 鉴权 -&gt; OpenAI 的使用</li></ol></li><li><ol start="5"><li>ChatGPT-WEB-UI 流程🏃🏻跑通，逐步扩展其他服务模块。让业务与场景结合</li></ol><ul><li>关注公众号、公众号回复、企业微信机器人、交易支付购买授权Token</li><li>让 ChatGPT-WEB-UI 与各个模块结合使用。</li></ul></li></ul><p>推荐工具：</p><ul><li>Termius：云服务器链接工具，自带一套 SFTP 工具，很好用。</li><li>IDEA 插件：Sequence Diagram - 用于方法上右键查看代码流程的，主要帮助大家理解代码。</li><li>Docker - 可本地安装，不需要非得购买云服务器，也可以满足学习诉求。</li><li>natapp - 内网穿透工具，相当于你开启后，可以分配给你一个域名，让外网访问到你的服务</li></ul><p>服务关系图和课程目录</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240118071619.png" alt="image.png"></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240118072039.png" alt="image.png"></p><h4 id="服务解耦思想"><a href="#服务解耦思想" class="headerlink" title="服务解耦思想"></a>服务解耦思想</h4><p>这里使用了一种方式，是将核心的基础物料通过 API 的方式与具体的物料服务模块解，其中物料指SDK和服务；</p><p>项目中具体的做法是将 SDK 项目进行了打包到本地仓库的操作，然后在微服务应用程序中直接引用这个依赖。</p><h3 id="2、项目初步学习"><a href="#2、项目初步学习" class="headerlink" title="2、项目初步学习"></a>2、项目初步学习</h3><p>看这个文档的时候建议还是有自己的一个学习节奏，保持更新迭代自己的文档相关内容，可以将自己的理解输出，尝试使用更简短的语言更新一下之前的内容，并补充一下没有注意到的地方。</p><h4 id="拉取项目操作和上传仓库"><a href="#拉取项目操作和上传仓库" class="headerlink" title="拉取项目操作和上传仓库"></a>拉取项目操作和上传仓库</h4><blockquote><p>push 工程到仓库</p></blockquote><p>文档地址： <a href="https://articles.zsxq.com/id_z9wh4hsg21dn.html">https://articles.zsxq.com/id_z9wh4hsg21dn.html</a></p><p>进入到： <a href="https://gitcode.net/CreativeAlliance">https://gitcode.net/CreativeAlliance</a></p><p>创建一个新的仓库： chatgpt-dev-ops-10863-lq</p><p>拉取这个项目到本地，然后用 IDEA打开并提交</p><p>命令行指引</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240119205949.png" alt="image.png"></p><p>推送现有的 Git 仓库</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs maxima">cd existing_repo<br>git remote <span class="hljs-built_in">rename</span> <span class="hljs-built_in">origin</span> old-<span class="hljs-built_in">origin</span><br>git remote add <span class="hljs-built_in">origin</span> https://gitcode.net/CreativeAlliance/chatgpt-dev-ops-<span class="hljs-number">10863</span>-lq.git<br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> --all<br>git <span class="hljs-built_in">push</span> -u <span class="hljs-built_in">origin</span> --tags<br></code></pre></td></tr></table></figure><p>推送现有文件夹</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">cd</span> existing_folder<br><span class="hljs-symbol">git</span> init<br><span class="hljs-symbol">git</span> remote <span class="hljs-keyword">add</span> origin https:<span class="hljs-comment">//gitcode.net/CreativeAlliance/chatgpt-dev-ops-10863-lq.git</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">add</span> .<br><span class="hljs-symbol">git</span> commit -m <span class="hljs-string">&quot;Initial commit&quot;</span><br><span class="hljs-symbol">git</span> <span class="hljs-keyword">push</span> -u origin master<br></code></pre></td></tr></table></figure><p>gitcode 的登陆方是需要 CSDN 的账号密码。</p><hr><h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p>Docker 安装使用</p><p>Portainer 环境配置</p><p>Nginx 环境配置： <a href="https://articles.zsxq.com/id_1lcdsxia3ld3.html">https://articles.zsxq.com/id_1lcdsxia3ld3.html</a></p><p>安装操作: [[Docker入门_Docker的基本使用#6、docker 安装 nginx]]</p><p>Nginx 的使用包括的配置有；配置、首页、日志、SSL等，而这些内容在默认基础安装的情况下，都是在 Docker 容器中的，不容易被管理和使用。所以一般我们在安装 Nginx 的时候是需要做映射处理。这个时候我们可以把在 Docker 上安装的 Nginx 配置信息拷贝到本地，之后做一些修改后，再去重新执行 Nginx 的安装【重新安装前记得把之前的 Nginx 删掉】。</p><p>常用命令:</p><ol><li>停止：docker stop Nginx</li><li>重启：docker restart Nginx</li><li>删除服务：docker rm Nginx</li><li>删除镜像：docker rmi Nginx</li><li>进入服务：docker exec -it Nginx &#x2F;bin&#x2F;bash</li></ol><p>其他:</p><ol><li>查看配置：ls &#x2F;etc&#x2F;nginx&#x2F;</li><li>查看页面：ls &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</li><li>其他说明：conf.d 是个文件夹</li></ol><p>这个 Portainer 控制台的使用可以看一下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240127222958.png" alt="image.png"></p><h4 id="API工程搭建"><a href="#API工程搭建" class="headerlink" title="API工程搭建"></a>API工程搭建</h4><h5 id="简单访问认证"><a href="#简单访问认证" class="headerlink" title="简单访问认证"></a>简单访问认证</h5><p>流程设计：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291538617.png" alt="image.png"></p><p>实现效果：以用户视角访问API开始，进入 Nginx 的 auth 认证模块，调用 SpringBoot 提供的认证服务。根据认证结果调用重定向到对应的 API 接口或者 404 页面。</p><blockquote><p>代码实现</p></blockquote><ol><li>在 Application 中提供了2个接口，一个认证，一个成功。</li><li>在 verify 接口中，如果 <code>token == success 就返回 HttpStatus.OK == 200 的码，否则返回 HttpStatus.BAD_REQUEST == 400</code> 错误码</li></ol><p>Application</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Logger</span> logger = <span class="hljs-title class_">LoggerFactory</span>.<span class="hljs-title function_">getLogger</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/verify&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ResponseEntity</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">verify</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> token</span>) &#123;<br>        logger.<span class="hljs-title function_">info</span>(<span class="hljs-string">&quot;验证 token：&#123;&#125;&quot;</span>, token);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;success&quot;</span>.<span class="hljs-title function_">equals</span>(token))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">status</span>(<span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">OK</span>).<span class="hljs-title function_">build</span>();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">ResponseEntity</span>.<span class="hljs-title function_">status</span>(<span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">BAD_REQUEST</span>).<span class="hljs-title function_">build</span>();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/success&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">success</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;test success by xfg&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx 配置</p><ol><li>用户访问 <a href="http://localhost/api">http://localhost/api</a> 目标是到 <code>http://192.168.1.101:8080/success</code> 但这里添加了 auth 模块，所以会先进入 auth 的处理。</li><li>&#x3D;  <code>auth 是绝对匹配，没有 = 号就是前缀匹配。在 auth 中把请求 api 的参数获取到在访问到验证地址 http://192.168.1.101:8080/verify?$query</code> 如果接口返回一个200的码就通过，其他的码就失败。</li></ol><p>改动 Nginx conf.d&#x2F;default.conf 文件，添加 auth 认证模块</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">server &#123;<br><br>    listen       <span class="hljs-number">80</span>;<br>    server_name  <span class="hljs-number">192.168</span>.<span class="hljs-number">1.101</span>;<br><br>    <span class="hljs-comment"># 首页</span><br>    index index.html;<br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">        root</span>   /usr/share/nginx/html;<br>        index  index.html index.htm;<br>    &#125;<br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">/api</span>/ &#123;<br>        auth_request /auth;<br>        <span class="hljs-comment"># 鉴权通过后的处理方式</span><br>        proxy_pass http://<span class="hljs-number">192.168</span>.<span class="hljs-number">1.101</span>:<span class="hljs-number">8080</span>/success;<br>    &#125;<br><br>    <span class="hljs-keyword">location</span> <span class="hljs-title">= /auth</span> &#123;<br>        <span class="hljs-comment"># 发送子请求到HTTP服务，验证客户端的凭据，返回响应码</span><br>        internal;<br>        <span class="hljs-comment"># 设置参数</span><br>        set $query &#x27;&#x27;;<br>        if ($request_uri ~* <span class="hljs-string">&quot;[^\?]+\?(.*)$&quot;</span>) &#123;<br>            set $query $<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-comment"># 验证成功，返回200 OK</span><br>        proxy_pass http://<span class="hljs-number">192.168</span>.<span class="hljs-number">1.101</span>:<span class="hljs-number">8080</span>/verify?$query;<br>        <span class="hljs-comment"># 发送原始请求</span><br>        proxy_pass_request_body off;<br>        <span class="hljs-comment"># 清空 Content-Type</span><br>        proxy_set_header Content-<span class="hljs-keyword">Type</span> <span class="hljs-string">&quot;&quot;</span>;<br>     &#125;<br><br>    error_page <span class="hljs-number">404</span> /<span class="hljs-number">404</span>.html;<br>        <span class="hljs-keyword">location</span> <span class="hljs-title">= /40x</span>.html &#123;<br><br>        &#125;<br><br>    error_page   <span class="hljs-number">500</span> <span class="hljs-number">502</span> <span class="hljs-number">503</span> <span class="hljs-number">504</span>  /<span class="hljs-number">50</span>x.html;<br>     <span class="hljs-keyword">location</span> <span class="hljs-title">= /50x</span>.html &#123;<br>     &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Shiro登录授权发放访问token"><a href="#Shiro登录授权发放访问token" class="headerlink" title="Shiro登录授权发放访问token"></a>Shiro登录授权发放访问token</h5><p>需要去看一下相关的代码和进行整理，这里主要阅读一下相关的课程文章并推进进度。</p><p>这里是先实现一个效果： 验证通过后发放 Token，之后再使用 Token 访问 OpenAI 地址。</p><p>本章是在 SpringBoot 项目中引入进来 Shiro、JWT，从而进行处理。</p><p>代码内容待后续分析</p><blockquote><p>项目结构</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291605000.png" alt="image.png|400"></p><ol><li>JwtToken：Token 的对象信息，你可以设置用户ID、用户密码</li><li>JwtRealm：一个自定义的验证服务，需要继承 AuthorizingRealm 类。</li><li>JwtFilter：自定义的 Filter 过滤器。</li><li>JwtUtil：token的创建、解析、验证工具类。</li><li>ShiroConfig：Shiro 的一个配置启动类。</li><li>ApiAccessController：新增加的API访问准入管理；当访问 OpenAI 接口时，需要进行准入验证。</li></ol><hr><p>后续看一下这些代码，大概的一个思路是：</p><p>当登录的时候校验通过，然后返回一个授权 token ；后续登录的时候通过解析这个 token 判断是否有对应权限操作。</p><p>看一下这篇课程文章： <a href="https://articles.zsxq.com/id_0843dvwa4j2i.html">https://articles.zsxq.com/id_0843dvwa4j2i.html</a></p><p>登录这方面的内容建议单独开一个单章去理解一下流行的一些技术和实现思路。</p><h5 id="chatgpt-api-项目"><a href="#chatgpt-api-项目" class="headerlink" title="chatgpt-api 项目"></a>chatgpt-api 项目</h5><p>项目地址： <a href="https://gitcode.net/KnowledgePlanet/chatgpt/chatgpt-api">https://gitcode.net/KnowledgePlanet/chatgpt/chatgpt-api</a></p><p>to be contined….</p><h4 id="服务镜像构建和容器部署"><a href="#服务镜像构建和容器部署" class="headerlink" title="服务镜像构建和容器部署"></a>服务镜像构建和容器部署</h4><p>参考： <a href="https://articles.zsxq.com/id_q9d1o7nvj5nb.html">https://articles.zsxq.com/id_q9d1o7nvj5nb.html</a></p><p>这一章的实现功能： 将上一章的实现的简易项目构建工程项目并推送到 Docker 仓库。</p><p>流程说明： 在工程中添加 Dockerfile 配置文件，对工程进行镜像打包。并把工程推送到本地和远程 Docker 仓库进行部署验证。</p><p>本地的 Docker 直接在 IDEA 配置即可启动，远程的服务仓库一种是配置开启2375端口，另外一种把镜像文件推送到 <a href="https://hub.docker.com/">https://hub.docker.com</a> 再通过拉取的方式使用</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291634686.png" alt="image.png"></p><p>看一下课程文件，然后实际操作一下： <a href="https://articles.zsxq.com/id_q9d1o7nvj5nb.html">https://articles.zsxq.com/id_q9d1o7nvj5nb.html</a></p><p>难度应该比较小，需要实际去跑一下。to be contined…</p><hr><h4 id="ChatGPT-SDK组件工程简单功能实现"><a href="#ChatGPT-SDK组件工程简单功能实现" class="headerlink" title="ChatGPT-SDK组件工程简单功能实现"></a>ChatGPT-SDK组件工程简单功能实现</h4><p>地址： <a href="https://articles.zsxq.com/id_637o58swvzwv.html">https://articles.zsxq.com/id_637o58swvzwv.html</a></p><p>实现效果： 搭建一个 ChatGPT-SDK 组件工程，专门用于封装对 OpenAI 接口的使用。</p><p>流程设计：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401291645971.png" alt="image.png"></p><h3 id="3、项目内容学习"><a href="#3、项目内容学习" class="headerlink" title="3、项目内容学习"></a>3、项目内容学习</h3><p>将课程文档对应的链接放一下，后续实际使用和学习到的时候用一下。</p><ul><li>微信公众号验签和初步对接OpenAI<ul><li>地址： <a href="https://articles.zsxq.com/id_e9r7rfv308px.html">https://articles.zsxq.com/id_e9r7rfv308px.html</a></li><li>跟之前自己做的 [[ChatGPT问答助手]]  里面部分内容差不多，实现过程类似。</li></ul></li><li>流式应答会话设计实现<ul><li>地址： <a href="https://articles.zsxq.com/id_4r1ifost3bhh.html">https://articles.zsxq.com/id_4r1ifost3bhh.html</a></li><li>功能效果： 丰富 OpenAiSession 会话服务接口，增加流式回答的事件监听处理。</li></ul></li><li>gpt-sdk 完善实现各类常用接口<ul><li>地址： <a href="https://articles.zsxq.com/id_hif1r28gp3i4.html">https://articles.zsxq.com/id_hif1r28gp3i4.html</a></li><li>实现效果： 实现 gpt 官网的一些其他接口功能</li></ul></li><li>学习文档地址： <a href="https://wx.zsxq.com/dweb2/index/columns/48411118851818">https://wx.zsxq.com/dweb2/index/columns/48411118851818</a></li><li>1、前端项目构建<ul><li>Web页面工程初始化<ul><li>地址： <a href="https://articles.zsxq.com/id_t56b7jqr7a95.html">https://articles.zsxq.com/id_t56b7jqr7a95.html</a></li></ul></li><li>工具栏面板<ul><li>地址： <a href="https://articles.zsxq.com/id_7oetre5ef0wo.html">https://articles.zsxq.com/id_7oetre5ef0wo.html</a></li><li>按钮定义与事件实现</li><li>地址： <a href="https://articles.zsxq.com/id_eosfsi8mkzw3.html">https://articles.zsxq.com/id_eosfsi8mkzw3.html</a></li></ul></li><li>对话框列表<ul><li>地址： <a href="https://articles.zsxq.com/id_13if2wn4jhlg.html">https://articles.zsxq.com/id_13if2wn4jhlg.html</a></li></ul></li><li>对话框消息<ul><li>地址： <a href="https://articles.zsxq.com/id_57ho2v2ol52r.html">https://articles.zsxq.com/id_57ho2v2ol52r.html</a></li></ul></li><li>完善对话处理<ul><li>地址： <a href="https://articles.zsxq.com/id_vux657zw1e0c.html">https://articles.zsxq.com/id_vux657zw1e0c.html</a></li></ul></li><li>对话角色设定<ul><li>地址： <a href="https://articles.zsxq.com/id_44wg8c8os2o2.html">https://articles.zsxq.com/id_44wg8c8os2o2.html</a></li></ul></li></ul></li><li>2、工程重构和流式异步响应接口实现<ul><li>地址： <a href="https://articles.zsxq.com/id_cnp0sxnfmpww.html">https://articles.zsxq.com/id_cnp0sxnfmpww.html</a></li></ul></li><li>3、流式接口对接<br>  地址：  <a href="https://articles.zsxq.com/id_ifllevif6p6i.html">https://articles.zsxq.com/id_ifllevif6p6i.html</a></li><li>4、公众号发送验证码鉴权登录<ul><li>地址：  <a href="https://articles.zsxq.com/id_kt4oql6efmmo.html">https://articles.zsxq.com/id_kt4oql6efmmo.html</a></li></ul></li><li>5、公众号扫码登录<ul><li>地址： <a href="https://articles.zsxq.com/id_a89dt3lfkm83.html">https://articles.zsxq.com/id_a89dt3lfkm83.html</a></li></ul></li><li>6、前后端构建镜像部署<ul><li>地址： <a href="https://articles.zsxq.com/id_soxvwros9icn.html">https://articles.zsxq.com/id_soxvwros9icn.html</a></li></ul></li><li>7、网站添加百度统计<ul><li>地址：  <a href="https://articles.zsxq.com/id_54o9ezlrnd8w.html">https://articles.zsxq.com/id_54o9ezlrnd8w.html</a></li></ul></li><li>chatgpt-api 白名单和敏感词规则过滤<ul><li>地址：  <a href="https://articles.zsxq.com/id_w35g7d56q72z.html">https://articles.zsxq.com/id_w35g7d56q72z.html</a></li></ul></li><li>chatgpt-sdk  支持多渠道对话<ul><li>地址：  <a href="https://articles.zsxq.com/id_j8cowvswwzgh.html">https://articles.zsxq.com/id_j8cowvswwzgh.html</a></li></ul></li><li>用户额度账户的校验领域实现<ul><li>地址： <a href="https://articles.zsxq.com/id_6en8ra41apnw.html">https://articles.zsxq.com/id_6en8ra41apnw.html</a></li></ul></li><li>商品下单对接微信支付<ul><li>地址：  <a href="https://articles.zsxq.com/id_z7jj23ml1eum.html">https://articles.zsxq.com/id_z7jj23ml1eum.html</a></li></ul></li><li>商品支付页<ul><li>地址：  <a href="https://articles.zsxq.com/id_twprn855gkwg.html">https://articles.zsxq.com/id_twprn855gkwg.html</a></li></ul></li><li>OpenAi多渠道策略模式<ul><li>地址：  <a href="https://articles.zsxq.com/id_hmjpsiji69lb.html">https://articles.zsxq.com/id_hmjpsiji69lb.html</a></li></ul></li><li>应用监控(Prometheus + Grafana)<ul><li>地址：  <a href="https://articles.zsxq.com/id_lai3vqzlp2pr.html">https://articles.zsxq.com/id_lai3vqzlp2pr.html</a></li></ul></li><li>应用分布式设计<ul><li>地址：  <a href="https://articles.zsxq.com/id_9smix85x3e3e.html">https://articles.zsxq.com/id_9smix85x3e3e.html</a></li></ul></li><li>整体部署上线<ul><li>地址： <a href="https://wx.zsxq.com/dweb2/index/topic_detail/188414845252452">https://wx.zsxq.com/dweb2/index/topic_detail/188414845252452</a></li></ul></li><li>dall-e 文生图<ul><li>地址：  <a href="https://wx.zsxq.com/dweb2/index/topic_detail/588581121148184">https://wx.zsxq.com/dweb2/index/topic_detail/588581121148184</a></li></ul></li></ul><p>to be contined….</p><p>后续内容麻烦看一下 [[OpenAi生成式服务微服务应用体系构建_Day02]] 相关的内容。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_线程池</title>
    <link href="/2024/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2024/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<p>概述：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401161011272.png" alt="image.png"></p><hr><p>个人仍然是推崇看一下JavaGuide的博客内容，然后辅助查阅一些资料去学习，同时辅助一些代码编程去理解。</p><p>博客地址： <a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></p><p>可以直接从第二章内容开始看。</p><h3 id="1、什么是线程池"><a href="#1、什么是线程池" class="headerlink" title="1、什么是线程池"></a>1、什么是线程池</h3><h4 id="使用线程池的好处"><a href="#使用线程池的好处" class="headerlink" title="使用线程池的好处"></a>使用线程池的好处</h4><p>类似数据库的连接池，能够有效减少线程的一些不必要的资源损耗（比如创建和销毁）；</p><p>在高并发情况下，针对一些短期异步任务，建议使用线程池；</p><p>可以看一下这个区别：</p><p>直接使用线程的情况</p><ol><li><strong>简单或单次任务</strong>：对于一些简单的或只需执行一次的多线程任务，直接创建线程可能更为直接和简单。</li><li><strong>精细控制</strong>：如果需要对每个线程的创建、启动、运行和销毁过程有更精细的控制，直接使用线程可能更合适。</li><li><strong>特定行为</strong>：某些特定的行为可能需要单独的线程，例如长时间运行的监听线程等。</li></ol><p>使用线程池的情况</p><ol><li><strong>大量短期任务</strong>：对于大量的短期异步任务，使用线程池可以显著减少线程创建和销毁的开销。</li><li><strong>资源管理</strong>：线程池可以有效地管理线程资源，避免因为过多线程而导致的资源耗尽问题。</li><li><strong>性能提升</strong>：在高负载的应用程序中，线程池可以通过重用现有线程提高性能。</li><li><strong>负载平衡</strong>：线程池可以平衡任务负载，确保线程的有效利用。</li><li><strong>任务队列和调度</strong>：线程池提供任务队列和调度功能，可以控制任务的执行顺序，同时提供定时执行和周期性执行等功能。</li></ol><hr><p>从这个定义中看一般在多线程的情况下，直接使用线程是在特定行为的情况下（监听线程等），其他情况考虑资源消耗和线程管理，建议使用线程池（尤其是在执行大量短期异步任务时）。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h4><p>看一下 Java 线程池 的一些基本定义和介绍：</p><p>Java中的线程池是一种执行任务的框架，它用于减少在创建和销毁线程时所花费的时间和资源。线程池在执行大量短期异步任务时尤其有用，因为它可以显著提高程序性能。在Java中，线程池主要是通过<code>java.util.concurrent</code>包中的<code>Executor</code>框架实现的。</p><p>线程池的关键概念</p><ol><li><strong>线程池（ThreadPool）</strong>：线程池是一组工作线程，它们负责从任务队列中获取并执行任务。</li><li><strong>任务（Task）</strong>：提交给线程池的工作单元，通常是实现了<code>Runnable</code>或<code>Callable</code>接口的对象。</li><li><strong>Executor框架</strong>：这个框架提供了管理线程池的工具，包括创建线程池、提交任务和管理线程池的生命周期。</li></ol><p><strong>线程池的主要类型</strong></p><ol><li><strong>FixedThreadPool</strong>：拥有固定数量线程的线程池。如果所有线程都在工作，新任务将在队列中等待。</li><li><strong>CachedThreadPool</strong>：一个可以根据需要创建新线程的线程池，但如果线程在一定时间内未使用，将被回收。</li><li><strong>SingleThreadExecutor</strong>：只有一个线程的线程池，它保证所有任务按照提交的顺序依次执行。</li><li><strong>ScheduledThreadPool</strong>：一个能够安排任务在给定延迟后执行，或定期执行的线程池。</li></ol><p><strong>使用线程池的好处</strong></p><ol><li><strong>提高资源利用率</strong>：通过重用现有线程减少线程创建和销毁的开销。</li><li><strong>提高响应速度</strong>：任务不需要等待线程创建就可以立即执行。</li><li><strong>提供更好的线程管理</strong>：可以根据系统的资源情况调整线程池的大小。</li><li><strong>提供任务队列和执行策略</strong>：可以根据需求管理和优化任务的执行顺序。</li></ol><blockquote><p>如何使用</p></blockquote><p>以下是一个使用<code>ExecutorService</code>创建固定大小线程池的简单示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.concurrent.ExecutorService;<br><span class="hljs-keyword">import</span> java.util.concurrent.Executors;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPoolExample</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-comment">// 创建拥有固定数量线程的线程池</span><br>        <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br><br>        <span class="hljs-comment">// 提交任务给线程池</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Task</span>();<br>            executor.execute(task);<br>        &#125;<br><br>        <span class="hljs-comment">// 关闭线程池</span><br>        executor.shutdown();<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-comment">// 任务代码</span><br>            System.out.println(<span class="hljs-string">&quot;Executing task in &quot;</span> + Thread.currentThread().getName());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项</p></blockquote><ul><li>在使用完线程池后，应该调用<code>shutdown()</code>方法来关闭线程池，否则程序可能不会终止。</li></ul><p>应当合理配置线程池的大小，过大的线程池可能会消耗过多资源，过小则无法充分利用系统资源。</p><ul><li>在处理IO密集型任务时，可以配置比CPU核心数更多的线程，因为IO操作不会一直占用CPU。</li><li>使用线程池时，应该注意任务提交和执行过程中可能出现的异常，并合理处理这些异常。</li><li>对于定时或周期性任务，<code>ScheduledThreadPoolExecutor</code>提供了灵活的调度选项。</li></ul><p>总之，线程池在Java多线程编程中是一个非常重要的组件，它不仅能提高程序性能，还能提供更好的资源管理和更简洁的编程模型。正确使用线程池对于构建高效、稳定且可伸缩的Java应用至关重要。</p><p>这个例子感觉并不是很好，这里是使用 Executors 工具类来进行创建的一个线程池内部类。</p><p>在 JavaGuide 中提及到，阿里是建议大家都使用  <strong>通过<code>ThreadPoolExecutor</code>构造函数来创建</strong> 线程池，使用工具类 Executors 来创建的话，容易造成资源耗时（如果使用不当）。</p><p>这里的 ThreadPool 和 Task 不用太过于理解，你可以辅助去理解  Executor 框架的一个运行，通过它去引申一些内容，从而对整个线程池的内容有更好的使用和理解。</p><p>因此这一篇文章的内容第一章节的内容可以跳过看，并没有太重要。</p><p>扩展的一些内容概念：</p><h4 id="ThreadPool"><a href="#ThreadPool" class="headerlink" title="ThreadPool"></a>ThreadPool</h4><p><code>ThreadPool</code>（线程池）在Java中是通过<code>java.util.concurrent</code>包中的<code>Executor</code>框架实现的。</p><p>再介绍一些基本概念</p><ol><li><strong>Executor和ExecutorService</strong>：<ul><li><code>Executor</code>是基础的接口，它提供了提交任务的方法。</li><li><code>ExecutorService</code>是更完整的接口，它继承自<code>Executor</code>，提供了更复杂的功能，如管理线程池的生命周期。</li></ul></li><li><strong>任务类型</strong>：<ul><li><code>Runnable</code>：一个不返回结果的任务。</li><li><code>Callable</code>：一个可以返回结果的任务。</li></ul></li></ol><p><code>ThreadPool</code>的一些基本用法：</p><ol><li><strong>创建线程池</strong>：<ul><li>你可以使用<code>Executors</code>类中的静态工厂方法来创建不同类型的线程池，如<code>newFixedThreadPool</code>、<code>newCachedThreadPool</code>、<code>newSingleThreadExecutor</code>等。</li></ul></li><li><strong>提交任务</strong>：<ul><li>使用<code>execute(Runnable)</code>方法提交不返回结果的任务。</li><li>使用<code>submit(Callable)</code>或<code>submit(Runnable)</code>方法提交返回结果的任务。</li></ul></li><li><strong>关闭线程池</strong>：<ul><li>使用<code>shutdown()</code>方法来关闭线程池。这个方法不会立即关闭线程池，而是不再接受新任务，等待所有已提交的任务执行完毕后关闭。</li><li>如果需要立即关闭线程池，可以使用<code>shutdownNow()</code>，但这会尝试停止正在执行的任务，并返回等待执行的任务列表。</li></ul></li></ol><h4 id="Task"><a href="#Task" class="headerlink" title="Task"></a>Task</h4><p><code>Task</code>是一个用于执行具有返回值的异步计算的抽象概念。</p><p>在线程池这里主要是要引入<code>java.util.concurrent</code>包中的<code>Callable</code>接口与<code>Future</code>类；</p><p>他们两个的使用代表着<code>Task</code>的核心概念。</p><h5 id="Callable"><a href="#Callable" class="headerlink" title="Callable"></a>Callable</h5><p><code>Callable</code>是一个接口，与<code>Runnable</code>相似，但它可以返回一个结果，并能抛出异常。<code>Callable</code>通常用于那些需要返回结果的任务。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">Callable&lt;Integer&gt; task = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 执行一些计算<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">123</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><h5 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h5><p>当你提交一个<code>Callable</code>任务给线程池执行时，你会得到一个<code>Future</code>对象。</p><p><code>Future</code>代表了异步计算的结果，它提供了检查计算是否完成的方法，并且能够获取计算的结果。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ExecutorService executor <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">1</span>)<span class="hljs-comment">;</span><br>Future&lt;Integer&gt; future <span class="hljs-operator">=</span> executor.submit(task)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>具体可以看一下实际使用，能够对这两个概念有比较明确的理解。</p><p>Executor 框架 的内容可以看下一章节的内容。</p><h3 id="2、Executor-框架介绍"><a href="#2、Executor-框架介绍" class="headerlink" title="2、Executor 框架介绍"></a>2、Executor 框架介绍</h3><p>在Java中，线程池主要是通过<code>java.util.concurrent</code>包中的<code>Executor</code>框架实现的。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>这个框架的作用就是简化并发编程，提供了线程池的实现。</p><p>介绍：</p><p>在Java中，<code>Executor</code>是一个接口，它代表了执行提供的任务的对象。它是<code>java.util.concurrent</code>包中的一部分，用于提供一种将任务的提交与每个任务的执行方式分离的机制。</p><p>在 JavaGuide 提及到 Executor 框架能够避免 this 逃匿，目前不是太了解这个概念，有兴趣可以了解下。</p><blockquote><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p></blockquote><blockquote><p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p><strong>下面这个是比较重点的一个内容</strong>，可以重点看一下（直接引入了JavaGuide 的一些内容进行阐述）</p><p> Executor 框架 三大部分组成</p><ul><li><strong>任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</strong><ul><li>执行任务需要实现的 <strong><code>Runnable</code> 接口</strong> 或 <strong><code>Callable</code>接口</strong>。</li><li><strong><code>Runnable</code> 接口</strong>或 <strong><code>Callable</code> 接口</strong> 实现类都可以被 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。</li></ul></li><li><strong>任务的执行(<code>Executor</code>)</strong></li><li><strong>异步计算的结果(<code>Future</code>)</strong><ul><li><strong><code>Future</code></strong> 接口以及 <code>Future</code> 接口的实现类 <strong><code>FutureTask</code></strong> 类都可以代表异步计算的结果。</li><li>当我们把 <strong><code>Runnable</code>接口</strong> 或 <strong><code>Callable</code> 接口</strong> 的实现类提交给 <strong><code>ThreadPoolExecutor</code></strong> 或 <strong><code>ScheduledThreadPoolExecutor</code></strong> 执行。（调用 <code>submit()</code> 方法时会返回一个 <strong><code>FutureTask</code></strong> 对象）</li></ul></li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401160931282.png" alt="image.png"></p><blockquote><p><strong>任务的执行(<code>Executor</code>)</strong></p></blockquote><p>如下图所示，包括任务执行机制的核心接口 <strong><code>Executor</code></strong> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。</p><p><code>ThreadPoolExecutor</code> 和 <strong><code>ScheduledThreadPoolExecutor</code></strong> 这两个关键类实现了 <strong><code>ExecutorService</code></strong> 接口</p><p>其中我们可以将更多的一个注意力放在 <code>ThreadPoolExecutor</code> 这个类中。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219213228.png" alt="image.png"></p><h4 id="Executor框架使用流程"><a href="#Executor框架使用流程" class="headerlink" title="Executor框架使用流程"></a><code>Executor</code>框架使用流程</h4><p>使用流程如下：</p><blockquote><ol><li>创建任务对象</li></ol></blockquote><p>首先，您需要创建一个任务对象。这可以是实现了<code>Runnable</code>接口的类，或者是实现了<code>Callable</code>接口的类。<code>Runnable</code>和<code>Callable</code>的区别在于：</p><ul><li><strong>Runnable</strong>：不返回结果，也不能抛出经过检查的异常。</li><li><strong>Callable</strong>：可以返回结果，并且能抛出异常。</li></ul><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">Runnable runnableTask = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 执行一些操作<br>&#125;;<br><br>Callable&lt;<span class="hljs-built_in">String</span>&gt; callableTask = <span class="hljs-function"><span class="hljs-params">()</span> -&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 执行一些操作，并返回结果<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Result&quot;</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li>创建ExecutorService并提交任务</li></ol></blockquote><p>然后，您需要创建一个<code>ExecutorService</code>，它是一个线程池服务，用于管理和执行任务。您可以通过<code>Executors</code>工具类创建不同类型的<code>ExecutorService</code>（不推荐）。</p><p>提交任务有两种方式：</p><ul><li>execute(Runnable command) ：用于提交不需要返回结果的<code>Runnable</code>任务。</li><li><strong>submit(Runnable task)</strong> 或 submit(Callable&lt; T &gt; task) ：用于提交<code>Runnable</code>或<code>Callable</code>任务。这将返回一个<code>Future</code>对象，您可以用它来检查任务是否完成，并获取<code>Callable</code>任务的结果。</li></ul><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ExecutorService executorService <span class="hljs-operator">=</span> Executors.newFixedThreadPool(<span class="hljs-number">4</span>)<span class="hljs-comment">;</span><br><br>// 使用execute方法提交Runnable任务<br>executorService.execute(runnableTask)<span class="hljs-comment">;</span><br><br>// 使用submit方法提交Callable任务，并获取Future对象<br>Future&lt;String&gt; future <span class="hljs-operator">=</span> executorService.submit(callableTask)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>获取任务结果</li></ol></blockquote><p>如果您提交的是<code>Callable</code>任务并使用了<code>submit</code>方法，您将获得一个<code>Future</code>对象。您可以通过这个对象获取任务的结果：</p><ul><li><strong>get()方法</strong>：调用<code>get()</code>会阻塞当前线程直到任务完成，并返回结果。</li><li>cancel(boolean mayInterruptIfRunning)：如果需要，您可以取消任务的执行。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-built_in">String</span> result = future.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 等待任务完成并获取结果</span><br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException | ExecutionException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>关闭ExecutorService</li></ol></blockquote><p>最后，当您不再需要线程池时，应该关闭<code>ExecutorService</code>。这可以防止新任务被提交，并允许已提交的任务完成。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">executorService.shutdown()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><p>使用<code>Executor</code>框架的流程大致如下：</p><ol><li>创建实现<code>Runnable</code>或<code>Callable</code>接口的任务对象。</li><li>创建<code>ExecutorService</code>并通过<code>execute</code>或<code>submit</code>提交任务。</li><li>（可选）如果使用了<code>submit</code>提交<code>Callable</code>任务，可以通过返回的<code>Future</code>对象获取结果。</li><li>关闭<code>ExecutorService</code>。</li></ol><p>这种方式的好处在于它提供了一种灵活且强大的机制来管理线程和执行并发任务，同时也简化了线程的使用和资源管理。</p><p>通过使用线程池，可以避免创建过多的线程，从而提高应用程序的性能和响应速度。</p><h4 id="扩充概念"><a href="#扩充概念" class="headerlink" title="扩充概念"></a>扩充概念</h4><h5 id="Executors"><a href="#Executors" class="headerlink" title="Executors"></a>Executors</h5><ol><li><strong>Executor接口</strong>：<ul><li><code>Executor</code>接口定义了一个<code>execute(Runnable command)</code>方法，用于在未来某个时间执行给定的命令（任务）。</li></ul></li><li><strong>ExecutorService接口</strong>：<ul><li><code>ExecutorService</code>是一个更复杂的接口，继承自<code>Executor</code>。它提供了更多的功能，如任务提交、关闭线程池、跟踪任务的完成等。</li></ul></li><li><strong>Executors工具类</strong>：<ul><li><code>Executors</code>是一个工具类，提供了用于创建不同类型线程池的工厂方法。</li></ul></li></ol><h5 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h5><ol><li><strong>FixedThreadPool</strong>：<ul><li>创建一个固定大小的线程池。当所有线程都在活动时，新任务将在队列中等待。</li></ul></li><li><strong>CachedThreadPool</strong>：<ul><li>创建一个可根据需要创建新线程的线程池。如果线程在一定时间内空闲，则会被回收。</li></ul></li><li><strong>SingleThreadExecutor</strong>：<ul><li>创建一个单线程的执行器，它用唯一的工作线程来执行任务，确保所有任务按照提交顺序依次执行。</li></ul></li><li><strong>ScheduledThreadPool</strong>：<ul><li>创建一个线程池，它可以安排命令在给定的延迟后运行，或者定期执行。</li></ul></li></ol><p>这种类型记忆内容建议使用思维导图 + 小黄鸭的方式记忆，并且定期回顾。</p><h3 id="3、ThreadPoolExecutor-类使用-★"><a href="#3、ThreadPoolExecutor-类使用-★" class="headerlink" title="3、ThreadPoolExecutor 类使用 ★"></a>3、ThreadPoolExecutor 类使用 ★</h3><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ThreadPoolExecutor(int corePoolSize,     <span class="hljs-comment">//线程池的核心线程数量</span><br>                          int maximumPoolSize,  <span class="hljs-comment">//线程池的最大线程数</span><br>                          long keepAliveTime,   <span class="hljs-comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br>                          TimeUnit unit,        <span class="hljs-comment">//时间单位</span><br>                          BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">//任务队列，用来储存等待执行任务的队列</span><br>                          ThreadFactory threadFactory,       <span class="hljs-comment">//线程工厂，用来创建线程，一般默认即可</span><br>                          RejectedExecutionHandler handler  <span class="hljs-comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br>  )&#123;<br>    <span class="hljs-comment">// 参数检查：核心线程数不能小于0，最大线程数不能小于或等于0，最大线程数不能小于核心线程数，keepAliveTime不能小于0</span><br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException();<br><br>    <span class="hljs-comment">// 参数检查：工作队列、线程工厂和拒绝策略不能为null</span><br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> new NullPointerException();<br><br>    <span class="hljs-comment">// 获取安全管理器的上下文，这是Java安全模型的一部分</span><br>    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?<br>            <span class="hljs-literal">null</span> :<br>            AccessController.getContext();<br><br>    <span class="hljs-comment">// 设置线程池的核心线程数</span><br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br><br>    <span class="hljs-comment">// 设置线程池的最大线程数</span><br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br><br>    <span class="hljs-comment">// 设置工作队列</span><br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br><br>    <span class="hljs-comment">// 设置线程保持活动的时间，单位转换为纳秒</span><br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><br>    <span class="hljs-comment">// 设置线程工厂，用于创建新线程</span><br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br><br>    <span class="hljs-comment">// 设置拒绝策略，当线程池不能接受任务时使用</span><br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h5><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240116002651.png" alt="image.png"></p><h5 id="饱和策略"><a href="#饱和策略" class="headerlink" title="饱和策略"></a>饱和策略</h5><p><code>ThreadPoolExecutor</code>的饱和策略（RejectedExecutionHandler）是一种用于处理在任务队列已满且当前运行的线程数量达到最大线程数量时提交的新任务的机制。</p><p>这些策略决定了线程池在饱和状态下如何响应新提交的任务。下面是<code>ThreadPoolExecutor</code>中常用的几种饱和策略：</p><ul><li><ol><li>AbortPolicy</li></ol><ul><li>这是默认的饱和策略。当线程池和队列都满时，新提交的任务将被拒绝，并抛出<code>RejectedExecutionException</code>异常。这种策略直接反馈执行失败，适用于那些希望立即知道任务无法执行的场景。</li></ul></li><li><ol start="2"><li>CallerRunsPolicy</li></ol><ul><li>在这种策略下，如果线程池饱和，那么提交任务的线程自己会执行该任务。这意味着任务将在<code>execute</code>方法的调用线程中运行。这种策略不会抛出异常，但可能会降低新任务的提交速度，从而影响整体性能。这适用于希望确保所有任务都被执行的场景，即使这可能导致原始任务提交线程的性能下降。</li></ul></li><li><ol start="3"><li>DiscardPolicy</li></ol><ul><li>此策略将静默丢弃被拒绝的任务，不抛出异常，也不提供任何警告。这可能会导致一些任务的丢失，因此使用这种策略时需要小心。</li></ul></li><li><ol start="4"><li>DiscardOldestPolicy</li></ol><ul><li>当线程池饱和时，这种策略将丢弃最早提交但尚未处理的任务，然后尝试重新提交新的任务。这种策略适用于那些可以接受处理最新任务为优先的场景</li></ul></li></ul><p>使用说明：</p><p>当使用Spring的<code>ThreadPoolTaskExecutor</code>或直接构造<code>ThreadPoolExecutor</code>时，如果没有指定<code>RejectedExecutionHandler</code>，则默认使用<code>AbortPolicy</code>。这意味着当线程池饱和时，新任务将被拒绝并抛出异常。对于需要可伸缩性的应用程序，可以考虑使用<code>CallerRunsPolicy</code>，因为它能够保证任务被执行，尽管这可能会降低任务提交的速度。</p><p>在选择饱和策略时，需要考虑应用程序的特定需求和行为。</p><p>比如，对于那些不能丢失任何任务的应用，<code>CallerRunsPolicy</code>可能是更好的选择。而对于那些可以容忍任务丢失的情况，<code>DiscardPolicy</code>或<code>DiscardOldestPolicy</code>可能更合适。</p><h4 id="线程池创建的两种方式"><a href="#线程池创建的两种方式" class="headerlink" title="线程池创建的两种方式"></a>线程池创建的两种方式</h4><h5 id="ThreadPoolExecutor构造函数"><a href="#ThreadPoolExecutor构造函数" class="headerlink" title="ThreadPoolExecutor构造函数"></a><code>ThreadPoolExecutor</code>构造函数</h5><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></p><h5 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a><code>Executors</code>工具类</h5><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>**<code>ScheduledThreadPool</code>**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><blockquote><p>不建议使用第二种，原因如下：</p></blockquote><p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code>Executors</code> 去创建，</p><p>而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li><code>CachedThreadPool</code>：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><p>这个弊端放后面再了解一下。</p><p>to be contined…</p><h3 id="4、线程池原理分析"><a href="#4、线程池原理分析" class="headerlink" title="4、线程池原理分析"></a>4、线程池原理分析</h3><p>看博客内容： <a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E9%87%8D%E8%A6%81">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90-%E9%87%8D%E8%A6%81</a></p><h3 id="5、线程池最佳实践"><a href="#5、线程池最佳实践" class="headerlink" title="5、线程池最佳实践"></a>5、线程池最佳实践</h3><p>参考： <a href="https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html">https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html</a></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></li><li><a href="https://www.bilibili.com/video/BV1eD4y1w7Rp">https://www.bilibili.com/video/BV1eD4y1w7Rp</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaFx基础使用</title>
    <link href="/2024/01/15/JavaFx%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/15/JavaFx%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、JavaFX是什么"><a href="#1、JavaFX是什么" class="headerlink" title="1、JavaFX是什么"></a>1、JavaFX是什么</h3><p>JavaFX 是一个用于构建富客户端应用程序的软件平台。它主要用于创建桌面应用程序，但也可用于创建浏览器内运行的富Internet应用程序（RIA）。JavaFX 提供了一套丰富的图形和媒体API，使得开发者能够设计和创建具有高级视觉效果的应用程序。</p><p>要使用JavaFX，你需要遵循以下基本步骤：</p><ol><li><p><strong>安装和设置</strong>：</p><ul><li>确保你安装了Java开发工具包（JDK）。自Java 11起，JavaFX不再作为JDK的一部分，因此你需要单独下载和安装JavaFX SDK。</li><li>在你的开发环境中配置JavaFX。这可能包括将JavaFX SDK路径添加到你的项目的库中。</li></ul></li><li><p><strong>创建JavaFX应用程序</strong>：</p><ul><li>JavaFX应用程序的入口点是继承自<code>javafx.application.Application</code>的类。你需要重写<code>start(Stage primaryStage)</code>方法，这是JavaFX应用程序的主要入口点。</li><li>使用JavaFX提供的UI控件（如按钮、文本字段、表格等）来构建用户界面。</li></ul></li><li><p><strong>场景和舞台</strong>：</p><ul><li>在JavaFX中，每个窗口被称为一个“舞台”（Stage），而舞台上的内容被组织在一个“场景”（Scene）中。</li><li>创建一个场景并将其设置到舞台上，然后显示舞台。</li></ul></li><li><p><strong>事件处理</strong>：</p><ul><li>JavaFX提供了一套丰富的事件处理机制。你可以为UI控件添加事件处理器（如按钮点击、鼠标事件等）。</li></ul></li><li><p><strong>运行应用程序</strong>：</p><ul><li>使用Java命令运行你的JavaFX应用程序，确保包括JavaFX库的路径。</li></ul></li><li><p><strong>使用FXML</strong>（可选）：</p><ul><li>FXML是一种基于XML的声明式语言，用于构建JavaFX应用程序的用户界面。使用FXML可以将用户界面设计与应用程序逻辑分离，使得设计师和开发者可以更容易地协作。</li></ul></li></ol><p>JavaFX支持CSS样式，使得开发者可以轻松改变应用程序的外观和感觉。此外，它还支持2D和3D图形、音频和视频媒体等功能。</p><p>要开始使用JavaFX，你可能需要查看一些教程和示例，这些可以在Oracle的官方文档或其他编程学习资源中找到</p><h3 id="2、基础使用"><a href="#2、基础使用" class="headerlink" title="2、基础使用"></a>2、基础使用</h3><p>JavaFX 提供了一系列的组件、事件、方法和样式(CSS)支持，使得开发者可以创建功能丰富且外观精美的应用程序。以下是这些方面的概览：</p><blockquote><p>组件（控件）</p></blockquote><p>JavaFX 中的组件通常被称为控件（Controls）。以下是一些常用的JavaFX控件：</p><ol><li><strong>基本控件</strong>：如<code>Button</code>, <code>Label</code>, <code>TextField</code>, <code>TextArea</code>等，用于基本的用户交互。</li><li><strong>高级控件</strong>：如<code>TableView</code>, <code>ListView</code>, <code>TreeView</code>, <code>DatePicker</code>等，用于更复杂的数据显示和交互。</li><li><strong>布局容器</strong>：如<code>HBox</code>, <code>VBox</code>, <code>BorderPane</code>, <code>GridPane</code>等，用于组织控件的布局。</li><li><strong>菜单控件</strong>：如<code>MenuBar</code>, <code>MenuItem</code>, <code>ContextMenu</code>等，用于创建菜单。</li><li><strong>对话框</strong>：如<code>Alert</code>, <code>FileChooser</code>, <code>ColorPicker</code>等，用于弹出式交互。</li></ol><blockquote><p>事件</p></blockquote><p>JavaFX 支持多种类型的事件，允许开发者处理用户交互和其他动态行为。常见的事件类型包括：</p><ol><li><strong>鼠标事件</strong>：如<code>MouseEvent</code>，处理鼠标的点击、移动、拖拽等。</li><li><strong>键盘事件</strong>：如<code>KeyEvent</code>，处理键盘按键的按下和释放。</li><li><strong>动作事件</strong>：如<code>ActionEvent</code>，通常用于按钮点击或菜单选择。</li><li><strong>窗口事件</strong>：如窗口打开、关闭、最小化等。</li></ol><blockquote><p>方法</p></blockquote><p>在JavaFX中，控件和其他对象提供了多种方法来执行操作或修改状态。常见的方法包括：</p><ol><li><strong>控件方法</strong>：用于设置控件的属性，如<code>setText()</code>, <code>setDisable()</code>, <code>setVisible()</code>等。</li><li><strong>布局方法</strong>：用于设置布局相关属性，如<code>setSpacing()</code>, <code>setAlignment()</code>, <code>setMargin()</code>等。</li><li><strong>事件处理方法</strong>：用于添加事件监听器，如<code>setOnAction()</code>, <code>setOnMouseClicked()</code>等。</li></ol><blockquote><p>样式（CSS）</p></blockquote><p>JavaFX 允许使用CSS来设置控件的样式，类似于在Web开发中使用CSS。你可以使用CSS来控制控件的外观，如颜色、字体、边距、背景等。</p><ol><li><strong>内联样式</strong>：直接在Java代码中设置控件的样式，如<code>button.setStyle(&quot;-fx-background-color: blue;&quot;)</code>。</li><li><strong>外部样式表</strong>：创建一个CSS文件，并在JavaFX应用中引用它，如<code>scene.getStylesheets().add(&quot;path/to/stylesheet.css&quot;)</code>。</li></ol><p>在CSS文件中，你可以定义类似于以下的样式规则：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.button</span> &#123;<br>    -fx-<span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span>;<br>    -fx-<span class="hljs-attribute">background-color</span>: <span class="hljs-number">#FF5733</span>;<br>&#125;<br><br><span class="hljs-selector-class">.label</span> &#123;<br>    -fx-<span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;Arial&quot;</span>;<br>    -fx-text-fill: <span class="hljs-number">#333333</span>;<br>&#125;<br><br><span class="hljs-comment">/* 为具有特定ID的控件设置样式 */</span><br><span class="hljs-selector-id">#myButton</span> &#123;<br>    -fx-<span class="hljs-attribute">border-color</span>: black;<br>    -fx-<span class="hljs-attribute">border-width</span>: <span class="hljs-number">2px</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>一些高级特性</p></blockquote><p>除了基本的控件、事件和样式，JavaFX还提供了一些高级特性，例如：</p><ol><li><strong>动画和特效</strong>：JavaFX提供了动画API，如<code>Timeline</code>, <code>Transition</code>等，以及各种特效如<code>DropShadow</code>, <code>Reflection</code>等。</li><li><strong>2D和3D图形</strong>：可以创建2D和3D图形，支持图形变换、相机视角等。</li><li><strong>多媒体支持</strong>：支持播放音频和视频，处理媒体流等。</li><li><strong>FXML</strong>：一种基于XML的语言，用于声明式地构建用户界面，将界面设计与应用逻辑分离。</li></ol><p>JavaFX提供的这些特性和工具使得开发丰富的客户端应用程序成为可能，同时也支持创建现代化且易于维护的用户界面。</p><p>通过结合使用这些组件、事件、方法和样式，可以创建出既美观又功能强大的应用程序。</p><hr><p>参考：</p><ul><li><a href="https://articles.zsxq.com/id_04g0ezlrsuje.html">https://articles.zsxq.com/id_04g0ezlrsuje.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>UI</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>JavaFx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仿桌面版微信聊天</title>
    <link href="/2024/01/15/%E4%BB%BF%E6%A1%8C%E9%9D%A2%E7%89%88%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/"/>
    <url>/2024/01/15/%E4%BB%BF%E6%A1%8C%E9%9D%A2%E7%89%88%E5%BE%AE%E4%BF%A1%E8%81%8A%E5%A4%A9/</url>
    
    <content type="html"><![CDATA[<p>学习项目地址：  <a href="https://wx.zsxq.com/dweb2/index/columns/48411118851818">https://wx.zsxq.com/dweb2/index/columns/48411118851818</a></p><p>项目地址：</p><ul><li><a href="https://gitcode.net/KnowledgePlanet/Netty/IM">https://gitcode.net/KnowledgePlanet/Netty/IM</a></li></ul><h3 id="1、项目介绍"><a href="#1、项目介绍" class="headerlink" title="1、项目介绍"></a>1、项目介绍</h3><p>功能：仿桌面版微信聊天</p><p>技术栈：JavaFx、Netty4.x、SpringBoot、Mysql</p><h3 id="2、运行项目"><a href="#2、运行项目" class="headerlink" title="2、运行项目"></a>2、运行项目</h3><p>下载项目中的三个项目，先加载并install，顺序分别是：itstack-naive-chat-server → itstack-naive-chat-ui  → itstack-naive-chat-client</p><p>直接启动 Applicatioin 类就行，改一下数据库连接配置。</p><h3 id="3、UI端"><a href="#3、UI端" class="headerlink" title="3、UI端"></a>3、UI端</h3><p>从这一章开始介绍一下实现的功能，并结合文档进行阐述。</p><p>UI 端是使用 JavaFx 来进行构建的一个桌面应用，主要的页面是包括等登录界面、聊天界面、对话弹出框、好友栏(参考桌面微信页面布局）。</p><p>建议先按照学习项目地址中的 业务项目 → IM 实战：Netty+JavaFx实战：仿桌面版微信聊天  → 课程目录 → 第一章 UI 开发</p><p>全部先自己看一遍</p><p>UI  端是项目工程看具体使用是构建后，打成一个 Jar 包，供客户端引入依赖使用；达到 UI 与 业务分离。</p><h3 id="4、架构设计"><a href="#4、架构设计" class="headerlink" title="4、架构设计"></a>4、架构设计</h3><p>使用到了四层架构模型DDD</p><ul><li>应用层 Application</li><li>领域层 domain</li><li>基础层 infrastructrue</li><li>接口层 interfaces</li></ul><p>将代码工程进行了一定的分层</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401161506299.png" alt="image.png"></p><h3 id="5、功能实现"><a href="#5、功能实现" class="headerlink" title="5、功能实现"></a>5、功能实现</h3><p>主要功能：登录、添加好友、对话通知、消息发送、断线重连。</p><h3 id="6、二次开发"><a href="#6、二次开发" class="headerlink" title="6、二次开发"></a>6、二次开发</h3><p>在这个基础上进行一定内容的改造： to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>获取本地服务访问第三方接口的IP地址</title>
    <link href="/2024/01/14/%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E7%9A%84IP%E5%9C%B0%E5%9D%80/"/>
    <url>/2024/01/14/%E8%8E%B7%E5%8F%96%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1%E8%AE%BF%E9%97%AE%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8E%A5%E5%8F%A3%E7%9A%84IP%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<p>有一种比较简单的方式，可以直接在浏览器访问，向一个返回请求者IP地址的API 发起请求。</p><p>比如 <code>httpbin.org/ip</code> 发送请求</p><p>或者访问：<code>ifconfig.me</code></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>chatgpt接口调用</title>
    <link href="/2024/01/14/chatgpt%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/"/>
    <url>/2024/01/14/chatgpt%E6%8E%A5%E5%8F%A3%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>参考开源项目：</p><ul><li><a href="https://github.com/suimz/chatgpt-web-java">https://github.com/suimz/chatgpt-web-java</a></li><li><a href="https://github.com/PlexPt/chatgpt-java/tree/main">https://github.com/PlexPt/chatgpt-java/tree/main</a></li></ul><p>官网文档： <a href="https://platform.openai.com/docs/guides/text-generation/chat-completions-api">https://platform.openai.com/docs/guides/text-generation/chat-completions-api</a></p><h3 id="1、最简单使用"><a href="#1、最简单使用" class="headerlink" title="1、最简单使用"></a>1、最简单使用</h3><p>这里的代码参考的是： <a href="https://github.com/PlexPt/chatgpt-java/tree/main">https://github.com/PlexPt/chatgpt-java/tree/main</a></p><p>同时该项目的 readme.md 有介绍文档内容，建议去看一下</p><p>示例类:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-comment">//国内需要代理</span><br>  <span class="hljs-type">Proxy</span> <span class="hljs-variable">proxy</span> <span class="hljs-operator">=</span> Proxys.http(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">1081</span>);<br> <span class="hljs-comment">//socks5 代理</span><br><span class="hljs-comment">// Proxy proxy = Proxys.socks5(&quot;127.0.0.1&quot;, 1080);</span><br><br>  <span class="hljs-type">ChatGPT</span> <span class="hljs-variable">chatGPT</span> <span class="hljs-operator">=</span> ChatGPT.builder()<br>            .apiKey(<span class="hljs-string">&quot;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&quot;</span>)<br>            .proxy(proxy)<br>            .apiHost(<span class="hljs-string">&quot;https://api.openai.com/&quot;</span>) <span class="hljs-comment">//反向代理地址</span><br>            .build()<br>            .init();<br>            <br>    <span class="hljs-type">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> chatGPT.chat(<span class="hljs-string">&quot;写一段七言绝句诗，题目是：火锅！&quot;</span>);<br>    System.out.println(res);<br></code></pre></td></tr></table></figure><p>他这里用了一个反向代理，我这里采用的策略是使用阿里云的函数计算FC来进行代理 <a href="https://api.openai.com/">https://api.openai.com/</a> 这个访问地址；上面这种方式是需要一个服务器。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">ChatGPT chatGPT <span class="hljs-operator">=</span> ChatGPT.builder()<br>          .apiKey(<span class="hljs-string">&quot;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&quot;</span>)<br>          .apiHost(<span class="hljs-string">&quot;https://openai-proxy-openai-proxy-xxxxxxx.run/&quot;</span>) //阿里云函数计算的代理地址<br>          .build()<br>          .init()<span class="hljs-comment">;</span><br>          <br>  String res <span class="hljs-operator">=</span> chatGPT.chat(<span class="hljs-string">&quot;写一段七言绝句诗，题目是：火锅！&quot;</span>)<span class="hljs-comment">;</span><br>  System.out.println(res)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>其他内容可以看一下项目代码</p><p>to be contined…</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>阿里通义千问API</title>
    <link href="/2024/01/14/%E9%98%BF%E9%87%8C%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AEAPI/"/>
    <url>/2024/01/14/%E9%98%BF%E9%87%8C%E9%80%9A%E4%B9%89%E5%8D%83%E9%97%AEAPI/</url>
    
    <content type="html"><![CDATA[<p>接口官网文档地址： <a href="https://help.aliyun.com/zh/dashscope/developer-reference/api-details">https://help.aliyun.com/zh/dashscope/developer-reference/api-details</a></p><h3 id="1、申请API-KEY"><a href="#1、申请API-KEY" class="headerlink" title="1、申请API-KEY"></a>1、申请API-KEY</h3><p>个人实际使用的时候这一步比较简单，最近是免费开通的（20240114）</p><p>开通地址： <a href="https://dashscope.console.aliyun.com/apiKey">https://dashscope.console.aliyun.com/apiKey</a></p><h3 id="2、使用通义千问"><a href="#2、使用通义千问" class="headerlink" title="2、使用通义千问"></a>2、使用通义千问</h3><p>申请 API_KEY 之后，进行下述操作：</p><p>安装最新版SDK: </p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240114102643.png" alt="image.png"></p><p>这个版本必须要写明确一点，他这样写有点问题，先去阿里云仓库查找一下： <a href="https://developer.aliyun.com/mvn/search">https://developer.aliyun.com/mvn/search</a></p><p>搜索： dashscope-sdk-java</p><p>在项目中引入这个依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dashscope-sdk-java --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dashscope-sdk-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>后面使用直接看一下官网，API 调用文档： <a href="https://help.aliyun.com/zh/dashscope/developer-reference/api-details">https://help.aliyun.com/zh/dashscope/developer-reference/api-details</a></p><p>使用的时候需要使用一下环境变量</p><p>官网的几种方式： <a href="https://help.aliyun.com/zh/dashscope/developer-reference/api-key-settings">https://help.aliyun.com/zh/dashscope/developer-reference/api-key-settings</a></p><p>看了一下几种方式，还是建议第一种来进行操作。</p><h4 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h4><p>通过环境变量设置 API-KEY （Linux系统建议）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> DASHSCOPE_API_KEY=<span class="hljs-string">&quot;YOUR_DASHSCOPE_API_KEY&quot;</span><br></code></pre></td></tr></table></figure><p>windows 系统</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">DASHSCOPE_API_KEY</span>=<span class="hljs-string">&quot;YOUR_DASHSCOPE_API_KEY&quot;</span><br><br><span class="hljs-comment">#查看环境变量</span><br>echo %DASHSCOPE_API_KEY% <br></code></pre></td></tr></table></figure><p>也可以通过代码的方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> com.alibaba.dashscope.utils.Constants;<br>Constants.apiKey=<span class="hljs-string">&quot;YOUR_DASHSCOPE_API_KEY&quot;</span>;<br></code></pre></td></tr></table></figure><h4 id="依赖引入"><a href="#依赖引入" class="headerlink" title="依赖引入"></a>依赖引入</h4><p>个人实际使用的时候引入了三个依赖，注意一下实际使用情况</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/dashscope-sdk-java --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dashscope-sdk-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-comment">&lt;!--okhttp3 依赖--&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.squareup.okhttp3<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.9.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-comment">&lt;!-- Other dependencies --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.code.gson<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>gson<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 使用最新的稳定版或者你所需要的版本 --&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">package com.tsmyk.wechatproject.wechat.utils;<br><br><span class="hljs-keyword">import</span> com.alibaba.dashscope.aigc.generation.Generation;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.aigc.generation.GenerationResult;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.aigc.generation.models.QwenParam;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.common.Message;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.common.MessageManager;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.common.<span class="hljs-keyword">Role</span>;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.<span class="hljs-keyword">exception</span>.ApiException;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.<span class="hljs-keyword">exception</span>.InputRequiredException;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.<span class="hljs-keyword">exception</span>.NoApiKeyException;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.utils.JsonUtils;<br><span class="hljs-keyword">import</span> com.alibaba.dashscope.utils.Constants;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author luoqi</span><br><span class="hljs-comment"> * @File TongYiAPIUtils.java</span><br><span class="hljs-comment"> * @Desc</span><br><span class="hljs-comment"> * @Create 2024/1/14 10:46</span><br><span class="hljs-comment"> * @ChangeList --------------------------------------------------------------------</span><br><span class="hljs-comment"> * Date                          Editor                     ChangeReason</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TongYiAPIUtils &#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">      * @Description: 测试通义千问的API访问基础使用</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      * @return: void</span><br><span class="hljs-comment">      * @throws</span><br><span class="hljs-comment">      * @author luoqi</span><br><span class="hljs-comment">      * @create: 2024/1/14 10:48</span><br><span class="hljs-comment">      * @ChangeList</span><br><span class="hljs-comment">      * --------------------------------------------------------------------</span><br><span class="hljs-comment">      *Date</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> callWithMessage()<br>            throws NoApiKeyException, ApiException, InputRequiredException &#123;<br>        Generation gen = <span class="hljs-built_in">new</span> Generation();<br>        MessageManager msgManager = <span class="hljs-built_in">new</span> MessageManager(<span class="hljs-number">10</span>);<br>        Message systemMsg =<br>                Message.builder().<span class="hljs-keyword">role</span>(<span class="hljs-keyword">Role</span>.<span class="hljs-keyword">SYSTEM</span>.getValue()).content(&quot;You are a helpful assistant.&quot;).build();<br>        Message userMsg = Message.builder().<span class="hljs-keyword">role</span>(<span class="hljs-keyword">Role</span>.<span class="hljs-keyword">USER</span>.getValue()).content(&quot;夸一下我，我又学习了一会呢&quot;).build();<br>        msgManager.<span class="hljs-keyword">add</span>(systemMsg);<br>        msgManager.<span class="hljs-keyword">add</span>(userMsg);<br>        QwenParam param =<br>                QwenParam.builder().model(Generation.Models.QWEN_PLUS).messages(msgManager.<span class="hljs-keyword">get</span>())<br>                        .resultFormat(QwenParam.ResultFormat.MESSAGE)<br>                        .topP(<span class="hljs-number">0.8</span>)<br>                        .enableSearch(<span class="hljs-keyword">true</span>)<br>                        .build();<br>        GenerationResult result = gen.<span class="hljs-keyword">call</span>(param);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(result);<br>        msgManager.<span class="hljs-keyword">add</span>(result);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(JsonUtils.toJson(result));<br>        //param.setPrompt(&quot;现在时间是 20:00&quot;);<br>        param.setMessages(msgManager.<span class="hljs-keyword">get</span>());<br>        result = gen.<span class="hljs-keyword">call</span>(param);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(result);<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(JsonUtils.toJson(result));<br>    &#125;<br><br><br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args)&#123;<br>        Constants.apiKey=&quot;sk-xxxxxxxxxxxxxxxxx&quot;;<br>        try &#123;<br>            callWithMessage();<br>        &#125; catch (ApiException | NoApiKeyException | InputRequiredException e) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(e.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">System</span>.<span class="hljs-keyword">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用参数看一下官方文档。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装和下载</title>
    <link href="/2024/01/13/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/2024/01/13/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Node-js-下载安装"><a href="#1、Node-js-下载安装" class="headerlink" title="1、Node.js 下载安装"></a>1、Node.js 下载安装</h3><p>官网下载： <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>安装后，验证一下是否安装成功</p><p>打开 cmd, 输入node -v，npm -v，出现如下界面安装成功</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117221300.png" alt="image.png"></p><h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><blockquote><p>环境变量配置</p></blockquote><p>新增<strong>用户变量</strong>  <code>NODE_PATH</code>，变量值设置为 <code>xxx\nodejs</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224932.png" alt="image.png"></p><p>编辑<strong>用户变量</strong>中的【Path】</p><p>修改 变量名 <code>Path</code></p><p>将默认的 C 盘下【 <code>AppData\Roaming\npm</code> 】修改成 <code>%NODE_PATH%</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224741.png" alt="image.png"></p><p>设置完后也打开 cmd, 输入一下  node -v，npm -v  看是否OK。</p><blockquote><p>配置npm的全局模块的存放路径以及cache的路径</p></blockquote><p>找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】</p><p>使用管理员身份打开cmd窗口，执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;xxx\Node.js\node_global&quot;</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;xxx\Node.js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>新增系统Path变量</p></blockquote><p>在【系统变量】中选择【Path】点击【编辑】添加你刚才配置的两个路径。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117225456.png" alt="image.png"></p><h3 id="3、安装淘宝镜像"><a href="#3、安装淘宝镜像" class="headerlink" title="3、安装淘宝镜像"></a>3、安装淘宝镜像</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>查看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h3 id="4、NVM-安装-★"><a href="#4、NVM-安装-★" class="headerlink" title="4、NVM 安装  ★"></a>4、NVM 安装  ★</h3><h4 id="window-下安装"><a href="#window-下安装" class="headerlink" title="window 下安装"></a>window 下安装</h4><p>下载地址： <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>NVM 是一个 node 版本管理工具，这里主要是由于前端项目中有时候需要的版本不同，需要切换</p><ul><li><ol><li>下载 nvm-setup.zip 文件</li></ol></li><li><ol start="2"><li>卸载电脑安装的 node ，在程序与功能上卸载 node ，同时删除之前的环境变量</li></ol></li><li>3.解压文件后，有一个 nvm-setup.exe ，点击安装</li><li>4.安装你需要的版本</li><li>5.可能需要重新启动一下你的电脑</li></ul><p>常用命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nvm ls               // 查看已安装<span class="hljs-keyword">node</span><span class="hljs-title">版本</span><br><span class="hljs-title">nvm</span> install vXX      // 安装对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> uninstall vXX    // 卸载对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> use xxx          // 选择使用XXX版本<br></code></pre></td></tr></table></figure><p>实际操作</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#安装并切换版本到 14.21.3，安装需要一点时间</span><br><span class="hljs-attribute">nvm</span> install <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">nvm</span> use <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><h4 id="linux-下安装"><a href="#linux-下安装" class="headerlink" title="linux 下安装"></a>linux 下安装</h4><blockquote><p>Linux 系统下安装</p></blockquote><p>也是需要先下载一下安装包</p><p>地址： <a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a></p><p>建议直接下这个： <a href="https://github.com/nvm-sh/nvm/archive/refs/tags/v0.38.0.tar.gz">https://github.com/nvm-sh/nvm/archive/refs/tags/v0.38.0.tar.gz</a></p><p>进行到对应目录后</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">//进入服务器 解压文件放置目录</span><br><span class="hljs-comment">//解压文件到当前目录</span><br>tar -zxvf nvm-<span class="hljs-number">0.38</span>.<span class="hljs-number">0</span><span class="hljs-selector-class">.tar</span>.gz<br></code></pre></td></tr></table></figure><p>解压后的配置参考： <a href="https://blog.csdn.net/Siebert_Angers/article/details/129290084">https://blog.csdn.net/Siebert_Angers/article/details/129290084</a></p><p>进入解压目录给安装脚本加权限最后执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> nvm-0.38.0   <span class="hljs-comment"># 进入解压目录</span><br><span class="hljs-built_in">chmod</span> +x nvm.sh    <span class="hljs-comment"># 给予安装脚本执行权限</span><br>./nvm.sh    <span class="hljs-comment"># 执行</span><br></code></pre></td></tr></table></figure><p>环境变量配置:</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">vim</span> /etc/<span class="hljs-keyword">profile</span><br></code></pre></td></tr></table></figure><p>添加下面的内容：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_DIR</span>=<span class="hljs-string">&quot;/usr/local/nvm-0.39.1&quot;</span>   # 更改成自己的解压目录<br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/nvm.sh&quot;</span>  # This loads nvm<br>[ -s <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span> ] &amp;&amp; \. <span class="hljs-string">&quot;<span class="hljs-variable">$NVM_DIR</span>/bash_completion&quot;</span>  # This loads nvm bash_completion<br><span class="hljs-comment"># 镜像源配置</span><br><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_NODEJS_ORG_MIRROR</span>=https://npm.taobao.org/mirrors/node/<br><span class="hljs-built_in">export</span> <span class="hljs-attribute">NVM_IOJS_ORG_MIRROR</span>=http://npm.taobao.org/mirrors/iojs<br></code></pre></td></tr></table></figure><p>刷新配置，使上面的环境变量配置生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>检测是否安装成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvm -v</span><br></code></pre></td></tr></table></figure><blockquote><p>配置npm</p></blockquote><p>执行下面的命令查看远程仓库有哪些可以安装的nodejs版本：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvm ls-remote</span><br></code></pre></td></tr></table></figure><p>安装指定版本 node：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">nvm</span> install v14.<span class="hljs-number">16</span><br></code></pre></td></tr></table></figure><p>把 npm 镜像更改为国内镜像：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">sass_binary_site</span>=https://npm.taobao.org/mirrors/node-sass/<br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">phantomjs_cdnurl</span>=https://npm.taobao.org/mirrors/phantomjs/<br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">electron_mirror</span>=https://npm.taobao.org/mirrors/electron/<br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> <span class="hljs-attribute">registry</span>=https://registry.npm.taobao.org<br></code></pre></td></tr></table></figure><p>查看镜像配置：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config ls<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/m0_62617719/article/details/130423504">https://blog.csdn.net/m0_62617719/article/details/130423504</a></li><li><a href="https://blog.csdn.net/JingYan_Chan/article/details/125405423">https://blog.csdn.net/JingYan_Chan/article/details/125405423</a></li><li><a href="https://blog.csdn.net/MyronCham/article/details/119561972">https://blog.csdn.net/MyronCham/article/details/119561972</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过阿里云的函数计算FC进行OpenAI访问国内代理</title>
    <link href="/2024/01/13/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97FC%E8%BF%9B%E8%A1%8COpenAI%E8%AE%BF%E9%97%AE%E5%9B%BD%E5%86%85%E4%BB%A3%E7%90%86/"/>
    <url>/2024/01/13/%E9%80%9A%E8%BF%87%E9%98%BF%E9%87%8C%E4%BA%91%E7%9A%84%E5%87%BD%E6%95%B0%E8%AE%A1%E7%AE%97FC%E8%BF%9B%E8%A1%8COpenAI%E8%AE%BF%E9%97%AE%E5%9B%BD%E5%86%85%E4%BB%A3%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1、需求"><a href="#1、需求" class="headerlink" title="1、需求"></a>1、需求</h3><p>需求是通过反向代理链接 <a href="https://api.openai.com/">https://api.openai.com</a> 的方式来实现</p><h3 id="2、获取阿里云函数计算FC"><a href="#2、获取阿里云函数计算FC" class="headerlink" title="2、获取阿里云函数计算FC"></a>2、获取阿里云函数计算FC</h3><p>需要先获取一下阿里云的  <code>AccessKeyId</code>和<code>AccessKeySecret</code></p><p>在控制台右上角获取，或者通过下方链接获取：   <a href="https://usercenter.console.aliyun.com/#/manage/ak">https://usercenter.console.aliyun.com/#/manage/ak</a></p><p>参考博客： <a href="https://blog.csdn.net/xuzhongyi103/article/details/134272331">https://blog.csdn.net/xuzhongyi103/article/details/134272331</a></p><p>部署参考文档： <a href="https://help.aliyun.com/zh/fc/developer-reference/install-serverless-devs-and-docker">https://help.aliyun.com/zh/fc/developer-reference/install-serverless-devs-and-docker</a></p><p>（阿里云文档）</p><h3 id="3、部署Serverless-Devs"><a href="#3、部署Serverless-Devs" class="headerlink" title="3、部署Serverless Devs"></a>3、部署Serverless Devs</h3><p>介绍：</p><p>Serverless Devs是一款多云的开发者工具，可以非常简单、快速、方便地部署AWS、阿里云、腾讯云等多个云厂商的函数计算等相关服务，</p><p>同时它也是一个开源项目，可以供用户随时随地地贡献组件，以满足不同场景的诉求。</p><hr><p>部署这个需要先安装 Node.js(&gt;&#x3D;10.8.0) 的环境，建议使用一下包管理工具 nvm</p><p>需要一台linux服务器，也可以是本地的linux系统，用于部署Serverless Devs</p><p>这里记录一下实际操作（参考阿里云文档）</p><blockquote><p>通过npm包管理器安装</p></blockquote><p>需要先安装了npm 环境，Node.js的版本需为Node.js 10及以上</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-comment">#安装Serverless Devs</span><br><span class="hljs-built_in">npm</span> install @serverless-devs/s -g<br></code></pre></td></tr></table></figure><p>执行以下命令，验证是否安装成功</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">s -v</span><br></code></pre></td></tr></table></figure><p>成功安装后的执行结果示例如下:</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">@serverless-devs/s: <span class="hljs-number">3.0</span>.<span class="hljs-number">0</span>, s-home: /root/.s, linux-x64, <span class="hljs-keyword">node</span><span class="hljs-title">-v14</span>.<span class="hljs-number">16.1</span><br></code></pre></td></tr></table></figure><p>下面这些步骤参考的是博客内容，依次执行即可</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment"># 添加密钥信息</span><br>s config add  <br><span class="hljs-comment"># 1. 云厂商选择 Alibaba Cloud (alibaba)</span><br><span class="hljs-comment"># 2. 填写刚才获取的AccessKeyId、AccessKeySecret</span><br><span class="hljs-comment"># 3. 为这一配置取别名，也可以直接回车，使用默认名称，例如取名为openai</span><br><br><span class="hljs-comment"># 安装openai-proxy代理包 类似docker镜像是第三方的</span><br>s init openai-proxy-ohyee<br><span class="hljs-comment"># 1. 该第三方包的仓库链接 https://registry.serverless-devs.com/details.html?name=openai-proxy-ohyee</span><br><span class="hljs-comment"># 2. 项目名称自命名 例如取名为openai-proxy</span><br><span class="hljs-comment"># 3. 地域选择us-west-1（美西海岸硅谷）</span><br><span class="hljs-comment"># 4. 认证配置文件选择上一步取别名的那个</span><br><span class="hljs-comment"># 5. 完成后，在/root目录下，会有openai-proxy文件夹，即这一步取的别名的目录</span><br><br><span class="hljs-comment"># 进入到该目录</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">/root/openai-proxy</span><br><br><span class="hljs-comment"># 再进入到该目录下的code目录</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">./code</span><br><br><span class="hljs-comment"># 执行npm安装命令</span><br>npm i<br><br><span class="hljs-comment"># 返回上一层 即/root/openai-proxy目录</span><br><span class="hljs-keyword">cd</span> <span class="hljs-string">..</span><br><br><span class="hljs-comment"># 执行部署命令 - 该命令会在阿里云控制台那边生成对应的服务</span><br>s <span class="hljs-keyword">deploy</span>  <span class="hljs-comment"># 执行过程中可以选择本地配置或远程配置 我选择的远程 use remote</span><br></code></pre></td></tr></table></figure><blockquote><p>阿里云控制台查看</p></blockquote><p>部署后到阿里云的函数计算FC中查看，注意切换一下地址到美国硅谷</p><p>点击进入函数管理</p><p>一直点击函数进入到函数详情</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240113235819.png" alt="image.png"></p><p>详情里面有一个公网访问地址</p><p>将实际你需要的 链接进行替换即可：</p><p>比如调用OpenAI的端口为：<code>https://api.openai.com/v1</code>  </p><p>替换为<code>https://xxx.run/v1</code>就可以了</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240114000222.png" alt="image.png"></p><p>链接的具体访问建议先使用API  调用工具看一下。</p>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ChatGPT问答助手</title>
    <link href="/2024/01/12/ChatGPT%E9%97%AE%E7%AD%94%E5%8A%A9%E6%89%8B/"/>
    <url>/2024/01/12/ChatGPT%E9%97%AE%E7%AD%94%E5%8A%A9%E6%89%8B/</url>
    
    <content type="html"><![CDATA[<p>前面一部分内容是开源项目 <a href="https://github.com/fuzhengwei/chatbot-api">https://github.com/fuzhengwei/chatbot-api</a> 的一些内容，后面是微信API 调用和 通义千问的部分使用介绍。</p><p>本项目来自知识星球《码农会锁》的开源项目【ChatGPT AI 问答助手】</p><p>项目地址：</p><ul><li><a href="https://gitcode.net/fuzhengwei/chatbot-api">https://gitcode.net/fuzhengwei/chatbot-api</a></li><li><a href="https://github.com/fuzhengwei/chatbot-api">https://github.com/fuzhengwei/chatbot-api</a></li></ul><p>本项目使用到了基本的项目工程构建、SpringBoot、DDD架构、Github仓库使用、爬虫接口、镜像打包、Docker容器部署。</p><p>构建的基本过程这里跳过，进入到实际使用和分析阶段。</p><blockquote><p>介绍DDD架构</p></blockquote><p>先介绍一下 DDD 架构，DDD 架构可以想象类似是 在 MVC 分层的基础中再进行了分类，将服务之间的调用耦合减轻。</p><p>DDD （领域驱动设计）是一种软件设计方法，主要关注的是业务领域和业务逻辑。强调基于业务模型来构建软件，使得软件能够更好地反映和满足业务需求。</p><p><strong>核心思想</strong>：</p><ul><li>将复杂的业务逻辑划分为不同的领域，每个领域代表一个业务的子集。</li><li>通过丰富的领域模型来捕捉业务领域的核心概念和逻辑。<br> <strong>实现方式</strong>：</li><li>通常包括实体（Entities）、值对象（Value Objects）、领域服务（Domain Services）、聚合（Aggregates）和仓储（Repositories）等概念。</li><li>DDD 还强调领域层和应用层的分离，确保业务逻辑的独立性。<br><strong>目的</strong>：</li><li>提供一种方法论，帮助开发者更好地理解和设计复杂业务系统。</li><li>通过领域模型的丰富性来提高软件的可维护性和可扩展性</li></ul><p>星球课程入口： <a href="https://wx.zsxq.com/dweb2/index/columns/48411118851818">https://wx.zsxq.com/dweb2/index/columns/48411118851818</a></p><p>B 站视频地址： <a href="https://www.bilibili.com/video/BV1RR4y1b7UQ">https://www.bilibili.com/video/BV1RR4y1b7UQ</a></p><p>大纲</p><ul><li>项目运行</li><li>领域服务核心内容分析</li><li>二开（订阅号信息回复）定时发送消息</li><li>接收微信消息并进行回复</li><li>QQ消息回复</li><li>尝试国内的大语言模型</li></ul><h3 id="1、项目运行"><a href="#1、项目运行" class="headerlink" title="1、项目运行"></a>1、项目运行</h3><p>从 项目地址 <a href="https://gitcode.net/fuzhengwei/chatbot-api">https://gitcode.net/fuzhengwei/chatbot-api</a>  ；</p><h4 id="项目加载"><a href="#项目加载" class="headerlink" title="项目加载"></a>项目加载</h4><p>拉取项目代码后，需要在 Maven 下面的 Lifecycle 下先进行总体的一个 clean 再 install ；</p><p>install 完成后再重新加载一下依赖；</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240112222113.png" alt="image.png"></p><p>在进行上一步操作的时候本人对部分模块先引用打包到了本地 chatbot-api-common、  chatbot-api-domain  ；但这个应该不是关键影响因素（可忽略）</p><h4 id="项目结构分析"><a href="#项目结构分析" class="headerlink" title="项目结构分析"></a>项目结构分析</h4><ul><li>chatbot-api-application<ul><li>ext<ul><li>进行任务注册服务，支持多组任务配置</li></ul></li><li>job<ul><li>定义定时任务，进行检索问题并进行AI回答，AI回答后进行问题回复。</li></ul></li></ul></li><li>chatbot-api-common<ul><li>公共服务</li></ul></li><li>chatbot-api-domain<ul><li>领域服务<ul><li>ai<ul><li>调用 openai 的 chatgpt 接口</li></ul></li><li>zsxq<ul><li>queryUnAnsweredQuestionsTopicId  获取知识星球的未回答内容</li><li>answer   回复知识星球的未回答内容</li></ul></li></ul></li></ul></li><li>chatbot-api-infrastructure<ul><li>聚合</li></ul></li><li>chatbot-api-interface<ul><li>启动类</li></ul></li></ul><hr><h3 id="2、领域服务核心内容分析"><a href="#2、领域服务核心内容分析" class="headerlink" title="2、领域服务核心内容分析"></a>2、领域服务核心内容分析</h3><p>根据视频教程内容是需要创建一个知识星球，获取其中分栏”等我回答中的信息”，不过这里知识星球它创建免费星球有限制，而创建收费星球限制最少收费50；</p><p>下面主要分析一下其领域服务核心内容实现流程。</p><p>测试包 cn.bugstack.chatbot.api.test 下类ApiTest 方法分析</p><p>这里大致的一个实现思路：</p><p>首先是通过查询“未回答问题”爬取知识星球的接口信息，然后是通过 chatgpt 回复相关内容（涉及到两个接口，一个是回答知识星球的相关问题，一个是调用 openai 的 chatgpt 接口返回数据）</p><p>这里来执行回复操作是通过定时任务来进行执行的，在教程视频： <a href="https://www.bilibili.com/video/BV1XR4y1h7JP/">https://www.bilibili.com/video/BV1XR4y1h7JP/</a></p><p>提及到了一个多组任务服务配置的技术实现，是通过将同一套流程但不同爬取接口方（比如：知识星球的多个群对应多个配置)；to be contined…</p><h4 id="查询“未回答问题”"><a href="#查询“未回答问题”" class="headerlink" title="查询“未回答问题”"></a>查询“未回答问题”</h4><p>爬取知识星球的接口信息操作</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs csharp">@Test<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query_unanswered_questions</span>() throws IOException</span> &#123;<br>    <span class="hljs-comment">// 使用 HttpClientBuilder 创建一个 CloseableHttpClient 实例。</span><br>    CloseableHttpClient httpClient = HttpClientBuilder.create().build();<br><br>    <span class="hljs-comment">// 创建一个 HttpGet 请求对象，URL 指向知识星球API的特定端点。</span><br>    <span class="hljs-comment">// 这个端点用于获取指定群组中的“未回答问题”。</span><br>    HttpGet <span class="hljs-keyword">get</span> = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">&quot;https://api.zsxq.com/v2/groups/48411118851818/topics?scope=unanswered_questions&amp;count=20&quot;</span>);<br><br>    <span class="hljs-comment">// 添加请求头。这里的 &quot;cookie&quot; 需要替换为有效的知识星球个人cookie信息，用于身份验证。</span><br>    <span class="hljs-keyword">get</span>.addHeader(<span class="hljs-string">&quot;cookie&quot;</span>, <span class="hljs-string">&quot;知识星球个人cookie信息&quot;</span>);<br><br>    <span class="hljs-comment">// 设置请求的内容类型为 JSON，并指定字符集为 UTF-8。</span><br>    <span class="hljs-keyword">get</span>.addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=utf8&quot;</span>);<br><br>    <span class="hljs-comment">// 执行 HTTP GET 请求并获取响应。</span><br>    CloseableHttpResponse response = httpClient.execute(<span class="hljs-keyword">get</span>);<br><br>    <span class="hljs-comment">// 检查响应状态码。如果状态码为 200 (HttpStatus.SC_OK)，表示请求成功。</span><br>    <span class="hljs-keyword">if</span> (response.getStatusLine().getStatusCode() == HttpStatus.SC_OK) &#123;<br>        <span class="hljs-comment">// 将响应实体转换为字符串，并打印出来。这通常是 JSON 格式的数据。</span><br>        String res = EntityUtils.toString(response.getEntity());<br>        System.<span class="hljs-keyword">out</span>.println(res);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果状态码不是 200，打印出状态码。</span><br>        <span class="hljs-comment">// 这可能表明请求出错或其他问题。</span><br>        System.<span class="hljs-keyword">out</span>.println(response.getStatusLine().getStatusCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里需要注意的是：需要正确设置知识星球的个人cookie信息才能成功发起请求，信息从浏览器的F12中查看。</p><h4 id="回答相关问题"><a href="#回答相关问题" class="headerlink" title="回答相关问题"></a>回答相关问题</h4><p>用于回答知识星球平台上的某个特定话题</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs wren">@<span class="hljs-title class_">Test</span><br><span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">answer</span>() <span class="hljs-variable">throws</span> <span class="hljs-title class_">IOException</span> &#123;<br>    <span class="hljs-comment">// 使用 HttpClientBuilder 创建一个 CloseableHttpClient 实例。</span><br>    <span class="hljs-title class_">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">HttpClientBuilder</span>.<span class="hljs-property">create</span>().<span class="hljs-property">build</span>();<br><br>    <span class="hljs-comment">// 创建一个 HttpPost 请求对象，URL 指向知识星球API的特定端点。</span><br>    <span class="hljs-comment">// 这个端点用于回答一个指定的话题。</span><br>    <span class="hljs-title class_">HttpPost</span> <span class="hljs-variable">post</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;https://api.zsxq.com/v2/topics/412884248251548/answer&quot;</span>);<br><br>    <span class="hljs-comment">// 添加请求头。这里的 &quot;cookie&quot; 需要替换为有效的知识星球个人cookie信息，用于身份验证。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">addHeader</span>(<span class="hljs-string">&quot;cookie&quot;</span>, <span class="hljs-string">&quot;知识星球个人cookie信息&quot;</span>);<br><br>    <span class="hljs-comment">// 设置请求的内容类型为 JSON，并指定字符集为 UTF-8。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json;charset=utf8&quot;</span>);<br><br>    <span class="hljs-comment">// 创建一个 JSON 格式的字符串，作为 POST 请求的参数。</span><br>    <span class="hljs-comment">// 这里的参数包括回答的文本、图片ID（如果有的话）和是否静音（silenced）。</span><br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">paramJson</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  <span class="hljs-char escape_">\&quot;</span>req_data<span class="hljs-char escape_">\&quot;</span>: &#123;<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    <span class="hljs-char escape_">\&quot;</span>text<span class="hljs-char escape_">\&quot;</span>: <span class="hljs-char escape_">\&quot;</span>自己去百度！<span class="hljs-char escape_">\\</span>n<span class="hljs-char escape_">\&quot;</span>,<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    <span class="hljs-char escape_">\&quot;</span>image_ids<span class="hljs-char escape_">\&quot;</span>: [],<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;    <span class="hljs-char escape_">\&quot;</span>silenced<span class="hljs-char escape_">\&quot;</span>: false<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;  &#125;<span class="hljs-char escape_">\n</span>&quot;</span> <span class="hljs-operator">+</span><br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br><br>    <span class="hljs-comment">// 创建一个 StringEntity 来封装 JSON 参数，设置其内容类型和编码。</span><br>    <span class="hljs-title class_">StringEntity</span> <span class="hljs-variable">stringEntity</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">StringEntity</span>(<span class="hljs-variable">paramJson</span>, <span class="hljs-title class_">ContentType</span>.<span class="hljs-property">create</span>(<span class="hljs-string">&quot;text/json&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>    <span class="hljs-comment">// 将封装好的参数设置到 POST 请求中。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">setEntity</span>(<span class="hljs-variable">stringEntity</span>);<br><br>    <span class="hljs-comment">// 执行 HTTP POST 请求并获取响应。</span><br>    <span class="hljs-title class_">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-variable">httpClient</span>.<span class="hljs-property">execute</span>(<span class="hljs-variable">post</span>);<br><br>    <span class="hljs-comment">// 检查响应状态码。如果状态码为 200 (HttpStatus.SC_OK)，表示请求成功。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">response</span>.<span class="hljs-property">getStatusLine</span>().<span class="hljs-property">getStatusCode</span>() <span class="hljs-operator">==</span> <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">SC_OK</span>) &#123;<br>        <span class="hljs-comment">// 将响应实体转换为字符串，并打印出来。这通常是 JSON 格式的数据。</span><br>        <span class="hljs-title class_">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">EntityUtils</span>.<span class="hljs-property">toString</span>(<span class="hljs-variable">response</span>.<span class="hljs-property">getEntity</span>());<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">res</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果状态码不是 200，打印出状态码。</span><br>        <span class="hljs-comment">// 这可能表明请求出错或其他问题。</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">response</span>.<span class="hljs-property">getStatusLine</span>().<span class="hljs-property">getStatusCode</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-ChatGPT-模型生成文本"><a href="#使用-ChatGPT-模型生成文本" class="headerlink" title="使用 ChatGPT 模型生成文本"></a>使用 ChatGPT 模型生成文本</h4><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs wren">@<span class="hljs-title class_">Test</span><br><span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">test_chatGPT</span>() <span class="hljs-variable">throws</span> <span class="hljs-title class_">IOException</span> &#123;<br>    <span class="hljs-comment">// 使用 HttpClientBuilder 创建一个 CloseableHttpClient 实例。</span><br>    <span class="hljs-title class_">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">HttpClientBuilder</span>.<span class="hljs-property">create</span>().<span class="hljs-property">build</span>();<br><br>    <span class="hljs-comment">// 创建一个 HttpPost 请求对象，URL 设置为 OpenAI API 的地址。</span><br>    <span class="hljs-title class_">HttpPost</span> <span class="hljs-variable">post</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HttpPost</span>(<span class="hljs-string">&quot;https://api.openai.com/v1/completions&quot;</span>);<br><br>    <span class="hljs-comment">// 设置请求头，指定内容类型为 JSON。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">addHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br>    <span class="hljs-comment">// 设置授权头。&quot;Bearer 自行申请 https://beta.openai.com/overview&quot; 需要替换为有效的授权令牌。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">addHeader</span>(<span class="hljs-string">&quot;Authorization&quot;</span>, <span class="hljs-string">&quot;Bearer 自行申请 https://beta.openai.com/overview&quot;</span>);<br><br>    <span class="hljs-comment">// 创建一个 JSON 字符串作为请求体。这里指定模型为 &quot;text-davinci-003&quot;，</span><br>    <span class="hljs-comment">// 提示词为 &quot;帮我写一个java冒泡排序&quot;，温度设置为0（生成文本的确定性更高），</span><br>    <span class="hljs-comment">// 并且最大令牌数设置为1024。</span><br>    <span class="hljs-title class_">String</span> <span class="hljs-variable">paramJson</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&#123;<span class="hljs-char escape_">\&quot;</span>model<span class="hljs-char escape_">\&quot;</span>: <span class="hljs-char escape_">\&quot;</span>text-davinci-003<span class="hljs-char escape_">\&quot;</span>, <span class="hljs-char escape_">\&quot;</span>prompt<span class="hljs-char escape_">\&quot;</span>: <span class="hljs-char escape_">\&quot;</span>帮我写一个java冒泡排序<span class="hljs-char escape_">\&quot;</span>, <span class="hljs-char escape_">\&quot;</span>temperature<span class="hljs-char escape_">\&quot;</span>: 0, <span class="hljs-char escape_">\&quot;</span>max_tokens<span class="hljs-char escape_">\&quot;</span>: 1024&#125;&quot;</span>;<br><br>    <span class="hljs-comment">// 将 JSON 参数封装到一个 StringEntity 对象中，并设置其内容类型和编码。</span><br>    <span class="hljs-title class_">StringEntity</span> <span class="hljs-variable">stringEntity</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">StringEntity</span>(<span class="hljs-variable">paramJson</span>, <span class="hljs-title class_">ContentType</span>.<span class="hljs-property">create</span>(<span class="hljs-string">&quot;text/json&quot;</span>, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br><br>    <span class="hljs-comment">// 将封装好的参数添加到 POST 请求中。</span><br>    <span class="hljs-variable">post</span>.<span class="hljs-property">setEntity</span>(<span class="hljs-variable">stringEntity</span>);<br><br>    <span class="hljs-comment">// 执行 HTTP POST 请求并获取响应。</span><br>    <span class="hljs-title class_">CloseableHttpResponse</span> <span class="hljs-variable">response</span> <span class="hljs-operator">=</span> <span class="hljs-variable">httpClient</span>.<span class="hljs-property">execute</span>(<span class="hljs-variable">post</span>);<br><br>    <span class="hljs-comment">// 检查响应状态码。如果状态码为 200 (HttpStatus.SC_OK)，表示请求成功。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-variable">response</span>.<span class="hljs-property">getStatusLine</span>().<span class="hljs-property">getStatusCode</span>() <span class="hljs-operator">==</span> <span class="hljs-title class_">HttpStatus</span>.<span class="hljs-property">SC_OK</span>) &#123;<br>        <span class="hljs-comment">// 将响应实体转换为字符串并打印。这通常是 JSON 格式的数据，包含由模型生成的文本。</span><br>        <span class="hljs-title class_">String</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">EntityUtils</span>.<span class="hljs-property">toString</span>(<span class="hljs-variable">response</span>.<span class="hljs-property">getEntity</span>());<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">res</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果状态码不是 200，打印出状态码。</span><br>        <span class="hljs-comment">// 这可能表明请求出错或其他问题。</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-variable">response</span>.<span class="hljs-property">getStatusLine</span>().<span class="hljs-property">getStatusCode</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="定时任务进行爬取问题并进行回复"><a href="#定时任务进行爬取问题并进行回复" class="headerlink" title="定时任务进行爬取问题并进行回复"></a>定时任务进行爬取问题并进行回复</h4><p>核心方法是 ChatbotTask下重写的 run 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 随机决定是否执行此次任务。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Random</span>().nextBoolean()) &#123;<br>            logger.info(<span class="hljs-string">&quot;&#123;&#125; 随机打烊中...&quot;</span>, groupName);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取当前时间。</span><br>        <span class="hljs-type">GregorianCalendar</span> <span class="hljs-variable">calendar</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GregorianCalendar</span>();<br>        <span class="hljs-type">int</span> <span class="hljs-variable">hour</span> <span class="hljs-operator">=</span> calendar.get(Calendar.HOUR_OF_DAY);<br><br>        <span class="hljs-comment">// 判断当前是否在非工作时间（晚上 22 点后或早上 7 点前）。</span><br>        <span class="hljs-keyword">if</span> (hour &gt; <span class="hljs-number">22</span> || hour &lt; <span class="hljs-number">7</span>) &#123;<br>            logger.info(<span class="hljs-string">&quot;&#123;&#125; 打烊时间不工作，AI 下班了！&quot;</span>, groupName);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 1. 检索问题：从某 API 获取未回答的问题。</span><br>        <span class="hljs-type">UnAnsweredQuestionsAggregates</span> <span class="hljs-variable">unAnsweredQuestionsAggregates</span> <span class="hljs-operator">=</span> zsxqApi.queryUnAnsweredQuestionsTopicId(groupId, cookie);<br>        logger.info(<span class="hljs-string">&quot;&#123;&#125; 检索结果：&#123;&#125;&quot;</span>, groupName, JSON.toJSONString(unAnsweredQuestionsAggregates));<br>        List&lt;Topics&gt; topics = unAnsweredQuestionsAggregates.getResp_data().getTopics();<br><br>        <span class="hljs-comment">// 判断是否检索到未回答的问题。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-literal">null</span> == topics || topics.isEmpty()) &#123;<br>            logger.info(<span class="hljs-string">&quot;&#123;&#125; 本次检索未查询到待会答问题&quot;</span>, groupName);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 2. AI 回答：使用 AI（可能是 ChatGPT 或类似服务）来生成回答。</span><br>        <span class="hljs-type">Topics</span> <span class="hljs-variable">topic</span> <span class="hljs-operator">=</span> topics.get(topics.size() - <span class="hljs-number">1</span>); <span class="hljs-comment">// 取最后一个问题进行回答。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">answer</span> <span class="hljs-operator">=</span> openAI.doChatGPT(openAiKey, topic.getQuestion().getText().trim());<br><br>        <span class="hljs-comment">// 3. 问题回复：将 AI 生成的回答发送回 API。</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">status</span> <span class="hljs-operator">=</span> zsxqApi.answer(groupId, cookie, topic.getTopic_id(), answer, silenced);<br>        logger.info(<span class="hljs-string">&quot;&#123;&#125; 编号：&#123;&#125; 问题：&#123;&#125; 回答：&#123;&#125; 状态：&#123;&#125;&quot;</span>, groupName, topic.getTopic_id(), topic.getQuestion().getText(), answer, status);<br><br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-comment">// 记录任何异常。</span><br>        logger.error(<span class="hljs-string">&quot;&#123;&#125; 自动回答问题异常&quot;</span>, groupName, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多组任务配置操作"><a href="#多组任务配置操作" class="headerlink" title="多组任务配置操作"></a>多组任务配置操作</h4><p>TaskRegistrarAutoConfig 配置类, 这个类是用于配置和安排一系列的定时任务</p><p>下面是其中的两个方法的说明和阐述：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setEnvironment</span>(<span class="hljs-params">Environment environment</span>) &#123;<br>    <span class="hljs-comment">// 设置配置前缀。</span><br>    <span class="hljs-title class_">String</span> prefix = <span class="hljs-string">&quot;chatbot-api.&quot;</span>;<br><br>    <span class="hljs-comment">// 从环境变量中获取配置项 &#x27;chatbot-api.launchList&#x27;。</span><br>    <span class="hljs-title class_">String</span> launchListStr = environment.<span class="hljs-title function_">getProperty</span>(prefix + <span class="hljs-string">&quot;launchList&quot;</span>);<br><br>    <span class="hljs-comment">// 如果配置项为空，则直接返回。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isEmpty</span>(launchListStr)) <span class="hljs-keyword">return</span>;<br><br>    <span class="hljs-comment">// 分割配置字符串，遍历每个组键。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> groupKey : launchListStr.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;,&quot;</span>)) &#123;<br>        <span class="hljs-comment">// 根据组键获取相关的任务组属性。</span><br>        <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Object</span>&gt; taskGroupProps = <span class="hljs-title class_">PropertyUtil</span>.<span class="hljs-title function_">handle</span>(environment, prefix + groupKey, <span class="hljs-title class_">Map</span>.<span class="hljs-property">class</span>);<br><br>        <span class="hljs-comment">// 将任务组属性存储在 taskGroupMap 中。</span><br>        taskGroupMap.<span class="hljs-title function_">put</span>(groupKey, taskGroupProps);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>从应用程序的环境变量中读取任务配置。</li><li>将配置字符串（例如，分组键）分割并遍历每个分组。</li><li>对于每个分组键，获取其相关属性并存储在 <code>taskGroupMap</code> 中。</li></ul><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-meta">@Override</span><br>public <span class="hljs-keyword">void</span> configureTasks(ScheduledTaskRegistrar taskRegistrar) &#123;<br>    <span class="hljs-comment">// 获取所有任务组的键集。</span><br>    <span class="hljs-built_in">Set</span>&lt;<span class="hljs-built_in">String</span>&gt; taskGroups = taskGroupMap.keySet();<br><br>    <span class="hljs-comment">// 遍历每个任务组的键。</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-built_in">String</span> groupKey : taskGroups) &#123;<br>        <span class="hljs-comment">// 获取每个任务组的配置。</span><br>        <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Object</span>&gt; taskGroup = taskGroupMap.<span class="hljs-keyword">get</span>(groupKey);<br><br>        <span class="hljs-comment">// 从配置中提取任务相关信息。</span><br>        <span class="hljs-built_in">String</span> groupName = taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;groupName&quot;</span>).toString();<br>        <span class="hljs-built_in">String</span> groupId = taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;groupId&quot;</span>).toString();<br>        <span class="hljs-built_in">String</span> cookie = taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;cookie&quot;</span>).toString();<br>        <span class="hljs-built_in">String</span> openAiKey = taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;openAiKey&quot;</span>).toString();<br>        <span class="hljs-built_in">String</span> cronExpressionBase64 = taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;cronExpression&quot;</span>).toString();<br><br>        <span class="hljs-comment">// 解码 Base64 编码的 cron 表达式。</span><br>        <span class="hljs-built_in">String</span> cronExpression = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(Base64.getDecoder().decode(cronExpressionBase64), StandardCharsets.UTF_8);<br><br>        <span class="hljs-comment">// 获取是否静音的布尔值。</span><br>        boolean silenced = Boolean.parseBoolean(taskGroup.<span class="hljs-keyword">get</span>(<span class="hljs-string">&quot;silenced&quot;</span>).toString());<br><br>        <span class="hljs-comment">// 记录日志信息。</span><br>        logger.info(<span class="hljs-string">&quot;创建任务 groupName：&#123;&#125; groupId：&#123;&#125; cronExpression：&#123;&#125;&quot;</span>, groupName, groupId, cronExpression);<br><br>        <span class="hljs-comment">// 添加定时任务。</span><br>        taskRegistrar.addCronTask(<span class="hljs-keyword">new</span> ChatbotTask(groupName, groupId, cookie, openAiKey, zsxqApi, openAI, silenced), cronExpression);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>配置和安排定时任务。</li><li>遍历之前在 <code>setEnvironment</code> 方法中设置的任务组。</li><li>从每个任务组配置中提取必要信息，包括任务名称、群组 ID、cookie、OpenAI 密钥、cron 表达式和静音标志。</li><li>对 Base64 编码的 cron 表达式进行解码。</li><li>创建并安排每个任务，使用提取的信息初始化 <code>ChatbotTask</code> 并将其添加到 <code>ScheduledTaskRegistrar</code>。</li></ul><h4 id="项目运行-🦅🦅"><a href="#项目运行-🦅🦅" class="headerlink" title="项目运行 🦅🦅"></a>项目运行 🦅🦅</h4><p>个人充值 openai 的 key 存在问题，这里是使用淘宝第三方购买的 apikey</p><p>to  be contined….</p><h3 id="3、二开（订阅号信息回复）定时发送消息"><a href="#3、二开（订阅号信息回复）定时发送消息" class="headerlink" title="3、二开（订阅号信息回复）定时发送消息"></a>3、二开（订阅号信息回复）定时发送消息</h3><p>有一个公众号定时推送的开源项目，可以看一下：  <a href="https://gitee.com/love_c/wechatPush?_from=gitee_searc">https://gitee.com/love_c/wechatPush?_from=gitee_searc</a></p><p>微信公众号回复的博客： <a href="https://cloud.tencent.com/developer/article/1641549">https://cloud.tencent.com/developer/article/1641549</a></p><p>其博客内容的代码地址： <a href="https://github.com/tsmyk0715/wechatproject">https://github.com/tsmyk0715/wechatproject</a> （这个项目还是四年前的项目）</p><p>尝试后续使用一下 WxJava 这个开源项目的相关内容 ： <a href="https://gitee.com/binary/weixin-java-tools">https://gitee.com/binary/weixin-java-tools</a></p><hr><p>实际运行的时候发现这里的接口参数还是需要使用测试号，如果使用个人号的话有权限限制，微信很多接口不能使用，这个需要注意一下。或者以后有机会拥有自己的服务号。</p><p>测试号申请地址： <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p><h4 id="定制化发送消息模板"><a href="#定制化发送消息模板" class="headerlink" title="定制化发送消息模板"></a>定制化发送消息模板</h4><p>wechatPush 这个开源项目中主要的工具类是： PushUtil</p><p>这里进行部分分析，该工具类 PushUtil 下 的 push 方法是 定义了一个微信消息推送的方法。它创建和发送定制化的模板消息给特定的用户</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息推送主要业务代码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title function_">push</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 创建一个 CloseableHttpClient 实例。</span><br>    <span class="hljs-type">CloseableHttpClient</span> <span class="hljs-variable">httpClient</span> <span class="hljs-operator">=</span> HttpClientBuilder.create().build();<br><br>    <span class="hljs-comment">// 构建微信模板消息。</span><br>    <span class="hljs-type">WxMpTemplateMessage</span> <span class="hljs-variable">templateMessage</span> <span class="hljs-operator">=</span> WxMpTemplateMessage.builder()<br>            .templateId(PushConfigure.getTemplateId())<br>            .build();<br><br>    <span class="hljs-comment">// 计算与特定日期相关的天数，例如恋爱纪念日。</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">loveDays</span> <span class="hljs-operator">=</span> MemoryDayUtil.calculationLianAi(PushConfigure.getLoveDate());<br><br>    <span class="hljs-comment">// 计算距离生日的天数。</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">birthdays</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (PushConfigure.isUseLunar()) &#123;<br>        <span class="hljs-comment">// 如果使用农历生日，调用相应方法计算。</span><br>        birthdays = MemoryDayUtil.calculationBirthdayByLunar(PushConfigure.getBirthday());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 使用阳历生日计算。</span><br>        birthdays = MemoryDayUtil.calculationBirthday(PushConfigure.getBirthday());<br>    &#125;<br><br>    <span class="hljs-comment">// 向模板消息添加相关数据。</span><br>    templateMessage.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WxMpTemplateData</span>(<span class="hljs-string">&quot;loveDays&quot;</span>, loveDays + <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;#FF1493&quot;</span>));<br>    templateMessage.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WxMpTemplateData</span>(<span class="hljs-string">&quot;birthdays&quot;</span>, birthdays + <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;#FFA500&quot;</span>));<br><br>    <span class="hljs-comment">// 获取天气数据。</span><br>    <span class="hljs-type">Result</span> <span class="hljs-variable">weatherResult</span> <span class="hljs-operator">=</span> WeatherUtil.getWeather();<br>    <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">messageAll</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br><br>    <span class="hljs-comment">// 处理天气数据。</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;0&quot;</span>.equals(weatherResult.getCode())) &#123;<br>        <span class="hljs-comment">// 如果获取天气数据失败，记录失败信息。</span><br>        messageAll.append(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>        messageAll.append(weatherResult.getMessage());<br>        templateMessage.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WxMpTemplateData</span>(<span class="hljs-string">&quot;weather&quot;</span>, <span class="hljs-string">&quot;***&quot;</span>, <span class="hljs-string">&quot;#00FFFF&quot;</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 如果成功获取天气数据，提取并添加到模板消息中。</span><br>        <span class="hljs-type">Weather</span> <span class="hljs-variable">weather</span> <span class="hljs-operator">=</span> (Weather) weatherResult.getData();<br>        <span class="hljs-comment">// 初始化农历日期工具类。</span><br>        <span class="hljs-type">LunarCalendarFestivalUtils</span> <span class="hljs-variable">festival</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LunarCalendarFestivalUtils</span>();<br>        festival.initLunarCalendarInfo(weather.getDate());<br><br>        <span class="hljs-comment">// 向模板消息中添加各种天气和日期信息。</span><br>        <span class="hljs-comment">// ... (代码省略)</span><br><br>        <span class="hljs-comment">// 天行数据接口调用。</span><br>        <span class="hljs-type">Result</span> <span class="hljs-variable">rainbowResult</span> <span class="hljs-operator">=</span> RainbowUtil.getRainbow();<br>        <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;200&quot;</span>.equals(rainbowResult.getCode())) &#123;<br>            <span class="hljs-comment">// 如果天行数据接口调用失败，记录失败信息。</span><br>            messageAll.append(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>            messageAll.append(rainbowResult.getMessage());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 成功获取天行数据，添加到模板消息。</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> (String) rainbowResult.getData();<br>            data = data.replaceAll(<span class="hljs-string">&quot;\r|\n&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);<br>            templateMessage.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WxMpTemplateData</span>(<span class="hljs-string">&quot;rainbow&quot;</span>, data, <span class="hljs-string">&quot;#FF69B4&quot;</span>));<br>        &#125;<br><br>        <span class="hljs-comment">// 根据不同的日期条件添加备注信息。</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">remark</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;❤&quot;</span>;<br>        <span class="hljs-comment">// ... (处理特定日期逻辑的代码)</span><br><br>        templateMessage.addData(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WxMpTemplateData</span>(<span class="hljs-string">&quot;remark&quot;</span>, remark, <span class="hljs-string">&quot;#FF1493&quot;</span>));<br><br>        <span class="hljs-comment">// 输出模板消息的 JSON 表示。</span><br>        System.out.println(templateMessage.toJson());<br><br>        <span class="hljs-comment">// 获取微信模板消息服务。</span><br>        <span class="hljs-type">WxMpTemplateMsgService</span> <span class="hljs-variable">service</span> <span class="hljs-operator">=</span> getService();<br><br>        <span class="hljs-comment">// 记录发送成功和失败的计数。</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">suc</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">err</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (String userId : PushConfigure.getUserId()) &#123;<br>            templateMessage.setToUser(userId);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 发送模板消息。</span><br>                service.sendTemplateMsg(templateMessage);<br>                suc += <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (WxErrorException e) &#123;<br>                <span class="hljs-comment">// 如果发送失败，记录失败信息。</span><br>            err += <span class="hljs-number">1</span>;<br>            messageAll.append(suc).append(<span class="hljs-string">&quot;个成功!&quot;</span>);<br>            messageAll.append(err).append(<span class="hljs-string">&quot;个失败!&quot;</span>);<br>            messageAll.append(<span class="hljs-string">&quot;&lt;br/&gt;&quot;</span>);<br>            messageAll.append(e.getMessage());<br>            <span class="hljs-comment">// 返回推送结果。</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;推送结果:&quot;</span> + messageAll;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 如果所有消息发送完毕，返回成功推送的用户数量和消息。</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;成功推送给&quot;</span> + suc + <span class="hljs-string">&quot;个用户!&quot;</span> + messageAll;<br>&#125;<br></code></pre></td></tr></table></figure><p>功能概述：</p><ul><li>此方法主要用于构建和发送定制化的微信模板消息。</li><li>它包含对恋爱纪念日和生日的计算，获取天气信息，以及调用天行数据接口。</li><li>消息的内容根据特定的日期条件进行定制。</li><li>最后，该方法通过微信公众号平台的 API 发送消息给指定的用户列表。</li></ul><p>注意事项：</p><ul><li>需要有效的微信公众号配置信息，如模板 ID 和用户 ID。</li><li><code>PushConfigure</code> 类中应包含所有相关的配置信息。</li><li>天气信息和天行数据接口的实现细节没有在代码中给出，需要单独实现。</li><li>异常处理用于捕获和记录消息发送过程中的错误。</li><li>此方法在成功发送所有消息后，返回一个汇总的结果字符串。</li></ul><h4 id="微信消息推送"><a href="#微信消息推送" class="headerlink" title="微信消息推送"></a>微信消息推送</h4><p>看了一下调用关系，其中核心方法是： executeInternal</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> &lt;T, E&gt; <span class="hljs-function">T <span class="hljs-title">executeInternal</span><span class="hljs-params">(RequestExecutor&lt;T, E&gt; executor, String uri, E data)</span> <span class="hljs-keyword">throws</span> WxErrorException </span>&#123;<br>    <span class="hljs-comment">// 处理日志中的敏感数据，例如脱敏。</span><br>    E dataForLog = DataUtils.handleDataWithSecret(data);<br><br>    <span class="hljs-comment">// 检查 URI 是否错误地包含 access_token，如果包含则抛出异常。</span><br>    <span class="hljs-keyword">if</span> (uri.contains(<span class="hljs-string">&quot;access_token=&quot;</span>)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;uri参数中不允许有access_token: &quot;</span> + uri);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取 access token，并构造带有 access token 的完整 URI。</span><br>        String accessToken = <span class="hljs-keyword">this</span>.getAccessToken(<span class="hljs-keyword">false</span>);<br>        String uriWithAccessToken = uri + (uri.contains(<span class="hljs-string">&quot;?&quot;</span>) ? <span class="hljs-string">&quot;&amp;&quot;</span> : <span class="hljs-string">&quot;?&quot;</span>) + <span class="hljs-string">&quot;access_token=&quot;</span> + accessToken;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 使用传入的 executor 执行请求，并获取结果。</span><br>            T result = executor.execute(uriWithAccessToken, data);<br><br>            <span class="hljs-comment">// 记录请求和响应数据到日志。</span><br>            <span class="hljs-keyword">this</span>.log.debug(<span class="hljs-string">&quot;\n【请求地址】: &#123;&#125;\n【请求参数】：&#123;&#125;\n【响应数据】：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Object[]&#123;uriWithAccessToken, dataForLog, result&#125;);<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (WxErrorException var9) &#123;<br>            <span class="hljs-comment">// 处理微信错误异常。</span><br>            WxError <span class="hljs-keyword">error</span> = var9.getError();<br><br>            <span class="hljs-comment">// 检查是否是因为 access token 过期引起的错误，并尝试刷新。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>.getErrorCode() == <span class="hljs-number">42001</span> || <span class="hljs-keyword">error</span>.getErrorCode() == <span class="hljs-number">40001</span> || <span class="hljs-keyword">error</span>.getErrorCode() == <span class="hljs-number">40014</span>) &#123;<br>                <span class="hljs-keyword">this</span>.getWxMpConfigStorage().expireAccessToken();<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getWxMpConfigStorage().autoRefreshToken()) &#123;<br>                    <span class="hljs-function"><span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-title">execute</span><span class="hljs-params">(executor, uri, data)</span></span>;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-comment">// 如果错误码不为0，记录错误并抛出异常。</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">error</span>.getErrorCode() != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">this</span>.log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;\n【请求地址】: &#123;&#125;\n【请求参数】：&#123;&#125;\n【错误信息】：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Object[]&#123;uriWithAccessToken, dataForLog, <span class="hljs-keyword">error</span>&#125;);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WxErrorException(<span class="hljs-keyword">error</span>, var9);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException var10) &#123;<br>            <span class="hljs-comment">// 处理 IO 异常。</span><br>            <span class="hljs-keyword">this</span>.log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;\n【请求地址】: &#123;&#125;\n【请求参数】：&#123;&#125;\n【异常信息】：&#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> Object[]&#123;uriWithAccessToken, dataForLog, var10.getMessage()&#125;);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WxErrorException(WxError.builder().errorMsg(var10.getMessage()).build(), var10);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>具体的调用关系有兴趣可以看一下项目代码。</p><h4 id="天气查询"><a href="#天气查询" class="headerlink" title="天气查询"></a>天气查询</h4><p>通过百度地图开发平台获取当地天气，需要申请成为开发者： <a href="https://lbsyun.baidu.com/apiconsole/center">https://lbsyun.baidu.com/apiconsole/center</a></p><p>国内天气查询： <a href="https://lbs.baidu.com/faq/api?title=webapi/weather/base">https://lbs.baidu.com/faq/api?title=webapi/weather/base</a></p><p>用户可通过行政区划代码查询实时天气信息及未来5天天气预报。</p><p>api 服务地址： </p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>api.map.baidu.com<span class="hljs-regexp">/weather/</span>v1/?district_id=<span class="hljs-number">222405</span>&amp;data_type=all&amp;ak=你的ak  <br><span class="hljs-regexp">//</span>GET请求<br></code></pre></td></tr></table></figure><p>需要先获取到 Access Key </p><p>在控制台管理 →  应用管理 → 我的应用： <a href="https://lbs.baidu.com/apiconsole/key/create">https://lbs.baidu.com/apiconsole/key/create</a></p><p>需要创建一个应用才能看到 AK</p><p>有兴趣可以看一下，通过IP地址获取邮政编码: <a href="https://blog.51cto.com/u_16175454/7185643">https://blog.51cto.com/u_16175454/7185643</a></p><p>但实际并不是邮政编码，而是看一下官网文档给的ID编号。</p><p>官网有一份文档 <a href="https://lbs.baidu.com/faq/api?title=webapi/weather/base">https://lbs.baidu.com/faq/api?title=webapi/weather/base</a>   ，</p><p>可以下载看一下：广州 440100  深圳 440300</p><p>设置IP访问白名单：  建议直接设置  0.0.0.0&#x2F;0 </p><p>由于不是公网访问，设置的IP应该是有点问题。</p><h4 id="”彩虹屁“接口"><a href="#”彩虹屁“接口" class="headerlink" title="”彩虹屁“接口"></a>”彩虹屁“接口</h4><p>调用的第三方接口，天聚数行平台的</p><p>接口地址： <a href="https://www.tianapi.com/apiview/181">https://www.tianapi.com/apiview/181</a></p><p>访问需要密钥： <a href="https://www.tianapi.com/console/">https://www.tianapi.com/console/</a></p><p>控制台 → 安全管理</p><p>实际使用的时候他这个第三方接口的 IP 白名单有遇到坑，设置不生效，新增之后；</p><p>后面不断尝试之后发现你充值他的 密钥Key 好像才刷新生效了。</p><h4 id="编辑模板"><a href="#编辑模板" class="headerlink" title="编辑模板"></a>编辑模板</h4><p>最后推送的时候用到了一个模板ID，我们需要在测试微信公众号这里编辑一下模板</p><figure class="highlight handlebars"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">你好，今天是</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">date.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">农历</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">lunar.DATA</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">festival.DATA</span>&#125;&#125;</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">remark.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">你所在的城市位置:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">city.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">当前天气:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">weather.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">最低气温: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">low.DATA</span>&#125;&#125;</span><span class="language-xml">度</span><br><span class="language-xml">最高气温: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">high.DATA</span>&#125;&#125;</span><span class="language-xml">度</span><br><span class="language-xml">风力: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">wc_day.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">风向: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">wd_day.DATA</span>&#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml"></span><br><span class="language-xml">学习打卡~</span><br><span class="language-xml">请开始今天晚上的学习吧！</span><br><span class="language-xml">今天是打卡的第</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">loveDays.DATA</span>&#125;&#125;</span><span class="language-xml">天</span><br><span class="language-xml">距离一年还剩下</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">birthdays.DATA</span>&#125;&#125;</span><span class="language-xml">天</span><br><span class="language-xml">Encourage:</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">rainbow.DATA</span>&#125;&#125;</span><br></code></pre></td></tr></table></figure><p>自定义模板后进行提交，复制提交后的 模板ID，放到配置文件中</p><p>userID 也是直接可以在公众号平台的列表可以看到</p><p>调用测试地址： <a href="http://localhost/test">http://localhost/test</a></p><h4 id="定时推送"><a href="#定时推送" class="headerlink" title="定时推送"></a>定时推送</h4><p>建立了一个定时任务配置类</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> com.tsmyk.wechatproject.wechat.scheduled;<br><br><span class="hljs-keyword">import</span> com.tsmyk.wechatproject.wechat.utils.PushMessageUtils;<br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.<span class="hljs-keyword">annotation</span>.EnableScheduling;<br><span class="hljs-keyword">import</span> org.springframework.scheduling.<span class="hljs-keyword">annotation</span>.Scheduled;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Task 定时任务</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> cws</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/8/22 21:42</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@EnableScheduling</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Task</span> &#123;<br>    <span class="hljs-comment">// 定时任务</span><br>    <span class="hljs-meta">@Scheduled(cron = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;wechat.cron&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> void goodMorning() &#123;<br>        PushMessageUtils.push();;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、接收微信消息并进行回复"><a href="#4、接收微信消息并进行回复" class="headerlink" title="4、接收微信消息并进行回复"></a>4、接收微信消息并进行回复</h3><p>项目地址： <a href="https://github.com/tsmyk0715/wechatproject">https://github.com/tsmyk0715/wechatproject</a></p><h4 id="项目介绍-🦌🦌🦌"><a href="#项目介绍-🦌🦌🦌" class="headerlink" title="项目介绍  🦌🦌🦌"></a>项目介绍  🦌🦌🦌</h4><p>先申请一个订阅号，登陆地址： <a href="https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&lang=zh_CN">https://mp.weixin.qq.com/cgi-bin/loginpage?t=wxm2-login&amp;lang=zh_CN</a></p><p>授权信息在 设置与开发 → 基本配置（申请成为开发者）</p><p>也可以进入到这个测试微信公众号地址： <a href="https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login">https://mp.weixin.qq.com/debug/cgi-bin/sandbox?t=sandbox/login</a></p><p>测试一下获取用户消息并进行回复</p><p>下载该项目： <a href="https://github.com/tsmyk0715/wechatproject">https://github.com/tsmyk0715/wechatproject</a> </p><h5 id="项目分析"><a href="#项目分析" class="headerlink" title="项目分析"></a>项目分析</h5><p>这个项目是使用的 开源工具 <code>weixin-java-mp</code> 进行开发的</p><p>同时你需要获取到微信向你发送消息，因此需要内网穿透一下，将本地的访问映射到公网。‘</p><p>这个项目相当于了你对自己的微信号服务进行个性化操作，关键操作是通过关联微信接口来进行实现的。</p><p>第三章的学习内容建议学习一下它的模板化操作和定时发送操作。</p><p>这个项目值得学习还挺多内容的，微信平台在后续的使用应该是比较频繁的，后续也可以学习 WxJava 等内容。</p><p>接口参数配置建议使用测试号。</p><h5 id="配置IP白名单"><a href="#配置IP白名单" class="headerlink" title="配置IP白名单"></a>配置IP白名单</h5><p>在公众号的基本配置里面的 IP 白名单，需要配置一下你的服务器IP</p><h5 id="获取access-token"><a href="#获取access-token" class="headerlink" title="获取access_token"></a>获取access_token</h5><p>这个是微信接口中的其中一个接口，需要获取到其他接口信息需要用到这个信息</p><p>微信公众号开发者文档： <a href="https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html">https://developers.weixin.qq.com/doc/offiaccount/Getting_Started/Overview.html</a></p><p>什么是 <code>access_token</code>? 官网的介绍如下：</p><p><code>access_token</code>是公众号的全局唯一接口调用凭据，公众号调用各接口时都需使用<code>access_token</code>。开发者需要进行妥善保存。<code>access_token</code>的存储至少要保留512个字符空间。<code>access_token</code>的有效期目前为<code>2</code>个小时，需定时刷新，重复获取将导致上次获取的access_token失效。</p><p>获取 <code>access_token</code> 的接口每日调用是有限制的，所以不是每次调用接口都重新获取<code>access_token</code>，而是获取到之后缓存起来，缓存失效之后再去重新获取即刷新。</p><p>获取这个信息需要调用微信的第三方API接口获取</p><ol><li>接口地址为：</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">https请求方式: <br><br><span class="hljs-attr">https</span>:<span class="hljs-comment">//api.weixin.qq.com/cgi-bin/token?grant_type=client_credential&amp;appid=APPID&amp;secret=APPSECRET</span><br></code></pre></td></tr></table></figure><p><strong>参数说明</strong></p><table><thead><tr><th>参数</th><th>是否必须</th><th>说明</th></tr></thead><tbody><tr><td>grant_type</td><td>是</td><td>获取access_token填写client_credential</td></tr><tr><td>appid</td><td>是</td><td>第三方用户唯一凭证</td></tr><tr><td>secret</td><td>是</td><td>第三方用户唯一凭证密钥，即appsecret</td></tr><tr><td>返回的是JSON格式的报文：</td><td></td><td></td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&#123;<span class="hljs-string">&quot;access_token&quot;</span>:<span class="hljs-string">&quot;ACCESS_TOKEN&quot;</span>,<span class="hljs-string">&quot;expires_in&quot;</span>:<span class="hljs-number">7200</span>&#125;<br></code></pre></td></tr></table></figure><p>修改配置：</p><h5 id="获取用户消息"><a href="#获取用户消息" class="headerlink" title="获取用户消息"></a>获取用户消息</h5><p>除此之外，还可以获取关注者的列表，关注者的信息等。</p><p><strong>获取用户的信息：</strong></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">WechatController</span> </span>&#123;<br>    <span class="hljs-comment">/** 日志 */</span><br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(getClass());<br>    <span class="hljs-comment">/** 工具类 */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> WechatUtils wechatUtils;<br><br>    <span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;getUserInfo&quot;</span>)<br>    <span class="hljs-keyword">public</span> void getUserInfo() &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            WxMpUserList userList = wechatUtils.getUserList();<br>            <span class="hljs-keyword">if</span> (userList == <span class="hljs-literal">null</span> || userList.getOpenIds().isEmpty()) &#123;<br>                logger.warn(<span class="hljs-string">&quot;关注者openId列表为空&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            List&lt;<span class="hljs-keyword">String</span>&gt; openIds = userList.getOpenIds();<br>            logger.info(<span class="hljs-string">&quot;关注者openId列表 = &#123;&#125;&quot;</span>, openIds.toString());<br><br>            <span class="hljs-keyword">String</span> openId = openIds.<span class="hljs-keyword">get</span>(<span class="hljs-number">0</span>);<br>            logger.info(<span class="hljs-string">&quot;开始获取 &#123;&#125; 的基本信息&quot;</span>, openId);<br>            WxMpUser userInfo = wechatUtils.getUserInfo(openId);<br>            <span class="hljs-keyword">if</span> (userInfo == <span class="hljs-literal">null</span>) &#123;<br>                logger.warn(<span class="hljs-string">&quot;获取 &#123;&#125; 的基本信息为空&quot;</span>, openId);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">String</span> city = userInfo.getCity();<br>            <span class="hljs-keyword">String</span> nickname = userInfo.getNickname();<br>            logger.info(<span class="hljs-string">&quot;&#123;&#125; 的昵称为：&#123;&#125;, 城市为：&#123;&#125;&quot;</span>, openId, nickname, city);<br>        &#125; <span class="hljs-keyword">catch</span> (WxErrorException e) &#123;<br>            logger.error(<span class="hljs-string">&quot;获取用户消息失败&quot;</span>, e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="接收用户发送的消息"><a href="#接收用户发送的消息" class="headerlink" title="接收用户发送的消息"></a><strong>接收用户发送的消息</strong></h5><p>当微信用户向公众号发送消息时，微信服务器会通过公众号后台配置的URL把信息发送到我们后台的接口上，注意此时的请求格式为 <code>POST</code>请求，发送过来的消息报文格式是XML格式的，每种消息类型的XML格式不一样。</p><p>这里跳过，具体内容看一下开源项目的代码。</p><h5 id="响应微信发出的请求消息"><a href="#响应微信发出的请求消息" class="headerlink" title="响应微信发出的请求消息"></a>响应微信发出的请求消息</h5><p>接口文档： <a href="https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html">https://developers.weixin.qq.com/doc/offiaccount/Message_Management/Passive_user_reply_message.html</a></p><p>微信要求响应信息必须要在五秒内，因此实际调用 API 的时候会有一个时间冲突。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240114222207.png" alt="image.png"></p><h4 id="项目运行"><a href="#项目运行" class="headerlink" title="项目运行"></a>项目运行</h4><p>通过你获取的测试号的 appid、appsecret、token 信息，配置号内网穿透（获取到微信发送的消息）</p><p>就可以启动这个项目了，启动类： WechatprojectApplication</p><h3 id="5、QQ消息回复"><a href="#5、QQ消息回复" class="headerlink" title="5、QQ消息回复"></a>5、QQ消息回复</h3><p>既然都了解到这里了，不如也看一下QQ消息是否能自动获取并问答。</p><p>to be contined…</p><h3 id="6、尝试国内的大语言模型"><a href="#6、尝试国内的大语言模型" class="headerlink" title="6、尝试国内的大语言模型"></a>6、尝试国内的大语言模型</h3><p>国外的这个封锁对大陆也真的恶心，代理服务等也很难受；</p><p>也可以尝试一下国内的 百度文心一言、讯飞星火、阿里通义千问等。</p><ul><li><a href="https://yiyan.baidu.com/">https://yiyan.baidu.com/</a></li><li><a href="https://passport.xfyun.cn/login">https://passport.xfyun.cn/login</a></li><li><a href="https://tongyi.aliyun.com/">https://tongyi.aliyun.com/</a></li></ul><p>后续考虑使用通义千问。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
      <tag>chatgpt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>obsidian常用插件使用记录</title>
    <link href="/2024/01/12/obsidian%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/01/12/obsidian%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>插件功能</p><ul><li>导出 pdf 带上目录</li></ul><hr><h4 id="1、导出-pdf-带上目录"><a href="#1、导出-pdf-带上目录" class="headerlink" title="1、导出 pdf 带上目录"></a>1、导出 pdf 带上目录</h4><p>使用 better-export-pdf 导出 pdf 带上目录</p><p>这个插件需要下载使用，下载地址：  <a href="https://github.com/l1xnan/obsidian-better-export-pdf/releases">https://github.com/l1xnan/obsidian-better-export-pdf/releases</a></p><p>下载对应的 obsidian-better-export-pdf.zip 文件即可。</p><p>参考： <a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/better-export-pdf/">https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/better-export-pdf/</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7系统_常用操作</title>
    <link href="/2024/01/12/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/01/12/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1、防火墙"><a href="#1、防火墙" class="headerlink" title="1、防火墙"></a>1、防火墙</h3><blockquote><p>查看防火墙状态</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">firewall-cmd <span class="hljs-comment">--state</span><br></code></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl stop firewalld   <span class="hljs-comment"># 关闭防火墙</span><br><span class="hljs-params">system</span>ctl start firewalld  <span class="hljs-comment"># 启动防火墙</span><br>firewall-cmd --reload      <span class="hljs-comment"># 重启防火墙</span><br><span class="hljs-params">system</span>ctl disable firewalld  <span class="hljs-comment"># 禁用防火墙</span><br></code></pre></td></tr></table></figure><blockquote><p>开放防火墙端口</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --query-port=80/tcp   <span class="hljs-comment">#端口开放情况</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --list-ports  <span class="hljs-comment">#查看开放的端口</span></span><br><br><span class="hljs-comment">#开放端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8080/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8083-8085/tcp</span><br><br><span class="hljs-comment">#关闭端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --remove-port=8083-8085/tcp</span><br></code></pre></td></tr></table></figure><p>端口开放后建议重启一下防火墙</p><h3 id="2、查看服务器状态"><a href="#2、查看服务器状态" class="headerlink" title="2、查看服务器状态"></a>2、查看服务器状态</h3><p>常用的Linux命令：</p><h4 id="CPU使用情况"><a href="#CPU使用情况" class="headerlink" title="CPU使用情况"></a>CPU使用情况</h4><ol><li><p><strong>top</strong>:</p><ul><li><code>top</code> 命令用于实时显示系统中各个进程的资源占用状况。</li><li>它显示的信息包括系统运行时间、当前登录用户数、系统负载、进程总数、CPU使用率、内存使用率等。</li></ul></li><li><p><strong>vmstat</strong>:</p><ul><li><code>vmstat</code>（Virtual Memory Statistics）命令用于展示虚拟内存、进程、CPU活动等信息。</li><li>例如：<code>vmstat 1 5</code> 每1秒刷新一次，共显示5次数据。</li></ul></li></ol><h4 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h4><ol><li><p><strong>free</strong>:</p><ul><li><code>free</code> 命令用于显示系统的空闲、使用中和交换内存的信息。</li><li>例如：<code>free -h</code> 显示易于阅读的格式。</li></ul></li><li><p><strong>htop</strong>:</p><ul><li><code>htop</code> 是 <code>top</code> 命令的一个增强版本，提供了更多信息，界面更友好。</li><li>它需要在某些Linux发行版上单独安装。</li></ul></li></ol><h4 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h4><ol><li><p><strong>df</strong>:</p><ul><li><code>df</code>（Disk Free）命令用于显示系统中每个文件系统的总空间、已用空间和可用空间。</li><li>例如：<code>df -h</code> 显示易于阅读的格式。</li></ul></li><li><p><strong>du</strong>:</p><ul><li><code>du</code>（Disk Usage）命令用于显示指定文件或目录占用的磁盘空间。</li><li>例如：<code>du -sh /path/to/directory</code> 显示指定目录的总空间占用。</li></ul></li></ol><h4 id="网络使用情况"><a href="#网络使用情况" class="headerlink" title="网络使用情况"></a>网络使用情况</h4><ol><li><p><strong>netstat</strong>:</p><ul><li><code>netstat</code> 命令用于显示网络连接、路由表、接口统计等网络信息。</li><li>例如：<code>netstat -tulnp</code> 显示所有监听端口。</li></ul></li><li><p><strong>ss</strong>:</p><ul><li><code>ss</code>（Socket Statistics）命令是 <code>netstat</code> 的一个现代替代品，用于显示套接字统计信息。</li><li>例如：<code>ss -tuln</code> 显示监听端口。</li></ul></li></ol><h4 id="系统活动和性能"><a href="#系统活动和性能" class="headerlink" title="系统活动和性能"></a>系统活动和性能</h4><ol><li><p><strong>sar</strong>:</p><ul><li><code>sar</code> 命令用于收集、报告或保存系统活动信息，它是sysstat包的一部分。</li><li>例如：<code>sar -u 1 5</code> 每秒报告一次CPU使用情况，共报告5次。</li></ul></li><li><p><strong>iostat</strong>:</p><ul><li><code>iostat</code> 命令用于显示CPU统计信息和所有分区的I&#x2F;O统计信息。</li><li>它有助于监控系统的输入&#x2F;输出设备负载。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门_Docker的基本使用</title>
    <link href="/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、安装-Docker操作-centos系列安装"><a href="#1、安装-Docker操作-centos系列安装" class="headerlink" title="1、安装 Docker操作 (centos系列安装)"></a>1、安装 Docker操作 (centos系列安装)</h3><p>安装操作</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum install -<span class="hljs-keyword">y</span> yum-utils<br><br>yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br><br><br>yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>启动docer并设置开机自启</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker<br><br><span class="hljs-params">system</span>ctl enable docker<br></code></pre></td></tr></table></figure><p>docker配置加速度</p><p>修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件并添加上 registry-mirrors 键值；注册阿里云，可获取自己的加速器</p><p>容器镜像服务 →  容器加速器</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;. <br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>docker安装验证</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h3 id="2、docker-compose安装"><a href="#2、docker-compose安装" class="headerlink" title="2、docker-compose安装"></a>2、docker-compose安装</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。</p><p>使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</p><blockquote><p>安装操作</p></blockquote><p>先需要下载一下二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v2.5.0/</span>docker-compose-linux-x86_64<br></code></pre></td></tr></table></figure><p>放入&#x2F;usr&#x2F;local&#x2F;bin&#x2F; 路径下并重新命名添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 docker-compose<br><span class="hljs-built_in">chmod</span> +x docker-compose<br></code></pre></td></tr></table></figure><p>这个也可以推荐看一下</p><p>将脚本下载，阿里云的下载速度较快，推荐适用</p><p><a href="https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/">https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/</a></p><p>把脚本放在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;下.名字为docker-compose ,加执行权限 ，docker-compose命令就有了</p><h3 id="3、docker-安装-redis-操作"><a href="#3、docker-安装-redis-操作" class="headerlink" title="3、docker 安装 redis 操作"></a>3、docker 安装 redis 操作</h3><p>安装 Redis 使用 Docker 是一个非常简单且快捷的过程。以下是通过 Docker 安装和运行 Redis 的基本步骤：</p><ol><li><p><strong>拉取 Redis 镜像</strong>： 首先，你需要从 Docker Hub 拉取最新的 Redis 镜像。打开命令行界面，然后输入以下命令：</p><p> <code>docker pull redis</code></p><p> 这个命令会从 Docker Hub 下载最新的 Redis 镜像。</p></li><li><p><strong>运行 Redis 容器</strong>： 接着，使用以下命令来启动一个 Redis 容器：</p><p> <code>docker run --name redis -d redis</code></p><p> 这里，<code>--name redis</code> 设置容器的名称为 <code>some-redis</code>。你可以根据需要更改这个名称。<code>-d</code> 参数表示容器将在后台运行。</p></li><li><p><strong>暴露和映射端口</strong>（可选）： 如果你打算从宿主机外部访问 Redis，你需要映射端口。Redis 默认端口是 <code>6379</code>，所以你可以这样映射端口：</p><p> <code>docker run --name redis -d -p 6379:6379 redis</code></p><p> <code>-p 6379:6379</code> 表示将容器的 6379 端口映射到宿主机的 6379 端口。</p></li><li><p><strong>访问 Redis</strong>： 一旦 Redis 容器在运行，你可以通过 Redis 客户端或任何支持 Redis 的程序访问它。如果你只是在本地机器上运行和访问 Redis，你可以通过 <code>localhost:6379</code> 来访问它。</p></li><li><p><strong>使用 Redis CLI 进行交互</strong>（可选）： 如果你想要通过 Redis 命令行界面与 Redis 容器交互，可以使用以下命令进入 Redis 容器：</p><p> <code>docker exec -it some-redis redis-cli</code></p></li></ol><p>小结：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker pull redis<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> --name redis -d -p 6379:6379 redis</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=6379/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><h3 id="4、docker-的一些常用命令-🦌"><a href="#4、docker-的一些常用命令-🦌" class="headerlink" title="4、docker 的一些常用命令   🦌"></a>4、docker 的一些常用命令   🦌</h3><p>常用的Docker命令：</p><h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>1、 <strong>启动容器</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>例如：<code>docker run -d -p 80:80 nginx</code> 会以守护态运行一个nginx容器，并将本机的80端口映射到容器的80端口。</p><p>2、<strong>列出容器</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps<span class="hljs-meta"> [OPTIONS]</span><br></code></pre></td></tr></table></figure><ul><li>只显示运行中的容器：<code>docker ps</code></li><li>显示所有容器（包括未运行的）：<code>docker ps -a</code></li></ul><p>3、 <strong>停止容器</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker stop <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker stop my_container</code> 停止名为 <code>my_container</code> 的容器。</li></ul><p>4、<strong>删除容器</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker rm <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker rm my_container</code> 删除名为 <code>my_container</code> 的容器。</li></ul><p>5、<strong>查看容器日志</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker logs <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker logs my_container</code> 查看名为 <code>my_container</code> 的容器的日志。</li></ul><p>6、重启 docker 容器</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker restart <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>如果你的容器名称是 <code>my_container</code>，那么重启这个容器的命令将是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker restart my_container</span><br></code></pre></td></tr></table></figure><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><p>1、<strong>列出镜像</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker images <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-comment">[REPOSITORY<span class="hljs-comment">[:TAG]</span>]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker images</code> 列出所有本地镜像。</li></ul><p>2、<strong>拉取镜像</strong>:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker pull [<span class="hljs-title class_">OPTIONS</span>] <span class="hljs-title class_">NAME</span>[<span class="hljs-symbol">:TAG|</span><span class="hljs-variable">@DIGEST</span>]<br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker pull nginx</code> 拉取最新的nginx镜像。</li></ul><p>3、<strong>构建镜像</strong>:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">docker build [OPTIONS] PATH |<span class="hljs-string"> URL </span>|<span class="hljs-string"> -</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker build -t my_image .</code> 会根据当前目录下的 <code>Dockerfile</code> 构建一个名为 <code>my_image</code> 的镜像。</li></ul><p>4、 <strong>删除镜像</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker rmi <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker rmi my_image</code> 删除名为 <code>my_image</code> 的镜像。</li></ul><h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><ol><li><p><strong>列出网络</strong>:</p><p> <code>docker network ls</code></p></li><li><p><strong>创建网络</strong>:</p><p> <code>docker network create [OPTIONS] NETWORK  </code></p><ul><li>例如：<code>docker network create my_network</code> 创建一个名为 <code>my_network</code> 的网络。</li></ul></li><li><p><strong>删除网络</strong>:</p><p> <code>docker network rm NETWORK</code></p><ul><li>例如：<code>docker network rm my_network</code> 删除名为 <code>my_network</code> 的网络。</li></ul></li></ol><h4 id="卷管理"><a href="#卷管理" class="headerlink" title="卷管理"></a>卷管理</h4><ol><li><p><strong>创建卷</strong>:</p><p> <code>docker volume create [OPTIONS] [VOLUME]</code></p><ul><li>例如：<code>docker volume create my_volume</code> 创建一个名为 <code>my_volume</code> 的卷。</li></ul></li><li><p><strong>列出卷</strong>:</p><p> <code>docker volume ls</code></p></li><li><p><strong>删除卷</strong>:</p><p> <code>docker volume rm VOLUME</code></p><ul><li>例如：<code>docker volume rm my_volume</code> 删除名为 <code>my_volume</code> 的卷。</li></ul></li></ol><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ol><li><p><strong>查看Docker版本</strong>:</p><p> <code>docker version</code></p></li><li><p><strong>查看Docker系统信息</strong>:</p><p> <code>docker info</code></p></li><li><p><strong>查看容器&#x2F;镜像&#x2F;卷等的详细信息</strong>:</p><p> <code>docker inspect NAME|ID</code></p></li></ol><h3 id="5、docker-安装-Mysql-操作"><a href="#5、docker-安装-Mysql-操作" class="headerlink" title="5、docker 安装 Mysql 操作"></a>5、docker 安装 Mysql 操作</h3><p>以下是使用Docker安装和运行MySQL 5.7和8.0版本的步骤：</p><blockquote><ol><li><strong>运行MySQL 5.7</strong></li></ol></blockquote><ol><li><p><strong>拉取MySQL 5.7镜像</strong>:</p><p> <code>docker pull mysql:5.7</code></p></li><li><p><strong>启动MySQL 5.7容器</strong>:</p></li></ol><p>以下命令启动一个名为 <code>mysql57</code> 的MySQL 5.7容器，设置root密码（在此示例中为<code>yourpassword</code>），并映射端口3306（或选择其他未使用的端口）到宿主机。<br>同时，你可以指定一个数据卷来持久化MySQL数据。</p><p><code>docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=yourpassword -p 3306:3306 -d mysql:5.7</code></p><ul><li>如果需要持久化数据到特定路径，可以添加 <code>-v</code> 参数，如:</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql57 -e MYSQL_ROOT_PASSWORD=yourpassword -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -v /my/own/datadir:/var/lib/mysql -d mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li><strong>运行MySQL 8.0</strong></li></ol></blockquote><ol><li><p><strong>拉取MySQL 8.0镜像</strong>:</p><p> <code>docker pull mysql:8.0</code></p></li><li><p><strong>启动MySQL 8.0容器</strong>:</p></li></ol><ul><li>由于MySQL 5.7已经使用了3306端口，所以对于MySQL 8.0，你需要映射到宿主机的另一个端口，例如3307。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql8 -e MYSQL_ROOT_PASSWORD=yourpassword -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> -d mysql:<span class="hljs-number">8</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>同样，你也可以指定数据卷来持久化MySQL 8.0的数据。</li><li><code>mysql:8.0</code> 指的是Docker镜像的名称和标签。在这里，<code>mysql</code> 是镜像的名称，<code>8.0</code> 是镜像的标签，它指定了MySQL的具体版本。</li></ul><ol start="3"><li><p><strong>验证和连接</strong></p></li><li><p><strong>验证容器运行状态</strong>:</p><p> <code>docker ps</code></p></li><li><p><strong>连接到MySQL容器</strong>:</p></li></ol><p>使用Docker内置的命令行或者使用任何MySQL客户端连接到数据库。例如，要连接到MySQL 5.7实例，可以使用：<br><code>docker exec -it mysql57 mysql -uroot -pyourpassword</code></p><ul><li>对于MySQL 8.0，连接命令类似，只是容器名称不同。</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>替换上述命令中的 <code>yourpassword</code> 为你自己的强密码。</li><li>如果你使用了自定义数据卷路径（如 <code>/my/own/datadir</code>），确保该路径在宿主机上存在，并且Docker有权限访问。</li><li>MySQL 8.0 默认使用了更强的密码加密策略（caching_sha2_password），某些客户端可能需要更新或配置以支持新的加密方式。</li></ul><hr><h3 id="6、docker-安装-nginx"><a href="#6、docker-安装-nginx" class="headerlink" title="6、docker 安装 nginx"></a>6、docker 安装 nginx</h3><p>参考: <a href="https://blog.csdn.net/BThinker/article/details/123507820">https://blog.csdn.net/BThinker/article/details/123507820</a></p><p>下面是先运行最新版本的 Nginx ,然后将服务下的文件复制一份到挂载目录,然后删除容器,重启运行的一个操作。</p><p>后面的一些目录和配置查看就可以直接在目录 home&#x2F;nginx&#x2F; 查看相关内容.</p><p>可以选择下载指定版本，或者最新版本</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker pull nginx</span><br></code></pre></td></tr></table></figure><p>创建Nginx配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 创建挂载目录</span><br><span class="hljs-built_in">mkdir</span> -p /home/nginx/conf<br><span class="hljs-built_in">mkdir</span> -p /home/nginx/log<br><span class="hljs-built_in">mkdir</span> -p /home/nginx/html<br></code></pre></td></tr></table></figure><p>启动前需要先创建Nginx外部挂载的配置文件（ &#x2F;home&#x2F;nginx&#x2F;conf&#x2F;nginx.conf）<br>之所以要先创建 , 是因为Nginx本身容器只存在&#x2F;etc&#x2F;nginx 目录 , 本身就不创建 nginx.conf 文件<br>当服务器和容器都不存在 nginx.conf 文件时, 执行启动命令的时候 docker会将nginx.conf 作为目录创建 , 这并不是我们想要的结果 。</p><blockquote><p>容器中的nginx.conf文件和conf.d文件夹复制到宿主机</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 生成容器</span><br>docker run --name nginx -p <span class="hljs-number">9001</span>:<span class="hljs-number">80</span> -d nginx<br><span class="hljs-comment"># 将容器nginx.conf文件复制到宿主机</span><br>docker cp nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf /</span>home<span class="hljs-regexp">/nginx/</span>conf/nginx.conf<br><span class="hljs-comment"># 将容器conf.d文件夹下内容复制到宿主机</span><br>docker cp nginx:<span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/conf.d /</span>home<span class="hljs-regexp">/nginx/</span>conf/conf.d<br><span class="hljs-comment"># 将容器中的html文件夹复制到宿主机</span><br>docker cp nginx:<span class="hljs-regexp">/usr/</span>share<span class="hljs-regexp">/nginx/</span>html <span class="hljs-regexp">/home/</span>nginx/<br></code></pre></td></tr></table></figure><p>创建 Nginx 容器并运行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-comment"># 直接执行docker rm nginx或者以容器id方式关闭容器</span><br><span class="hljs-comment"># 找到nginx对应的容器id</span><br>docker <span class="hljs-built_in">ps</span> <span class="hljs-literal">-a</span><br><span class="hljs-comment"># 关闭该容器</span><br>docker stop nginx<br><span class="hljs-comment"># 删除该容器</span><br>docker <span class="hljs-built_in">rm</span> nginx<br> <br><span class="hljs-comment"># 删除正在运行的nginx容器</span><br>docker <span class="hljs-built_in">rm</span> <span class="hljs-operator">-f</span> nginx<br></code></pre></td></tr></table></figure><p>启动命令</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs groovy">docker run \<br>-p <span class="hljs-number">9002</span>:<span class="hljs-number">80</span> \<br>--name nginx \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.<span class="hljs-attr">conf:</span><span class="hljs-regexp">/etc/</span>nginx/nginx.conf \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>conf.<span class="hljs-attr">d:</span><span class="hljs-regexp">/etc/</span>nginx/conf.d \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/log:/</span><span class="hljs-keyword">var</span><span class="hljs-regexp">/log/</span>nginx \<br>-v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/html:/</span>usr<span class="hljs-regexp">/share/</span>nginx/html \<br>-d <span class="hljs-attr">nginx:</span>latest<br></code></pre></td></tr></table></figure><p>单行模式</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs groovy">docker run -p <span class="hljs-number">9002</span>:<span class="hljs-number">80</span> --name nginx -v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/conf/</span>nginx.<span class="hljs-attr">conf:</span><span class="hljs-regexp">/etc/</span>nginx<span class="hljs-regexp">/nginx.conf -v /</span>home<span class="hljs-regexp">/nginx/</span>conf<span class="hljs-regexp">/conf.d:/</span>etc<span class="hljs-regexp">/nginx/</span>conf.d -v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/log:/</span><span class="hljs-keyword">var</span><span class="hljs-regexp">/log/</span>nginx -v <span class="hljs-regexp">/home/</span>nginx<span class="hljs-regexp">/html:/</span>usr<span class="hljs-regexp">/share/</span>nginx/html -d <span class="hljs-attr">nginx:</span>latest<br></code></pre></td></tr></table></figure><p>测试访问:</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//IP:9002/</span><br></code></pre></td></tr></table></figure><p>重启容器操作:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 重启容器</span><br><span class="hljs-attribute">docker</span> restart nginx<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_45868731/article/details/131743699">https://blog.csdn.net/qq_45868731/article/details/131743699</a></li><li><a href="https://blog.csdn.net/ninimino/article/details/113388745">https://blog.csdn.net/ninimino/article/details/113388745</a></li><li><a href="https://blog.csdn.net/weixin_45821811/article/details/116211724">https://blog.csdn.net/weixin_45821811/article/details/116211724</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot项目部署方案</title>
    <link href="/2024/01/11/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <url>/2024/01/11/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用操作：</p><h3 id="1、profiles指定不同环境的配置"><a href="#1、profiles指定不同环境的配置" class="headerlink" title="1、profiles指定不同环境的配置"></a>1、profiles指定不同环境的配置</h3><p>一般用于区别不同的环境，常见的 开发、测试、正式</p><p>环境区分配置文件，可以通过两种方式：</p><ul><li><p>通过application.yml中编码指定 <code>profile.active=uat</code> 方式指定</p></li><li><p>通过mvn中profiles来区分不同环境对应的配置文件夹，人工可以手动在idea勾选生成不同环境的包(推荐)</p></li></ul><h4 id="application-yml-编码指定"><a href="#application-yml-编码指定" class="headerlink" title="application.yml 编码指定"></a>application.yml 编码指定</h4><p>略</p><h4 id="mvn-→-profiles-区分"><a href="#mvn-→-profiles-区分" class="headerlink" title="mvn → profiles 区分"></a>mvn → profiles 区分</h4><p>在mvn中配置如下内容</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--传递给脚本的参数值--&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node1<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node2<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>看一下下面这个解释</p><p><strong>节点粗解：</strong></p><p><strong>id：</strong> 用来指定不同环境配置文件所在的目录:</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401110850243.png" alt="image.png"></p><p>而在上面的代码中，在给定的配置中，定义了三个 <code>profile</code>，分别是 <code>node</code>, <code>node1</code>, 和 <code>node2</code>。每个 <code>profile</code> 中定义了一些 <code>properties</code>，这些属性可以在构建过程中使用</p><p><strong>properties：</strong> </p><p>该节点中的节点是可作为参数传递给其他配置文件，上面代码中的package-name节点值可以在另外的assembly.xml或者shell脚本文件中通过<code>$&#123;package-name&#125;</code>获取到，如下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401110851350.png" alt="image.png"></p><p><strong>activeByDefault：</strong> 指定默认环境配置文件夹</p><p>↑ 看了一下大概的解释，这里的用法大概是在 pom 依赖配置文件中定义一下对应的 profile 的节点 id ；并配置对应文件夹（在 profiles 文件夹下）</p><p>通过不同的文件夹对应不同的 yml 配置文件</p><p>然后在打包或者运行的时候通过 类似这种命令来操作 <code>mvn clean install -Pnode1</code>  ；具体待实践一下。</p><h3 id="2、maven-assembly-plugin打-发布压缩包"><a href="#2、maven-assembly-plugin打-发布压缩包" class="headerlink" title="2、maven-assembly-plugin打  发布压缩包"></a>2、maven-assembly-plugin打  发布压缩包</h3><p>先记录一下，具体没用过，暂时不太清楚</p><p>具体内容看参考链接： <a href="https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ">https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ</a></p><p>to be contined….</p><p>后续内容待实际部署的时候使用一下，再进行记录</p><hr><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ">https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>springboot</tag>
      
      <tag>Build</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day05</title>
    <link href="/2024/01/08/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day05/"/>
    <url>/2024/01/08/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day05/</url>
    
    <content type="html"><![CDATA[<h4 id="1、邮件功能"><a href="#1、邮件功能" class="headerlink" title="1、邮件功能"></a>1、邮件功能</h4><p>略，后续实际运行看一下并进行分析。</p><p>类： RabbitMqUtil、SendMailUtils、SmsUtil</p><p>通过这个工具类来进行发送邮件。</p><h4 id="2、切面：限制请求访问"><a href="#2、切面：限制请求访问" class="headerlink" title="2、切面：限制请求访问"></a>2、切面：限制请求访问</h4><p>建议和 [[蘑菇博客项目_Day04#1、自定义注解<code>AvoidRepeatableCommit</code>的使用]] 这部分内容一起看</p><p><code>RequestLimitAspect</code> 类是一个Spring AOP切面，用于限制接口请求的频率。这个切面通过Redis实现请求的计数和时间限制。</p><p>下面是对这个切面类实现的详细解释和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestLimitAspect</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">POINT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;execution(* com.moxi.mogublog.web.restapi..*.*(..))&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RequestLimitConfig requestLimitConfig;<br><br>    <span class="hljs-meta">@Pointcut(POINT)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知：用于在方法执行前后进行请求限制的检查。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 连接点，提供对拦截方法的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (requestLimitConfig.getStart()) &#123;<br>            <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>            <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attribute.getRequest();<br><br>            <span class="hljs-comment">// 获取IP和请求路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURL().toString();<br><br>            <span class="hljs-comment">// 获取方法名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConf.REQUEST_LIMIT + RedisConf.SEGMENTATION + ip + RedisConf.SEGMENTATION + methodName;<br><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.getMethod(point);<br><br>            <span class="hljs-comment">// 检查方法是否有RequestLimit注解</span><br>            <span class="hljs-keyword">if</span> (currentMethod.isAnnotationPresent(RequestLimit.class)) &#123;<br>                <span class="hljs-type">RequestLimit</span> <span class="hljs-variable">requestLimit</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RequestLimit.class);<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">checkResult</span> <span class="hljs-operator">=</span> checkWithRedis(requestLimit.amount(), requestLimit.time(), key);<br>                <span class="hljs-keyword">if</span> (checkResult) &#123;<br>                    log.info(<span class="hljs-string">&quot;requestLimited, [用户ip:&#123;&#125;], [访问地址:&#123;&#125;]超过了限定的次数[&#123;&#125;]次&quot;</span>, ip, url, requestLimit.amount());<br>                    <span class="hljs-keyword">return</span> ResultUtil.result(ECode.REQUEST_OVER_LIMIT, <span class="hljs-string">&quot;接口请求过于频繁&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> point.proceed();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">checkResult</span> <span class="hljs-operator">=</span> checkWithRedis(requestLimitConfig.getAmount(), requestLimitConfig.getTime(), key);<br>            <span class="hljs-keyword">if</span> (checkResult) &#123;<br>                log.info(<span class="hljs-string">&quot;requestLimited, [用户ip:&#123;&#125;], [访问地址:&#123;&#125;]超过了限定的次数[&#123;&#125;]次&quot;</span>, ip, url, requestLimitConfig.getAmount());<br>                <span class="hljs-keyword">return</span> ResultUtil.result(ECode.REQUEST_OVER_LIMIT, <span class="hljs-string">&quot;接口请求过于频繁&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过Redis记录和检查请求次数，实现请求限制。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount 允许的最大请求次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间限制（毫秒）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    Redis键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否超过请求限制</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkWithRedis</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">long</span> time, String key)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> redisUtil.incrBy(key, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>            redisUtil.expire(key, time, TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count &gt; amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中：</p><ol><li><strong>定义切点</strong>：通过 <code>@Pointcut</code> 定义了一个切点，拦截特定包下的所有方法。</li><li><strong>环绕通知</strong>：<code>@Around(&quot;pointcut()&quot;)</code> 表明 <code>around</code> 方法会在切点匹配的方法执行前后进行。</li><li><strong>请求限制逻辑</strong>：<ul><li>获取请求的IP地址和URL。</li><li>构造一个Redis键，基于IP地址和方法名称。</li><li>检查当前方法是否有 <code>@RequestLimit</code> 注解，如果有，使用注解中的参数进行请求限制检查。</li><li>如果没有该注解，使用配置文件中定义的参数进行检查。</li><li>使用 <code>checkWithRedis</code> 方法检查是否超过请求限制。如果超过，返回错误信息。</li></ul></li><li><strong>Redis计数和过期时间</strong>：<ul><li><code>checkWithRedis</code> 方法使用Redis来计数每个请求的频率</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础_基础内容03</title>
    <link href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/"/>
    <url>/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/</url>
    
    <content type="html"><![CDATA[<h3 id="1、异常"><a href="#1、异常" class="headerlink" title="1、异常"></a>1、异常</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401181322703.png" alt="image.png"></p><h5 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h5><blockquote><p>try-catch-finally 中哪个部分可以省略</p></blockquote><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 示例：try-catch-finally结构</span><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 代码块，可能会产生异常</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType1 e) &#123;<br>    <span class="hljs-comment">// 处理ExceptionType1异常</span><br>&#125; <span class="hljs-keyword">catch</span> (ExceptionType2 e) &#123;<br>    <span class="hljs-comment">// 处理ExceptionType2异常</span><br>&#125; <span class="hljs-keyword">finally</span> &#123;<br>    <span class="hljs-comment">// 清理代码，总是会执行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在Java中的<code>try-catch-finally</code>异常处理结构中：</p><ol><li><strong><code>try</code>块</strong>:<ul><li>不可省略。必须有<code>try</code>块，因为它定义了可能产生异常的代码段。</li></ul></li><li><strong><code>catch</code>块</strong>:<ul><li>可以省略，但如果省略<code>catch</code>块，必须有<code>finally</code>块。</li><li>如果<code>try</code>块中的代码可能抛出异常，通常需要至少一个<code>catch</code>块来处理这些异常。</li></ul></li><li><strong><code>finally</code>块</strong>:<ul><li>可以省略，但如果省略<code>finally</code>块，必须有至少一个<code>catch</code>块。</li><li><code>finally</code>块用于执行清理操作，无论是否捕获到异常，<code>finally</code>块总是会执行。</li></ul></li></ol><p>因此，可以省略<code>catch</code>块或<code>finally</code>块中的任何一个，但不能两个都省略。你至少需要<code>try</code>和<code>catch</code>，或者<code>try</code>和<code>finally</code>组合。</p><hr><h4 id="Checked-Exception-和-Unchecked-Exception"><a href="#Checked-Exception-和-Unchecked-Exception" class="headerlink" title="Checked Exception 和 Unchecked Exception"></a>Checked Exception 和 Unchecked Exception</h4><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>比如下面这段 IO 操作的代码：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401181324094.png" alt="image.png"></p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>IllegalArgumentException</code>(参数错误比如方法入参类型错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误，<code>IllegalArgumentException</code>的子类）</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误比如权限不够）</li><li><code>UnsupportedOperationException</code>(不支持的操作错误比如重复创建同一用户)</li><li>……</li></ul><h5 id="空指针异常"><a href="#空指针异常" class="headerlink" title="空指针异常"></a>空指针异常</h5><p>空指针异常是不受检测异常下运行期异常中的一种；当我们在尝试使用 null 引用的时候，会发生 NPE。</p><p>最基础也是比较需要注意的一个情况是字符串比较，在字符串比较的时候，保证常量放前面</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401311055211.png" alt="image.png"></p><blockquote><p>如何避免指针异常</p></blockquote><ul><li><ol><li>在使用之前先检查一下是否为 null</li></ol></li><li><ol start="2"><li>调用方法的时候进行参数检查</li></ol></li><li><ol start="3"><li>在设计方法或者API 的时候，尽量不要返回 null 值，而且返回一个空集合或者默认值；</li></ol></li><li><ol start="4"><li>初始化使用字段，保证不为 null</li></ol></li><li><ol start="5"><li>使用 Optional</li></ol></li><li><ol start="6"><li>使用断言（开发和测试环境）</li></ol></li></ul><p>使用示例：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 示例：避免空指针异常的方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NullPointerAvoidance</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-built_in">String</span>[] args) &#123;<br>        <span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span> = <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 1. 检查是否为 null</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">str</span> != <span class="hljs-literal">null</span>) &#123;<br>            System.<span class="hljs-property">out</span>.<span class="hljs-property">println</span>(<span class="hljs-built_in">str</span>.<span class="hljs-property">length</span>());<br>        &#125;<br><br>        <span class="hljs-comment">// 2. 使用Optional类（Java 8+）</span><br>        Optional&lt;<span class="hljs-built_in">String</span>&gt; optionalStr = Optional.<span class="hljs-property">ofNullable</span>(<span class="hljs-built_in">str</span>);<br>        optionalStr.<span class="hljs-property">ifPresent</span>(System.<span class="hljs-property">out</span>::<span class="hljs-built_in">println</span>);<br><br>        <span class="hljs-comment">// 3. 安全调用方法（例如使用Apache Commons Lang）</span><br>        <span class="hljs-type">int</span> length = StringUtils.<span class="hljs-property">length</span>(<span class="hljs-built_in">str</span>); <span class="hljs-comment">// 安全的，不会抛出空指针异常</span><br><br>        <span class="hljs-comment">// 4. 使用断言（仅在开发和测试环境中）</span><br>        <span class="hljs-keyword">assert</span> <span class="hljs-built_in">str</span> != <span class="hljs-literal">null</span> : <span class="hljs-string">&quot;字符串不应该为 null&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="Throwable-类常用方法"><a href="#Throwable-类常用方法" class="headerlink" title="Throwable 类常用方法"></a>Throwable 类常用方法</h4><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="2、泛型"><a href="#2、泛型" class="headerlink" title="2、泛型"></a>2、泛型</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><strong>Java 泛型（Generics）</strong> 是 JDK 5 中引入的一个新特性。</p><p>一般有三种使用方式:<strong>泛型类</strong>、<strong>泛型接口</strong>、<strong>泛型方法</strong></p><blockquote><p>泛型类</p></blockquote><p>定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span><br><span class="hljs-comment">//在实例化泛型类时，必须指定T的具体类型</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt;&#123;<br><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span>(<span class="hljs-params">T key</span>)</span> &#123;<br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">getKey</span>()</span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vhdl"><span class="hljs-keyword">Generic</span>&lt;<span class="hljs-built_in">Integer</span>&gt; genericInteger = <span class="hljs-keyword">new</span> <span class="hljs-keyword">Generic</span>&lt;<span class="hljs-built_in">Integer</span>&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><blockquote><p>泛型接口</p></blockquote><p>定义</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">method</span>()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，不指定类型：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">class</span> <span class="hljs-symbol">GeneratorImpl</span>&lt;<span class="hljs-symbol">T</span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Generator</span>&lt;<span class="hljs-symbol">T</span>&gt;&#123;<br>    @Override<br>    <span class="hljs-keyword">public</span> T method() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现泛型接口，指定类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">GeneratorImpl</span>&lt;T&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Generator</span>&lt;<span class="hljs-title class_">String</span>&gt;&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">method</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>泛型方法</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt; E &gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span>(<span class="hljs-params"> E[] inputArray </span>)</span><br>&#123;<br>      <span class="hljs-keyword">for</span> ( E element : inputArray )&#123;<br>         System.<span class="hljs-keyword">out</span>.printf( <span class="hljs-string">&quot;%s &quot;</span>, element );<br>      &#125;<br>      System.<span class="hljs-keyword">out</span>.println();<br> &#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mathematica"><span class="hljs-operator">//</span> 创建不同类型数组：<span class="hljs-built_in">Integer</span><span class="hljs-operator">,</span> <span class="hljs-variable">Double</span> 和 <span class="hljs-built_in">Character</span><br><span class="hljs-built_in">Integer</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">intArray</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-number">1</span><span class="hljs-operator">,</span> <span class="hljs-number">2</span><span class="hljs-operator">,</span> <span class="hljs-number">3</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-built_in">String</span><span class="hljs-punctuation">[</span><span class="hljs-punctuation">]</span> <span class="hljs-variable">stringArray</span> <span class="hljs-operator">=</span> <span class="hljs-punctuation">&#123;</span> <span class="hljs-string">&quot;Hello&quot;</span><span class="hljs-operator">,</span> <span class="hljs-string">&quot;World&quot;</span> <span class="hljs-punctuation">&#125;</span><span class="hljs-operator">;</span><br><span class="hljs-variable">printArray</span><span class="hljs-punctuation">(</span> <span class="hljs-variable">intArray</span>  <span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br><span class="hljs-variable">printArray</span><span class="hljs-punctuation">(</span> <span class="hljs-variable">stringArray</span>  <span class="hljs-punctuation">)</span><span class="hljs-operator">;</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：静态泛型方法是没有办法使用类上声明的泛型的。只能使用自己声明的 <code>&lt;E&gt;</code> （静态方法的加载在类前面）</p></blockquote><h4 id="类型擦除、通配符"><a href="#类型擦除、通配符" class="headerlink" title="类型擦除、通配符"></a>类型擦除、通配符</h4><p>to be contined…</p><h3 id="3、反射"><a href="#3、反射" class="headerlink" title="3、反射"></a>3、反射</h3><blockquote><p>反射是什么</p></blockquote><p>Java反射是一种强大的机制，它允许程序在运行时检查或修改Java虚拟机中的类的行为。基本上，反射使得程序可以操作那些在编译时还不知道的类和对象。</p><p>使用场景：像我们常用的框架 Spring&#x2F;Spring Boot、MyBatis 都大量使用了动态代理，而动态代理的实现也依赖于反射。</p><p><strong>理解Java反射</strong></p><ul><li><strong>动态性</strong>: 反射的核心是动态性。它使得你可以在运行时动态地创建对象、调用方法、访问字段，而不必在编译时具体知道类的名称和方法。</li><li><strong>API</strong>: Java反射的功能主要通过<code>java.lang.Class</code>类及<code>java.lang.reflect</code>包中的类（如<code>Method</code>、<code>Field</code>、<code>Constructor</code>等）提供。</li><li><strong>类元数据</strong>: 反射允许程序获取任何类的内部信息，包括类的成员方法、字段、构造函数、注解等。</li></ul><blockquote><p>为什么你使用 Spring 的时候 ，一个<code>@Component</code>注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 <code>@Value</code>注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？</p></blockquote><p>这些都是因为你可以基于反射分析类，然后获取到类&#x2F;属性&#x2F;方法&#x2F;方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。</p><blockquote><p>反射的优缺点：</p></blockquote><ul><li>优点：强大和灵活</li><li>缺点：<ul><li>性能开销较大，使用不当可能导致代码难以理解和维护</li><li>可能带来安全问题</li></ul></li></ul><p>to be contined…</p><h3 id="4、注解"><a href="#4、注解" class="headerlink" title="4、注解"></a>4、注解</h3><h3 id="5、SPI"><a href="#5、SPI" class="headerlink" title="5、SPI"></a>5、SPI</h3><blockquote><p>SPI 是什么东西</p></blockquote><p>要知道它的作用，需要清楚为什么会有这个机制。</p><p>参考： <a href="https://javaguide.cn/java/basis/java-basic-questions-03.html#spi">https://javaguide.cn/java/basis/java-basic-questions-03.html#spi</a></p><p>参考： <a href="https://pdai.tech/md/java/advanced/java-advanced-spi.html">https://pdai.tech/md/java/advanced/java-advanced-spi.html</a></p><p>可以看一下这句话：SPI（Service Provider Interface），是JDK内置的一种 服务提供发现机制，可以用来启用框架扩展和替换组件。</p><p>Java 会提供一个公开的接口（标准服务接口），第三方会提供该接口的服务实现(不同厂商可以针对同一接口做出不同的实现)</p><p>而Java的<strong>SPI机制可以为某个接口寻找服务实现</strong>。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401311713463.png" alt="image.png"></p><blockquote><p>SPI 是什么</p></blockquote><ul><li>SPI是一种服务发现机制。</li><li>它允许服务提供者通过配置文件提供服务实现，而服务使用者可以加载这些实现</li></ul><blockquote><p>SPI 实现原理</p></blockquote><ul><li>Java SPI的实现基于<code>ServiceLoader</code>类。</li><li>服务提供者在<code>META-INF/services</code>目录下提供配置文件，其中指定接口的实现类。</li><li><code>ServiceLoader</code>可以加载这些实现。</li></ul><p>关于 SPI 如何为某个公开的标准服务接口找到其实现服务，可以看一个示例。</p><blockquote><p>SPI机制的简单示例</p></blockquote><blockquote><p>网上示例：<a href="https://zhuanlan.zhihu.com/p/28909673">这里在新窗口打开</a></p></blockquote><p>我们现在需要使用一个内容搜索接口，搜索的实现可能是基于文件系统的搜索，也可能是基于数据库的搜索。</p><ul><li>先定义好接口</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">Search</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword);   <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>文件搜索实现</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">FileSearch</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Search</span></span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword) &#123;<br>        System.out.println(<span class="hljs-string">&quot;文件搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>数据库搜索实现</li></ul><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">DatabaseSearch</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">Search</span></span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> List&lt;<span class="hljs-keyword">String</span>&gt; searchDoc(<span class="hljs-keyword">String</span> keyword) &#123;<br>        System.out.println(<span class="hljs-string">&quot;数据搜索 &quot;</span>+keyword);<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>resources 接下来可以在resources下新建META-INF&#x2F;services&#x2F;目录，然后新建接口全限定名的文件：<code>com.cainiao.ys.spi.learn.Search</code>，里面加上我们需要用到的实现类</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.cainiao</span><span class="hljs-selector-class">.ys</span><span class="hljs-selector-class">.spi</span><span class="hljs-selector-class">.learn</span>.FileSearch<br></code></pre></td></tr></table></figure><ul><li>测试方法</li></ul><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">public</span> <span class="hljs-keyword">class</span> TestCase &#123;<br>    <span class="hljs-built_in">public</span> static <span class="hljs-type">void</span> main(String[] args) &#123;<br>        ServiceLoader&lt;<span class="hljs-keyword">Search</span>&gt; s = ServiceLoader.<span class="hljs-keyword">load</span>(<span class="hljs-keyword">Search</span>.<span class="hljs-keyword">class</span>);<br>        Iterator&lt;<span class="hljs-keyword">Search</span>&gt; iterator = s.iterator();<br>        <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>           <span class="hljs-keyword">Search</span> <span class="hljs-keyword">search</span> =  iterator.next();<br>           <span class="hljs-keyword">search</span>.searchDoc(&quot;hello world&quot;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到输出结果：文件搜索 hello world</p><p>如果在<code>com.cainiao.ys.spi.learn.Search</code>文件里写上两个实现类，那最后的输出结果就是两行了。</p><p>这就是因为<code>ServiceLoader.load(Search.class)</code>在加载某接口时，会去<code>META-INF/services</code>下找接口的全限定名文件，再根据里面的内容加载相应的实现类。</p><p>这就是spi的思想，接口的实现由provider实现，provider只用在提交的jar包里的<code>META-INF/services</code>下根据平台定义的接口新建文件，并添加进相应的实现类内容就好。</p><h3 id="6、序列化和反序列化"><a href="#6、序列化和反序列化" class="headerlink" title="6、序列化和反序列化"></a>6、序列化和反序列化</h3><h3 id="7、语法糖"><a href="#7、语法糖" class="headerlink" title="7、语法糖"></a>7、语法糖</h3><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-03.html">https://javaguide.cn/java/basis/java-basic-questions-03.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础_基础内容02</title>
    <link href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/"/>
    <url>/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/</url>
    
    <content type="html"><![CDATA[<p>本章节主要是对于Java中对象的使用，Object 基类的使用，以及 String 类的使用进行阐述；</p><h3 id="一、面向对象基础"><a href="#一、面向对象基础" class="headerlink" title="一、面向对象基础"></a>一、面向对象基础</h3><h4 id="1-1、面向对象和面向过程的区别"><a href="#1-1、面向对象和面向过程的区别" class="headerlink" title="1.1、面向对象和面向过程的区别"></a>1.1、面向对象和面向过程的区别</h4><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><h4 id="1-2、创建对象"><a href="#1-2、创建对象" class="headerlink" title="1.2、创建对象"></a>1.2、创建对象</h4><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><blockquote><p>对象的相等和引用相等的区别</p></blockquote><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><p>对象是什么？</p><p>对象是类的一个实例，类定义了对象的状态（属性）和行为（方法）</p><p>创建对象的步骤：</p><ol><li><strong>定义类</strong>: 首先，需要定义一个类，作为对象的蓝图。类定义了对象的属性和方法。</li><li><strong>声明对象</strong>: 接下来，声明一个类的变量。这个变量将引用新创建的对象。</li><li><strong>实例化对象</strong>: 使用 <code>new</code> 关键字创建类的一个实例。</li><li><strong>初始化对象</strong>: 通过调用类的构造器来初始化新创建的对象</li></ol><p>创建对象示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 定义Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">String</span> name, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在另一个类中创建Person的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Person对象</span><br>        Person person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>new Person(&quot;Alice&quot;, 30);</code> 创建了一个 <code>Person</code> 类的实例，并且用 <code>Alice</code> 和 <code>30</code> 初始化这个对象的 <code>name</code> 和 <code>age</code> 属性。</p><h4 id="1-3、构造方法"><a href="#1-3、构造方法" class="headerlink" title="1.3、构造方法"></a>1.3、构造方法</h4><p>构造方法的作用：构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>如果没有声明构造方法，类会有一个默认的不带参数的改造方法。</p><p>构造方法的特点：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</p><h4 id="1-4、面向对象特征"><a href="#1-4、面向对象特征" class="headerlink" title="1.4、面向对象特征"></a>1.4、面向对象特征</h4><p>面向对象的三大特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>面向对象编程（OOP）的三大特征是封装、继承和多态。这些特征共同为创建模块化、可重用和易于维护的代码提供了基础。</p><table><thead><tr><th>特征</th><th>描述</th><th>优点</th></tr></thead><tbody><tr><td>封装</td><td>封装是把数据（属性）和行为（方法）组合成一个单元（类），并对数据的访问进行限制和保护。在Java中，可以通过使用访问修饰符（如<code>private</code>, <code>public</code>）来实现。</td><td>- 提高了数据安全性<br>- 减少了代码间的耦合<br>- 增强了代码的可读性和可维护性</td></tr><tr><td>继承</td><td>继承是一种使得一个类（子类）能够继承另一个类（父类）的属性和方法的机制。子类可以扩展或修改继承自父类的行为。</td><td>- 促进了代码的重用<br>- 建立了类之间的层次关系<br>- 提高了代码的可维护性</td></tr><tr><td>多态</td><td>多态是指允许不同类的对象对同一消息作出响应的能力，即同一操作作用于不同的对象时可以有不同的解释和行为。</td><td>- 增强了程序的灵活性和扩展性<br>- 允许不同类的对象被统一处理</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ol><li><strong>封装</strong>: 就像一个咖啡机，它隐藏了内部的复杂机械过程，只暴露出简单的接口（按钮）给用户使用。</li><li><strong>继承</strong>: 类似于父母与孩子的关系。孩子会继承父母的一些特征（如眼睛的颜色），同时也可以发展自己独特的特性（如不同的职业技能）。</li><li><strong>多态</strong>: 可以比作一个通用的电源插座。不同的电器（即使是不同类型的电器）都可以插入同一个插座，但插入后的行为（如充电、运转）依赖于接入的具体电器。</li></ol><h4 id="1-5、接口与抽象类"><a href="#1-5、接口与抽象类" class="headerlink" title="1.5、接口与抽象类"></a>1.5、接口与抽象类</h4><blockquote><p>接口和抽象类的区别</p></blockquote><ul><li>首先是类和接口的区别，接口可以实现多个接口，类只能继承单个；</li><li>然后更多的是用法上面的区别：接口是一个协议，强调功能的相似性（相同的行为）；抽闲类强调的是类之间的共性（公共类结构）。</li></ul><hr><p>接口（Interfaces）和抽象类（Abstract Classes）是用于实现抽象层次的两种主要方式。</p><p>它们都不能被实例化，但在用法和目的上存在一些关键区别。</p><blockquote><p>对比</p></blockquote><table><thead><tr><th>特征</th><th>接口（Interfaces）</th><th>抽象类（Abstract Classes）</th></tr></thead><tbody><tr><td>实例化</td><td>不能直接实例化。</td><td>也不能直接实例化。</td></tr><tr><td>方法定义</td><td>可以有默认方法和静态方法。所有方法默认为public。不需要使用<code>abstract</code>关键字。</td><td>可以包含抽象方法（没有实现体的方法）和非抽象方法。抽象方法使用<code>abstract</code>关键字。</td></tr><tr><td>属性定义</td><td>只能定义常量（默认为public static final）。</td><td>可以包含非常量字段，且这些字段可以有各种访问控制。</td></tr><tr><td>实现&#x2F;扩展</td><td>一个类可以实现多个接口。</td><td>一个类只能继承一个抽象类。</td></tr><tr><td>构造器</td><td>不能有构造器。</td><td>可以有构造器。</td></tr><tr><td>多重继承的支持</td><td>支持（一个类可以实现多个接口）。</td><td>不支持（一个类只能继承一个类，但可以实现多个接口）。</td></tr><tr><td>默认方法</td><td>Java 8之后，接口可以有默认方法（有方法体）。</td><td>抽象类可以有具有实现的方法。</td></tr><tr><td>访问修饰符限制</td><td>接口中的方法默认是public的，属性默认是public static final的。</td><td>抽象类中的方法和属性可以有多种访问修饰符。</td></tr><tr><td>使用场景</td><td>当各个实现之间没有共享的代码，但需要共同遵守某些规则（方法）时使用。</td><td>当各个实现之间有大量共享的代码或属性时使用。</td></tr></tbody></table><p>类比</p><ol><li><strong>接口</strong>: 就像一个标准或协议，它定义了规范，但不提供完整的实现。就像电器的插头和插座的标准，制造商需要按照这个标准制造产品。</li><li><strong>抽象类</strong>: 可以看作是半成品，它定义了一些基本功能和结构，但留下了一些空白（抽象方法）供继承它的子类完成。</li></ol><h4 id="1-6、深拷贝与浅拷贝，引用拷贝"><a href="#1-6、深拷贝与浅拷贝，引用拷贝" class="headerlink" title="1.6、深拷贝与浅拷贝，引用拷贝"></a>1.6、深拷贝与浅拷贝，引用拷贝</h4><p>区别：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</li></ul><p>对比</p><table><thead><tr><th>类型</th><th>描述</th><th>结果</th></tr></thead><tbody><tr><td>浅拷贝</td><td>只复制对象的基本类型字段和引用类型字段的引用，不复制引用对象本身。</td><td>两个对象共享引用类型的成员。</td></tr><tr><td>深拷贝</td><td>复制对象的所有字段，包括基本类型和引用类型字段，引用类型的对象也会被复制。</td><td>两个对象完全独立，不共享任何成员。</td></tr><tr><td>引用拷贝</td><td>只复制对象的引用，不复制对象本身。</td><td>两个引用指向同一个对象，任何一个对象的改变都会影响到另一个。</td></tr></tbody></table><p> 类比</p><ul><li><strong>浅拷贝</strong>: 就像拍摄一张画作的照片，你得到的是画作的表面复制品，但它仍然连接着原来的画。</li><li><strong>深拷贝</strong>: 就像复制一个画作的每一笔细节来创建一个全新的画作，完全独立于原作。</li><li><strong>引用拷贝</strong>: 就像给别人画作的一个指向地址，两人看的是同一幅画。</li></ul><p>图描述：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240109211507.png" alt="image.png"></p><h4 id="1-7、内部类"><a href="#1-7、内部类" class="headerlink" title="1.7、内部类"></a>1.7、内部类</h4><blockquote><p>什么是内部类</p></blockquote><p>内部类是定义在另一个类内部的类。在Java中，内部类主要用于将一些逻辑密切相关的类组织在一起，从而提供更好的封装和维护性。</p><p>内部类提供了一种强大的方式来组织和封装复杂的逻辑，但同时也增加了代码的复杂性。因此，在使用内部类时应该权衡其带来的好处和复杂性。</p><p><strong>基本概念</strong>:</p><ul><li>内部类可以访问其外部类的成员，包括私有成员。</li><li>内部类的对象与其外部类的对象之间存在联系。</li></ul><blockquote><p>内部类的类型</p></blockquote><ul><li><strong>成员内部类</strong>（非静态内部类）：定义在外部类的成员位置，需要外部类的实例来创建。</li><li><strong>静态内部类</strong>：用<code>static</code>修饰的内部类，不需要外部类的实例就可以创建。</li><li><strong>局部内部类</strong>：定义在方法内的类，只在该方法的作用域内可见和可用。</li><li><strong>匿名内部类</strong>：没有名字的局部内部类，通常用于创建那些只需要一次使用的类实例。</li></ul><p>详细一些的解释：</p><p><strong>成员内部类</strong>:</p><ul><li>定义在外部类的成员位置。</li><li>可以访问外部类的所有成员，包括私有成员。</li><li>需要外部类的实例来创建。</li><li>语法：<code>OuterClass.InnerClass innerObject = outerObject.new InnerClass();</code></li></ul><p><strong>静态内部类</strong>:</p><ul><li>用<code>static</code>修饰，是外部类的静态成员。</li><li>可以不依赖于外部类实例被创建。</li><li>只能访问外部类的静态成员。</li><li>语法：<code>OuterClass.StaticInnerClass innerObject = new OuterClass.StaticInnerClass();</code></li></ul><p><strong>局部内部类</strong>:</p><ul><li>定义在方法内部。</li><li>只能在定义它的方法中被使用。</li><li>可以访问外部类的所有成员和方法内的final局部变量。</li></ul><p><strong>匿名内部类</strong>:</p><ul><li>没有名称的局部内部类。</li><li>通常用于实现接口或继承抽象类的临时需求。</li><li>语法：<code>new InterfaceName() &#123; /* 实现 */ &#125;</code> 或 <code>new ClassName() &#123; /* 扩展 */ &#125;</code>。</li></ul><blockquote><p>使用示例</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 示例：成员内部类、静态内部类、局部内部类和匿名内部类的使用</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title">OuterClass</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String outerField = <span class="hljs-string">&quot;Outer&quot;</span>;<br><br>    <span class="hljs-comment">// 成员内部类</span><br>    <span class="hljs-keyword">class</span> <span class="hljs-title">MemberInnerClass</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Member Inner Class: &quot;</span> + outerField);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 静态内部类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StaticInnerClass</span> &#123;<br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>            System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Static Inner Class&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">test</span>()</span> &#123;<br>        <span class="hljs-comment">// 局部内部类</span><br>        <span class="hljs-keyword">class</span> <span class="hljs-title">LocalInnerClass</span> &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Local Inner Class: &quot;</span> + outerField);<br>            &#125;<br>        &#125;<br><br>        LocalInnerClass localInner = <span class="hljs-keyword">new</span> LocalInnerClass();<br>        localInner.display();<br>    &#125;<br><br>    <span class="hljs-comment">// 匿名内部类</span><br>    <span class="hljs-function">Runnable <span class="hljs-title">getRunnable</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Anonymous Inner Class&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        OuterClass outer = <span class="hljs-keyword">new</span> OuterClass();<br><br>        <span class="hljs-comment">// 使用成员内部类</span><br>        OuterClass.MemberInnerClass memberInner = outer.<span class="hljs-function"><span class="hljs-keyword">new</span> <span class="hljs-title">MemberInnerClass</span>()</span>;<br>        memberInner.display();<br><br>        <span class="hljs-comment">// 使用静态内部类</span><br>        OuterClass.StaticInnerClass staticInner = <span class="hljs-keyword">new</span> OuterClass.StaticInnerClass();<br>        staticInner.display();<br><br>        <span class="hljs-comment">// 使用局部内部类</span><br>        outer.test();<br><br>        <span class="hljs-comment">// 使用匿名内部类</span><br>        Runnable runnable = outer.getRunnable();<br>        runnable.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h5><p>参考： <a href="https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html">https://www.cnblogs.com/nerxious/archive/2013/01/25/2876489.html</a></p><p>一般使用匿名内部类是用来简化代码编写，匿名内部类一般只使用一次</p><p>如何使用：使用匿名内部类需要继承一个父类或实现一个接口</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">//当不使用匿名内部类的情况</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-title">extends</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>    &#125;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Person p = <span class="hljs-keyword">new</span> Child();<br>        p.eat();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//当使用匿名内部类的情况</span><br><span class="hljs-comment">//匿名内部类的基本实现</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Person p = <span class="hljs-keyword">new</span> Person() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//在接口上使用匿名内部类</span><br><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span>;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Person p = <span class="hljs-keyword">new</span> Person() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">eat</span>()</span> &#123;<br>                System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;eat something&quot;</span>);<br>            &#125;<br>        &#125;;<br>        p.eat();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//Thread类的匿名内部类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Thread t = <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>                    System.<span class="hljs-keyword">out</span>.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        t.start();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Runnable接口的匿名内部类实现</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        Runnable r = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span>()</span> &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>                    System.<span class="hljs-keyword">out</span>.print(i + <span class="hljs-string">&quot; &quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        Thread t = <span class="hljs-keyword">new</span> Thread(r);<br>        t.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二、Object"><a href="#二、Object" class="headerlink" title="二、Object"></a>二、Object</h3><h4 id="2-1-Object-类的常用方法"><a href="#2-1-Object-类的常用方法" class="headerlink" title="2.1 Object 类的常用方法"></a>2.1 Object 类的常用方法</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title function_">getClass</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-built_in">Object</span> obj)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">toString</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>(<span class="hljs-type">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>() <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span>() <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p>以下是Java中 <code>Object</code> 类的常用方法的总结，包括每个方法的功能和特性：</p><table><thead><tr><th>方法签名</th><th>返回类型</th><th>描述</th><th>特性</th></tr></thead><tbody><tr><td><code>public final native Class&lt;?&gt; getClass()</code></td><td><code>Class&lt;?&gt;</code></td><td>返回当前运行时对象的Class对象。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写</td></tr><tr><td><code>public native int hashCode()</code></td><td>int</td><td>返回对象的哈希码，主要用于哈希表。</td><td><code>native</code> 方法，通常与 <code>equals()</code> 方法一起使用。</td></tr><tr><td><code>public boolean equals(Object obj)</code></td><td>boolean</td><td>比较两个对象的内存地址是否相等。String类重写了此方法来比较字符串值。</td><td>可被子类重写以提供相等性逻辑。</td></tr><tr><td><code>protected native Object clone()</code></td><td>Object</td><td>创建并返回当前对象的一份拷贝。</td><td><code>native</code> 方法，类必须实现 <code>Cloneable</code> 接口才能使用此方法。</td></tr><tr><td><code>public String toString()</code></td><td>String</td><td>返回对象的字符串表示，通常包括类名和哈希码的16进制字符串。</td><td>建议所有子类重写此方法。</td></tr><tr><td><code>public final native void notify()</code></td><td>void</td><td>唤醒在此对象监视器上等待的单个线程。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。</td></tr><tr><td><code>public final native void notifyAll()</code></td><td>void</td><td>唤醒在此对象监视器上等待的所有线程。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。</td></tr><tr><td><code>public final native void wait(long timeout)</code></td><td>void</td><td>使当前线程等待直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>，或超时。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>public final void wait(long timeout, int nanos)</code></td><td>void</td><td>使当前线程等待直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>，或超时加额外纳秒。</td><td>使用 <code>final</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>public final void wait()</code></td><td>void</td><td>使当前线程无限期等待，直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>。</td><td>使用 <code>final</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>protected void finalize()</code></td><td>void</td><td>在对象被垃圾回收器回收时触发的操作。</td><td>在Java 9中被弃用，但子类可以重写以进行清理操作。</td></tr></tbody></table><p>这些方法提供了对象行为的基本框架，从对象的生命周期管理到线程间的通信。</p><h4 id="2-2-和-equals-的区别"><a href="#2-2-和-equals-的区别" class="headerlink" title="2.2 &#x3D;&#x3D; 和 equals() 的区别"></a>2.2 &#x3D;&#x3D; 和 equals() 的区别</h4><p>&#x3D;&#x3D; 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><p>在Java中，&#x3D;&#x3D; 运算符和<code>equals()</code>方法用于比较两个对象，但它们在比较方式上有本质的不同。</p><blockquote><p>&#x3D;&#x3D; 运算符</p></blockquote><ol><li><p><strong>用途</strong>: 主要用于比较基本数据类型的值和引用类型的地址。</p></li><li><p><strong>对基本类型</strong>: 比较两个基本类型的值是否相同（例如，<code>int</code>, <code>char</code>, <code>double</code>等）。</p></li><li><p><strong>对引用类型</strong>: 比较两个对象引用是否指向内存中的同一位置。</p></li></ol><blockquote><p><code>equals()</code> 方法</p></blockquote><ol><li><p><strong>用途</strong>: 主要用于比较两个对象的内容或状态是否相等。</p></li><li><p><strong>默认行为</strong>: 在 <code>Object</code> 类中定义的 <code>equals()</code> 方法默认行为与  &#x3D;&#x3D; 相同，即比较对象的内存地址。</p></li><li><p><strong>重写</strong>: 多数类，如 <code>String</code>, <code>Date</code> 等，都重写了 <code>equals()</code> 方法来进行逻辑比较，即比较对象的内容而不是内存地址。</p></li></ol><blockquote><p>表格比较</p></blockquote><table><thead><tr><th>特性</th><th>&#x3D;&#x3D; 运算符</th><th><code>equals()</code> 方法</th></tr></thead><tbody><tr><td>比较类型</td><td>基本数据类型的值 &#x2F; 引用类型的内存地址</td><td>对象内容（可重写）</td></tr><tr><td>默认行为</td><td>比较内存地址（对于引用类型）</td><td>在 <code>Object</code> 类中也是比较内存地址</td></tr><tr><td>可重写性</td><td>不可重写</td><td>可以重写以提供自定义比较逻辑</td></tr><tr><td>使用场景</td><td>当需要检查两个变量是否指向相同的对象时使用</td><td>当需要检查两个对象是否在逻辑上相等时使用</td></tr><tr><td>例子</td><td><code>a == b</code>（对于基本类型或检查两个引用是否指向同一对象）</td><td><code>a.equals(b)</code>（对于检查两个对象的内容是否相等）</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ul><li><p><strong>&#x3D;&#x3D; 运算符</strong>: 就像检查两张名片上的地址是否一样，即使两张名片属于同一人，但如果地址不同，结果就是不相等。</p></li><li><p><strong><code>equals()</code> 方法</strong>: 就像比较两个人的面貌，即使他们住在不同的地方（不同的内存地址），只要面貌相同（内容相同），就认为他们相等。</p></li></ul><p>扩展的一些问题：</p><p>to be conteind…</p><h4 id="2-3-hashCode-有什么用"><a href="#2-3-hashCode-有什么用" class="headerlink" title="2.3 hashCode 有什么用"></a>2.3 hashCode 有什么用</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><p>hashCode() 和  equals() 方法</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><blockquote><p>为什么重写 equals() 时必须重写 hashCode() 方法？</p></blockquote><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p>如果没有重写哈希函数的话，两个键获取哈希表位置索引可能会不对，造成一些现象，比如：在集合中查找对象时可能会失败，即使该对象已经存在；即使使用一个逻辑上相等的键去查找，也可能无法找到对应的值，导致数据访问上的问题等。</p><blockquote><p>散列表</p></blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。</p><p>这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>一个通俗的例子是，</p><p>为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F( )，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。</p><blockquote><p>哈希表</p></blockquote><p>哈希表（Hash Table）其实也叫散列表，是一个数据结构。</p><p>哈希表本质上就是一个数组，只不过数组存放的是单一的数据，而哈希表中存放的是键值对（key - value pair）</p><p>key 通过哈希函数（hash function）得到数组的索引，进而存取索引位置的值。</p><p>不同的 key 通过哈希函数可能得到相同的索引值，此时，产生了哈希碰撞。</p><p>通过在数组中插入链表或者二叉树，可以解决哈希碰撞问题。</p><hr><h3 id="三、String"><a href="#三、String" class="headerlink" title="三、String"></a>三、String</h3><h4 id="3-1-String、StringBuffer、StringBuilder-的区别？"><a href="#3-1-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="3.1  String、StringBuffer、StringBuilder 的区别？"></a>3.1  String、StringBuffer、StringBuilder 的区别？</h4><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>是</td><td>是</td><td>否</td></tr><tr><td>性能</td><td>较低（对于频繁修改）</td><td>高（线程安全）</td><td>高（非线程安全）</td></tr><tr><td>用途</td><td>文本不频繁改变时</td><td>多线程中文本频繁改变</td><td>单线程中文本频繁改变</td></tr></tbody></table><p>String 是通过 final 进行修饰的，我们每次对<code>String</code>对象的修改实际都会生成一个新的<code>String</code>对象。</p><p><code>StringBuffer</code>和<code>StringBuilder</code>的默认容量大小都是16个字符。</p><h4 id="3-2-String-为什么是不可变的"><a href="#3-2-String-为什么是不可变的" class="headerlink" title="3.2 String 为什么是不可变的"></a>3.2 String 为什么是不可变的</h4><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变</li></ol><h4 id="3-3-字符串拼接用“-”-还是-StringBuilder"><a href="#3-3-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="3.3  字符串拼接用“+” 还是 StringBuilder?"></a>3.3  字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p>在JDK8中，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> str1 = <span class="hljs-string">&quot;he&quot;</span>;<br><span class="hljs-type">String</span> str2 = <span class="hljs-string">&quot;llo&quot;</span>;<br><span class="hljs-type">String</span> str3 = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">String</span> str4 = str1 + str2 + str3;<br></code></pre></td></tr></table></figure><p>对应字节码</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101412356.png" alt="image.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span>[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> s = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    s += arr[i];<br>&#125;<br>System.out.<span class="hljs-built_in">println</span>(s);<br></code></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101412821.png" alt="image.png"></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">String</span>[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>StringBuilder s = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> value : <span class="hljs-type">arr</span>) &#123;<br>    s.append(value);<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101413874.png" alt="image.png"></p><p>而在 JDK9中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code>；这也意味着 JDK 9 之后，我们可以放心使用“+” 进行字符串拼接。</p><h4 id="3-4-String-equals-和-Object-equals-有何区别"><a href="#3-4-String-equals-和-Object-equals-有何区别" class="headerlink" title="3.4  String#equals() 和 Object#equals() 有何区别"></a>3.4  String#equals() 和 Object#equals() 有何区别</h4><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h4 id="3-5-字符串常量池-🐎"><a href="#3-5-字符串常量池-🐎" class="headerlink" title="3.5 字符串常量池   🐎"></a>3.5 字符串常量池   🐎</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 在堆中创建字符串对象”ab“<br>// 将字符串对象”ab“的引用保存在字符串常量池中<br>String aa <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span><span class="hljs-comment">;</span><br>// 直接返回字符串常量池中字符串对象”ab“的引用<br>String bb <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span><span class="hljs-comment">;</span><br>System.out.println(aa<span class="hljs-operator">=</span><span class="hljs-operator">=</span>bb)<span class="hljs-comment">;// true</span><br></code></pre></td></tr></table></figure><blockquote><p>说一下字符串常量池在JVM中的位置</p></blockquote><p>字符串常量池是被存放在方法区这个位置；方法区 1.7 之前是叫永久代；1.8 之后是叫元空间（存放在本地内存）</p><p>说一下 方法区和 堆的区别，主要说一下存放内容的差别：</p><ul><li>方法区：<ul><li>存储已被虚拟机加载的类信息、常量、静态变量、即时编译后的代码等数据。</li><li>方法区存储类结构（如运行时常量池、字段、方法数据）等。</li></ul></li><li>堆：存储对象实例和数组，是垃圾收集器管理的主要区域，也是Java应用最大的内存消耗区域。</li></ul><hr><p>最近也看到了字符串常量池的相关概念，通过直接赋值的方式创建的Stirng 字符串是存放在了常量池的位置；</p><p>而通过 new 的方式是放到了 堆内存。</p><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 示例：String的创建方式</span><br><span class="hljs-built_in">String</span> s1 = <span class="hljs-string">&quot;a&quot;</span>;  <span class="hljs-comment">// 字符串常量池</span><br><span class="hljs-built_in">String</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&quot;a&quot;</span>);  <span class="hljs-comment">// 堆内存</span><br></code></pre></td></tr></table></figure><p>当您在Java中使用<code>String s = &quot;a&quot;;</code>和<code>String s = new String(&quot;a&quot;);</code>这两种方式创建字符串时，它们在内存中的存储方式不同。</p><ol><li><strong><code>String s = &quot;a&quot;;</code></strong>:<ul><li>这种方式创建的字符串对象存储在字符串常量池中。</li><li>字符串常量池位于Java堆内存中，但它是一块特殊的存储区域，专门用于存放字符串常量。</li><li>如果字符串常量池已经包含了一个等于<code>&quot;a&quot;</code>的字符串，那么<code>s1</code>将指向这个已存在的字符串，而不是创建一个新的。</li></ul></li><li><strong><code>String s = new String(&quot;a&quot;);</code></strong>:<ul><li>这种方式创建的字符串对象存储在堆内存中。</li><li>使用<code>new</code>关键字会强制在堆内存中创建一个新的<code>String</code>对象，即使字符串常量池中已经存在一个相同内容的字符串。</li><li>这意味着即使内容相同，<code>s2</code>也是一个全新的对象。</li></ul></li></ol><p>在大多数情况下，推荐使用字符串字面量的方式（如<code>&quot;a&quot;</code>），这样可以更有效地利用Java的字符串常量池，提高性能和减少内存开销。使用<code>new String(&quot;a&quot;)</code>的方式主要在某些特定场景下使用，例如，当你需要创建一个与常量池中字符串内容相同但是独立的对象时。</p><h4 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象-🐕"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象-🐕" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象  🐕"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象  🐕</h4><p>会创建 1 或 2 个字符串对象。</p><p>to be contined…</p><h4 id="3-7-intern-方法"><a href="#3-7-intern-方法" class="headerlink" title="3.7 intern 方法"></a>3.7 intern 方法</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</p><p>to be contined…</p><h4 id="3-8-String-类型的变量和常量做“-”运算时发生了什么"><a href="#3-8-String-类型的变量和常量做“-”运算时发生了什么" class="headerlink" title="3.8 String 类型的变量和常量做“+”运算时发生了什么"></a>3.8 String 类型的变量和常量做“+”运算时发生了什么</h4><p>to be contined…</p><h4 id="3-9-编码转换"><a href="#3-9-编码转换" class="headerlink" title="3.9  编码转换"></a>3.9  编码转换</h4><p>先直接看操作示例代码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 示例：String字符串的编码转换</span><br><span class="hljs-keyword">String</span> originalStr = <span class="hljs-string">&quot;Hello, 世界&quot;</span>;  <span class="hljs-comment">// 假设这是UTF-8编码的字符串</span><br>byte[] bytes;<br><br><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 将字符串从UTF-8转换为ISO-8859-1</span><br>    bytes = originalStr.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    <span class="hljs-keyword">String</span> <span class="hljs-keyword">new</span><span class="hljs-type">Str</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(bytes, <span class="hljs-string">&quot;ISO-8859-1&quot;</span>);<br><br>    <span class="hljs-comment">// 将字符串从ISO-8859-1转回UTF-8</span><br>    bytes = <span class="hljs-keyword">new</span><span class="hljs-type">Str</span>.getBytes(<span class="hljs-string">&quot;ISO-8859-1&quot;</span>);<br>    <span class="hljs-keyword">String</span> finalStr = <span class="hljs-keyword">new</span> <span class="hljs-type">String</span>(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException e) &#123;<br>    e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>字符串（<code>String</code>）的编码转换操作步骤：</p><ul><li>将<code>String</code>转换为字节数组<ul><li>使用<code>String</code>的<code>getBytes(String charsetName)</code>方法，<code>charsetName</code>是目标编码格式，如”UTF-8”、”ISO-8859-1”等</li></ul></li><li>从字节数组重新创建<code>String</code><ul><li>使用<code>new String(byte[] bytes, String charsetName)</code>构造函数</li></ul></li></ul><p>需要注意的是，不是所有的字符都可以在不同的编码之间无损转换。例如，将包含中文字符的字符串从UTF-8转换为ISO-8859-1可能会丢失信息，因为ISO-8859-1编码不支持中文字符。因此，在进行编码转换时，应确保目标编码能够支持源字符串中的所有字符。</p><p>此外，处理编码转换时还需要注意<code>UnsupportedEncodingException</code>异常，这种异常会在指定了不支持的字符集时抛出。在实际应用中，应适当处理或抛出这种异常。</p><h4 id="3-10-字符串工具类-StringUtils"><a href="#3-10-字符串工具类-StringUtils" class="headerlink" title="3.10  字符串工具类 StringUtils"></a>3.10  字符串工具类 StringUtils</h4><blockquote><p>字符串工具类 isEmpty 和 isBlank 的区别</p></blockquote><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 示例：字符串工具类中的 isEmpty 和 isBlank 方法</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringUtils</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEmpty</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span> == <span class="hljs-literal">null</span> || <span class="hljs-built_in">str</span>.<span class="hljs-property">length</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isBlank</span>(<span class="hljs-built_in">String</span> <span class="hljs-built_in">str</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">str</span> == <span class="hljs-literal">null</span> || <span class="hljs-built_in">str</span>.<span class="hljs-property">trim</span>().<span class="hljs-property">length</span>() == <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>isEmpty 方法会检查字符串是否为 null 以及长度为 0 ;isEmpty(“ “)  →  false</li><li>isBlank 方法会检查字符串是否为 null 以及是否是空字符串; isBlank(“ “)  →  true</li></ul><hr><h3 id="四、常用API"><a href="#四、常用API" class="headerlink" title="四、常用API"></a>四、常用API</h3><h4 id="Enum"><a href="#Enum" class="headerlink" title="Enum"></a>Enum</h4><p>枚举类是JDK1.5引入的一个类型</p><p>参考： </p><ul><li><a href="https://javaniuniu.com/java/enums/01">https://javaniuniu.com/java/enums/01</a></li><li><a href="https://blog.csdn.net/qq_27093465/article/details/52180865">https://blog.csdn.net/qq_27093465/article/details/52180865</a></li></ul><blockquote><p>枚举类常量</p></blockquote><p>枚举是一个特殊的class, 相当于被 final static修饰，是不能被继承的；同时所有的枚举都继承自java.lang.Enum类，<br>由于Java 不支持多继承，所以枚举对象不能再继承其他类的</p><p>最简单的使用方法是把相关的常量分组到一个枚举类型里，示例如下：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs fortran"><span class="hljs-keyword">public</span> <span class="hljs-keyword">enum</span> Color &#123;  <br>  RED, GREEN, <span class="hljs-keyword">BLANK</span>, YELLOW  <br>&#125; <br></code></pre></td></tr></table></figure><p>同时 switch  是支持 枚举类型的参数的，也是一种常见的用法；</p><p>除此之外，可以看一下向枚举中添加新方法等用法，覆盖枚举方法等操作。</p><p>to be contined…</p><p>写法规范建议：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401311026670.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></li><li><a href="https://www.cnblogs.com/Steven-HU/p/14505316.html">https://www.cnblogs.com/Steven-HU/p/14505316.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础_基础内容01</title>
    <link href="/2024/01/07/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/"/>
    <url>/2024/01/07/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/</url>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念和常识"><a href="#一、基础概念和常识" class="headerlink" title="一、基础概念和常识"></a>一、基础概念和常识</h3><h4 id="1-1、Java语言的特点"><a href="#1-1、Java语言的特点" class="headerlink" title="1.1、Java语言的特点"></a>1.1、Java语言的特点</h4><p>比较多的特点，目前 Java 中在实际项目开发中真正强大的是Java 的生态；</p><p>且技术是服务于业务的，就业率和使用率在国内占比较大。</p><p>特点：</p><ul><li>平台无关性</li><li>面向对象（封装、继承、多态）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>……</li></ul><h4 id="1-2、Java-SE-vs-Java-EE"><a href="#1-2、Java-SE-vs-Java-EE" class="headerlink" title="1.2、Java SE  vs Java EE"></a>1.2、Java SE  vs Java EE</h4><p>Java SE （Java Platform，Standard Edition） 是 Java 的基础版本，Java EE  （Java Platform, Enterprise Edition ）是 Java 的高级版本。</p><blockquote><p>基本介绍：</p></blockquote><p>Java SE是Java编程语言的标准版，它提供了Java语言的核心功能，包括：</p><ul><li><strong>基本语言特性</strong>：如变量、数组、循环、条件语句等。</li><li><strong>核心类库</strong>：提供了基础的类库，包括数据类型、数学函数、文件处理、网络编程、并发编程等。</li><li><strong>图形用户界面（GUI）</strong>: 如AWT（Abstract Window Toolkit）和Swing。</li><li><strong>Java虚拟机（JVM）</strong>: Java程序的运行环境。</li><li><strong>工具</strong>: 如编译器（javac），解释器（java），打包工具（jar）等。</li></ul><p>Java EE是Java的企业版，它在Java SE的基础上增加了用于构建大型企业级应用的功能。Java EE包括：</p><ul><li><strong>扩展的类库</strong>: 在Java SE的基础上提供了额外的类库和API，用于企业级应用开发。</li><li><strong>服务器端技术</strong>: 如Servlets、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）等。</li><li><strong>Web服务</strong>: 支持创建和消费Web服务。</li><li><strong>持久化API</strong>: 如Java Persistence API（JPA）。</li><li><strong>分布式计算</strong>: 支持构建大型、分布式的多层应用。</li><li><strong>集成技术</strong>: 如JMS（Java Message Service）和JavaMail。</li></ul><blockquote><p>总结</p></blockquote><ul><li><strong>Java SE</strong> 提供了Java语言的基础，更适合开发桌面应用程序或简单的服务器应用程序</li><li><strong>Java EE</strong> 在Java SE的基础上增加了企业级特性，更适合开发复杂的企业级应用程序或 Web 应用程序</li></ul><h4 id="1-3、JVM-vs-JDK-vs-JRE"><a href="#1-3、JVM-vs-JDK-vs-JRE" class="headerlink" title="1.3、JVM vs JDK  vs  JRE"></a>1.3、JVM vs JDK  vs  JRE</h4><ul><li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</li><li>JDK （Java Development Kit）是完整的Java软件开发工具包</li><li>JRE（Java Runtime Environment） 是 Java 运行时环境</li></ul><p>JDK &gt;  JRE  &gt;  JVM</p><p>关系可以看这张图：<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401081433625.png" alt="image.png"></p><hr><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> </p><p>我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。</p><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h4 id="1-4、JIT"><a href="#1-4、JIT" class="headerlink" title="1.4、JIT"></a>1.4、JIT</h4><p>略</p><h4 id="1-5、编译与解释"><a href="#1-5、编译与解释" class="headerlink" title="1.5、编译与解释"></a>1.5、编译与解释</h4><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。<ul><li>一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li></ul></li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。<ul><li>解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等</li></ul></li></ul><blockquote><p>为什么说 Java 语言“编译与解释并存”？  →   先编译 后解释</p></blockquote><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。</p><p>因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h4 id="1-6、AOT"><a href="#1-6、AOT" class="headerlink" title="1.6、AOT"></a>1.6、AOT</h4><p>略</p><h4 id="1-7、Oracle-JDK-vs-OpenJDK"><a href="#1-7、Oracle-JDK-vs-OpenJDK" class="headerlink" title="1.7、Oracle JDK vs OpenJDK"></a>1.7、Oracle JDK vs OpenJDK</h4><p>JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司;  原来的 SUN 公司把 JDK 给开源了； Oracle 公司就类似开了一个分支，做了一个闭源版本。</p><blockquote><p>区别：</p></blockquote><p> OpenJDK</p><ol><li><strong>开源</strong>：OpenJDK是一个开放源代码的Java SE平台实现，它是自由软件并且公开发布。它是Oracle JDK的基础。</li><li><strong>社区驱动</strong>：由开源社区维护和更新。它通常是最先获得最新语言特性和修复的版本。</li><li><strong>许可证</strong>：使用GPL（通用公共许可证）v2许可证，带有Classpath例外，允许不受GPL限制地使用类库。</li><li><strong>更新</strong>：通常更加频繁地获得更新和补丁。</li><li><strong>广泛使用</strong>：由于其开源性质，被广泛用于各种环境，包括商业应用。</li></ol><p>Oracle JDK</p><ol><li><strong>Oracle官方版本</strong>：Oracle JDK是由Oracle公司提供的Java SE平台的官方实现。它基于OpenJDK，并包含了一些附加组件。</li><li><strong>商业用途许可费</strong>：Oracle JDK的早期版本免费用于个人和开发用途，但从JDK 11开始，Oracle更改了许可策略，对于商业用途或生产环境中的使用需要付费。</li><li><strong>性能优化和附加特性</strong>：Oracle JDK可能包括一些专有的性能增强和其他特性，如JRockit或Mission Control。</li><li><strong>支持</strong>：Oracle提供专业的长期支持服务，适合企业用户。</li><li><strong>更新频率</strong>：Oracle JDK的更新可能不如OpenJDK频繁，但更稳定，经过了更严格的测试。</li></ol><blockquote><p>总结</p></blockquote><ul><li><strong>OpenJDK</strong> 是一个完全开源的JDK版本，适用于需要免费、开源解决方案的场景。</li><li><strong>Oracle JDK</strong> 提供了一些附加特性和专业支持，适用于需要稳定支持和企业级特性的商业应用。</li></ul><h4 id="1-8、Java-和-C-的区别"><a href="#1-8、Java-和-C-的区别" class="headerlink" title="1.8、Java 和 C++ 的区别?"></a>1.8、Java 和 C++ 的区别?</h4><p>稍微记一下。</p><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）</li><li>…….</li></ul><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><h4 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h4><ol><li><p><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</p></li><li><p><strong>多行注释</strong>：通常用于解释一段代码的作用。</p></li><li><p><strong>文档注释</strong>：通常用于生成 Java 开发文档。</p></li></ol><h4 id="2-2-标识符和关键字"><a href="#2-2-标识符和关键字" class="headerlink" title="2.2 标识符和关键字"></a>2.2 标识符和关键字</h4><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识符</strong> 。</p><blockquote><p>关键字</p></blockquote><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p></blockquote><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><p>⚠️ 注意：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><h4 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>符号在前就先加/减，符号在后就后加/减</strong></div><p>Java中的自增（<code>++</code>）和自减（<code>--</code>）运算符是常用的一元运算符，用于增加或减少变量的值。</p><blockquote><p>自增运算符（<code>++</code>）</p></blockquote><p>自增运算符<code>++</code>用于将变量的值增加1。它有两种形式：</p><ol><li><p><strong>前缀自增</strong>：<code>++var</code>。在表达式求值之前增加变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = ++a; // 先将a增加1，变成6，然后将a的值赋给b，b也是6</code></li></ul></li><li><p><strong>后缀自增</strong>：<code>var++</code>。在表达式求值之后增加变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = a++; // 先将a的值赋给b，b是5，然后a增加1，变成6</code></li></ul></li></ol><blockquote><p>自减运算符（<code>--</code>）</p></blockquote><p>自减运算符<code>--</code>用于将变量的值减少1。它同样有两种形式：</p><ol><li><p><strong>前缀自减</strong>：<code>--var</code>。在表达式求值之前减少变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = --a; // 先将a减少1，变成4，然后将a的值赋给b，b也是4</code></li></ul></li><li><p><strong>后缀自减</strong>：<code>var--</code>。在表达式求值之后减少变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = a--; // 先将a的值赋给b，b是5，然后a减少1，变成4</code></li></ul></li></ol><blockquote><p>使用场景和注意事项</p></blockquote><ul><li>这些运算符通常用在循环和简单的数值操作中。</li><li>选择前缀还是后缀形式取决于你希望在表达式其他部分使用变量的哪个值（增加或减少前的值，还是增加或减少后的值）。</li><li>在单独使用时（不作为更大表达式的一部分），前缀和后缀形式的效果是相同的。</li></ul><blockquote><p>进阶问题</p></blockquote><p>考虑以下代码片段：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span> = 1; <br><span class="hljs-attribute">int j</span> = i++ + ++i;<br></code></pre></td></tr></table></figure><p>此时 j 的值是多少？</p><p><strong>分析：</strong></p><p>给定代码分析</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span> = 1; <br><span class="hljs-attribute">int j</span> = i++ + ++i;<br></code></pre></td></tr></table></figure><ol><li><strong>第一个操作 - <code>i++</code></strong> (后缀自增): 这个操作首先返回<code>i</code>的当前值，然后<code>i</code>的值增加1。所以，在这个表达式的这一部分，<code>i</code>的值被视为1，但之后<code>i</code>变成了2。</li><li><strong>第二个操作 - <code>++i</code></strong> (前缀自增): 在执行这个操作时，<code>i</code>已经是2了。现在，由于是前缀自增，<code>i</code>首先被增加1，变成3，然后这个值被用于表达式。所以，这一部分的值是3。</li><li><strong>结果</strong>: 结合这两部分，<code>j = 1 + 3</code>，所以<code>j</code>的最终值是4。</li></ol><p>关键点</p><ul><li>后缀自增(<code>i++</code>)先返回当前值，然后增加。</li><li>前缀自增(<code>++i</code>)先增加，然后返回增加后的值。</li><li>在包含多个自增&#x2F;自减操作的复合表达式中，理解求值的顺序非常重要。</li></ul><h4 id="2-4-移位运算符"><a href="#2-4-移位运算符" class="headerlink" title="2.4 移位运算符"></a>2.4 移位运算符</h4><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li></ul><h4 id="2-5-continue、break-和-return-的区别"><a href="#2-5-continue、break-和-return-的区别" class="headerlink" title="2.5 continue、break 和 return 的区别"></a>2.5 continue、break 和 return 的区别</h4><p>关键词：</p><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><hr><h4 id="2-6-switch-case"><a href="#2-6-switch-case" class="headerlink" title="2.6  switch case"></a>2.6  switch case</h4><p>语法</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">switch</span>(<span class="hljs-keyword">expression</span>)&#123;<br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-keyword">case</span> value :<br>       <span class="hljs-comment">//语句</span><br>       <span class="hljs-keyword">break</span>; <span class="hljs-comment">//可选</span><br>    <span class="hljs-comment">//你可以有任意数量的case语句</span><br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">//可选</span><br>       <span class="hljs-comment">//语句</span><br>&#125;<br></code></pre></td></tr></table></figure><p>switch case用来判断一个变量与一系列值中某个值是否相等，每个值称为一个分支</p><p>使用规则：</p><ul><li>switch语句中变量类型可以是：byte、short、int、char。从Java SE 7开始，switch支持String类型，同时case必须为字符串常量</li><li>switch语句可以拥有多个case，每个case后面跟一个要比较的值和冒号</li><li>case语句中的值的数据类型必须与变量的数据类型相同</li><li>当变量的值与case语句的值相等，case语句之后的语句开始执行，直到出现break语句才会跳出switch</li><li>当遇到break时，switch终止。程序跳转到switch后面的语句执行。case不必须要包含break。如果没有break出现，程序会继续执行下一条case，直到出现break</li><li>switch可以包含一个default分支，该分支是switch的最后一个分支，该分支可以在任何位置，但建议写在最后。default在没有case的值和变量相等时执行。default不需要break</li></ul><blockquote><p>switch case 支持哪几种数据类型</p></blockquote><p>在Java中，<code>switch</code>语句支持以下几种数据类型：</p><ol><li><strong>整数类型</strong>:<ul><li>包括<code>byte</code>、<code>short</code>、<code>int</code>以及它们的包装类<code>Byte</code>、<code>Short</code>、<code>Integer</code>。</li><li><code>char</code>和<code>Character</code>也被支持，因为它们可以被转换为整数类型。</li></ul></li><li><strong>枚举类型</strong> (<code>enum</code>):<ul><li>可以使用枚举类型的常量作为<code>case</code>标签。</li></ul></li><li><strong>字符串类型</strong> (<code>String</code>):<ul><li>从Java 7开始，<code>switch</code>语句支持字符串类型。</li><li>字符串比较是基于字符串的内容而不是引用。</li></ul></li><li><strong>Java 12 引入的新特性</strong>:<ul><li>从Java 12开始，<code>switch</code>表达式支持更多的数据类型和更灵活的使用方式（作为预览特性）。</li></ul></li></ol><p>需要注意的是，<code>long</code>、<code>float</code>、<code>double</code>及其包装类不被<code>switch</code>语句支持。此外，<code>switch</code>语句中的<code>case</code>标签必须使用常量表达式，不能使用变量。</p><p><code>switch</code>语句的这种类型限制主要是出于性能考虑，因为<code>switch</code>通常是通过整数跳转表实现的，这使得<code>switch</code>语句在处理整数类型时非常高效。使用枚举和字符串则是为了提供更多的编程便利。</p><hr><h3 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h3><h4 id="3-1、Java-中的基本数据类型"><a href="#3-1、Java-中的基本数据类型" class="headerlink" title="3.1、Java 中的基本数据类型"></a>3.1、Java 中的基本数据类型</h4><table><thead><tr><th>类型</th><th>基础类型</th><th>默认值</th><th>占用空间大小</th><th>位数</th><th>取值范围</th><th>对应包装类型</th></tr></thead><tbody><tr><td>数字类型</td><td>byte</td><td>0</td><td>1字节</td><td>8</td><td>-128 ~ 127</td><td>Byte</td></tr><tr><td>数字类型</td><td>short</td><td>0</td><td>2字节</td><td>16</td><td>-32768（-2^15） ~ 32767（2^15 - 1）</td><td>Short</td></tr><tr><td>数字类型</td><td>int</td><td>0</td><td>4字节</td><td>16</td><td>-2147483648 ~ 2147483647</td><td>Integer</td></tr><tr><td>数字类型</td><td>long</td><td>0L</td><td>8字节</td><td>32</td><td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td><td>Long</td></tr><tr><td>数字类型</td><td>float</td><td>0.0f</td><td>4字节</td><td>23</td><td>1.4E-45 ~ 3.4028235E38</td><td>Float</td></tr><tr><td>数字类型</td><td>double</td><td>0.0d</td><td>8字节</td><td>64</td><td>4.9E-324 ~ 1.7976931348623157E308</td><td>Double</td></tr><tr><td>字符类型</td><td>char</td><td>‘\u0000’（即空字符）</td><td>2字节（使用Unicode编码）</td><td>16</td><td>0 ~ 65535（2^16 - 1）</td><td>Character</td></tr><tr><td>布尔类型</td><td>boolean</td><td>false</td><td>1字节</td><td>1</td><td>true、false</td><td>Boolean</td></tr></tbody></table><p>补充一下计算机存储字节相关的知识：</p><ol><li><strong>位（Bit）</strong>:<ul><li>计算机中数据的最小单位。</li><li>一个位可以表示一个二进制值，即0或1。</li></ul></li><li><strong>字节（Byte）</strong>:<ul><li>常用的数据存储单位。</li><li>1字节 &#x3D; 8位。</li><li>例如，如果一个数据类型占用1字节，那么它实际上可以存储8位二进制信息。</li></ul></li></ol><h4 id="3-2-基本类型和包装类型"><a href="#3-2-基本类型和包装类型" class="headerlink" title="3.2 基本类型和包装类型"></a>3.2 基本类型和包装类型</h4><blockquote><p>区别</p></blockquote><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">比较方式<br><br>对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。<br></code></pre></td></tr></table></figure><blockquote><p>特点</p></blockquote><ol><li><strong>对象特性</strong>：包装类型是对象，可以调用各种方法，例如<code>Integer.parseInt()</code>。</li><li><strong>可用于泛型</strong>：在集合类等使用泛型的场合，只能使用对象，因此必须使用包装类型。</li><li><strong>可表示空值</strong>：可以表示为<code>null</code>，而基本类型不能。</li><li><strong>堆内存</strong>：对象通常存储在堆上，这可能导致处理稍慢于基本类型。</li><li><strong>自动装箱和拆箱</strong>：Java提供自动将基本类型转换为包装类型（装箱）和将包装类型转换为基本类型（拆箱）的功能。</li></ol><blockquote><p>比较和选择</p></blockquote><ul><li>使用基本数据类型时，如果关注性能和内存，并且不需要对象的特性，比如在大量数值计算中。</li><li>使用包装类型时，如果需要对象的特性，比如在使用集合类、需要表示空值或使用泛型时。</li></ul><h4 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h4><p>Java中的某些包装类实现了一个称为“缓存机制”的特性，主要是为了提高性能和减少内存使用。这一机制最常见于<code>Integer</code>和其他几种数字类型的包装类中。我们来详细探讨这一点。</p><blockquote><p>包装类型缓存机制的概述</p></blockquote><ol><li><strong>Integer缓存</strong>: Java的<code>Integer</code>类缓存了从<code>-128</code>到<code>127</code>之间的整数。这意味着在这个范围内的整数会被预先创建并缓存。当代码需要这些值的包装实例时，会重用已经创建的对象，而不是每次都创建新对象。</li><li><strong>其他类型</strong>: 类似的缓存机制也适用于<code>Byte</code>, <code>Short</code>, <code>Long</code>, <code>Character</code>等包装类。但具体的缓存范围可能不同。例如，<code>Byte</code>缓存了所有可能的值（从<code>-128</code>到<code>127</code>），而<code>Character</code>缓存了从<code>\u0000</code>到<code>\u007F</code>的字符。</li></ol><blockquote><p>缓存机制的工作原理</p></blockquote><p>当你通过<code>valueOf</code>方法（这是自动装箱背后使用的方法）或者直接使用自动装箱来创建一个包装对象时，Java会首先检查其值是否在缓存范围内。如果是，它会从缓存中返回相应的对象实例；如果不是，它会创建一个新的对象实例。</p><p>例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer a <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;  // 使用缓存</span><br>Integer b <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;  // 重用相同的对象</span><br>Integer c <span class="hljs-operator">=</span> <span class="hljs-number">200</span><span class="hljs-comment">;  // 创建新的对象实例，因为200不在缓存范围内</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>a</code>和<code>b</code>引用的是内存中相同的<code>Integer</code>对象，因为100在缓存范围内。</p><blockquote><p>缓存机制的好处</p></blockquote><ul><li><strong>性能提升</strong>：通过减少不必要的对象创建，提高了性能。</li><li><strong>内存优化</strong>：减少了内存的占用，因为共享了相同的对象。</li></ul><blockquote><p>使用时的注意事项</p></blockquote><ul><li>当比较包装类型的值时，应该使用<code>equals</code>方法而不是&#x3D;&#x3D; 运算符，因为 &#x3D;&#x3D; 比较的是引用，而不是值。但在缓存范围内，使用 &#x3D;&#x3D; 可能会误导你认为比较的是值。</li><li>在处理大量的整数运算时，要意识到自动装箱和拆箱可能会引入额外的性能开销</li></ul><hr><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p><p><code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，</p><p><code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> new Integer(<span class="hljs-number">40</span>)<span class="hljs-comment">;</span><br>System.out.println(i1<span class="hljs-operator">=</span><span class="hljs-operator">=</span>i2)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。</p><p>因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>记住：</strong> 所有整型包装类对象之间值的比较，全部使用 equals 方法比较</div><p> <img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240108224809.png" alt="image.png"></p><h5 id="常量池技术"><a href="#常量池技术" class="headerlink" title="常量池技术"></a>常量池技术</h5><p>看到一个概念，即将这个缓存机制也称为常量池技术；解释可以看下面的内容：</p><p>Java中的包装类型（如<code>Integer</code>、<code>Long</code>、<code>Byte</code>、<code>Character</code>、<code>Short</code>等）使用了常量池技术，主要目的是为了减少不必要的对象创建，提高空间和时间效率。</p><p>示例：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 示例：使用Integer的常量池</span><br><span class="hljs-keyword">Integer</span> a = <span class="hljs-number">127</span>;  <span class="hljs-comment">// 使用常量池</span><br><span class="hljs-keyword">Integer</span> b = <span class="hljs-number">127</span>;  <span class="hljs-comment">// 同样使用常量池，a和b指向相同的对象</span><br><br><span class="hljs-keyword">Integer</span> c = <span class="hljs-number">128</span>;  <span class="hljs-comment">// 超出常量池范围，创建新的Integer对象</span><br><span class="hljs-keyword">Integer</span> d = <span class="hljs-number">128</span>;  <span class="hljs-comment">// 同样创建新的Integer对象，c和d指向不同的对象</span><br></code></pre></td></tr></table></figure><p>常量池的一些相关内容：</p><ol><li><strong>常量池</strong>:<ul><li>常量池是一种特殊的存储区域，用于存储包装类的常用对象。</li><li>在Java中，<code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code>、<code>Character</code>这些类的对象有常量池。</li></ul></li><li><strong>Integer常量池范围</strong>:<ul><li>对于<code>Integer</code>，常量池的范围默认是从-128到127。</li><li>当你创建一个在这个范围内的<code>Integer</code>对象时，Java会直接从常量池中返回已存在的对象而不是创建一个新的对象。</li></ul></li><li><strong>超出常量池范围</strong>:<ul><li>如果创建的对象超出了常量池的范围，Java会创建一个新的对象。</li></ul></li><li><strong>节省内存</strong>:<ul><li>由于常量池的使用，相同的数值会指向相同的对象，这在一定程度上节省了内存。</li></ul></li><li><strong><code>Character</code>常量池范围</strong>:<ul><li>对于<code>Character</code>，常量池的范围是从<code>\u0000</code>到<code>\u007F</code>（即0到127）。</li></ul></li><li><strong>自动装箱</strong>:<ul><li>当你将基本数据类型转换为包装类时，Java会自动使用常量池（如果值在常量池的范围内），这个过程称为自动装箱。</li></ul></li><li><strong>注意事项</strong>:<ul><li>在比较包装类型对象时，应该使用<code>equals</code>方法而不是&#x3D;&#x3D; ，因为 &#x3D;&#x3D; 比较的是引用，而不是值。但在常量池范围内， &#x3D;&#x3D; 可以正常工作因为引用指向相同的对象。</li></ul></li></ol><p>常量池技术是Java中一种重要的内存优化手段，它在处理大量的包装类型对象时尤为有效。</p><h4 id="3-4-自动装箱与拆箱"><a href="#3-4-自动装箱与拆箱" class="headerlink" title="3.4 自动装箱与拆箱"></a>3.4 自动装箱与拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><p>实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：自动装箱和拆箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">boxed</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">// 自动装箱，相当于 Integer.valueOf(10)</span><br><span class="hljs-type">int</span> <span class="hljs-variable">unboxed</span> <span class="hljs-operator">=</span> boxed; <span class="hljs-comment">// 自动拆箱，相当于 boxed.intValue()</span><br></code></pre></td></tr></table></figure><p><strong>自动装箱（Autoboxing）</strong>:</p><ul><li>当需要一个包装类型的对象时，Java会自动将基本数据类型转换为对应的包装类型。</li><li>这是通过调用包装类的静态<code>valueOf</code>方法实现的。</li><li>例如，当你写<code>Integer boxed = 10;</code>时，实际上执行的是<code>Integer boxed = Integer.valueOf(10);</code>。</li></ul><p><strong>自动拆箱（Unboxing）</strong>:</p><ul><li>当需要一个基本数据类型的值时，Java会自动将包装类型的对象转换为基本数据类型。</li><li>这是通过调用包装类对象的<code>xxxValue</code>方法实现的（例如，<code>intValue</code>、<code>doubleValue</code>等）。</li><li>例如，当你写<code>int unboxed = boxed;</code>时，实际上执行的是<code>int unboxed = boxed.intValue();</code>。</li></ul><p><strong>注意事项</strong>:</p><ul><li><strong>空指针异常</strong>：自动拆箱可能导致空指针异常。如果包装类型的引用为<code>null</code>，在自动拆箱时会尝试调用<code>null</code>的<code>xxxValue</code>方法，从而抛出<code>NullPointerException</code>。</li><li><strong>性能考虑</strong>：虽然自动装箱和拆箱很方便，但在性能敏感的场景下应当谨慎使用，因为装箱和拆箱操作涉及额外的对象创建和方法调用。</li></ul><p>自动装箱和拆箱让开发者可以更加自然地编写代码，无需显式地在基本数据类型和包装类型之间转换，但同时也需要了解其背后的原理和潜在陷阱。</p><h5 id="可能导致NPE的自动拆箱"><a href="#可能导致NPE的自动拆箱" class="headerlink" title="可能导致NPE的自动拆箱"></a>可能导致NPE的自动拆箱</h5><p>NPE 指的是空指针异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 示例：可能导致NPE的自动拆箱</span><br><span class="hljs-type">Integer</span> <span class="hljs-variable">myInteger</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-type">int</span> <span class="hljs-variable">myInt</span> <span class="hljs-operator">=</span> myInteger; <span class="hljs-comment">// 自动拆箱时可能抛出NullPointerException</span><br></code></pre></td></tr></table></figure><p>上述我们也讲到，如果包装类型的引用为<code>null</code>，在自动拆箱时会尝试调用<code>null</code>的<code>xxxValue</code>方法，从而抛出<code>NullPointerException</code>。</p><p>说一下这种情况如何处理：</p><p><strong>处理方法</strong>:</p><ol><li><strong>检查空值</strong>:<ul><li>在进行自动拆箱之前，先检查包装类型的对象是否为<code>null</code>。</li><li>示例：<code>if (myInteger != null) &#123; myInt = myInteger; &#125;</code></li></ul></li><li><strong>使用默认值</strong>:<ul><li>如果包装类型可能为<code>null</code>，可以使用默认值来避免NPE。</li><li>示例：<code>myInt = (myInteger != null) ? myInteger : defaultValue;</code></li></ul></li><li><strong>避免不必要的装箱和拆箱</strong>:<ul><li>在可能的情况下，尽量避免不必要的自动装箱和拆箱，特别是在关键的业务逻辑中。</li></ul></li><li><strong>使用Optional类</strong>:<ul><li>在Java 8及以上版本，可以使用<code>Optional</code>类来优雅地处理可能为<code>null</code>的情况。</li><li>示例：<code>myInt = Optional.ofNullable(myInteger).orElse(defaultValue);</code></li></ul></li><li><strong>代码审查和测试</strong>:<ul><li>在编码阶段进行严格的代码审查，确保对可能为<code>null</code>的对象进行了适当的处理。</li><li>编写单元测试来覆盖可能产生NPE的场景。</li></ul></li></ol><h4 id="3-5-浮点数运算精度丢失"><a href="#3-5-浮点数运算精度丢失" class="headerlink" title="3.5 浮点数运算精度丢失"></a>3.5 浮点数运算精度丢失</h4><p>看一下下面这个代码示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">float</span> a = <span class="hljs-number">2</span>.<span class="hljs-number">0</span>f - <span class="hljs-number">1</span>.<span class="hljs-number">9</span>f;<br><span class="hljs-attribute">float</span> b = <span class="hljs-number">1</span>.<span class="hljs-number">8</span>f - <span class="hljs-number">1</span>.<span class="hljs-number">7</span>f;<br><span class="hljs-attribute">System</span>.out.println(a);// <span class="hljs-number">0</span>.<span class="hljs-number">100000024</span><br><span class="hljs-attribute">System</span>.out.println(b);// <span class="hljs-number">0</span>.<span class="hljs-number">099999905</span><br><span class="hljs-attribute">System</span>.out.println(a == b);// false<br></code></pre></td></tr></table></figure><p>原因分析：</p><p>浮点数运算中的精度丢失是一个在计算机科学中广泛存在的问题，尤其是在使用单精度（<code>float</code>）和双精度（<code>double</code>）类型时。这个问题的根源在于浮点数在计算机中的表示方式。</p><blockquote><p>浮点数表示</p></blockquote><p>浮点数在计算机中通常使用IEEE 754标准表示。这种表示方法有两个主要部分：</p><ol><li><strong>尾数（Mantissa）</strong>：代表数字的有效数字。</li><li><strong>指数（Exponent）</strong>：决定小数点的位置。</li></ol><p>由于这两个部分都有固定的位数，所以只能精确表示一定范围和精度的数。一些数，如分数<code>1/3</code>或特定的小数，无法被精确地表示为浮点数。</p><blockquote><p>精度丢失的原因</p></blockquote><ol><li><strong>有限的位数</strong>：由于尾数和指数的位数是有限的，因此浮点数不能精确表示所有的数值。在转换和运算过程中，会进行四舍五入以适应这些位数，从而导致精度丢失。</li><li><strong>二进制表示</strong>：某些十进制小数在二进制下是无限循环小数，无法精确表示，例如0.1。</li></ol><p>实际影响</p><p>在进行浮点数运算时，如加法、减法、乘法和除法，这种精度的丢失可能会累积，导致最终结果与预期有较大偏差。这在金融计算等需要高精度的场合尤为重要。</p><blockquote><p>解决方法</p></blockquote><ol><li><strong>使用<code>BigDecimal</code></strong>: 在Java中，<code>BigDecimal</code>类可以用于精确的小数运算。它允许控制舍入模式，可以用于金融和科学计算中。</li><li><strong>避免不必要的运算</strong>：减少浮点数运算的数量可以减少累积误差。</li><li><strong>理解和接受一定的误差</strong>：在某些场合，完全精确的结果可能并不是必需的，此时理解并接受浮点运算的限制是合理的。</li></ol><h3 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h3><h4 id="4-1-成员变量与局部变量"><a href="#4-1-成员变量与局部变量" class="headerlink" title="4.1 成员变量与局部变量"></a>4.1 成员变量与局部变量</h4><p>成员变量（字段、属性），局部变量在声明位置、作用域、初始化行为等方面有显著的不同</p><blockquote><p>成员变量（Member Variables）</p></blockquote><p>成员变量是定义在类中的变量，它们描述了类的属性或状态。根据是否使用<code>static</code>关键字，成员变量可以进一步分为实例变量和类变量。</p><ol><li><strong>实例变量</strong>：没有用<code>static</code>修饰的成员变量。每个类的实例都有自己的一套实例变量的副本。</li><li><strong>类变量（静态变量）</strong>：用<code>static</code>修饰的成员变量。它们属于类本身，所有实例共享同一个静态变量的副本。</li></ol><p>特点</p><ul><li><strong>作用域</strong>：整个类内部。</li><li><strong>生命周期</strong>：与对象的生命周期（实例变量）或类的生命周期（静态变量）相同。</li><li><strong>默认值</strong>：自动初始化为默认值（如<code>int</code>为0，对象引用为<code>null</code>）。</li><li><strong>访问方式</strong>：可以通过对象（实例变量）或类名（静态变量）访问。</li></ul><blockquote><p>局部变量（Local Variables）</p></blockquote><p>局部变量是在方法内、构造器内或代码块内定义的变量。</p><p><strong>特点</strong></p><ul><li><strong>作用域</strong>：仅限于它们被声明的方法、构造器或代码块内。</li><li><strong>生命周期</strong>：从声明开始到方法、构造器或代码块执行完毕时结束。</li><li><strong>初始化</strong>：不会自动初始化，必须在使用前显式初始化。</li><li><strong>内存位置</strong>：通常存储在栈上。</li></ul><blockquote><p>比较</p></blockquote><table><thead><tr><th>特性</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>声明位置</td><td>类体内部</td><td>方法、构造器或代码块内</td></tr><tr><td>作用域</td><td>整个类内部</td><td>仅限于声明它们的块内</td></tr><tr><td>生命周期</td><td>实例变量：随对象存在；静态变量：随类存在</td><td>随方法、构造器或代码块执行完毕而结束</td></tr><tr><td>初始化</td><td>自动初始化为默认值</td><td>必须显式初始化</td></tr><tr><td>内存位置</td><td>堆（实例变量）或方法区（静态变量）</td><td>栈</td></tr></tbody></table><h4 id="4-2-静态变量"><a href="#4-2-静态变量" class="headerlink" title="4.2 静态变量"></a>4.2 静态变量</h4><p>略</p><h4 id="4-3-字符型常量和字符串常量"><a href="#4-3-字符型常量和字符串常量" class="headerlink" title="4.3 字符型常量和字符串常量"></a>4.3 字符型常量和字符串常量</h4><p>字符型常量（Character Constants）和字符串常量（String Constants）之间的主要区别：</p><table><thead><tr><th>特性</th><th>字符型常量（Character Constants）</th><th>字符串常量（String Constants）</th></tr></thead><tbody><tr><td>引号类型</td><td>单引号（’）</td><td>双引号（”）</td></tr><tr><td>内容</td><td>仅包含单个字符</td><td>可包含零个、一个或多个字符</td></tr><tr><td>类型</td><td>基本数据类型（<code>char</code>）</td><td>类（<code>String</code>）</td></tr><tr><td>存储大小</td><td>16位（2字节）Unicode字符</td><td>取决于字符串长度</td></tr><tr><td>可变性</td><td>不适用</td><td>不可变（一旦创建，内容不可更改）</td></tr><tr><td>示例</td><td><code>&#39;A&#39;</code>, <code>&#39;1&#39;</code>, <code>&#39;\n&#39;</code></td><td><code>&quot;Hello&quot;</code>, <code>&quot;123&quot;</code>, <code>&quot;&quot;</code></td></tr></tbody></table><h3 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h3><h4 id="5-1-什么是方法"><a href="#5-1-什么是方法" class="headerlink" title="5.1  什么是方法"></a>5.1  什么是方法</h4><p>略</p><h4 id="5-2-方法的返回值"><a href="#5-2-方法的返回值" class="headerlink" title="5.2 方法的返回值"></a>5.2 方法的返回值</h4><p>根据方法的返回值类型和参数类型，方法可以分为几种不同的类别。</p><p>区别：</p><table><thead><tr><th>类别</th><th>返回值类型</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>无返回值无参数</td><td><code>void</code></td><td>无参数</td><td>这类方法不返回任何值，也不接受任何参数。</td></tr><tr><td>无返回值有参数</td><td><code>void</code></td><td>有参数</td><td>这类方法不返回值，但接受一个或多个参数。</td></tr><tr><td>有返回值无参数</td><td>非<code>void</code></td><td>无参数</td><td>这类方法返回一个值，但不接受任何参数。</td></tr><tr><td>有返回值有参数</td><td>非<code>void</code></td><td>有参数</td><td>这类方法既返回一个值，又接受一个或多个参数。</td></tr></tbody></table><blockquote><p>例子</p></blockquote><ol><li><strong>无返回值无参数</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span>()</span> &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br><span class="hljs-comment">// 下面这个方法也没有返回值，虽然用到了 return</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (...) &#123;<br>        <span class="hljs-comment">// 表示结束方法的执行,下方的输出语句不会执行</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.<span class="hljs-keyword">out</span>.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>无返回值有参数</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">public</span></span> void f2(<span class="hljs-keyword">Parameter</span> 1, ..., <span class="hljs-keyword">Parameter</span> <span class="hljs-comment">n) &#123;</span><br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>有返回值无参数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">f3</span>()</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>有返回值有参数</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">f4</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="5-3-静态方法与实例方法"><a href="#5-3-静态方法与实例方法" class="headerlink" title="5.3 静态方法与实例方法"></a>5.3 静态方法与实例方法</h4><blockquote><p>区别</p></blockquote><p>静态方法（Static Methods）</p><ol><li><strong>定义</strong>: 使用<code>static</code>关键字定义。</li><li><strong>调用方式</strong>: 可以通过类名直接调用，不需要创建类的对象。</li><li><strong>访问</strong>: 只能直接访问类的静态成员（变量和方法）。不能直接访问实例成员。</li><li><strong>用途</strong>: 常用于不依赖于对象状态的工具或帮助方法。</li></ol><p>实例方法（Instance Methods）</p><ol><li><strong>定义</strong>: 没有<code>static</code>关键字，属于类的实例。</li><li><strong>调用方式</strong>: 需要创建类的对象，通过对象调用。</li><li><strong>访问</strong>: 可以访问类的实例成员（变量和方法）以及静态成员。</li><li><strong>用途</strong>: 通常用于操作或访问对象的实例数据。</li></ol><blockquote><p>比较</p></blockquote><table><thead><tr><th>特性</th><th>静态方法</th><th>实例方法</th></tr></thead><tbody><tr><td>定义</td><td>使用 <code>static</code> 关键字</td><td>没有 <code>static</code> 关键字</td></tr><tr><td>调用方式</td><td>通过类名调用（例如 <code>ClassName.method()</code>）</td><td>通过对象实例调用（例如 <code>object.method()</code>）</td></tr><tr><td>访问类的成员</td><td>只能访问静态成员</td><td>可访问实例成员和静态成员</td></tr><tr><td>对象状态依赖</td><td>不依赖对象状态</td><td>依赖或可访问对象状态</td></tr><tr><td>典型用途</td><td>工具方法、计算方法、无需对象状态的操作</td><td>操作或访问对象的实例数据</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ul><li><strong>静态方法</strong>: 就像是大学的公共图书馆，所有学生（类的实例）都可以使用，但它不属于任何一个学生。</li><li><strong>实例方法</strong>: 就像学生的个人笔记本，每个学生都有自己的笔记本，可以在其中写下自己的笔记（实例数据），并且每个笔记本都是独一无二的。</li></ul><hr><blockquote><p>静态方法不能调用非静态成员</p></blockquote><p>主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</li></ol><h4 id="5-4-重载和重写"><a href="#5-4-重载和重写" class="headerlink" title="5.4 重载和重写"></a>5.4 重载和重写</h4><p>重载：（同一个类中的操作）</p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>重写：（子类对父类的操作）</p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><table><thead><tr><th>特性</th><th>重载 (Overloading)</th><th>重写 (Overriding)</th></tr></thead><tbody><tr><td>所在位置</td><td>同一个类中</td><td>子类中</td></tr><tr><td>方法名</td><td>必须相同</td><td>必须相同</td></tr><tr><td>参数列表</td><td>必须不同（数量、类型或顺序）</td><td>必须相同</td></tr><tr><td>返回类型</td><td>可以不同</td><td>必须与被重写的方法兼容</td></tr><tr><td>访问修饰符</td><td>可以不同</td><td>不能比父类方法更严格</td></tr><tr><td>抛出的异常</td><td>可以不同</td><td>不能抛出新的检查异常或更广泛的检查异常</td></tr><tr><td>实现目的</td><td>增加同一操作的灵活性</td><td>实现运行时多态，提供特定的实现</td></tr></tbody></table><h5 id="重载和重写-02"><a href="#重载和重写-02" class="headerlink" title="重载和重写_02"></a>重载和重写_02</h5><blockquote><p>重载和重写的区别</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 示例：重载和重写的区别</span><br><span class="hljs-keyword">class</span> <span class="hljs-title">ParentClass</span> &#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Parent display()&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title">ChildClass</span> <span class="hljs-title">extends</span> <span class="hljs-title">ParentClass</span> &#123;<br>    <span class="hljs-comment">// 方法重写</span><br>    @Override<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Child display()&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 方法重载</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span>(<span class="hljs-params">String message</span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Child display() with Message: &quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>重载（Overloading）</strong>:</p><ul><li>发生在同一个类中。</li><li>指的是一个类中有多个同名方法，但它们的参数列表不同（参数的数量、类型或者顺序不同）。</li><li>与方法的返回类型、访问修饰符无关。</li><li>编译时多态：方法调用是根据方法签名（方法名和参数列表）在编译时确定的。</li></ul><p><strong>重写（Overriding）</strong>:</p><ul><li>发生在父子类之间。</li><li>子类提供了一个具有相同名称、返回类型及参数列表的方法，用以重写（覆盖）父类中的相应方法。</li><li>访问权限不能比父类中被重写的方法更严格。</li><li>运行时多态：具体调用哪个方法是在运行时根据对象的实际类型确定的。</li><li>必须保持一致的异常声明（或不声明异常）。</li></ul><p>这两种机制是Java实现多态性的重要手段。重载允许同一个类中定义功能相似但参数不同的方法，而重写则允许子类改变或扩展从父类继承的行为.</p><blockquote><p>重载与方法的返回类型、访问修饰符无关</p></blockquote><p>在Java中，方法重载（Overloading）的定义是指在同一个类中可以存在多个同名方法，只要它们的参数列表不同即可。这里的“参数列表不同”可以是参数的数量、类型或者参数顺序的不同。</p><p>当提到“与方法的返回类型、访问修饰符无关”时，意思是：</p><ol><li><strong>返回类型无关</strong>:<ul><li>重载的方法可以有不同的返回类型。方法的返回类型不是重载考虑的因素。</li><li>比如，你可以有一个返回<code>void</code>的<code>display()</code>方法和一个返回<code>String</code>的<code>display(String message)</code>方法。</li></ul></li><li><strong>访问修饰符无关</strong>:<ul><li>重载的方法可以有不同的访问权限（如<code>public</code>、<code>private</code>等）。</li><li>重载仅仅关注于方法的名称和参数列表。</li></ul></li></ol><p>这意味着，当你重载一个方法时，你可以改变它的返回类型和访问修饰符，但这不会影响到重载的本质。重载完全是基于方法的参数列表的。重载提供了一种便利，使得你可以用同一个方法名来定义做相似事情但参数不同的方法。</p><h4 id="5-5-可变长参数"><a href="#5-5-可变长参数" class="headerlink" title="5.5 可变长参数"></a>5.5 可变长参数</h4><p>略</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/gre6gr">https://www.yuque.com/snailclimb/mf2z3k/gre6gr</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_Kafka_基础使用</title>
    <link href="/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Kafka 是什么</li><li>Kafka 的核心概念</li></ul><h3 id="1、Kafka-是什么"><a href="#1、Kafka-是什么" class="headerlink" title="1、Kafka 是什么"></a>1、Kafka 是什么</h3><p>略</p><h3 id="2、Kafka-的核心概念"><a href="#2、Kafka-的核心概念" class="headerlink" title="2、Kafka 的核心概念"></a>2、Kafka 的核心概念</h3><p>核心概念主要是： Producer、Consumer、Broker、Topic、Partition</p><p>有点类似 RocketMQ，毕竟RocketMQ 的设计之处是参考了部分 Kafka 的设计，其中 Kafka 是没有 Queue 这个概念的，主题 Topic 下面的实际存储数据采用的是 Partion 分区。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231230105605.png" alt="image.png"></p><hr><blockquote><p>kafka 和 Zookeeper 的关系</p></blockquote><p>在 Kafka 2.8 之前，Kafka 其重度依赖于 Zookeeper。</p><p>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，简化了 Kafka 的架构。</p><p>Zookeeper 的作用就是注册中心，作为节点的 Broker 的路由管理 和集群负载等功能</p><blockquote><p>kafka 和 RocketMQ 的区别</p></blockquote><p>可以看一下下面这个解释,  具体更深层次的理解建议从实际的代码程序方面入手去理解。</p><p>Kafka 和 RocketMQ 都是高性能的消息中间件，广泛用于处理大规模数据流和实现分布式系统中的消息传递。</p><p>尽管它们有许多相似之处，但也存在一些关键的区别。以下是 Kafka 和 RocketMQ 主要区别的概述：</p><blockquote><ol><li>设计架构</li></ol></blockquote><ul><li><strong>Kafka</strong>：最初由LinkedIn开发，重点放在高吞吐量和可扩展性上。Kafka 使用分区（Partition）和复制（Replication）的概念来保证消息的可靠性和可伸缩性。</li><li><strong>RocketMQ</strong>：最初由阿里巴巴开发，设计重点是提供更丰富的消息模型和服务质量。它采用了更复杂的存储和消息路由机制。</li></ul><blockquote><ol start="2"><li>存储机制</li></ol></blockquote><ul><li><strong>Kafka</strong>：采用分布式、可伸缩的日志存储机制。每个主题（Topic）分为多个分区，每个分区在物理上对应一个日志文件。</li><li><strong>RocketMQ</strong>：使用单一的 <code>CommitLog</code> 文件来存储所有主题的消息，然后通过 <code>ConsumeQueue</code> 和 <code>IndexFile</code> 来为消息提供索引和快速访问。</li></ul><blockquote><ol start="3"><li>消息消费模型</li></ol></blockquote><ul><li><strong>Kafka</strong>：主要支持发布-订阅模型，但也可以通过分区分配实现类似队列的消费模式。Kafka 强调消费者的概念，每个消费者负责跟踪自己的偏移量。</li><li><strong>RocketMQ</strong>：提供更多样的消息模型，包括发布-订阅、点对点消息、顺序消息和延时消息等。</li></ul><blockquote><ol start="4"><li>事务消息</li></ol></blockquote><ul><li><strong>Kafka</strong>：在较新版本中增加了对事务消息的支持，但实现相对简单。</li><li><strong>RocketMQ</strong>：提供了更为复杂和强大的事务消息支持。</li></ul><blockquote><ol start="5"><li>性能和可靠性</li></ol></blockquote><ul><li><strong>Kafka</strong>：以其高性能和高吞吐量而著称，特别是在处理大量数据时。</li><li><strong>RocketMQ</strong>：虽然也提供高性能处理，但在某些场景下可能不如Kafka高效，尤其是在单一CommitLog设计下。</li></ul><blockquote><ol start="6"><li>社区和生态</li></ol></blockquote><ul><li><strong>Kafka</strong>：有着广泛的社区支持和成熟的生态系统，是流数据处理和实时分析的首选。</li><li><strong>RocketMQ</strong>：在中国有较强的社区支持，特别是在阿里巴巴及其生态系统中得到广泛应用。</li></ul><p>选择Kafka还是RocketMQ，取决于具体的应用场景和需求。</p><p>如果需要处理大规模的数据流，特别是在数据分析和流处理方面，Kafka可能是更好的选择。而如果需要更复杂的消息类型和服务质量，或者对事务消息有更高的要求，RocketMQ可能更适合。在实际选择时，还需要考虑团队的技术栈兼容性和具体的业务需求。</p><h3 id="3、Kafka-消费顺序、消息丢失和重复消费"><a href="#3、Kafka-消费顺序、消息丢失和重复消费" class="headerlink" title="3、Kafka 消费顺序、消息丢失和重复消费"></a>3、Kafka 消费顺序、消息丢失和重复消费</h3><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html">https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RabbitMQ_基础使用</title>
    <link href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>RabbitMQ是什么</li><li>RabbitMQ的组成部分</li><li>RabbitMQ 的工作流程</li><li>RabbitMQ广播和直接模式示例</li></ul><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。</p><p>MQ 的核心作用：削峰、解耦、异步</p><h3 id="1、RabbitMQ是什么"><a href="#1、RabbitMQ是什么" class="headerlink" title="1、RabbitMQ是什么"></a>1、RabbitMQ是什么</h3><p>建议直接去官网看一下相关概念： <a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></p><blockquote><p>RabbitMQ的特点</p></blockquote><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。</p><p>特点</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><blockquote><p>安装和使用</p></blockquote><ul><li><ol><li>安装 erlang 环境</li></ol></li><li><ol start="2"><li>安装RabbitMQ服务端</li></ol></li></ul><h3 id="2、RabbitMQ的组成部分"><a href="#2、RabbitMQ的组成部分" class="headerlink" title="2、RabbitMQ的组成部分"></a>2、RabbitMQ的组成部分</h3><p>核心概念</p><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。<ul><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li></ul></li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>大概流程：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121056722.png" alt="image.png"></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和 routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">生产者</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消息</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">交换机</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">路由</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">队列</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消费</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">消费者</span><br>    <span class="hljs-comment">\                                         /</span><br>     <span class="hljs-comment">\</span><span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">通道 Channel</span><span class="hljs-title">]</span><span class="hljs-literal">-----------------------</span><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><p>通道的概念：</p><ul><li><strong>定义</strong>：通道是建立在实际的 TCP 连接内的一个轻量级连接。它是执行大多数操作（如消息发布或消息接收）的路径。</li><li><strong>作用</strong>：通道是多路复用连接中的一个独立路径，允许多个通道共享一个 TCP 连接，而不必为每个通道建立物理连接。这提高了资源利用率和通信效率</li><li>生产者使用通道来发送消息到交换机，而消费者使用通道从队列中接收消息。通道作为消息传输的通道，连接了生产者、交换机和消费者。</li></ul><p>通道是作为消息传递的载体贯穿整个过程。</p><p>to be contined….</p><h3 id="3、RabbitMQ-的工作流程"><a href="#3、RabbitMQ-的工作流程" class="headerlink" title="3、RabbitMQ 的工作流程"></a>3、RabbitMQ 的工作流程</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>建立连接</li><li>生产者<ul><li>声明交换机类型、名称、是否持久化等</li><li>发送消息</li></ul></li><li>交换机<ul><li>交换机接收消息，进行消息路由</li></ul></li><li>消费者<ul><li>订阅消息（监听队列）</li><li>接收消息，业务处理</li></ul></li></ul><blockquote><ol><li>消息生产者与 RabbitMQ Broker 建立连接</li></ol></blockquote><ul><li><strong>建立连接（Connection）</strong>：消息生产者（Producer）首先与 RabbitMQ Broker 建立连接。这个连接是一个比较重的操作，通常是长连接，并在多个消息发送过程中复用。</li><li><strong>开启通道（Channel）</strong>：一旦连接建立，生产者开启一个或多个通道（Channel）。通道是轻量级的，用于执行实际的消息发送和接收操作。在 RabbitMQ 中，所有的消息传输都是通过通道完成的。</li></ul><blockquote><ol start="2"><li>生产者声明交换机</li></ol></blockquote><ul><li><strong>声明交换机（Exchange）</strong>：生产者需要声明一个交换机，并指定它的类型（如 direct, topic, fanout, headers）和名称。生产者还可以设置交换机的其他属性，如是否持久化。持久化的交换机可以在 Broker 重启后依然存在。</li></ul><blockquote><ol start="3"><li>生产者发送消息</li></ol></blockquote><ul><li><strong>发送消息</strong>：生产者向指定的交换机发送消息。发送时，生产者还可以指定消息的各种属性，如是否持久化消息体，设置消息优先级等。</li><li><strong>指定 Routing Key</strong>：发送消息时，生产者需要指定一个 <code>routing key</code>。这个 <code>routing key</code> 用于决定消息如何路由到队列。</li></ul><blockquote><ol start="4"><li>交换机处理消息</li></ol></blockquote><ul><li><strong>接收消息</strong>：交换机接收到生产者发送的消息后，开始根据交换机类型和 <code>routing key</code> 进行消息路由。</li><li><strong>路由到队列</strong>：交换机根据 <code>routing key</code> 和交换机类型将消息路由到一个或多个绑定的队列中。例如，在 direct 类型的交换机中，消息会路由到 <code>routing key</code> 完全匹配的队列。</li></ul><blockquote><ol start="5"><li>消费者处理消息</li></ol></blockquote><ul><li><strong>监听队列</strong>：消费者（Consumer）监听一个或多个队列，等待消息的到来。</li><li><strong>接收消息</strong>：一旦有消息到达队列，消费者就会接收到这个消息。</li><li><strong>业务处理</strong>：消费者获取消息后，开始进行相应的业务处理。</li></ul><p>在整个过程中，RabbitMQ 通过交换机和队列的机制提供了强大的消息路由能力。</p><p>交换机决定了消息如何根据 <code>routing key</code> 被路由到不同的队列，而消费者从队列中获取消息进行处理。这种机制支持了高度的解耦和灵活的消息处理策略，适用于各种复杂的消息处理场景。</p><h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><p>RabbitMQ 中最常用的几种交换机类型及其区别：</p><blockquote><ol><li>Direct Exchange（直接交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到那些 <code>binding key</code> 与消息的 <code>routing key</code> 完全匹配的队列。</li><li><strong>用途</strong>：非常适合单播（unicast）或多播（multicast）路由场景，即一对一或一对多发送。</li></ul><blockquote><ol start="2"><li>Fanout Exchange（扇出交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到所有与该交换机绑定的队列，忽略 <code>routing key</code>。</li><li><strong>用途</strong>：非常适合广播消息，如日志系统，其中消息需要被发送到多个目的地。</li></ul><blockquote><ol start="3"><li>Topic Exchange（主题交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：可以根据模式匹配 <code>routing keys</code> 和 <code>binding keys</code>（模式中可以包含通配符）。<code>routing key</code> 为点分隔的一系列单词，<code>binding key</code> 中可以包含特殊字符 <code>*</code> 和 <code>#</code> 来进行模式匹配，其中 <code>*</code> 匹配一个单词，<code>#</code> 匹配零个或多个单词。</li><li><strong>用途</strong>：适用于同时需要单播和多播路由逻辑的复杂路由配置。</li></ul><blockquote><ol start="4"><li>Headers Exchange（头部交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：基于消息头部（headers）中的属性进行匹配。不依赖 <code>routing key</code>。匹配规则可以是“所有”（<code>x-match=all</code>，即所有头部属性必须匹配）或“任何”（<code>x-match=any</code>，即任意头部属性匹配）。</li><li><strong>用途</strong>：适用于需要根据多个属性进行路由决策的高级路由策略。</li></ul><blockquote><p>总结</p></blockquote><p>选择哪种交换机类型主要取决于你的具体应用场景和消息路由需求。</p><p>直接交换机适合简单的单播路由，扇出交换机适合广播，主题交换机适合复杂的路由场景，而头部交换机适合基于多属性的路由决策。了解这些交换机的特点可以帮助你更好地设计消息路由策略，并充分利用 RabbitMQ 的强大功能。</p><p>RabbitMQ 的处理流程是围绕着连接、交换机、消息发送和消息接收这几个核心环节展开的。</p><h4 id="路由键（Routing-Key）的作用"><a href="#路由键（Routing-Key）的作用" class="headerlink" title="路由键（Routing Key）的作用"></a>路由键（Routing Key）的作用</h4><p>路由键是消息发布到 RabbitMQ 时<strong>附带的一个字符串标识</strong>，它的作用是帮助交换机决定如何路由消息。</p><p>这里的“路由”指的是决定消息应该被发送到哪一个或哪些队列。路由键的具体作用取决于交换机的类型：</p><ol><li><strong>Direct Exchange</strong>：交换机会将消息路由到那些 <code>binding key</code> 与 <code>routing key</code> 完全匹配的队列。</li><li><strong>Topic Exchange</strong>：可以进行模式匹配，交换机会根据 <code>routing key</code> 和队列的 <code>binding key</code>（可以包含通配符）进行匹配。</li><li><strong>Fanout Exchange</strong>：忽略路由键，消息会被发送到所有绑定到该交换机的队列。</li><li><strong>Headers Exchange</strong>：不依赖路由键，而是根据发送的消息头部中的键值对进行匹配。</li></ol><h4 id="交换机与消费者之间的协同"><a href="#交换机与消费者之间的协同" class="headerlink" title="交换机与消费者之间的协同"></a>交换机与消费者之间的协同</h4><p>交换机不直接与消费者通信来决定向哪个消费者发送消息。</p><p>相反，它依赖于队列和队列与消费者之间的关系来实现消息的分发。下面是它们是如何协同工作的：</p><ol><li><p><strong>队列绑定到交换机</strong>：队列通过 <code>binding key</code>（在 fanout 和 headers 交换机中，这个 <code>binding key</code> 不一定被使用）绑定到交换机。这个过程决定了哪些消息会被路由到特定的队列。</p></li><li><p><strong>消费者监听队列</strong>：消费者通过打开一个通道并订阅（或监听）一个或多个队列来接收消息。这意味着消费者告诉 RabbitMQ：“我对这个队列中的消息感兴趣，请将它们发送给我。”</p></li><li><p><strong>消息分发</strong>：当消息通过交换机被路由到队列后，RabbitMQ 会将队列中的消息发送给订阅该队列的消费者。这个分发过程可能是基于不同的策略，如轮询或公平调度等。</p></li></ol><h4 id="消费者的监听"><a href="#消费者的监听" class="headerlink" title="消费者的监听"></a>消费者的监听</h4><p>当我们说消费者“监听”一个队列时，实际上是指消费者开启了一个持续的、异步的过程，这个过程会等待、接收并处理来自队列的消息。</p><p>消费者通过通道向 RabbitMQ 注册其对特定队列的兴趣。一旦队列中有消息，RabbitMQ 就会将消息推送给消费者。消费者接收到消息后，会根据自己的逻辑进行处理。</p><p>消费者通过监听队列来接收消息，交换机本身并不决定消息发送给哪个消费者，这是由队列中的消息与消费者之间的关系决定的。<strong>消费者监听意味着它们准备好接收和处理从队列中来的消息。</strong></p><h3 id="4、RabbitMQ广播和直接模式示例"><a href="#4、RabbitMQ广播和直接模式示例" class="headerlink" title="4、RabbitMQ广播和直接模式示例"></a>4、RabbitMQ广播和直接模式示例</h3><p>项目参考： <a href="https://gitee.com/yidao620/springboot-bucket">https://gitee.com/yidao620/springboot-bucket</a></p><p>这个项目的最后更新时间是五年前， 这里建议单独打开一下 springboot-rabbitmq</p><p>本地的 maven 版本是 3.5.2 , springboot-rabbitmq 依赖中的 maven-compiler-plugin 改为了 3.6.1 后没有报错</p><p>在 SpringBoot 中，使用消息队列需要引入 amqp 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yml 配置内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>  <br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>  <br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>在这个项目中，定义了一个配置类 RabbitConfig</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package com.xncoding.pos.config;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RabbitConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @version 1.0</span><br><span class="hljs-comment"> * @since 2018/3/1</span><br><span class="hljs-comment"> */</span><br>@Configuration<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br>    @Resource<br>    private RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定制化 AMQP 模版。</span><br><span class="hljs-comment">     * 设置消息转换器、编码、消息确认和返回回调。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return the amqp template</span><br><span class="hljs-comment">     */</span><br>    @Bean<br>    public AmqpTemplate amqpTemplate() &#123;<br>        Logger log = LoggerFactory.getLogger(RabbitTemplate.<span class="hljs-keyword">class</span>);<br><br>        <span class="hljs-regexp">// 使用 Jackson 作为消息转换器，自动将消息转换为 JSON 格式</span><br><span class="hljs-regexp">        rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 设置字符编码为 UTF-<span class="hljs-number">8</span><br>        rabbitTemplate.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>        <span class="hljs-regexp">// 消息发送失败时返回到队列，需要在配置文件中设置 publisher-returns: true</span><br><span class="hljs-regexp">        rabbitTemplate.setMandatory(true);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 定义消息发送失败的回调<br>        rabbitTemplate.setReturnCallback<span class="hljs-function"><span class="hljs-params">((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">String</span> correlationId = message.getMessageProperties().getCorrelationIdString();</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;消息：&#123;&#125; 发送失败, 应答码：&#123;&#125; 原因：&#123;&#125; 交换机: &#123;&#125;  路由键: &#123;&#125;&quot;</span>, correlationId, replyCode, replyText, exchange, routingKey);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        // 定义消息发送到交换机确认回调，需要在配置文件中设置 <span class="hljs-title">publisher-confirms</span>: <span class="hljs-title">true</span></span><br><span class="hljs-function">        <span class="hljs-title">rabbitTemplate</span>.<span class="hljs-title">setConfirmCallback</span><span class="hljs-params">((correlationData, ack, cause) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span> (ack) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange成功,id: &#123;&#125;&quot;</span>, correlationData.getId());</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange失败,原因: &#123;&#125;&quot;</span>, cause);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">rabbitTemplate</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Direct</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Direct</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Exchange</span> <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Direct</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">directExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directQueue&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">directQueue</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_QUEUE&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列绑定到交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>    <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">exchange</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">directBinding</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;directQueue&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 @Qualifier(<span class="hljs-string">&quot;directExchange&quot;</span>) Exchange exchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列绑定到交换机，使用路由键 &quot;<span class="hljs-title">DIRECT_ROUTING_KEY</span>&quot;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(exchange)</span>.<span class="hljs-title">with</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>)</span>.<span class="hljs-title">noargs</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Fanout</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">FanoutExchange</span> <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(FanoutExchange)</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">fanoutExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">A</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueA</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">A</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_A&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">B</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueB</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">B</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_B&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingA</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingB</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这个 <code>RabbitConfig</code> 配置类通过 <code>@Bean</code> 注解声明了多个 Spring Bean，用于设置 RabbitMQ 的不同组件。</p><p>它涵盖了消息模板的定制、交换机和队列的声明，以及队列与交换机的绑定。</p><p>这样的配置提供了灵活的方式来定义消息传递的行为，包括消息格式、路由策略和队列管理，适用于不同的消息处理需求。</p><p>通过这种方式，可以在 Spring 应用中轻松地使用 RabbitMQ 进行高效的消息通信。</p><hr><p>通过广播方式发送消息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送广播模式的消息。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> p</span>) &#123;<br>    <span class="hljs-comment">// 创建 CorrelationData 对象，带有一个唯一的标识符。</span><br>    <span class="hljs-comment">// 这个标识符用于消息确认过程中识别消息。</span><br>    <span class="hljs-title class_">CorrelationData</span> correlationData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>().<span class="hljs-title function_">toString</span>());<br><br>    <span class="hljs-comment">// 使用 RabbitTemplate 将消息发送到指定的交换机。</span><br>    <span class="hljs-comment">// 参数1: 交换机名称 - 这里是 &quot;FANOUT_EXCHANGE&quot;。</span><br>    <span class="hljs-comment">// 参数2: 路由键 - 在 Fanout 交换机中，路由键会被忽略，所以这里传递一个空字符串。</span><br>    <span class="hljs-comment">// 参数3: 消息内容 - 这里是传入的参数 p。</span><br>    <span class="hljs-comment">// 参数4: CorrelationData - 包含消息的唯一标识符，用于消息跟踪和确认。</span><br>    rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的配置类中，是声明了 Fanout 交换机， 并且绑定两个队列在这个交换机上。</p><h4 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.service;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.support.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-built_in">this</span>.getClass());<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试广播模式.</span><br><span class="hljs-comment">     * 在广播模式下，消息会被发送到所有绑定到交换机的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcast</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 FANOUT_EXCHANGE 交换机，路由键为空字符串</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试Direct模式.</span><br><span class="hljs-comment">     * 在Direct模式下，消息会被路由到具有指定路由键的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">direct</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 DIRECT_EXCHANGE 交换机，并指定路由键</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>, p, correlationData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.mq;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息监听器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Receiver.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听一.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_A 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_A&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_A &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听二.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_B 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_B&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_B &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * DIRECT模式.</span><br><span class="hljs-comment">     * 在 DIRECT_QUEUE 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;DIRECT_QUEUE&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;DIRECT &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在生产者类（<code>SenderService</code>）中，两个方法分别演示了如何在广播（Fanout）和直接（Direct）模式下发送消息。</li><li>在消费者类（<code>Receiver</code>）中，每个方法都使用了 <code>@RabbitListener</code> 注解来监听特定的队列，并在接收到消息后执行相应的处理逻辑。</li></ul><p>这里由于你配置了接收的监听，因此当你发送的时候你就收到了这条消息，并且通过日志的方式打印了出来，如果需要比较明显一点的观察现象，可以加一个等待时间确保被消费。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 等待一段时间以确保消息被消费 </span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="主题交换机（Topic-Exchange）的使用示例"><a href="#主题交换机（Topic-Exchange）的使用示例" class="headerlink" title="主题交换机（Topic Exchange）的使用示例"></a>主题交换机（Topic Exchange）的使用示例</h4><p>Topic Exchange 直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。</p><p>这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”* “ 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。<br><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121409207.png" alt="image.png"></p><blockquote><p>使用示例</p></blockquote><p>在前文的基础上，新增一些内容</p><p>配置类(更新配置类以包含一个主题交换机和两个队列，以及它们的绑定)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他配置 ...</span><br><br>    <span class="hljs-comment">// Topic Exchange 配置</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TopicExchange</span> <span class="hljs-title function_">topicExchange</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicExchange</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueOneWord</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueMultipleWords</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.*&quot; 只匹配一个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicOneWord</span>(<span class="hljs-params">Queue topicQueueOneWord, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueOneWord).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.#&quot; 匹配零个或多个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicMultipleWords</span>(<span class="hljs-params">Queue topicQueueMultipleWords, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueMultipleWords).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.#&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RabbitTemplate</span> rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到主题交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendToTopic</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> routingKey, <span class="hljs-built_in">String</span> message</span>) &#123;<br>        rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>, routingKey, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Logger</span> log = <span class="hljs-title class_">LoggerFactory</span>.<span class="hljs-title function_">getLogger</span>(<span class="hljs-title class_">Receiver</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicOneWord</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_ONE_WORD: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicMultipleWords</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_MULTIPLE_WORDS: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类(发送消息并验证它们被正确路由到对应的队列：)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// ... 其他测试 ...</span><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SenderService senderService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testTopicExchange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.*&quot;，应该只被 TOPIC_QUEUE_ONE_WORD 接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one&quot;</span>, <span class="hljs-string">&quot;Message for topic.one&quot;</span>);<br><br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.#&quot;，应该被两个队列接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one.two&quot;</span>, <span class="hljs-string">&quot;Message for topic.one.two&quot;</span>);<br><br>        <span class="hljs-comment">// 等待一段时间以确保消息被消费</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个测试消息使用路由键 “topic.one”，它符合 <code>*</code> 的匹配规则（匹配一个单词），因此只有 “TOPIC_QUEUE_ONE_WORD” 队列接收到这个消息。</li><li>第二个测试消息使用路由键 “topic.one.two”，它符合 <code>#</code> 的匹配规则（匹配多个单词），因此两个队列都接收到这个消息。</li></ul><p>运行测试后，通过日志输出可以验证这些匹配规则是否按预期工作。</p><blockquote><p>小结</p></blockquote><p>在 RabbitMQ中比较常用的三种模式是：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。</p><p>熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>通配符(TopicExchange)这种模式也可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一些。</p><hr><p>参考</p><ul><li><a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li><a href="https://developer.aliyun.com/article/769883">https://developer.aliyun.com/article/769883</a></li><li><a href="https://blog.csdn.net/CherryChenieth/article/details/124767155">https://blog.csdn.net/CherryChenieth/article/details/124767155</a></li><li><a href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RocketMQ_基础使用</title>
    <link href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>RocketMQ是什么</li><li>队列模型和主题模型</li><li>RocketMQ架构设计</li><li>RocketMQ 的功能特性</li><li>如何解决顺序消费和重复消费</li><li>RocketMQ 如何实现分布式事务</li><li>如何解决消息堆积问题？</li><li>回溯消费</li><li>RocketMQ 如何保证高性能读写</li><li>RocketMQ 的刷盘机制</li><li>RocketMQ 如何保证不丢失消息</li></ul><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>消息队列能用来干什么</p><ul><li>异步</li><li>解耦</li><li>削峰</li></ul><p>在引入消息队列时，同时意味着会给系统带来一系列的副作用和挑战，这些问题需要在设计和实施过程中予以特别考虑。</p><p>关键点和风险：</p><ul><li><ol><li>降低系统的可用性</li></ol></li><li><ol start="2"><li>增加系统的复杂度</li></ol></li><li><ol start="3"><li>如何解决重复消费消息的问题</li></ol></li><li><ol start="4"><li>如何解决消息的顺序消费问题</li></ol></li><li><ol start="5"><li>解决分布式事务问题</li></ol></li><li><ol start="6"><li>解决消息堆积的问题</li></ol></li></ul><h3 id="1、RocketMQ是什么"><a href="#1、RocketMQ是什么" class="headerlink" title="1、RocketMQ是什么"></a>1、RocketMQ是什么</h3><p>RocketMQ 是一款开源的分布式消息和流处理平台，由阿里巴巴集团开发并贡献给 Apache 软件基金会。它被设计用于处理大规模、高吞吐量的消息传递，并在阿里巴巴集团内部及众多企业中广泛使用。</p><p>特点：高性能，高可靠，高实时，分布式</p><h3 id="2、队列模型和主题模型"><a href="#2、队列模型和主题模型" class="headerlink" title="2、队列模型和主题模型"></a>2、队列模型和主题模型</h3><p>了解 RocketMQ 前，我们先了解下面两个名词概念：队列模型和主题模型</p><h4 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h4><ul><li>队列模型<ul><li>队列方式，生产者消费者</li></ul></li><li>主题模型&#x2F;发布订阅<ul><li>发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。<img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231220201308.png" alt="image.png|500"></li></ul></li></ul><h4 id="RocketMQ中的消息模型"><a href="#RocketMQ中的消息模型" class="headerlink" title="RocketMQ中的消息模型"></a>RocketMQ中的消息模型</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>`RocketMQ` 中的消息模型是按照 主题模型 所实现的</strong></div><p>RocketMQ 实现的消息传递模型遵循了主题模型（也称为发布&#x2F;订阅模型）这一标准。</p><p>主题模型是消息中间件中的一种设计模式，它定义了如何进行消息的发布和订阅。在这种模型中，消息生产者（发布者）发送消息到一个主题（Topic），而消息消费者（订阅者）订阅这个主题并接收相应的消息。</p><blockquote><p>核心概念理解：</p></blockquote><ul><li><strong>主题模型（Topic Model）</strong>：<ul><li>它是一种发布&#x2F;订阅消息传递的架构模式。</li><li>消息生产者发布消息到主题，而不是直接发送给特定的消费者。</li><li>消息消费者订阅主题来接收消息，而不是从特定生产者接收。</li></ul></li><li><strong>发布&#x2F;订阅模型（Pub&#x2F;Sub Model）</strong>：<ul><li>这是主题模型的另一种叫法，强调的是消息的发布和订阅机制。</li><li>任何订阅了主题的消费者都能接收到主题中的消息，实现了生产者和消费者的解耦。</li></ul></li></ul><h4 id="RocketMQ-的主题模型如何实现"><a href="#RocketMQ-的主题模型如何实现" class="headerlink" title="RocketMQ 的主题模型如何实现"></a>RocketMQ 的主题模型如何实现</h4><p>在 RocketMQ 中，这种模型是通过多个队列（Queue）来实现的，每个队列相当于 Kafka 中的分区或 RabbitMQ 中的 Exchange。</p><p>具体实现看下一章的架构设计。</p><h3 id="3、RocketMQ架构设计"><a href="#3、RocketMQ架构设计" class="headerlink" title="3、RocketMQ架构设计"></a>3、RocketMQ架构设计</h3><p>先了解一下，在 RocketMQ 中，他的一些基础角色。</p><h4 id="基础角色"><a href="#基础角色" class="headerlink" title="基础角色"></a>基础角色</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231226214425.png" alt="image.png"></p><p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code></p><ul><li><code>NameServer</code><ul><li>注册中心，提供 <code>Broker</code>管理和路由信息管理</li><li>操作步骤<ul><li><ol><li><code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中（此时，<code>NameServer</code> 会存放很多 <code>Broker</code> 的信息  ←  Broker 的路由表信息）</li></ol></li><li><ol start="2"><li>消费者和生产者从 <code>NameServer</code> 获取路由表信息和对应的  <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)</li></ol></li></ul></li><li>多个 NameServer 形成集群，但它们之间不同步信息。客户端（Producer 和 Consumer）可以连接任意一个 NameServer</li></ul></li><li><code>Broker</code><ul><li>消息队列服务器，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</li><li>Broker 可以是 Master 也可以是 Slave。<ul><li>每个 Master 可以有多个 Slave。Master 负责读写消息，Slave 可以进行消息的同步，保证数据的高可用性。</li></ul></li><li>Broker 是消息存储和转发的核心。生产者将消息发送到 Broker，Broker 负责将消息保存在相应的队列中。</li><li>Broker 处理所有与消息相关的操作，包括消息的存储、检索、删除以及向消费者分发消息。</li><li>Broker 负责维护每个队列的状态，如消息偏移量（Offset），确保消息能够被正确地消费。</li></ul></li><li><code>Producer</code><ul><li>生产者</li></ul></li><li><code>Consumer</code><ul><li>消费者</li><li>消费者向 Broker 订阅特定的 Topic。这个过程会涉及 NameServer 来找到托管该 Topic 的 Broker。</li><li>一旦 Broker 中的 Topic 收到消息，符合条件的消费者（那些订阅了该 Topic 的消费者）就可以接收到这些消息。</li><li><strong>消费模式</strong>：<ul><li>在集群消费模式下，每条消息只会被消费者组中的一个消费者处理。</li><li>在广播消费模式下，每条消息会被发送到消费者组中的所有消费者。</li></ul></li></ul></li></ul><h4 id="消息处理-😀"><a href="#消息处理-😀" class="headerlink" title="消息处理 😀"></a>消息处理 😀</h4><p>生产消息和消费消息操作：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312271701523.png" alt="image.png"></p><p>讲述一下在 RocketMQ 中，生产者组发送消息以及消费者组是如何接受消息的。</p><p>在RocketMQ 中，NameServer 负责服务发现和路由管理，当生产者组发送某一个主题的消息时候，Producer Groups 会先从 NameServer 获取到 Topic 主题消息 所在的 Broker 信息，根据这些信息，生产者组会发送消息到正确的 Broker 和 对应的队列中。</p><p>里面的一个核心观点是 Topic ，个人理解主题Topic 是 将Queue进行分类，类似分组、标签（逻辑上）</p><p>而 Queue 的实际作用是 物理实际分区，消息的实际存储地方；消息发送到正确的 Broker 后，Broker 会负责将消息<strong>保存在</strong>相应的队列中。</p><p>Consumer Groups 会从NameServer 查询 Broker 的信息（从 NameServer 来找到托管该 Topic 的 Broker），订阅对应主题的消息，当 一旦 Broker 中的 Topic 收到消息，就可以接收到对应消息。</p><hr><p>一些常用的操作和概念也需要理解下。</p><p>当某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p><p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p><blockquote><p>通常建议消费者组中的消费者数量与主题中的队列数量保持一致</p></blockquote><ul><li>这样做的目的是为了最大化并行处理的效率。</li><li><strong>原因</strong>：如果消费者的数量多于队列的数量，那么会有一些消费者实际上没有分配到队列，从而闲置。相反，如果消费者的数量少于队列的数量，某些队列可能不会被及时消费，导致消息积压。</li></ul><blockquote><p><strong>每个消费组在每个队列上维护一个消费位置</strong> </p></blockquote><ul><li><strong>Offset 的作用</strong>：消费位移是指消费者在队列中消费到的位置。它用于跟踪消费者已经消费到哪里，以便在消费者重启或故障后能够从上次的位置继续消费。</li><li><strong>谁来维护</strong>：这个位移是由 Broker 维护的。消费者在处理完消息后，会向 Broker 报告自己的消费位移。</li><li><strong>消息的保留</strong>：队列中的消息通常会在所有消费者组消费之后才会被删除。这意味着，只要有一个消费者组还没有消费某条消息，这条消息就会被保留在队列中。</li></ul><blockquote><p>消息的存储和删除</p></blockquote><ul><li><strong>数据的持久化</strong>：Broker 负责消息的存储。只要消息还没有被所有订阅的消费者组消费，它就会一直存储在 Broker 中。</li><li><strong>消息的删除</strong>：消息通常在满足一定条件后才会被删除，例如，当所有消费者组都消费了该消息，或者消息达到了其存储的最大时间（如设置了消息的存储时长）。</li></ul><blockquote><p>为什么一个主题中需要维护多个队列？</p></blockquote><ol><li><strong>提高并发能力</strong>：在一个主题下配置多个队列的目的是为了提高消息处理的并发能力。这允许多个生产者同时向不同的队列发送消息，同时也允许多个消费者并行地从不同队列中拉取和处理消息。</li><li><strong>负载均衡和效率</strong>：如果一个主题只有一个队列，那么所有的消息都会被顺序地放入这个单一的队列中，这限制了并行处理的可能性。在这种情况下，即使有多个消费者，也只能有一个消费者在任何给定时间处理队列中的消息，从而降低了整体的处理效率。</li></ol><h4 id="RocketMQ-的高可用"><a href="#RocketMQ-的高可用" class="headerlink" title="RocketMQ 的高可用"></a>RocketMQ 的高可用</h4><p>高可用情景下，会构建 <code>broker</code>  集群并且进行主从部署，同时<code>NameServer</code> 也进行集群部署。</p><p>官网架构图</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312211545167.png" alt="image.png"></p><p>第一，构建 <code>broker</code>  集群并且进行主从部署，此时，消息会分布在多个  <code>broker</code> </p><p>当某个 <code>Broker</code> 宕机，在<code>Rocketmq</code> 的 <code>master/slave</code> 结构下，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，则 <code>slave</code> 提供消费服务，但是不能写入消息</p><p>第二， <code>NameServer</code> 进行了集群部署（ <strong>去中心化</strong> 的，没有主节点）；</p><p><code>Broker 会和所有 NameServer 保持长连接 ，并且在每隔 30 秒 </code>Broker<code>会向所有</code>Nameserver<code>发送心跳，心跳包含了自身的</code>Topic<code>配置信息，这个步骤就对应图中的</code>Routing Info&#96;</p><p>第三，在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p><p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。</p><p><code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p><h3 id="4、RocketMQ-的功能特性"><a href="#4、RocketMQ-的功能特性" class="headerlink" title="4、RocketMQ 的功能特性"></a>4、RocketMQ 的功能特性</h3><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>在 RocketMQ 中，一般使用的是普通消息，还有定时消息、顺序消息、事务消息；下面我们分别来了解一下具体的一些使用。</p><blockquote><p>普通消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于大多数标准的消息传递需求，如异步处理、系统解耦、数据分发等。</li><li><strong>使用</strong>：生产者发送消息到指定的主题（Topic），消费者从主题订阅并处理这些消息。消息按照到达 Broker 的顺序存储。</li></ul><p><strong>普通消息生命周期</strong></p><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><blockquote><p>定时消息</p></blockquote><ul><li><strong>业务场景</strong>：用于那些需要在指定时间点执行的任务，如延迟通知、定时任务等。</li><li><strong>使用</strong>：生产者发送消息时指定一个延时级别，消息将在指定的延时后才被投递。RocketMQ 不支持任意的延时时间，而是提供了几个预设的延时级别（如1分钟、5分钟、10分钟等）。</li></ul><p><strong>定时消息生命周期</strong></p><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息<strong>单独存储在定时存储系统中</strong>，等待定时时刻到达。</li><li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><p>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p><blockquote><p>顺序消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于严格要求消息顺序的场景，如股票价格更新、订单状态变更等，这些场景中消息的处理顺序会影响到业务逻辑的正确性。</li><li><strong>使用</strong>：生产者在发送消息时，将消息分配到特定的队列。消费者从队列中按顺序消费消息。RocketMQ 通过固定的映射关系（如订单号的散列值）来保证相同类型的消息被路由到同一队列。</li></ul><p>顺序消息仅支持使用 MessageType 为 FIFO 的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。</p><p>和普通消息发送相比，顺序消息发送必须要设置消息组。（推荐实现 MessageQueueSelector 的方式）。要保证消息的顺序性需要单一生产者串行发送。</p><p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p><blockquote><p>事务消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于需要保证消息发送和本地事务同时成功或失败的场景，如支付和订单服务间的交互。</li><li><strong>使用</strong>：<ul><li>生产者发送半消息（预备消息）。</li><li>执行本地事务（比如数据库操作）。</li><li>根据本地事务执行结果，提交或回滚消息。提交的消息将被消费者消费，回滚的消息将被删除。</li></ul></li></ul><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><ul><li>不建议单一进程创建大量生产者<ul><li>对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则</li></ul></li><li>不建议频繁创建和销毁生产者</li></ul><blockquote><p>创建和销毁生产者</p></blockquote><p>正确示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Producer p <span class="hljs-operator">=</span> ProducerBuilder.build()<span class="hljs-comment">;</span><br>for (int i <span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;i&lt;n;i++)&#123;</span><br>    Message m<span class="hljs-operator">=</span> MessageBuilder.build()<span class="hljs-comment">;</span><br>    p.send(m)<span class="hljs-comment">;</span><br> &#125;<br>p.shutdown()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="消费者分组-🦌"><a href="#消费者分组-🦌" class="headerlink" title="消费者分组  🦌"></a>消费者分组  🦌</h4><ul><li>PushConsumer</li><li>SimpleConsumer</li><li>PullConsumer</li></ul><h4 id="生产者分组和消费者分组"><a href="#生产者分组和消费者分组" class="headerlink" title="生产者分组和消费者分组"></a>生产者分组和消费者分组</h4><blockquote><p>生产者分组</p></blockquote><ol><li><strong>RocketMQ 5.x 版本及以后</strong>：<ul><li>生产者现在是“匿名”的，即不再强调生产者分组（ProducerGroup）的概念。</li><li>在服务端，生产者不需要显式地配置为特定的分组，这简化了生产者的管理。</li></ul></li><li><strong>RocketMQ 3.x 和 4.x 版本</strong>：<ul><li>在这些历史版本中，生产者分组是一个重要的概念，用于标识和管理一组有着相同行为的生产者。</li><li>如果你是从这些旧版本升级到 5.x，那么之前使用的生产者分组可以废弃，不再需要设置，且不会影响当前业务。</li></ul></li></ol><blockquote><p>消费者分组</p></blockquote><ol><li><strong>概念</strong>：<ul><li>消费者分组是多个消费者的一个逻辑分组，这些消费者有着一致的消费行为。</li><li>通过消费者分组，可以实现消费行为的负载均衡和高可用性。</li></ul></li><li><strong>功能</strong>：<ul><li><strong>订阅关系管理</strong>：RocketMQ 以消费者分组的粒度来管理和追溯订阅关系。</li><li><strong>投递顺序性</strong>：服务端支持顺序投递和并发投递，这些投递方式在消费者分组中统一配置。</li><li><strong>消费重试策略</strong>：包括重试次数和死信队列的设置，用于处理消费失败的情况。</li></ul></li><li><strong>版本差异</strong>：<ul><li><strong>5.x 版本</strong>：消费者的消费行为统一由关联的消费者分组在服务端配置和管理，确保同一分组内所有消费者的行为一致。</li><li><strong>3.x&#x2F;4.x 历史版本</strong>：消费行为由消费者客户端接口定义，需要在消费者客户端设置时确保同一分组下的消费者行为一致。</li></ul></li></ol><p>RocketMQ 5.x 版本中对生产者分组的概念进行了简化，使其成为匿名的，而消费者分组则仍然是一个关键概念，用于管理消费者的行为和策略。</p><h3 id="5、如何解决顺序消费和重复消费"><a href="#5、如何解决顺序消费和重复消费" class="headerlink" title="5、如何解决顺序消费和重复消费"></a>5、如何解决顺序消费和重复消费</h3><h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><p>根据上文的架构设计中，我们可以知道<code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序的。</p><p>讲述顺序消费一般会设计两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p><ul><li>普通顺序<ul><li>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</li></ul></li><li>严格顺序<ul><li>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</li></ul></li></ul><p>在严格顺序这种模式下，实现的成本较高，同时风险比较大，如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。现在主要场景是在 <code>binlog</code> 同步。</p><p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p><hr><p>下面围绕普通顺序讲述一下消息的顺序保证实现。</p><p> <code>Producer</code> 生产消息的时候会进行轮询(取决负载均衡策略)来向同一主题的不同消息队列发送消息。</p><p>在这种情况下， RocketMQ 中实现普通顺序模式主要涉及到如何确保相关的消息（例如同一个订单的不同操作）被发送到同一个队列中，以保持消息的顺序性。</p><p>这里的关键在于正确地选择队列来发送消息。以下是详细的解释和实现方法：</p><blockquote><p>普通顺序模式的基本原理</p></blockquote><ul><li><strong>问题</strong>：在默认情况下，生产者在发送消息时可能会轮询地选择不同的队列，这可能导致同一个业务流程（如一个订单的不同操作）的相关消息被发送到不同的队列，从而打乱消息的顺序。</li><li><strong>解决方案</strong>：为了保证同一业务流程的消息被发送到同一个队列，需要在发送消息时采用一致的队列选择策略。</li></ul><blockquote><p>实现普通顺序模式</p></blockquote><ol><li><strong>使用哈希取模法</strong>：<ul><li>这是实现消息顺序的一种常用方法。生产者在发送每条消息时，可以根据业务标识符（例如订单ID）进行哈希计算。</li><li>然后，使用这个哈希值对队列数量进行取模运算，以此决定将消息发送到哪个队列。</li><li>这样做的结果是，相同订单ID的所有消息都会被发送到同一个队列，保持了顺序。</li></ul></li><li><strong>RocketMQ 的队列选择算法</strong>：<ul><li>RocketMQ 提供了内置的队列选择算法，其中之一是基于消息键的哈希值来选择队列。</li><li>当生产者发送消息时，可以指定一个消息键（例如订单ID），RocketMQ 会根据这个键的哈希值来选择队列。</li></ul></li><li><strong>发送顺序消息的实践</strong>：<ul><li>在实际应用中，确保每次发送消息时都使用相同的业务标识符（如订单ID）作为消息键。</li><li>这样，无论是使用 RocketMQ 的内置队列选择算法还是自定义的哈希取模法，都能确保同一订单的不同操作（创建、支付、发货）的消息被发送到同一个队列。</li></ul></li></ol><p><strong>消费顺序消息</strong></p><ul><li>在消费端，消费者会按照消息在队列中的顺序来处理消息。</li><li>由于相关的消息都在同一队列中，这保证了消费者能够按照发送顺序来处理这些消息。</li></ul><blockquote><p>队列选择算法</p></blockquote><p>RocketMQ 实现了两种队列选择算法，也可以自己实现</p><ul><li>轮询算法<ul><li>轮询算法就是向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布</li><li>是 RocketMQ 默认队列选择算法</li></ul></li><li>最小投递延迟算法<ul><li>每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可。</li><li>&#96;producer.setSendLatencyFaultEnable(true);</li></ul></li><li>继承 MessageQueueSelector 实现</li></ul><p>继承 MessageQueueSelector 实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">SendResult</span> sendResult = producer.<span class="hljs-title function_">send</span>(msg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageQueue</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">List&lt;MessageQueue&gt; mqs, Message msg, <span class="hljs-built_in">Object</span> arg</span>) &#123;<br>        <span class="hljs-comment">//从mqs中选择一个队列,可以根据msg特点选择</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br></code></pre></td></tr></table></figure><h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><blockquote><p>重复消费问题</p></blockquote><ul><li>在消息队列系统中，由于各种原因（如网络波动、Broker 重启等），消息可能会被重复发送给消费者。</li><li>如果消费者对同一消息的重复处理会导致不同的结果（如多次增加用户积分），就会产生问题。</li></ul><blockquote><p>幂等性解决策略</p></blockquote><ul><li><strong>幂等性定义</strong>：幂等操作指的是无论执行多少次，都产生相同的效果。在消息队列的上下文中，这意味着对同一消息的重复处理应该保证最终结果不变。</li><li><strong>实例说明</strong>：例如，一个处理订单积分的系统，即使接收到同一订单消息多次，也应该只给用户增加一次相应的积分。</li></ul><blockquote><p>实现幂等性的方法</p></blockquote><ol><li><strong>使用 Redis</strong>：<ul><li>利用 Redis 的 key-value 特性实现幂等性。例如，使用订单ID作为 key，确保对同一订单的处理是幂等的。</li></ul></li><li><strong>数据库插入法</strong>：<ul><li>依赖数据库的唯一键约束来防止重复数据的插入，如使用唯一索引来确保每条消息只被处理一次。</li></ul></li><li><strong>场景特定解决方案</strong>：<ul><li>根据业务场景的不同，选择合适的幂等性实现方法。考虑消息消费的特性，决定是采用强校验还是弱校验的幂等性策略。</li></ul></li></ol><p>幂等性的概念不限于消息队列，它同样适用于其他场景，如避免 HTTP 服务的重复请求处理或解决 RPC 框架在自动重试时的重复调用问题。</p><p>重要的是根据具体的业务需求和场景来设计和实现幂等性策略。</p><h4 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h4><h5 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h5><p>选择队列后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时此时 RocketMQ 会进行重试。</p><p>重新选择其他 Broker 中的消息队列进行发送，默认重试两次，可以手动设置。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">producer.setRetryTimesWhenSendFailed(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="消息过大"><a href="#消息过大" class="headerlink" title="消息过大"></a>消息过大</h5><p>消息超过 4k 时 RocketMQ 会将消息压缩后在发送到 Broker 上，减少网络资源的占用。</p><h3 id="6、RocketMQ-如何实现分布式事务"><a href="#6、RocketMQ-如何实现分布式事务" class="headerlink" title="6、RocketMQ 如何实现分布式事务"></a>6、RocketMQ 如何实现分布式事务</h3><p>这里建议用实际例子去补充一下具体如何完成的，目前我们讲述一下 RocketMQ 是如何实现分布式事务的。</p><blockquote><p>分布式事务的常见实现方式（每种方法都有其适用场景和局限性）</p></blockquote><ul><li>2PC（两阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>事务消息（half 半消息机制）</li></ul><blockquote><p>RocketMQ 的分布式事务实现</p></blockquote><p>在 RocketMQ 中，其采用的实现机制是：事务消息加上事务反查机制。</p><p>参考一下这篇博客中关于订单关于的一个流程使用： <a href="https://juejin.cn/post/6844904099993878536">https://juejin.cn/post/6844904099993878536</a></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281351790.png" alt="image.png"></p><p>上述内容提及到自己认为需要注意的点：</p><ul><li>本地事务进行下一步操作后，服务方才会提交或者回滚半消息到 RocketMQ 的节点 Broker</li></ul><blockquote><p>图：RocketMQ 实现分布式事务</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281358695.png" alt="image.png"></p><p>关于 Half Message，半消息  和 事务状态回查  的一个基本表述：</p><ol><li><strong>事务消息（Half 消息）</strong>：<ul><li><strong>第一步：发送 Half 消息</strong>：所谓的 Half 消息是指一种特殊状态的消息，它在事务完成之前对消费者是不可见的。</li><li><strong>实现机制</strong>：当发送一个事务消息时，RocketMQ 首先存储这个消息，但将其标记为不可见状态（Half 状态）。这是通过改变消息的主题为 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 实现的，因为消费者通常不订阅这个特殊主题，所以不会消费这些 Half 消息。</li></ul></li><li><strong>事务反查机制</strong>：<ul><li><strong>定时任务</strong>：RocketMQ 会启动一个定时任务，定期检查 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 中的消息。</li><li><strong>反查请求</strong>：对于每条 Half 消息，RocketMQ 会根据其生产者组向相应的服务发送事务状态回查请求。</li><li><strong>事务状态决定</strong>：根据回查结果，RocketMQ 会决定是提交还是回滚这条消息。如果事务成功，消息将变为正常状态并可被消费；如果事务失败，消息将被回滚或删除。</li></ul></li><li><strong>网络波动和事务反查的重要性</strong>：<ul><li><strong>问题场景</strong>：如果在确认事务成功（即第四步）时出现网络问题，RocketMQ 无法知道该消息是否应该对消费者可见。</li><li><strong>反查机制的作用</strong>：事务反查确保即使在网络波动或其他问题的情况下，事务消息的最终状态也能得到正确处理。</li></ul></li></ol><p>其他的表述也是大同小异，具体更多的细节可以看一下具体实现，以及相关联的其他分布式事务是如何实现的，比较差异。</p><h3 id="7、如何解决消息堆积问题？"><a href="#7、如何解决消息堆积问题？" class="headerlink" title="7、如何解决消息堆积问题？"></a>7、如何解决消息堆积问题？</h3><p>解决消息队列中的堆积问题通常需要从两个主要方面考虑：</p><ul><li>生产者生产消息减少</li><li>消费者处理消息速率加快</li></ul><blockquote><p>生产者生产消息减少</p></blockquote><p>处理策略一般是限流和降级：</p><ul><li><strong>生产者限流</strong>：在高峰期，如果生产者生产消息的速度过快，可以采取限流措施。这意味着暂时减少消息的生产速率，或者在非高峰时段再进行消息的发送。</li><li><strong>服务降级</strong>：在系统负载过高时，可以临时关闭一些非核心业务功能，减少消息的产生。</li></ul><blockquote><p>消费者处理消息速率加快</p></blockquote><p>处理策略可以是 增加消费者实例 以及 增加队列数量</p><ul><li>增加消费者实例（集群消费模式下增长同一个消费者组下的实例数对堆积消息消费处理帮助不大）<ul><li>当现有队列中有消息堆积，并且现有的消费者处理能力不足以及时处理这些消息时。</li><li>增加消费者实例可以帮助更快地处理现有队列中已经堆积的消息。</li><li>在一个队列只被一个消费者消费的场景中（如 RocketMQ 的集群消费模式），增加同一消费者组的实例数对于加快处理一个单独队列中的堆积消息是无效的。</li></ul></li><li>增加队列数量（增加队列数量后，新来的一些消息能够被策略分配到新的队列，从而减少堆积压力）<ul><li>当预期未来将有高负载，或者想要提高系统处理新消息的能力时。</li><li>增加队列数量可以为新生产的消息提供更多的存储空间，并允许更多的消费者并行处理这些新消息。</li><li>仅仅增加队列数量而不增加消费者实例可能导致新队列中的消息未被及时消费，特别是在集群消费模式下。</li></ul></li></ul><div style="background: linear-gradient(to right, #74ebd5, #ACB6E5); color: #333; padding: 15px; border-radius: 10px; border: 1px solid #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">  <strong> </strong>最快速解决消息堆积问题的方法还是增加消费者实例，不过 同时你还需要增加每个主题的队列数量 。</div><hr><p>在消息堆积后，我们一般的处理是先排查消费端故障，让处理消费正常起来；</p><p>但此时消息队列中已经堆积了大量的一个消息待处理，我们除了优化消费者端的消息处理逻辑和实施快速失败机制之外，还有其他几种方法可以考虑：</p><ul><li><ol><li>调整队列和消费者的映射关系</li></ol></li><li><ol start="2"><li>临时增加特定队列的消费者</li></ol><ul><li>尽管在集群模式下，一个队列在同一时间只能由一个消费者消费，但您可以尝试临时创建一个新的消费者组，专门用来处理那个堆积的队列。</li></ul></li><li><ol start="3"><li>使用消息过滤</li></ol><ul><li><strong>消息选择性消费</strong>：如果适用，可以在消费者端使用消息过滤，专注于处理最紧急或最重要的消息。</li></ul></li><li><ol start="4"><li>短期策略</li></ol><ul><li><strong>临时措施</strong>：作为一种短期策略，可以暂时将一些不太重要的业务处理延后，优先处理堆积的消息。</li></ul></li><li><ol start="5"><li>系统资源优化，监控和动态调整</li></ol></li></ul><h3 id="8、回溯消费"><a href="#8、回溯消费" class="headerlink" title="8、回溯消费"></a>8、回溯消费</h3><blockquote><p>官方文档解释</p></blockquote><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，</p><p>在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p><h3 id="9、RocketMQ-如何保证高性能读写"><a href="#9、RocketMQ-如何保证高性能读写" class="headerlink" title="9、RocketMQ 如何保证高性能读写"></a>9、RocketMQ 如何保证高性能读写</h3><p>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝，用来读写文件</p><p>to be contined….</p><h3 id="10、RocketMQ-的刷盘机制-🦅"><a href="#10、RocketMQ-的刷盘机制-🦅" class="headerlink" title="10、RocketMQ 的刷盘机制   🦅"></a>10、RocketMQ 的刷盘机制   🦅</h3><h4 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h4><p>在 RocketMQ 中，同步刷盘和异步刷盘是两种不同的消息持久化策略，它们各有优劣，并适用于不同的业务场景。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281520496.png" alt="image.png"></p><p>以下是对这两种策略的详细说明和比较：</p><blockquote><p>同步刷盘（SYNC_FLUSH）</p></blockquote><ul><li><strong>工作原理</strong>：在同步刷盘模式下，每当生产者发送一条消息，Broker 需要将消息写入磁盘并完成刷盘操作后，才会向生产者返回确认（ACK）。只有收到这个确认，生产者才知道消息已经安全存储。</li><li><strong>优点</strong>：提供了更高的消息可靠性。即使在Broker意外宕机的情况下，也不会丢失已确认的消息。</li><li><strong>缺点</strong>：影响性能。由于每条消息都需要等待磁盘写入完成，这会增加消息的延迟时间，降低吞吐量。</li><li><strong>适用场景</strong>：适用于对消息可靠性有极高要求的场景，如金融交易、重要业务数据处理等。</li></ul><blockquote><p>异步刷盘（ASYNC_FLUSH）</p></blockquote><ul><li><strong>工作原理</strong>：在异步刷盘模式下，Broker 将消息写入内存后，就立即向生产者返回确认。实际的刷盘操作是由后台线程异步完成的，不会阻塞消息的发送。</li><li><strong>优点</strong>：提高了性能和吞吐量。由于消息发送不需要等待磁盘操作完成，因此减少了延迟。</li><li><strong>缺点</strong>：消息可靠性降低。如果Broker在消息还未刷入磁盘前发生宕机，那么这部分消息可能会丢失。</li><li><strong>适用场景</strong>：适用于对性能要求较高，但对消息可靠性要求不是特别严格的场景，如日志收集、一些非关键的业务通知等。</li></ul><p><strong>刷盘策略的设置</strong></p><ul><li><strong>配置参数</strong>：在 RocketMQ 中，可以通过设置Broker的<code>FlushDiskType</code>参数来调整刷盘策略。</li><li>可以选择<code>ASYNC_FLUSH</code>（异步刷盘）或<code>SYNC_FLUSH</code>（同步刷盘）。</li></ul><p>同步刷盘和异步刷盘在消息可靠性和性能之间提供了不同的平衡点。</p><p>在实际应用中，应根据业务需求的不同，选择最合适的刷盘策略。对于那些要求高可靠性的场景，同步刷盘是更好的选择；而对于那些更看重性能和吞吐量的应用，异步刷盘则更为适合</p><h4 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h4><p>同步复制和异步复制在 RocketMQ 中指的是主从Broker之间的数据复制方式，这直接影响消息的可靠性和系统的可用性。这两种复制策略在保证数据一致性和提高系统性能之间提供了不同的平衡点。以下是对这两种策略的详细说明和比较：</p><blockquote><p>同步复制（同步双写）</p></blockquote><ul><li><strong>工作原理</strong>：在同步复制模式下，当消息被写入主Broker后，它必须同时被复制到从Broker上。只有当消息在主从Broker上都成功写入后，才向生产者返回写入成功的确认。</li><li><strong>优点</strong>：提高了数据的可靠性。即使主Broker宕机，从Broker上仍然有消息的完整副本。</li><li><strong>缺点</strong>：影响性能。由于消息写入操作需要在主从Broker上都完成，这可能导致较高的延迟和降低吞吐量。</li><li><strong>适用场景</strong>：适用于对数据可靠性要求极高的场景，如金融交易。</li></ul><blockquote><p>异步复制</p></blockquote><ul><li><strong>工作原理</strong>：在异步复制模式下，当消息写入主Broker之后，系统就直接返回写入成功。消息的复制到从Broker是异步进行的。</li><li><strong>优点</strong>：提高了性能。由于不需要等待从Broker确认，消息的写入和确认速度更快。</li><li><strong>缺点</strong>：可能存在数据不一致的风险。如果主Broker在数据复制完成前宕机，从Broker可能缺少最新的数据。</li><li><strong>适用场景</strong>：适用于对性能要求较高，但数据可靠性要求不是极端严格的场景。</li></ul><blockquote><p>可用性与顺序性的考虑</p></blockquote><ul><li><strong>可用性问题</strong>：由于RocketMQ不支持自动主从切换，如果主Broker宕机，整个系统将无法继续生产消息。虽然消费者可以从从Broker消费消息，但在主Broker宕机期间会存在短暂的主从数据不一致情况。</li><li><strong>解决方案</strong>：通过部署多个主从集群（多Broker架构）来提高可用性。每个Topic分布在不同的Broker中，可以在一定程度上解决单个Broker宕机问题。</li><li><strong>顺序性问题</strong>：在多Broker架构下，如果某个主Broker负责特定顺序消息宕机，其他Broker无法替代它处理这些消息，可能影响消息的顺序性。</li><li><strong>Dledger</strong>：RocketMQ通过引入Dledger技术，支持半数以上节点的消息复制后才确认写入成功，并支持主节点的动态选举，解决了严格顺序性和高可用性的问题。</li></ul><p>同步复制和异步复制在RocketMQ中提供了不同的数据一致性和性能平衡。在设计系统时，需要根据业务需求的具体情况选择合适的复制策略。</p><p>Dledger作为一种解决方案，虽然提高了可用性和顺序性保证，但在选举过程中可能会暂时无法提供服务，并且对节点的数量有一定要求。在实际应用中，需综合考虑业务场景的特性和对数据可靠性、系统性能的具体需求来决定使用哪种复制策略。</p><h4 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h4><p>RocketMQ 的存储机制采用混合型结构，优化了数据的写入效率和读取效率。这种设计涉及到三个关键组件：CommitLog、ConsumeQueue 和 IndexFile。</p><p>以下是这些组件的功能和它们在整个存储结构中的作用：</p><blockquote><p>CommitLog   核心文件</p></blockquote><ul><li><strong>功能</strong>：CommitLog 是消息存储的核心文件，它存储了生产者写入的消息主体内容及其元数据。</li><li><strong>存储结构</strong>：CommitLog 文件的大小默认为1GB，文件命名基于起始偏移量，例如 <code>00000000001073741824</code>。</li><li><strong>写入方式</strong>：消息主要是顺序写入CommitLog文件，提高了写入效率。当一个文件写满后，写入会继续在下一个文件。</li></ul><blockquote><p>ConsumeQueue   索引文件</p></blockquote><ul><li><strong>功能</strong>：ConsumeQueue 作为消费消息的索引，提升读取效率。</li><li><strong>结构</strong>：ConsumeQueue 保存了特定Topic下队列消息在CommitLog中的起始物理偏移量、消息大小和消息Tag的HashCode值。</li><li><strong>存储路径</strong>：采用 <code>topic/queue/file</code> 的三层组织结构，文件路径为 <code>$HOME/store/consumequeue/&#123;topic&#125;/&#123;queueId&#125;/&#123;fileName&#125;</code>。</li><li><strong>条目组织</strong>：每个条目固定20字节，包括commitlog的物理偏移量、消息长度和tag hashcode，允许像数组一样随机访问每个条目。</li></ul><blockquote><p>IndexFile</p></blockquote><ul><li><strong>功能</strong>：提供了通过key或时间区间查询消息的能力，但不涉及消息的主体内容。</li></ul><p>存储机制的特点</p><ul><li><strong>高效写入</strong>：不分Topic地顺序写入CommitLog，增加了写入效率。</li><li><strong>索引优化</strong>：使用ConsumeQueue作为索引文件，加快了基于Topic的消息检索和消费。</li><li><strong>文件大小</strong>：CommitLog文件设计成固定大小主要是为了支持内存映射机制，提高文件操作的效率。</li></ul><p>读取流程</p><ul><li>生产者发送消息时指定Topic和QueueId，消息被顺序存储到CommitLog。</li><li>相应的索引信息（偏移量、大小、tag hash）被存入对应Topic和QueueId的ConsumeQueue文件。</li><li>消费者根据消费偏移量（ConsumeOffset）在ConsumeQueue中检索下一条消息的位置，然后根据CommitLog中的位置找到实际消息。</li></ul><p>RocketMQ的存储架构通过将所有消息顺序存储在一个共享的CommitLog文件并使用ConsumeQueue和IndexFile作为索引文件来实现高效的消息读写。</p><p>这种设计在提高写入效率的同时，通过索引机制加快了消息的检索和消费速度。<br>与Kafka的每个Topic独立存储文件相比，RocketMQ的这种混合型存储结构更注重写入效率和灵活的读取操作。</p><blockquote><p><code>IndexFile</code> 和 <code>ConsumeQueue</code> 的区别</p></blockquote><p>在 RocketMQ 中，<code>IndexFile</code> 和 <code>ConsumeQueue</code> 都是消息存储结构的重要部分，但它们的用途和工作方式有所不同。</p><p>理解这两者之间的区别有助于更好地把握 RocketMQ 的消息存储和检索机制。</p><p>以下是对 <code>IndexFile</code> 和 <code>ConsumeQueue</code> 的主要区别的概述：</p><blockquote><p>ConsumeQueue</p></blockquote><ul><li><strong>目的</strong>：<code>ConsumeQueue</code> 作为消费消息的索引，其主要目的是加快消息消费的效率。</li><li><strong>内容</strong>：它保存了特定 Topic 下的队列消息在 <code>CommitLog</code> 中的起始物理偏移量、消息大小和消息 Tag 的 HashCode 值。</li><li><strong>结构</strong>：<code>ConsumeQueue</code> 文件是定长设计，每个条目包含了消息在 <code>CommitLog</code> 的偏移量、长度和 Tag HashCode，使得消费者能够快速定位消息。</li><li><strong>使用</strong>：消费者使用 <code>ConsumeQueue</code> 来快速查找待消费的消息，有效提升了消息消费的速度和效率。</li></ul><blockquote><p>IndexFile</p></blockquote><ul><li><strong>目的</strong>：<code>IndexFile</code> 的主要作用是提供一种基于 key 或时间区间来快速查询消息的方法。</li><li><strong>内容</strong>：它创建了消息属性（如消息的唯一标识符或业务键）的索引，以及消息在 <code>CommitLog</code> 中的物理偏移量。</li><li><strong>结构</strong>：<code>IndexFile</code> 不是针对特定 Topic 或队列的，而是为了提供跨所有消息的快速查找功能。</li><li><strong>使用</strong>：当需要根据特定关键字或者时间区间查询消息时，<code>IndexFile</code> 能够快速定位这些消息。</li></ul><p>区别：</p><ul><li><strong>使用场景</strong>：<code>ConsumeQueue</code> 是为了优化消息消费过程而设计的，而 <code>IndexFile</code> 则是为了提供一种灵活的消息查询机制。</li><li><strong>数据内容</strong>：<code>ConsumeQueue</code> 侧重于消息消费的快速定位，而 <code>IndexFile</code> 侧重于提供基于关键字和时间的快速检索。</li><li><strong>结构设计</strong>：<code>ConsumeQueue</code> 是基于 Topic 的逻辑消费队列，每个条目指向 <code>CommitLog</code> 中的特定消息；而 <code>IndexFile</code> 是一个全局索引，允许根据不同的查询条件找到消息。</li></ul><hr><h3 id="11、RocketMQ-如何保证不丢失消息"><a href="#11、RocketMQ-如何保证不丢失消息" class="headerlink" title="11、RocketMQ 如何保证不丢失消息"></a>11、RocketMQ 如何保证不丢失消息</h3><p>RocketMQ 采用了多种机制来确保消息的可靠性，防止消息丢失。</p><p>以下是 RocketMQ 实现消息不丢失的主要方法：</p><ul><li><ol><li>消息持久化</li></ol></li><li><ol start="2"><li>高可用性设计</li></ol></li><li><ol start="3"><li>消息重试机制</li></ol></li><li><ol start="5"><li>事务消息</li></ol></li><li><ol start="6"><li>同步复制</li></ol></li><li><ol start="7"><li>消息确认机制</li></ol></li></ul><blockquote><ol><li>消息持久化</li></ol></blockquote><ul><li><strong>磁盘存储</strong>：默认情况下，所有消息在被消费之前都会被持久化到磁盘，确保即使在发生系统崩溃的情况下也不会丢失消息。</li><li><strong>同步和异步刷盘</strong>：提供了同步刷盘和异步刷盘两种模式。同步刷盘提供更高的消息可靠性，而异步刷盘则提供更高的性能。</li></ul><blockquote><ol start="2"><li>高可用性设计</li></ol></blockquote><ul><li><strong>主从架构</strong>：通过部署多个Broker实例（包括主Broker和从Broker），并使用数据复制机制来确保数据的一致性和可靠性。</li><li><strong>故障自动转移</strong>：如果主Broker宕机，从Broker可以自动接管，保证服务的持续可用性。</li></ul><blockquote><ol start="3"><li>消息重试机制</li></ol></blockquote><ul><li><strong>消费者重试</strong>：如果消费者处理消息失败，RocketMQ 提供了消息重试机制，允许消费者在一定时间后重新尝试处理消息。</li></ul><blockquote><ol start="4"><li>死信队列</li></ol></blockquote><ul><li><strong>死信处理</strong>：对于多次重试仍然失败的消息，可以被发送到死信队列。这样做可以避免一直重试无法处理的消息，同时保留这些消息以便后续分析和处理。</li></ul><blockquote><ol start="5"><li>事务消息</li></ol></blockquote><ul><li><strong>半消息和事务回查</strong>：对于需要事务支持的场景，RocketMQ 提供了事务消息功能。这包括发送半消息和在必要时进行事务状态的回查，以保证事务的一致性。</li></ul><blockquote><ol start="6"><li>同步复制</li></ol></blockquote><ul><li><strong>数据复制</strong>：在主从架构中，可以配置数据同步复制，确保从Broker实时复制主Broker的数据。</li></ul><blockquote><ol start="7"><li>消息确认机制</li></ol></blockquote><ul><li><strong>生产者确认</strong>：生产者可以等待Broker的确认回应，以确保消息已经成功存储在Broker上。</li><li><strong>消费者确认</strong>：消费者在处理完消息后发送确认，确保消息不会被重复投递。</li></ul><hr><p>参考</p><ul><li><a href="https://rocketmq.apache.org/docs/quickStart/01quickstart">https://rocketmq.apache.org/docs/quickStart/01quickstart</a></li><li><a href="https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/">https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/</a></li><li><a href="https://developer.aliyun.com/article/788183">https://developer.aliyun.com/article/788183</a></li><li><a href="https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html">https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html</a></li><li><a href="https://juejin.cn/post/7134227366481494046">https://juejin.cn/post/7134227366481494046</a></li><li><a href="https://b23.tv/GneHu8S">https://b23.tv/GneHu8S</a></li><li><a href="https://juejin.cn/post/6844904099993878536">https://juejin.cn/post/6844904099993878536</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues">https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues</a></li><li><a href="http://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/RocketMQ%20%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.md">http://learn.lianglianglee.com/%E6%96%87%E7%AB%A0/RocketMQ%20%E9%9D%A2%E8%AF%95%E9%A2%98%E9%9B%86%E9%94%A6.md</a></li><li><a href="https://www.cnblogs.com/javazhiyin/p/13327925.html">https://www.cnblogs.com/javazhiyin/p/13327925.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题</title>
    <link href="/2023/12/26/Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2023/12/26/Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://hexo.fluid-dev.com/docs/start/">https://hexo.fluid-dev.com/docs/start/</a></li><li><a href="https://hexo.fluid-dev.com/">https://hexo.fluid-dev.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架学习_MyBatis-Plus使用</title>
    <link href="/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://caochenlei.blog.csdn.net/article/details/108809902">https://caochenlei.blog.csdn.net/article/details/108809902</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/108281646?spm=1001.2014.3001.5502&ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkwNDU3Lz90eXBlPWJsb2c=">https://caochenlei.blog.csdn.net/article/details/108281646?spm=1001.2014.3001.5502&amp;ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkwNDU3Lz90eXBlPWJsb2c%3D</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_Redis实战篇</title>
    <link href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-实战篇"><a href="#Redis-实战篇" class="headerlink" title="Redis 实战篇"></a>Redis 实战篇</h2><h3 id="1、Redis-分布式锁"><a href="#1、Redis-分布式锁" class="headerlink" title="1、Redis 分布式锁"></a>1、Redis 分布式锁</h3><p>分布式锁的实现常见的有：</p><ul><li>基于数据库的锁（乐观锁和悲观锁）</li><li>基于缓存的锁</li><li>基于Zookeeper 的锁（强一致性）</li><li>基于消息队列的锁（少见）</li><li>基于其他分布式协调服务</li></ul><p>这里主要介绍一下 Redis 分布式锁的实现方式，以及它是如何使用的。</p><p>Redis 分布式锁通过是<strong>利用<code>SETNX</code>这个方法</strong>，如果插入Key成功，则表示获得到了锁，如果有人插入成功，那么其他人就回插入失败，无法获取到锁，利用这套逻辑完成<code>互斥</code>，从而实现分布式锁</p><p>在使用 <code>SETNX</code>这个方法的时候，一般还会使用 EXPIRE 命令为锁设置一个过期时间防止死锁。</p><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://cyborg2077.github.io/2022/10/22/RedisPractice/">https://cyborg2077.github.io/2022/10/22/RedisPractice/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容03</title>
    <link href="/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/"/>
    <url>/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><h3 id="1、分库分表"><a href="#1、分库分表" class="headerlink" title="1、分库分表"></a>1、分库分表</h3><p>MySQL的分表分库是一种数据库架构设计方法，用于处理大规模数据和高并发访问。</p><p>随着数据量的增长和访问量的提升，单一数据库或表可能难以承受压力，这时通过分表分库可以有效地提高性能和可扩展性。</p><blockquote><p>分表（Sharding）</p></blockquote><p>分表是指将一个大表拆分成多个小表的过程。</p><p>这些小表可以分布在同一个数据库或多个数据库中。分表通常基于某些关键字段进行，比如时间、用户ID等。</p><ul><li><strong>垂直分表</strong>：将表中不同的列分到不同的表中。例如，一个用户表可以被分成用户基础信息表和用户详细信息表。</li><li><strong>水平分表</strong>：根据行数据将表分成多个表，每个表包含相同的列，但只包含部分行。例如，基于用户ID范围或创建时间进行切分。</li></ul><blockquote><p>分库（Database Sharding）</p></blockquote><p>分库涉及将数据分布到多个数据库实例上。每个数据库实例可以托管在不同的服务器上，从而分散负载和提高容错能力。</p><ul><li><strong>分布式数据库</strong>：数据被分散存储在多个物理位置，每个数据库实例可以独立处理查询和事务。</li><li><strong>读写分离</strong>：常与分库结合使用，读操作和写操作分别在不同的数据库实例上进行。</li></ul><p>在实现MySQL的分表分库时，可能需要使用一些工具和中间件，如MyCAT、Shard-Query等，它们帮助管理复杂的分片逻辑，并对应用层透明。</p><h3 id="2、主从复制和读写分离"><a href="#2、主从复制和读写分离" class="headerlink" title="2、主从复制和读写分离"></a>2、主从复制和读写分离</h3><p>在MySQL中，主从复制和读写分离是两种常用的架构策略，用于提高数据库的可用性、扩展性和性能。</p><h4 id="主从复制（Master-Slave-Replication）"><a href="#主从复制（Master-Slave-Replication）" class="headerlink" title="主从复制（Master-Slave Replication）"></a>主从复制（Master-Slave Replication）</h4><p>主从复制是一种数据复制的方法，其中数据从一个主服务器（Master）自动复制到一个或多个从服务器（Slave）。</p><p>工作原理</p><ol><li><strong>日志复制</strong>：主服务器的更改（如INSERT、UPDATE、DELETE操作）被记录到二进制日志中。</li><li><strong>日志传输</strong>：这些更改（日志条目）被传输到从服务器。</li><li><strong>应用更改</strong>：从服务器读取这些日志条目，并在自己的数据副本上应用这些更改。</li></ol><p>目的和优势：</p><ul><li><strong>数据备份</strong>：提供了数据备份，有助于灾难恢复。</li><li><strong>读取负载分散</strong>：从服务器可以用于读取操作，减轻主服务器的负载。</li><li><strong>高可用性</strong>：如果主服务器出现故障，从服务器可以被提升为新的主服务器。</li></ul><p>主从辅助操作主要涉及三个线程: binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li><li><strong>I&#x2F;O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401041611217.png" alt="image.png"></p><h4 id="读写分离（Read-Write-Splitting）"><a href="#读写分离（Read-Write-Splitting）" class="headerlink" title="读写分离（Read-Write Splitting）"></a>读写分离（Read-Write Splitting）</h4><p>读写分离涉及将数据库的读取操作（SELECT查询）和写入操作（INSERT、UPDATE、DELETE）分离到不同的服务器上。</p><p>实现方法</p><ul><li><strong>主服务器处理写操作</strong>：所有更改数据的操作都在主服务器上执行。</li><li><strong>从服务器处理读操作</strong>：所有的读取请求都被重定向到从服务器。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401041612689.png" alt="image.png"></p><blockquote><p>小结</p></blockquote><p>读写分离和主从复制可以通过MySQL的内置功能实现，也可以使用第三方工具如ProxySQL、MaxScale等来帮助管理。</p><p>主从复制和读写分离是提高MySQL数据库性能和可靠性的重要策略。</p><p>它们在处理大量数据和高并发访问的情况下尤其有用，但也需要考虑其带来的额外管理和配置复杂性。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-devide.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-devide.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库_基础知识</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>数据库基础知识包含了数据库设计、管理和操作的核心概念。</p><p>常见的一些概念👇</p><p>有兴趣百度了解下，或者通过参考链接扩展一下相关内容</p><ul><li>数据库和数据库管理系统（DBMS）</li><li>数据模型（关系模型与非关系模型）</li><li>数据库设计<ul><li>ER图</li><li>数据库范式</li></ul></li><li>元组, 码, 候选码, 主码, 外码, 主属性, 非主属性</li><li>主键和外键</li><li>为什么不推荐使用外键与级联</li><li>存储过程</li><li>数据库设计</li><li>字符集</li></ul><h4 id="SQL（结构化查询语言）"><a href="#SQL（结构化查询语言）" class="headerlink" title="SQL（结构化查询语言）"></a>SQL（结构化查询语言）</h4><ul><li><strong>数据定义语言（DDL）</strong>：定义数据库结构，包括CREATE、ALTER、DROP等命令。</li><li><strong>数据操纵语言（DML）</strong>：用于数据访问和处理，包括INSERT、UPDATE、DELETE、SELECT等命令。</li><li><strong>数据控制语言（DCL）</strong>：用于权限和事务控制，包括GRANT、REVOKE、BEGIN TRANSACTION等。</li></ul><h4 id="drop、delete-与-truncate-区别"><a href="#drop、delete-与-truncate-区别" class="headerlink" title="drop、delete 与 truncate 区别?"></a>drop、delete 与 truncate 区别?</h4><ul><li>drop           移除整个表结构，包括其数据和表定义     不能回滚（DDL)</li><li>delete         删除表中的一行或多行记录      能回滚(DML)</li><li>truncate      删除表中的所有记录    不能回滚（DDL)</li></ul><p>执行速度：一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p><p>在MySQL中，<code>DROP</code>、<code>DELETE</code>和<code>TRUNCATE</code>都是用于移除数据的命令，但它们在用法和影响上有明显的区别：</p><blockquote><ol><li>DELETE</li></ol></blockquote><ul><li><strong>用途</strong>：<code>DELETE</code>用于删除表中的一行或多行记录。</li><li><strong>特点</strong>：<ul><li>可以带有<code>WHERE</code>子句，提供了条件删除的功能。</li><li>影响的行数会记录在事务日志中，因此可以回滚。</li><li>触发器（如果有的话）会被激活。</li><li>较慢，特别是在删除大量数据时，因为它逐行删除。</li></ul></li><li><strong>示例</strong>：<code>DELETE FROM table_name WHERE condition;</code></li></ul><blockquote><ol start="2"><li>TRUNCATE</li></ol></blockquote><ul><li><strong>用途</strong>：<code>TRUNCATE</code>用于删除表中的所有记录。</li><li><strong>特点</strong>：<ul><li>不能带有<code>WHERE</code>子句，它总是删除表中的所有记录。</li><li>执行速度比<code>DELETE</code>快，因为它不逐行删除数据，而是直接移除数据页。</li><li>不记录详细的事务日志，只记录重建空表的操作，因此无法回滚（在某些数据库系统中，<code>TRUNCATE</code>是事务安全的，并且可以回滚）。</li><li>重置表的自增计数器（如果有的话）。</li><li>不触发触发器。</li></ul></li><li><strong>示例</strong>：<code>TRUNCATE TABLE table_name;</code></li></ul><blockquote><ol start="3"><li>DROP</li></ol></blockquote><ul><li><strong>用途</strong>：<code>DROP</code>用于移除整个表结构，包括其数据和表定义。</li><li><strong>特点</strong>：<ul><li>删除表的结构及其数据，释放存储空间。</li><li>不能回滚（一旦执行，表就完全消失了）。</li><li>不触发触发器。</li><li>在删除大量数据且不再需要该表时使用。</li></ul></li><li><strong>示例</strong>：<code>DROP TABLE table_name;</code></li></ul><blockquote><p>总结</p></blockquote><ul><li><strong>删除数据行</strong>：如果需要删除部分数据行，使用<code>DELETE</code>。若需删除所有数据行且表结构仍需保留，使用<code>TRUNCATE</code>。</li><li><strong>删除表</strong>：如果要删除整个表及其数据，使用<code>DROP</code>。</li><li><strong>性能考虑</strong>：当处理大量数据时，<code>TRUNCATE</code>比<code>DELETE</code>更高效。</li><li><strong>事务和回滚</strong>：<code>DELETE</code>操作可以回滚，而<code>TRUNCATE</code>和<code>DROP</code>在大多数情况下不能。</li></ul><p>选择使用哪个命令取决于具体的需求，如是否需要保留表结构、是否需要条件删除或是否关注性能优化。</p><h4 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h4><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行。</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li></ol><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/basis.html">https://javaguide.cn/database/basis.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容02</title>
    <link href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/"/>
    <url>/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/</url>
    
    <content type="html"><![CDATA[<h3 id="3、事务隔离"><a href="#3、事务隔离" class="headerlink" title="3、事务隔离"></a>3、事务隔离</h3><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><p>在 <strong>MySQL</strong> 中，事务支持是在引擎层实现的，MyISAM 引擎是不支持事务的，InnoDB 支持；</p><p>下述内容是围绕 InnoDB 引擎来讲述。</p><h4 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h4><p>在MySQL中，事务隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>这个概念对于理解并发操作时可能出现的问题（如脏读、不可重复读、幻读）至关重要。</p><p>MySQL支持以下四种标准的事务隔离级别：</p><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ul><blockquote><ol><li>READ UNCOMMITTED（读未提交）</li></ol></blockquote><p>这是最低的隔离级别，在这个级别，事务可以读取到其他事务还未提交的更改。</p><p>想象一个图书馆，所有书籍即使正在被编辑（数据被修改）也可以被任何人阅读。</p><p>这可能导致“脏读”，即一个事务可能读取到另一个事务修改但尚未提交的数据，如果那个事务回滚，读取到的数据就是无效的。</p><blockquote><ol start="2"><li>READ COMMITTED（读已提交）</li></ol></blockquote><p>在这个级别，一个事务只能读取到其他事务已经提交的更改。</p><p>回到图书馆的例子，这就相当于只有当一本书完成编辑并返回到书架上时，其他人才能阅读它。</p><p>这解决了脏读的问题，但仍然可能出现“不可重复读”，因为在同一个事务中，同样的查询可能会返回不同的结果，如果其他事务在两次查询之间提交了更改。</p><blockquote><ol start="3"><li>REPEATABLE READ（可重复读）</li></ol></blockquote><p>MySQL的默认隔离级别。</p><p>在这个级别，事务在开始时创建一个数据快照，<strong>确保在整个事务期间可以重复读取相同的数据</strong>，即使其他事务提交了更改。</p><p>在图书馆中，即使书籍被编辑，你也会一直读到你最初找到的版本。虽然解决了不可重复读的问题，但它仍然面临“幻读”的问题，当一个事务中的两个相同的查询可能<strong>因为另一个事务的插入操作</strong>而返回不同的行数。</p><blockquote><ol start="4"><li>SERIALIZABLE（串行化）</li></ol></blockquote><p>这是最高的隔离级别，它通过<strong>强制事务顺序执行</strong>，避免了幻读的问题。在图书馆中，这相当于当你阅读一本书时，<strong>其他任何人都不能编辑或检查这本书</strong>。这会导致明显的性能下降，因为它阻止了可能的并发事务执行。</p><p>不同隔离级别对性能和并发性的影响是一个权衡：</p><ul><li>更低的隔离级别（如READ UNCOMMITTED和READ COMMITTED）提高了并发性，但牺牲了数据的准确性。</li><li>更高的隔离级别（如REPEATABLE READ和SERIALIZABLE）提供了更准确的数据和事务一致性，但可能会降低并发性。</li></ul><p>选择哪个隔离级别取决于应用程序的特定需求和它可以容忍的数据不一致程度。</p><p>例如，银行系统可能会倾向于使用更高的隔离级别以保证事务的准确性，而一个只显示近似数据的报告系统可能会选择一个更低的隔离级别以获得更好的性能。</p><h4 id="隔离级别REPEATABLE-READ（可重复读）的实现"><a href="#隔离级别REPEATABLE-READ（可重复读）的实现" class="headerlink" title="隔离级别REPEATABLE READ（可重复读）的实现"></a>隔离级别REPEATABLE READ（可重复读）的实现</h4><p>在MySQL中，REPEATABLE READ（可重复读）隔离级别的实现是通过结合使用多版本并发控制（MVCC）和回滚日志来完成的。</p><p>这两种机制共同工作，以确保事务可以在其执行期间多次读取同一数据的一致状态，同时避免由其他并发事务引起的数据不一致。</p><blockquote><p>多版本并发控制（MVCC）</p></blockquote><p>MVCC是可重复读隔离级别的核心，它允许在不加锁的情况下进行读操作，同时仍然保持事务间的隔离。</p><ul><li><strong>数据版本化</strong>：在MVCC中，每当数据被更新时，原始数据不会立即被覆盖。相反，会创建一个新的数据版本。这样，不同的事务可以看到同一数据的不同版本。</li><li><strong>读视图（Read-View）</strong>：当事务开始时，它创建一个读视图，这个视图代表数据库在那一时刻的状态。在整个事务期间，即使数据在其他事务中被更改，该事务也能看到其读视图中的数据版本。</li></ul><blockquote><p>回滚日志</p></blockquote><p>回滚日志是实现MVCC的关键组成部分，它用于记录每个数据版本的历史信息。</p><ul><li><strong>版本链</strong>：每当数据项被更新，回滚日志就会记录一个操作，这些操作形成了一条版本链。例如，一个值从1改为2，再改为3，最后变为4，回滚日志会记录这一系列变化。</li><li><strong>保留历史数据</strong>：这些回滚操作允许数据库“回滚”到早期的状态。因此，即使当前数据值是4，不同的事务依据它们的读视图可能看到的值是1、2或4。</li></ul><p>回滚日志什么时候删除？</p><ul><li>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</li><li>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</li></ul><blockquote><p>实现原理</p></blockquote><p>结合MVCC和回滚日志，可重复读隔离级别在MySQL中的实现可以这样理解：</p><ol><li><strong>事务开始时创建读视图</strong>：事务开始时捕捉数据库的瞬时快照，这个快照定义了事务能看到的数据版本。</li><li><strong>读取操作时使用回滚日志</strong>：当事务中的操作需要读取数据时，系统会利用回滚日志找到该事务读视图对应的数据版本。</li><li><strong>隔离性的保证</strong>：即使在事务执行过程中，其他事务已经提交了对相同数据的更改，该事务仍然只能看到其开始时的数据版本。</li><li><strong>回滚日志的维护</strong>：回滚日志会一直保留，直到没有事务需要早期的数据版本为止。这确保了即使在有长事务存在的情况下，数据的早期版本仍然可用。</li></ol><blockquote><p>长事务的影响</p></blockquote><p>由于长事务可能会访问旧版本的数据，MySQL必须保留长事务开始之前的所有回滚信息。这不仅占用了大量存储空间，而且可能影响系统性能。</p><p>例如，在MySQL 5.5及以前的版本中，大量的回滚日志可能导致ibdata文件过大，即使长事务最终提交，这些空间也不会自动释放，有时需要重建整个数据库来清理这些空间。</p><p>因此，虽然REPEATABLE READ提供了较强的隔离性，但也需要合理管理事务的生命周期，避免长事务对系统性能和存储空间的负面影响。</p><hr><p>刚刚看到一个概念，叫 Next-Key Locking。他可以保持在可重复隔离级别下，同时避免脏读的一种锁机制。</p><p>可串行化的化就完全是强制事务顺序执行，而 Next-Key Locking 的话是结合了行锁和间隙锁，避免了一定范围内出现脏读。</p><h4 id="Next-Key-Locking"><a href="#Next-Key-Locking" class="headerlink" title="Next-Key Locking"></a>Next-Key Locking</h4><p>Next-Key Locking 是 InnoDB 存储引擎特有的锁机制，它结合了行锁和间隙锁（gap lock）的特性。Next-Key Lock 实际上锁定了一个范围，不仅锁定了行记录本身，还锁定了记录之间的间隙，从而防止其他事务在这个范围内插入新的记录。</p><blockquote><p>作用与效果</p></blockquote><ul><li><strong>作用</strong>：通过 Next-Key Locking，MySQL 能够确保在可重复读隔离级别下，一个事务在其执行期间看到的数据范围保持不变，即使有其他事务试图在这个范围内插入新的数据，也会因为锁的存在而被阻塞，直到原事务完成。这样就有效地避免了幻读问题。</li><li><strong>效果</strong>：因此，在可重复读隔离级别下，MySQL 能够有效解决幻读问题，确保事务的一致性和隔离性。</li></ul><p>简而言之，通过 Next-Key Locking 机制，MySQL 在可重复读隔离级别下通过锁定数据范围和间隙来防止幻读，从而保证了数据的一致性和事务的隔离性。</p><blockquote><p>和串行化的区别</p></blockquote><p>Next-Key Locking 不是串行化（Serializable）隔离级别，而是一种锁机制，主要用于 InnoDB 存储引擎在可重复读（Repeatable Read）隔离级别下防止幻读问题的一种实现方法。串行化隔离级别和可重复读隔离级别是事务隔离级别的两种不同标准，它们在处理并发事务时有不同的特性和行为。</p><p>Next-Key Locking</p><ul><li>Next-Key Locking 是 InnoDB 特有的一种锁机制，结合了行锁和间隙锁（Gap Lock）。</li><li>它锁定一个范围而不仅仅是单个行记录，包括记录本身和记录之间的间隙。</li><li>主要用在可重复读（Repeatable Read）隔离级别下，用于防止幻读问题。</li></ul><p>串行化隔离级别（Serializable）</p><ul><li>串行化是最高的事务隔离级别，它通过强制事务顺序执行来避免并发事务带来的问题，包括脏读、不可重复读和幻读。</li><li>在串行化隔离级别下，读操作会加锁，使得其他事务不能同时进行写操作。</li><li>串行化通过对所有读取的行加锁达到与单线程顺序执行相同的效果，从而保证了数据的绝对一致性。</li></ul><p>区别</p><ul><li><strong>隔离级别</strong>：Next-Key Locking 是可重复读隔离级别下防止幻读的一种锁机制，而串行化是一个事务隔离的标准级别，它通过加锁来序列化所有的事务。</li><li><strong>性能和并发</strong>：由于 Next-Key Locking 只锁定需要的数据范围，所以可重复读级别下的并发性能比串行化级别更好。串行化隔离级别通过加锁限制了并发，虽然数据一致性最强，但性能开销也最大。</li><li><strong>应用场景</strong>：Next-Key Locking 在需要防止幻读同时又要保持较高并发性的场景下使用较多。串行化适用于对数据一致性要求极高的场景，但并发要求不高。</li></ul><p>总结来说，Next-Key Locking 是一种锁机制，用于可重复读隔离级别下的 InnoDB 存储引擎，而串行化是最高等级的事务隔离级别，两者在并发控制和性能开销上有明显的差异。</p><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>事务的启动方式：</strong>显示启动事务；自动提交模式</div><p>在MySQL中，事务的启动方式对于事务管理和性能优化至关重要。理解和正确使用不同的事务启动方式可以避免长事务带来的风险。下面是MySQL中常见的几种事务启动方式：</p><blockquote><ol><li>显式启动事务</li></ol></blockquote><ul><li><strong>使用语句启动</strong>：最直接的启动事务的方式是使用<code>BEGIN</code>或<code>START TRANSACTION</code>语句。这种方式下，事务会持续到执行<code>COMMIT</code>或<code>ROLLBACK</code>语句为止。<code>COMMIT</code>用于提交事务中的所有更改，而<code>ROLLBACK</code>用于撤销所有更改。</li><li><strong>显式控制</strong>：这种方法的优点是开发者对事务的开始和结束有明确的控制，这有助于避免不必要的长事务。</li></ul><blockquote><ol start="2"><li>自动提交模式</li></ol></blockquote><ul><li><strong>设置自动提交</strong>：通过执行<code>SET autocommit=0</code>，可以关闭当前线程的自动提交。这意味着即使执行了一个简单的<code>SELECT</code>查询，也会启动一个事务，并且事务不会自动提交。</li><li><strong>潜在风险</strong>：这种模式下，如果开发者忘记了手动提交或回滚事务，或者在长连接中使用此模式，可能会无意中创建长事务，这会占用大量资源并影响数据库性能。</li></ul><blockquote><ol start="3"><li>推荐的实践</li></ol></blockquote><ul><li><strong>默认自动提交</strong>：建议总是使用<code>SET autocommit=1</code>。通过显式的<code>BEGIN</code>、<code>COMMIT</code>和<code>ROLLBACK</code>语句来控制事务，这样可以清晰地管理事务的生命周期。</li><li><strong>减少交互</strong>：对于需要频繁启动事务的场景，可以使用<code>COMMIT WORK AND CHAIN</code>语法。在<code>autocommit=1</code>的情况下，这个命令不仅提交当前事务，还会自动开始一个新事务。这减少了每个事务开始时执行<code>BEGIN</code>的需求，同时保持了事务的显式控制。</li></ul><blockquote><ol start="4"><li>监控长事务</li></ol></blockquote><ul><li><strong>检测长事务</strong>：可以通过查询<code>information_schema.innodb_trx</code>表来监控长时间运行的事务。例如，要查找运行时间超过60秒的事务，可以使用类似以下的查询语句：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> information_schema.innodb_trx <br><span class="hljs-keyword">WHERE</span> TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) &gt; <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure>  这对于识别可能影响数据库性能的长事务非常有用。</li></ul><p>通过以上方法，开发者可以更有效地管理MySQL事务，避免因误用或不当的事务管理导致的性能问题。</p><p>明确的事务界定，结合对长事务的监控，有助于维持数据库的健康状态和高效性能。</p><hr><blockquote><p>问题：作为业务开发负责人兼数据库负责人，如何避免长事务的出现并妥善处理这种情况。</p></blockquote><p>长事务可能导致多种性能问题，如锁争用、事务日志膨胀、主从延迟等。</p><p>以下是一些有效的策略和最佳实践：</p><ul><li><ol><li>教育和培训</li></ol></li><li><ol start="2"><li>代码审查</li></ol></li><li><ol start="3"><li>监控和报警</li></ol></li><li><ol start="4"><li>性能分析</li></ol></li><li><ol start="5"><li>优化事务管理</li></ol></li><li><ol start="6"><li>应用架构设计</li></ol></li><li><ol start="7"><li>测试和仿真</li></ol></li><li><ol start="8"><li>环境管理</li></ol></li></ul><blockquote><ol start="3"><li>监控和报警</li></ol></blockquote><ul><li><strong>事务持续时间监控</strong>：监控事务的持续时间，使用如<code>information_schema.innodb_trx</code>的查询来识别长事务。</li><li><strong>实时报警系统</strong>：实现实时报警系统，当事务超过预设阈值时发出警告。</li></ul><blockquote><ol start="4"><li>性能分析</li></ol></blockquote><ul><li><strong>分析慢查询日志</strong>：定期检查慢查询日志，找出可能导致长事务的慢SQL语句。</li><li><strong>使用性能分析工具</strong>：使用如MySQL Workbench等工具分析数据库性能，寻找优化点。</li></ul><blockquote><ol start="5"><li>优化事务管理</li></ol></blockquote><ul><li><strong>短事务原则</strong>：鼓励使用短事务原则，尽量减少事务的作用范围和持续时间。</li><li><strong>避免不必要的事务</strong>：有些读取操作可能不需要事务，特别是在只读操作中。</li></ul><h3 id="4、数据库索引-🐱"><a href="#4、数据库索引-🐱" class="headerlink" title="4、数据库索引   🐱"></a>4、数据库索引   🐱</h3><p>在MySQL中，数据库索引是一种特殊的数据结构，它们帮助数据库快速高效地定位和检索数据。</p><p>你可以将索引类比为图书的目录：就像目录使你能够快速找到你想要阅读的章节，数据库索引允许数据库快速找到存储在数据表中的特定数据，而不必扫描整个表。</p><blockquote><p>索引的类型</p></blockquote><p>按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。<br>按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。<br>按字段特性分类可分为：主键索引、普通索引、前缀索引。<br>按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。</p><h4 id="索引-B-树"><a href="#索引-B-树" class="headerlink" title="索引(B+树)"></a>索引(B+树)</h4><blockquote><p>B+ Tree 原理</p></blockquote><p>参考： </p><ul><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/wghadf">https://www.yuque.com/snailclimb/mf2z3k/wghadf</a></li></ul><p>索引为什么使用 B+ 树</p><p>引入各种树解决的问题以及面临的新问题</p><ul><li>二叉查找树（BST)<ul><li>不平衡</li><li>二叉查找树的平均时间复杂度是 O(lgn)；但是在极端情况下，BST会退化为链表，此时时间复杂度为 O(n)</li></ul></li><li>平衡二叉树（AVL)<ul><li>旋转耗时</li><li>删除的一个耗时效率较低，比起使用的好处而言，综合使用并不广泛</li></ul></li><li>红黑树<ul><li>树太高</li><li>红黑树在内存的表现优异；但是在真正存储在磁盘的时候，考虑的偏重是需要减少IO次数</li></ul></li><li>B树<ul><li>为磁盘而生</li><li>将二叉树改为了多路平衡查找树</li></ul></li><li>B+ 树<ul><li>在 B 树的基础上，进一步降低了树的高度，部分改造，使得范围查询更加高效。</li></ul></li></ul><h3 id="5、锁机制"><a href="#5、锁机制" class="headerlink" title="5、锁机制"></a>5、锁机制</h3><p>MySQL的锁机制是一种用来管理多个事务对同一数据进行访问的机制，旨在保持数据的一致性和完整性。</p><p>锁机制允许多个事务同时读写数据库，同时防止数据冲突和不一致。（锁是一种常见的并发事务的控制方式）</p><p>MySQL中的锁主要可以分为以下几种类型：</p><ul><li>表级锁（Table-level Locks）</li><li>行级锁（Row-level Locks）</li><li>页面锁（Page-level Locks）</li><li>共享锁和排他锁</li><li>意向锁（Intention Locks）</li><li>死锁（Deadlocks）</li></ul><blockquote><ol><li>表级锁（Table-level Locks）</li></ol></blockquote><ul><li><strong>简单但开销小</strong>：锁定整个表，是最简单的锁策略，开销最小。</li><li><strong>并发性低</strong>：不适合高并发操作，因为它阻止了对同一表的其他访问。</li><li><strong>应用</strong>：MyISAM存储引擎主要使用表级锁。</li></ul><blockquote><ol start="2"><li>行级锁（Row-level Locks）</li></ol></blockquote><ul><li><strong>高并发处理</strong>：只锁定需要访问的数据行。是最细粒度的锁，允许高度的并发。</li><li><strong>开销大</strong>：比表级锁更多的内存和CPU资源。</li><li><strong>死锁</strong>：可能会引起死锁，需要额外的逻辑来处理。</li><li><strong>应用</strong>：InnoDB存储引擎使用行级锁。</li></ul><blockquote><ol start="3"><li>页面锁（Page-level Locks）</li></ol></blockquote><ul><li><strong>中间粒度</strong>：锁定内存中的页面，介于表级锁和行级锁之间。</li><li><strong>并发和资源</strong>：平衡了并发性和资源开销。</li><li><strong>应用</strong>：一些存储引擎如BerkeleyDB使用页面锁。</li></ul><blockquote><ol start="4"><li>共享锁和排他锁</li></ol></blockquote><ul><li><strong>共享锁（Shared Locks）</strong>：又称读锁，允许事务读一行数据。<ul><li>读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li></ul></li><li><strong>排他锁（Exclusive Locks）</strong>：又称写锁，允许事务排他地写一行数据。<ul><li>又称写锁&#x2F;独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li><li>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</li></ul></li></ul><blockquote><ol start="5"><li>意向锁（Intention Locks）</li></ol></blockquote><ul><li><strong>层级锁系统</strong>：用于支持表级锁和行级锁的兼容。</li><li><strong>类型</strong>：包括意向共享锁和意向排他锁。</li></ul><blockquote><ol start="6"><li>死锁（Deadlocks）</li></ol></blockquote><ul><li><strong>问题</strong>：当多个事务相互等待对方释放锁时发生。</li><li><strong>解决</strong>：MySQL会自动检测并解决死锁，通常是通过回滚一个事务来解锁。</li></ul><p><strong>锁策略的选择</strong></p><ul><li>不同的存储引擎支持不同的锁策略。例如，InnoDB支持行级锁和表级锁，而MyISAM主要使用表级锁。</li><li>锁的选择取决于多种因素，包括事务的类型、并发级别、数据表的大小等。</li></ul><p>锁机制的实际应用</p><ul><li>在高并发的数据库系统中，适当的锁策略对于维护数据的完整性和提高系统性能至关重要。</li><li>理解不同锁的行为和影响可以帮助数据库管理员和开发人员优化查询，减少死锁，并提高数据库的整体性能。</li></ul><p>参考 <a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81</a></p><h4 id="表级锁和行级锁"><a href="#表级锁和行级锁" class="headerlink" title="表级锁和行级锁"></a>表级锁和行级锁</h4><p>概念：</p><blockquote><ol><li>表级锁（Table-level Locks）</li></ol></blockquote><ul><li><strong>简单但开销小</strong>：锁定整个表，是最简单的锁策略，开销最小。</li><li><strong>并发性低</strong>：不适合高并发操作，因为它阻止了对同一表的其他访问。</li><li><strong>应用</strong>：MyISAM存储引擎主要使用表级锁。</li></ul><blockquote><ol start="2"><li>行级锁（Row-level Locks）</li></ol></blockquote><ul><li><strong>高并发处理</strong>：只锁定需要访问的数据行。是最细粒度的锁，允许高度的并发。</li><li><strong>开销大</strong>：比表级锁更多的内存和CPU资源。</li><li><strong>死锁</strong>：可能会引起死锁，需要额外的逻辑来处理。</li><li><strong>应用</strong>：InnoDB存储引擎使用行级锁。</li></ul><p>在实际的使用中，MySQL 目前默认的存储引擎 InnoDB 中，默认为行级锁，同时 InnoDB 也支持表级锁。</p><p>与之对应的 MyISAM 存储引擎，它只支持表级锁（table-level locking），一锁就锁整张表。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong>：</p><ul><li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><blockquote><p>行级锁的使用有什么注意事项？</p></blockquote><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因</p><h4 id="行锁分类"><a href="#行锁分类" class="headerlink" title="行锁分类"></a>行锁分类</h4><blockquote><p>InnoDB 有哪几类行锁</p></blockquote><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li><li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li><li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围： <a href="https://segmentfault.com/a/1190000040129107">https://segmentfault.com/a/1190000040129107</a></p><hr><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>作用： 通过意向锁来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享&#x2F;排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>IS 锁</td><td>兼容</td><td>兼容</td></tr><tr><td>IX 锁</td><td>兼容</td><td>兼容</td></tr></tbody></table><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><table><thead><tr><th></th><th>IS 锁</th><th>IX 锁</th></tr></thead><tbody><tr><td>S 锁</td><td>兼容</td><td>互斥</td></tr><tr><td>X 锁</td><td>互斥</td><td>互斥</td></tr></tbody></table><hr><p>再看一下下面的这个解释：</p><p>意向锁是 InnoDB 引擎用来优化行锁和表锁之间操作的一种锁机制。其主要目的是为了在数据库中实现多粒度锁定（即同时使用行锁和表锁），并且能够提供一种机制来判断是否可以安全地对整个表加锁。意向锁是表级锁，但它是用来表明事务在接下来的操作中，对表中行记录所计划使用的锁类型（共享或排他）。</p><blockquote><p>意向锁的作用</p></blockquote><ul><li><strong>快速判断表锁兼容性</strong>：意向锁让数据库快速知道是否可以不检查每一行而对整个表加锁。例如，如果一个事务已经对某行加了排他锁，那么此时不能对整个表加共享锁，因为存在不兼容的行锁。</li><li><strong>避免死锁</strong>：通过先获取意向锁再获取具体的行锁，可以减少死锁的可能性。</li></ul><blockquote><p>意向锁的类型</p></blockquote><ul><li><strong>意向共享锁（IS锁）</strong>：表明事务打算对表中的某些行加共享锁。在加共享锁之前，必须先获得表的IS锁。</li><li><strong>意向排他锁（IX锁）</strong>：表明事务打算对表中的某些行加排他锁。在加排他锁之前，必须先获得表的IX锁。</li></ul><blockquote><p>工作原理</p></blockquote><p>当事务想要对某个数据行进行操作（读取或修改）时，它会根据操作类型（是否会修改数据）尝试在该行上加共享锁或排他锁。但在此之前，事务必须先在整个表上获取对应的意向锁（IS或IX）。这样，当另一个事务尝试对整个表加锁时，它可以通过检查表上的意向锁来快速确定是否存在行级锁冲突，而不必检查表中每一行的锁状态。</p><blockquote><p>用户透明</p></blockquote><p>对于数据库的使用者而言，意向锁是完全透明的，即用户无需手动管理意向锁。InnoDB 存储引擎会自动管理意向锁的获取和释放，以确保数据库操作的一致性和并发性。</p><p>总结来说，意向锁是一种表级锁，用于声明事务对表中行记录的加锁意图，它使得数据库能够在保持高并发的同时，有效地管理和调和行级锁和表级锁之间的关系。</p><h3 id="6、explain的使用"><a href="#6、explain的使用" class="headerlink" title="6、explain的使用"></a>6、explain的使用</h3><p>在MySQL中，<code>EXPLAIN</code>是一个非常有用的工具，它用于分析MySQL如何执行SQL查询，特别是用于优化查询性能。</p><p>使用<code>EXPLAIN</code>可以帮助你理解MySQL如何处理你的SQL语句，包括选择哪些索引，如何连接表，以及估计的行数等。</p><blockquote><p>如何使用EXPLAIN</p></blockquote><p>要使用<code>EXPLAIN</code>，只需在你的SELECT语句之前加上关键字<code>EXPLAIN</code>。例如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> your_table <span class="hljs-keyword">WHERE</span> your_column = <span class="hljs-string">&#x27;some_value&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这条命令会返回一个结果集，展示了MySQL执行该查询的计划。</p><blockquote><p>EXPLAIN输出的关键列</p></blockquote><p><code>EXPLAIN</code>的输出包含了许多列，以下是一些最重要的列：</p><ol><li><strong>id</strong>：表示SELECT的序列号，用于区分查询中不同部分的执行顺序。</li><li><strong>select_type</strong>：查询的类型，如SIMPLE（简单表，即不使用表连接或子查询），PRIMARY（主查询），SUBQUERY（子查询）等。</li><li><strong>table</strong>：显示这一行的数据是关于哪个表的。</li><li><strong>type</strong>：表示连接类型，是优化中非常重要的一个指标，从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。</li><li><strong>possible_keys</strong>：显示可能应用在这张表上的索引。</li><li><strong>key</strong>：实际使用的索引。如果为NULL，则没有使用索引。</li><li><strong>key_len</strong>：使用的索引的长度。在不损失精确性的情况下，长度越短越好。</li><li><strong>ref</strong>：显示索引的哪一列被使用了。</li><li><strong>rows</strong>：MySQL认为必须检查的用来返回请求数据的行数。</li><li><strong>Extra</strong>：包含MySQL解决查询的详细信息。比如，“Using index”表示相应的SELECT操作使用了覆盖索引，避免了访问表的数据行。</li></ol><blockquote><p>使用EXPLAIN进行性能优化</p></blockquote><p>通过分析<code>EXPLAIN</code>的输出，你可以获得如何优化查询的线索：</p><ul><li><strong>确保适当的索引被使用</strong>：如果<code>key</code>列是NULL，或者<code>type</code>列显示为ALL或index，可能需要优化索引。</li><li><strong>检查连接顺序</strong>：在<code>id</code>列中，较大的值表示优先级较高的表，你可以通过调整查询结构来改变连接顺序。</li><li><strong>优化查询结构</strong>：根据<code>Extra</code>列的信息，你可能需要调整查询结构，如更改JOIN类型或重新编写子查询。</li></ul><blockquote><p>注意事项</p></blockquote><ul><li><strong>EXPLAIN不执行查询</strong>：它只显示MySQL如何执行查询，实际上并不执行该查询。</li><li><strong>估计的行数可能不准确</strong>：<code>rows</code>列显示的是估计的行数，这个估计可能基于表统计数据，而不是实际的行数。</li></ul><p>平时用这个进行分析语句的时候，看的最多的三个字段是：select_type、key、rows</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><p>性能优化注意的点比较多，建议看一下这个： </p><ul><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-performance.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-performance.html</a></li></ul><p>性能优化策略</p><ul><li>优化数据访问<ul><li><ol><li>减少请求的数据量</li></ol></li><li><ol start="2"><li>减少服务器端扫描的行数</li></ol></li></ul></li><li>重构查询方式<ul><li>1.切分大查询</li><li>2.分解大连接查询</li></ul></li></ul><p>参考</p><ul><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2">https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2</a></li><li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236">https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236</a></li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/wghadf">https://www.yuque.com/snailclimb/mf2z3k/wghadf</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容01</title>
    <link href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/"/>
    <url>/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>基础架构</li><li>日志系统</li><li>事务隔离</li><li>MySQL索引</li><li>锁机制</li><li>explain</li></ul><h3 id="1、基础架构"><a href="#1、基础架构" class="headerlink" title="1、基础架构"></a>1、基础架构</h3><p>MySQL的逻辑架构可以从上到下分为几个主要层次：</p><ul><li>客户端层<ul><li>包括了用户的接口，如命令行客户端和图形用户界面（GUI）</li></ul></li><li>服务层<ul><li>连接处理：管理客户端和服务器之间的连接，包括身份认证。</li><li>SQL接口：接收SQL命令，并且返回查询结果。</li><li>解析器：将SQL语句分解成可以理解和执行的部分。</li><li>优化器：决定最佳的查询路径。</li><li>缓存&#x2F;缓冲：存储数据，以便更快地访问。</li></ul></li><li>存储引擎层<ul><li>负责MySQL中数据的存储和提取。</li><li>MySQL的存储引擎是可插拔的，最常见的如InnoDB（支持事务和行级锁定）和MyISAM（支持全文搜索但不支持事务）。</li></ul></li><li>存储层<ul><li>实际存储数据的地方</li><li>包括数据文件、索引文件等</li></ul></li></ul><p>每一层在MySQL的运行中扮演着关键角色，并且它们共同工作以处理和存储数据。<br>客户端层接收用户输入的SQL查询，服务层对这些查询进行处理和优化，存储引擎层执行这些查询并通过存储层对数据进行物理存储和修改。</p><blockquote><p>餐厅与数据库</p></blockquote><p>现在，让我们用一个类比来帮助理解。想象MySQL是一家餐厅：</p><p>客户端层像是餐厅的顾客，他们点菜（发送SQL查询）。</p><p>服务层是服务员，他们接收订单，解释顾客的需求（解析SQL），并决定如何最有效地准备食物（优化查询）。<br>存储引擎层像是厨师，根据服务员给出的订单来准备食物（执行SQL查询）。</p><p>存储层则是冰箱和储藏室，存储着所有食材（数据）。</p><p>在这个过程中，每个员工和每个存储区都必须协调一致，以确保食物（数据）的质量和服务的效率。</p><blockquote><p>默认存储引擎</p></blockquote><p>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><blockquote><p>Server层和存储引擎层</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312221022103.png" alt="image.png|600"></p><p>将这个描述与上面的类比结合起来，可以这样理解：</p><ol><li><strong>Server层</strong>：<ul><li>这一层可以被视为餐厅的前台和服务区域。</li><li><strong>连接器</strong>：餐厅的接待台，负责迎接顾客（建立客户端连接）。</li><li><strong>查询缓存</strong>：已经准备好的菜肴，可以立即提供给顾客，无需再次等待厨师准备（缓存之前的查询结果）。</li><li><strong>分析器</strong>：服务员听顾客点菜并确认菜单上有这道菜（解析SQL查询，检查语法）。</li><li><strong>优化器</strong>：服务员决定为顾客服务的顺序，以确保效率（决定查询的最优执行计划）。</li><li><strong>执行器</strong>：服务员将顾客的订单传达给厨师并确保菜肴能够按要求出品（执行查询）。</li><li>此层包含所有的内置函数，就像餐厅有各种调味品和烹饪方法可供选择。</li><li>跨存储引擎的功能，如存储过程、触发器、视图，都像是餐厅提供的特殊服务，无论使用哪个厨房（存储引擎），都可以提供。</li></ul></li><li><strong>存储引擎层</strong>：<ul><li>这一层相当于餐厅的厨房。</li><li>每个存储引擎都像是一个专门的烹饪区域，有着不同的烹饪技术和设备（如InnoDB支持事务，MyISAM提供全文搜索功能）。</li><li>存储引擎负责数据的物理存储和检索，就像厨师们管理食材并将其制作成菜肴一样。</li></ul></li></ol><blockquote><p>对于SQL的解析和优化</p></blockquote><ul><li><strong>SQL解析</strong>：当服务层接收到客户端层发送的SQL语句后，它首先进行语法检查和解析，将SQL分解为解析树。</li><li><strong>SQL优化</strong>：然后，优化器会评估多个可能的查询执行计划，并选择一个成本最低（通常是执行时间最短）的计划</li></ul><blockquote><p>连接器</p></blockquote><p>建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但如果使用长连接，服务器需要一直分配资源给这些连接（在执行过程中临时使用的内存是管理在连接对象里面），随着时间的推移，如果有很多大的操作，它占用的内存就会越来越大，最终可能会耗尽内存，导致数据库服务崩溃。</p><p>解决这个问题，有两个方法：</p><ol><li><strong>定期断开连接</strong>：就像定期清理手机后台运行的应用，以释放内存，保持手机运行流畅。你可以在数据库中，用完连接后或者执行了一些大查询操作之后，断开连接，下次需要时再重新连接。</li><li><strong>使用mysql_reset_connection</strong>：如果你用的是MySQL 5.7或更高版本，这就像给手机做个快速重启，清除所有运行的程序但不完全关机，这样可以迅速释放内存。<code>mysql_reset_connection</code>命令可以重置连接的状态，但不需要像完全断开连接那样再次进行繁琐的握手和权限验证。</li></ol><blockquote><p>查询缓存</p></blockquote><p>作用：作为查询缓存</p><ol><li>当你执行一个<code>SELECT</code>语句时，MySQL会检查查询缓存。</li><li>如果之前执行过相同的查询（这里的“相同”意味着字节到字节的完全匹配），并且结果已经缓存，MySQL就会立即返回结果，不用再次执行查询。</li><li>查询的文本是缓存的“key”，查询的结果是“value”。</li></ol><p>缺点：</p><ul><li>查询缓存每当表更新时就会失效。如果表经常更新，那么缓存的命中率就会非常低。</li><li>每次表更新，所有相关的缓存都会被清空。这意味着，即使你的查询结果被存入缓存，但如果表一更新，这些结果就会消失。</li></ul><p>因为这些限制，对于那些数据更新频繁的系统，启用查询缓存可能会带来更多的性能开销而不是好处。只有在数据很少变动的情况下，比如某些配置表，查询缓存才可能提高性能。</p><p>如果你还是想要利用查询缓存，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>。这样，只有那些你显式指定为<code>SQL_CACHE</code>的查询才会使用查询缓存，就像这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SQL_CACHE * <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> ID=<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>但是，值得注意的是，从MySQL 8.0版本开始，查询缓存功能被完全移除了。这是因为在实践中，维护查询缓存通常会导致更多的性能问题，而现代的数据库系统有更高效的方式来提高查询性能，比如更好的索引和优化器策略。</p><p>所以，在最新的MySQL版本中，不需要也不能使用查询缓存了。</p><blockquote><p>分析器</p></blockquote><ul><li>词法分析</li><li>语法分析</li></ul><blockquote><p>优化器:  决定查询的最优执行计划</p></blockquote><blockquote><p>执行器：执行查询（操作存储引擎，返回结果）</p></blockquote><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>MySQL 的存储引擎负责MySQL中数据的存储和提取。其中 MySQL的存储引擎是可插拔的，最常见的如InnoDB（支持事务和行级锁定）和MyISAM（支持全文搜索但不支持事务）。</p><p>在 MySQL 中，我们可以使用 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p><p>我们可以使用 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。不同的 MySQL 版本之间的默认存储引擎可能会有差别。</p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><p>MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p><p>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a> 。</p><p>常见的几种 MySQL 存储引擎：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240217210220.png" alt="image.png"></p><blockquote><p>MyISAM 和 InnoDB 两种 MySQL 存储引擎在索引实现上的根本区别</p></blockquote><ol><li><p><strong>InnoDB 的索引和数据存储方式</strong>：InnoDB 使用的是一种称为聚集索引（Clustered Index）的结构，其中数据表是按照主键顺序存储和组织的，这就意味着表数据本身就是索引的一部分。因此，InnoDB 的数据文件本身就充当了索引的角色，叶节点包含了实际的表数据。这种方式的优点是访问主键索引非常快，但缺点是次级索引（非主键索引）需要存储主键的值来引用实际的数据行。</p></li><li><p><strong>MyISAM 的索引和数据存储方式</strong>：与 InnoDB 不同，MyISAM 将索引和数据存储在分开的文件中。它使用非聚集索引，索引文件仅存储数据记录的地址。这意味着无论是主键索引还是次级索引，MyISAM 都需要进行额外的查找步骤来定位实际的数据记录。这种方式的优点是简化了索引的管理，尤其是对于非主键索引的操作；但缺点是访问数据可能需要更多的磁盘I&#x2F;O，尤其是对主键的查询。</p></li></ol><p>简而言之，InnoDB 的数据文件就是按 B+Tree 组织的聚集索引，数据直接存储在索引的叶节点中，而 MyISAM 使用分离的文件存储数据和索引，索引文件中存储的是指向数据文件中记录的指针。这两种不同的实现方式影响了数据访问的性能和存储效率。</p><hr><h3 id="2、日志系统"><a href="#2、日志系统" class="headerlink" title="2、日志系统"></a>2、日志系统</h3><p>MySQL的日志系统是其核心功能之一，就像黑匣子一样，记录了发生在数据库中的所有关键活动。它包括多种类型的日志，每种日志记录不同类型的信息，对于数据库的恢复、优化和故障排除都至关重要。</p><p>下面是MySQL日志系统中最重要的几种日志类型：</p><ul><li>错误日志</li><li>查询日志（通用查询日志）</li><li>二进制日志（binlog）</li><li>慢查询日志</li><li>中继日志（Relay Log）</li><li>InnoDB重做日志（Redo Log）</li><li>InnoDB回滚日志（Undo Log）</li></ul><blockquote><p>错误日志</p></blockquote><p>错误日志就像是医生的诊断记录，它记录MySQL服务器启动、运行或停止时遇到的问题。如果数据库出现问题，这是第一个要查看的地方。这里会有关于任何错误的详细信息，包括服务启动失败的原因。</p><blockquote><p>查询日志（通用查询日志）</p></blockquote><p>查询日志记录了所有对MySQL服务器的请求，无论这些请求是否得到了执行。可以把它看作是商店的客流记录器，记录每一个进门的顾客及其请求的商品。</p><p>由于记录了所有活动，包括每条SQL语句的文字记录，这个日志很容易变得非常大，因此在高负载系统中通常不推荐开启。</p><blockquote><p>二进制日志（binlog）</p></blockquote><p>二进制日志是数据库活动的详细记录，包括所有修改数据或可能修改数据的语句（如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）。可以将二进制日志视为飞机的黑匣子，记录飞行过程中的所有重要事件。</p><p>它对于复制和数据恢复是必不可少的，因为它可以用来在另一台服务器上重放数据更改，或者在数据丢失后恢复数据。</p><blockquote><p>慢查询日志</p></blockquote><p>慢查询日志记录执行时间超过特定时长的查询。</p><p>将其想象为监控摄像头，特别关注那些在商店里逗留时间过长的顾客。这对于发现那些需要优化的查询非常有帮助。</p><blockquote><p>中继日志（Relay Log）</p></blockquote><p>在MySQL复制设置中，从服务器上的中继日志记录了从主服务器接收到的所有二进制日志事件。</p><p>从服务器上的复制子系统会读取这些日志，并应用到从服务器的数据库中。这类似于接力赛中，接力棒在运动员之间传递的过程。</p><blockquote><p>InnoDB重做日志（Redo Log）</p></blockquote><p>InnoDB存储引擎专用的日志，它记录了导致数据库状态改变的所有操作，确保在系统崩溃后能够恢复数据。</p><p>可以把它看作是飞机上的飞行记录仪，记录了飞行中所有的操作，以便在事故后重建发生了什么。</p><blockquote><p>InnoDB回滚日志（Undo Log）</p></blockquote><p>回滚日志是InnoDB用来处理事务的，它记录了数据的旧版本，使得数据库能够“回滚”到以前的状态。</p><p>可以把它比作是时光机，能够把事情恢复到过去某个时间点的状态。</p><h4 id="RedoLog-And-binlog"><a href="#RedoLog-And-binlog" class="headerlink" title="RedoLog And  binlog"></a>RedoLog And  binlog</h4><p><strong>InnoDB重做日志（Redo Log）与 二进制日志（binlog）</strong></p><p>我们来看一下InnoDB的重做日志（Redo Log）和二进制日志（binlog）的作用和它们在MySQL中的应用。</p><blockquote><p>InnoDB重做日志（Redo Log）</p></blockquote><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>Redo Log：</strong>重做日志文件大小是固定的，并组成一个循环写入的序列。（有一个擦除点和写入点，文件满的时候需要先擦除再写入）</div><p>在InnoDB存储引擎中，重做日志用于记录对数据库所做的每个写操作，确保在系统崩溃后可以恢复这些操作。</p><p>这个过程类似于传统账本与便笺的使用。想象一下，当店主在便笺上快速记下客户的购买记录，之后在每天结束时，他会将这些记录详细地转移到正式的账本中。便笺上的记录对应于重做日志，而正式账本就像是数据库文件。</p><p>重做日志是循环使用的，有一个固定的大小。当数据库进行写操作时，InnoDB会将操作详情写入重做日志，并标记为准备（prepare）状态。</p><p>随后，在合适的时机，这些操作会被实际应用到磁盘上的数据文件中。</p><p>这种策略允许InnoDB引擎快速响应写操作，因为它不需要每次都同步写入磁盘。</p><hr><p>InnoDB的重做日志（Redo Log）包括两部分：内存中的重做日志缓冲（redo log buffer）和磁盘上的重做日志文件。</p><ol><li><p><strong>重做日志缓冲（Redo Log Buffer）</strong>：这是内存中的一部分，用于暂时存放那些还没有被写入到磁盘重做日志文件的数据。当事务被提交时，事务的重做日志信息首先被写入到这个缓冲区中。</p></li><li><p><strong>重做日志文件（Redo Log Files）</strong>：这些是存放在磁盘上的物理文件，用于持久保存重做日志数据。即使在系统崩溃的情况下，由于这些信息被存储在磁盘上，InnoDB也可以在重启后使用这些日志来恢复数据。</p></li></ol><p>关于重做日志文件的大小，它们是固定的，并且可以通过MySQL的配置文件进行设置。通常，重做日志文件组成一个循环写入的序列，这意味着当最后一个日志文件写满后，系统会回到第一个日志文件开始覆盖旧的日志（这取决于日志的写入位置和检查点的位置）。</p><p>在配置文件（通常是<code>my.cnf</code>或<code>my.ini</code>）中，可以通过以下参数来定义重做日志文件的大小和数量：</p><ul><li><code>innodb_log_file_size</code>：定义单个重做日志文件的大小。</li><li><code>innodb_log_files_in_group</code>：定义重做日志文件组中文件的数量。</li></ul><p>例如，如果你设置<code>innodb_log_file_size</code>为512MB，并且设置<code>innodb_log_files_in_group</code>为4，那么总共会有2GB的重做日志空间可用（512MB * 4 &#x3D; 2048MB或2GB）。</p><p>选择适当的重做日志文件大小是很重要的，因为它会影响数据库的性能和恢复能力。如果重做日志太小，可能会导致频繁的I&#x2F;O操作，因为日志空间会迅速填满并需要频繁地进行日志切换操作。如果太大，恢复过程可能会更慢，因为InnoDB可能需要处理大量的日志数据来恢复状态。通常，这个值应该根据系统的负载和I&#x2F;O能力来调整。</p><blockquote><p>二进制日志（binlog）</p></blockquote><p>二进制日志记录了所有对数据库进行更改的SQL语句。它不是特定于InnoDB的，而是MySQL服务器层面的日志。你可以把它看作是一部摄像机，记录下了发生的所有事件，无论是好是坏。</p><p>在数据库需要恢复或者进行复制设置时，二进制日志是不可或缺的。</p><p>与重做日志不同，二进制日志是逻辑日志，记录的是发生了什么（例如“给ID&#x3D;2的这一行的c字段加1”），而重做日志是物理日志，记录的是在哪个数据页上做了修改。二进制日志是按顺序追加的，并且不会覆盖旧的日志。</p><blockquote><p>两者的协同工作与两阶段提交</p></blockquote><div style="background-color: #ced6e0; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>两阶段提交：</strong>只有在重做日志和二进制日志都被成功写入后，事务才会提交。</div><p>当执行一个更新操作时，InnoDB会先写入重做日志，这个操作会标记为prepare状态。一旦这个操作被写入，即使系统崩溃，这个操作也不会丢失，确保了数据库的crash-safe特性。<strong>只有在重做日志和二进制日志都被成功写入后，事务才会提交</strong>。</p><p>这就引入了所谓的“两阶段提交”：</p><ol><li><strong>准备阶段</strong>：事务的修改先被写入重做日志，并将事务标记为prepare状态。</li><li><strong>提交阶段</strong>：事务的修改被写入二进制日志，然后InnoDB事务会提交，重做日志的状态会变为commit。</li></ol><p>这种机制保证了即使在事务提交过程中发生故障，重做日志和二进制日志的状态也能保持一致。这对于恢复到精确的某一点以及主从复制是必要的，确保了数据的一致性。</p><blockquote><p>应用场景</p></blockquote><p>在应用中，你可以利用重做日志来确保事务的持久性和原子性。</p><p>例如，如果你的系统突然断电或者崩溃，重做日志可以用来恢复未提交的事务，以及确保已提交的事务不会丢失。</p><p>二进制日志主要用于：</p><ul><li><strong>数据复制</strong>：将binlog内容复制到从服务器，从服务器重放这些操作，保持和主服务器的数据一致。</li><li><strong>数据恢复</strong>：当需要将数据库恢复到过去的某个状态时，可以使用全量备份加上二进制日志来达到这个目的。</li></ul><p>两阶段提交保证了在使用重做日志和二进制日志时，系统的状态是一致的，这对于确保数据的准确性和可恢复性非常重要。</p><blockquote><p>思考题： 在什么场景下，一天一备会比一周一备更有优势呢？</p></blockquote><p>日常全量备份相比周备份的优势在于减少了数据丢失的风险。如果发生灾难，你只会丢失一天的数据，而不是一周的。这直接影响了数据库系统的恢复点目标（Recovery Point Objective，RPO），即在数据丢失事件后数据恢复的能力。</p><p>每天备份的RPO明显小于每周备份，因此一天一备的策略更适合对数据准确性要求较高的系统。</p><hr><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1ve411F794">https://www.bilibili.com/video/BV1ve411F794</a></li><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2">https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2</a></li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析</title>
    <link href="/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_ThreadPoolExecutor_2/"/>
    <url>/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_ThreadPoolExecutor_2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Java 构建线程的方式</li><li>线程池的7个参数</li><li>线程池的执行流程</li><li>线程池属性标识</li><li>线程池的 execute 方法执行</li><li>Worker 的封装</li></ul><blockquote><p>从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析</p></blockquote><h3 id="一、Java-构建线程的方式（常识）"><a href="#一、Java-构建线程的方式（常识）" class="headerlink" title="一、Java 构建线程的方式（常识）"></a>一、Java 构建线程的方式（常识）</h3><ul><li>继承 Thread</li><li>实现 Runnable</li><li>实现 Callable</li><li>线程池方式（Java提供了构建线程池的方式）<ul><li>Java提供了 Executors 可以去创建（规范中不允许使用这种方式创建线程池，这种方式对线程的控制粒度比较低）</li><li>推荐手动创建线程池</li></ul></li></ul><h3 id="二、线程池的7个参数（常识）"><a href="#二、线程池的7个参数（常识）" class="headerlink" title="二、线程池的7个参数（常识）"></a>二、线程池的7个参数（常识）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,   <span class="hljs-comment">//核心线程池</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">//最大线程数</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">//最大空闲时间</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,         <span class="hljs-comment">//时间单位</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//阻塞队列</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,        <span class="hljs-comment">//线程工厂</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;   <span class="hljs-comment">//拒绝策略</span><br></code></pre></td></tr></table></figure><h3 id="三、线程池的执行流程（常识）"><a href="#三、线程池的执行流程（常识）" class="headerlink" title="三、线程池的执行流程（常识）"></a>三、线程池的执行流程（常识）</h3><blockquote><p>线程池执行流程</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231221203519.png" alt="image.png"></p><p>为什么要先进阻塞再去尝试创建非核心线程：</p><p>饭店（线程池） - 厨子（线程） - 人多先排队（阻塞队列）- 招厨子（创建最大线程数） - 今日客满（拒绝策略）</p><h3 id="四、线程池属性标识"><a href="#四、线程池属性标识" class="headerlink" title="四、线程池属性标识"></a>四、线程池属性标识</h3><h4 id="4-1-线程池属性"><a href="#4-1-线程池属性" class="headerlink" title="4.1 线程池属性"></a>4.1 线程池属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ctl 是一个int 类型的数值，表达了两个意思，1：声明当前线程池的状态, 2: 声明线程池中的线程数</span><br><span class="hljs-comment">//高3位是：线程池状态</span><br><span class="hljs-comment">//低29位是： 线程池中的线程个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;  <span class="hljs-comment">//29，方便后面做位运算</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;   <span class="hljs-comment">//通过位运算得出最大容量</span><br>  <br><span class="hljs-comment">// runState is stored in the high-order bits  </span><br><span class="hljs-comment">//线程池状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//111 代表线程池为RUNNING，代表正常接收任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//000 代表线程池为`SHUTDOWN`状态，不接收新任务，但是内部还会处理阻塞队列中的任务，正在进行的任务也正常处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//001  代表线程池为`STOP`状态，不接收新任务，也不去处理阻塞队列中的任务，同时会中断正在执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//010 代表线程池为`TIDYING`状态，过渡的状态，代表当前线程池即将Game Over</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//011 代表线程池为`TERMINATED`，要执行terminated(),真的凉凉了</span><br>  <br><span class="hljs-comment">// Packing and unpacking ctl  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;  <span class="hljs-comment">//得到线程池的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;   <span class="hljs-comment">//得到当前线程池的线程数量</span><br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code>类使用了一些高级的位操作来高效地管理线程池的状态和工作线程的数量。</p><blockquote><p>核心变量解释</p></blockquote><ul><li><code>AtomicInteger ctl</code><ul><li>实际它是使用了 <code>AtomicInteger ctl</code> 这个变量来进行存储线程池的状态和线程数。原子操作保证了线程安全，即在多线程环境下，对这个变量的修改是原子性的，避免了竞态条件。</li><li>高3位是：线程池状态</li><li>低29位是： 线程池中的线程个数</li></ul></li><li><code>COUNT_BITS</code><ul><li>用于计算和存储线程数量的位数。它是<code>Integer.SIZE</code>（Java中整数的位数，通常是32位）减去3。</li><li>29，方便后面做位运算;3位用于表示线程池状态</li></ul></li><li><code>CAPACITY</code><ul><li>表示的最大线程数。它通过将1左移<code>COUNT_BITS</code>位然后减1来计算。</li><li>类似 100000000 - 1 &#x3D; 011111111111 这种，是常见的位运算的一种表示方式</li></ul></li></ul><blockquote><p>线程池状态</p></blockquote><p>线程池的状态被存储在<code>ctl</code>的高位。这些状态包括：</p><ul><li><strong><code>RUNNING</code></strong><ul><li>111</li><li>线程池可以接受新任务，并且也可以处理排队的任务。</li></ul></li><li><strong><code>SHUTDOWN</code></strong><ul><li>000</li><li>不接受新任务，但是可以处理排队的任务。</li></ul></li><li><strong><code>STOP</code></strong><ul><li>001</li><li>不接受新任务，不处理排队的任务，并且中断正在进行的任务。</li></ul></li><li><strong><code>TIDYING</code></strong><ul><li>010</li><li>所有任务都已终止，workerCount（活动线程数）为零，线程池正在转换到状态<code>TERMINATED</code>。</li></ul></li><li><strong><code>TERMINATED</code></strong><ul><li>011</li><li><code>terminated()</code>方法已经完成</li></ul></li></ul><blockquote><p>位操作方法</p></blockquote><ul><li><strong><code>runStateOf(int c)</code></strong>: 提取<code>ctl</code>中的状态部分。</li><li><strong><code>workerCountOf(int c)</code></strong>: 提取<code>ctl</code>中的工作线程数部分。</li><li><strong><code>ctlOf(int rs, int wc)</code></strong>: 将运行状态和工作线程数组合成一个<code>ctl</code>值</li></ul><h4 id="4-2-线程池状态变化"><a href="#4-2-线程池状态变化" class="headerlink" title="4.2 线程池状态变化"></a>4.2 线程池状态变化</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231222005453.png" alt="image.png"></p><h3 id="五、线程池的-execute-方法执行"><a href="#五、线程池的-execute-方法执行" class="headerlink" title="五、线程池的 execute 方法执行"></a>五、线程池的 execute 方法执行</h3><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>execute</code>方法是用于提交任务的关键方法。</p><p>它决定如何将一个新的<code>Runnable</code>任务添加到线程池中。</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>(<span class="hljs-params">Runnable command</span>)</span> &#123;<br>    <span class="hljs-comment">// 检查提交的任务不是null</span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>    <span class="hljs-comment">// 获取当前线程池状态和工作线程数</span><br>    <span class="hljs-built_in">int</span> c = ctl.<span class="hljs-keyword">get</span>();<br><br>    <span class="hljs-comment">// 如果当前工作线程数小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 尝试添加一个新工作线程来执行这个任务</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果成功，直接返回</span><br>        <span class="hljs-comment">// 如果添加工作线程失败，重新获取线程池状态</span><br>        c = ctl.<span class="hljs-keyword">get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果线程池处于运行状态，且任务能被添加到队列中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">// 重新检查线程池状态</span><br>        <span class="hljs-built_in">int</span> recheck = ctl.<span class="hljs-keyword">get</span>();<br>        <span class="hljs-comment">// 如果线程池不再运行，并且能从队列中移除任务，则拒绝任务</span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="hljs-keyword">remove</span>(command))<br>            reject(command);<br>        <span class="hljs-comment">// 如果没有活动的工作线程，则添加一个新的工作线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果任务不能被添加到队列，尝试创建一个新工作线程来执行这个任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command); <span class="hljs-comment">// 如果创建失败，则拒绝任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现步骤：</p><ol><li><strong>参数检查</strong>: 首先检查传入的<code>Runnable</code>对象不是<code>null</code>。</li><li><strong>工作线程数量检查</strong>: 如果当前工作线程的数量小于核心线程数<code>corePoolSize</code>，尝试直接创建一个新的工作线程来执行任务。</li><li><strong>任务队列处理</strong>: 如果当前线程数已经达到或超过核心线程数，或者新工作线程的创建失败，则尝试将任务加入到等待队列中。</li><li><strong>状态重新检查</strong>: 在成功将任务加入队列后，需要再次检查线程池的状态，确保线程池仍在运行。如果线程池状态改变（例如，被关闭了），则尝试移除刚加入的任务，并执行拒绝策略。</li><li><strong>无活动线程处理</strong>: 如果任务被成功加入队列，但没有活动的工作线程可以处理队列中的任务，这时会尝试创建一个新的工作线程。</li><li><strong>拒绝策略</strong>: 如果无法将任务加入队列，且无法创建新的工作线程，最后的选项是拒绝任务。</li></ol><h4 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker 方法"></a>addWorker 方法</h4><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>addWorker</code>方法是用于向线程池中添加新的工作线程的关键方法。</p><p>它在处理新任务或者需要增加线程池中的线程数量时被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取当前线程池的控制状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// 检查线程池的状态是否允许添加新的工作线程</span><br>        <span class="hljs-comment">// 仅在以下情况返回false：</span><br>        <span class="hljs-comment">// 1. 线程池状态为SHUTDOWN以上（不包括SHUTDOWN）且不满足以下所有条件：</span><br>        <span class="hljs-comment">//    - 状态为SHUTDOWN</span><br>        <span class="hljs-comment">//    - firstTask为null</span><br>        <span class="hljs-comment">//    - 工作队列不为空</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            !(rs == SHUTDOWN &amp;&amp;<br>              firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>              !workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 无限循环，尝试增加工作线程的数量</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-comment">// 检查当前工作线程数是否超过了最大容量或设置的阈值</span><br>            <span class="hljs-comment">// 如果超过容量或者超过corePoolSize/maximumPoolSize，则返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 使用CAS操作增加工作线程计数</span><br>            <span class="hljs-comment">// 如果CAS成功，跳出retry标签，继续向下执行</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 如果CAS失败，重新读取ctl</span><br>            c = ctl.get(); <br>            <span class="hljs-comment">// 如果运行状态发生变化，重新开始外层循环</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果CAS失败但运行状态没有变化，继续尝试内层循环的CAS操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加工作线程的过程</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建新的工作线程</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-comment">// 如果成功创建线程</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 在持有锁的情况下再次检查线程池状态</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-comment">// 如果线程池状态允许添加工作线程，则将其添加到工作集合中</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// 检查线程是否已经启动（预防异常情况）</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新记录的最大池大小</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 如果成功添加工作线程，则启动该线程</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果工作线程未能成功启动，处理失败情况</span><br>        <span class="hljs-keyword">if</span> (!workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-comment">// 返回工作线程是否成功启动</span><br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现步骤：</p><ol><li><strong>状态检查</strong>: 首先检查线程池的状态，确定是否可以添加新的工作线程。如果线程池正在关闭，并且条件不允许添加工作线程（例如，任务队列为空），则直接返回<code>false</code>。</li><li><strong>增加工作线程数</strong>: 使用一个无限循环，通过CAS（Compare-And-Swap）操作尝试增加工作线程计数。如果CAS操作成功，跳出循环；如果失败，重新尝试。</li><li><strong>创建和启动工作线程</strong>: 创建一个新的<code>Worker</code>对象，并尝试启动其线程。这个过程涉及获取一个全局锁以保证线程安全。</li><li><strong>线程池状态再次检查</strong>: 在锁内部再次检查线程池的状态，以确保在获取锁的过程中状态没有改变。</li><li><strong>添加到工作集合</strong>: 如果一切正常，将新的<code>Worker</code>添加到工作线程集合中，并更新记录的最大池大小。</li><li><strong>启动线程</strong>: 尝试启动线程。如果启动成功，返回<code>true</code>；否则，在<code>finally</code>块中处理启动失败的情况。</li></ol><p><code>addWorker</code>方法的实现体现了线程池如何有效地管理线程的创建和添加。</p><p>使用CAS操作保证了线程安全，而双重检查（在方法开始和持有锁时）确保了即使在高并发的情况下也能正确地管理线程池的状态。</p><h3 id="六、Worker-的封装"><a href="#六、Worker-的封装" class="headerlink" title="六、Worker 的封装"></a>六、Worker 的封装</h3><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>Worker</code>是一个关键的内部类，它封装了线程池中的工作线程的行为和属性。</p><p><code>Worker</code>类继承自<code>AbstractQueuedSynchronizer</code>，是一个用于构建锁和其他同步组件的框架</p><h4 id="ThreadPoolExecutor内部类Worker的构造函数"><a href="#ThreadPoolExecutor内部类Worker的构造函数" class="headerlink" title="ThreadPoolExecutor内部类Worker的构造函数"></a><code>ThreadPoolExecutor</code>内部类<code>Worker</code>的构造函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Worker(Runnable firstTask) &#123;<br>    <span class="hljs-comment">// 设置Worker的状态为-1，暂时阻止线程中断</span><br>    <span class="hljs-comment">// 这是为了防止在Worker真正开始运行前被中断</span><br>    setState(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 将传入的任务（可能为null）设置为Worker的第一个任务</span><br>    <span class="hljs-comment">// 这个任务将是Worker创建后执行的第一个任务</span><br>    <span class="hljs-keyword">this</span>.firstTask = firstTask;<br><br>    <span class="hljs-comment">// 使用线程池的线程工厂创建一个新线程，并将当前Worker作为任务传递给这个新线程</span><br>    <span class="hljs-comment">// 这里，Worker自身实际上是一个Runnable，因为它实现了Runnable接口</span><br>    <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码分析：</p><ol><li><strong>暂时禁用中断</strong>: <code>setState(-1)</code>设置Worker的状态，这个状态用于控制线程的中断。设置为-1意味着在<code>runWorker</code>方法真正开始执行之前，线程不应被中断。这是一个预防措施，以确保Worker在开始执行其任务前不会被意外中断。</li><li><strong>设置第一个任务</strong>: <code>this.firstTask = firstTask</code>将传入的任务赋值给Worker的<code>firstTask</code>属性。这个任务是Worker将要执行的第一个任务。如果这个值是<code>null</code>，Worker将从线程池的任务队列中获取任务。</li><li><strong>创建新线程</strong>: <code>this.thread = getThreadFactory().newThread(this)</code>调用线程工厂来创建一个新线程，并将当前Worker作为运行任务传递。由于Worker实现了<code>Runnable</code>接口，它可以被线程直接执行。线程工厂是线程池的一个组成部分，用于定制线程创建过程（例如设置线程名称、优先级等）。</li></ol><h4 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h4><p>定义了线程池中的工作线程（<code>Worker</code>）如何执行任务</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> runWorker(Worker w) &#123;<br>    <span class="hljs-comment">// 获取当前执行这个方法的线程</span><br>    Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">// 从Worker获取第一个任务</span><br>    Runnable <span class="hljs-keyword">task</span> = w.firstTask;<br>    <span class="hljs-comment">// 设置Worker的第一个任务为null</span><br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 释放Worker上的锁，允许中断</span><br>    w.unlock(); <br><br>    <span class="hljs-comment">// 标记是否异常完成任务</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当有任务执行或者能从任务队列中获取到任务时，继续循环</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">task</span> != <span class="hljs-keyword">null</span> || (<span class="hljs-keyword">task</span> = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 锁定Worker，以开始执行任务</span><br>            w.lock();<br>            <span class="hljs-comment">// 如果线程池正在停止，确保线程被中断；</span><br>            <span class="hljs-comment">// 如果不是，则确保线程不被中断。这需要在第二种情况下重新检查以处理shutdownNow竞争状态</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 在执行任务前的钩子方法</span><br>                beforeExecute(wt, <span class="hljs-keyword">task</span>);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 运行任务</span><br>                    <span class="hljs-keyword">task</span>.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 在执行任务后的钩子方法</span><br>                    afterExecute(<span class="hljs-keyword">task</span>, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 任务执行完毕，清理工作</span><br>                <span class="hljs-keyword">task</span> = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果正常退出循环，设置completedAbruptly为false</span><br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 处理Worker退出</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行步骤：</p><ol><li><strong>初始化</strong>: 首先获取当前线程和Worker中的第一个任务。解锁Worker以允许线程中断。</li><li><strong>任务执行循环</strong>: 方法进入一个循环，不断执行任务。如果Worker的第一个任务为空，则尝试从线程池的任务队列中获取新的任务。</li><li><strong>中断管理</strong>: 在每次任务执行前，检查线程池的状态，如果需要，根据线程池的状态来决定是否中断当前线程。</li><li><strong>任务执行</strong>: 实际执行任务，并处理任何可能抛出的异常。同时，执行钩子方法<code>beforeExecute</code>和<code>afterExecute</code>，这些方法可以用于在任务执行前后做一些准备和清理工作。</li><li><strong>任务完成后处理</strong>: 更新完成任务的计数，清理变量，解锁Worker。</li><li><strong>异常处理与退出</strong>: 如果任务执行过程中发生异常导致线程意外结束，<code>completedAbruptly</code>标记会保持为<code>true</code>。在最后的<code>finally</code>块中，调用<code>processWorkerExit</code>来处理Worker的退出，这可能包括替换这个Worker或者根据当前线程池状态进行其他处理。</li></ol><hr><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1244y1n7bz">https://www.bilibili.com/video/BV1244y1n7bz</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_进阶内容</title>
    <link href="/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>进阶内容学习</p></blockquote><ul><li>Redis事务</li><li>Redis性能优化</li><li>Redis生产问题</li><li>Redis集群</li><li>Redis使用规范</li></ul><h3 id="1、Redis-事务"><a href="#1、Redis-事务" class="headerlink" title="1、Redis 事务"></a>1、Redis 事务</h3><p>to be contined….</p><h3 id="2、Redis-性能优化"><a href="#2、Redis-性能优化" class="headerlink" title="2、Redis 性能优化"></a>2、Redis 性能优化</h3><h4 id="2-1-使用批量操作减少网络传输"><a href="#2-1-使用批量操作减少网络传输" class="headerlink" title="2.1  使用批量操作减少网络传输"></a>2.1  使用批量操作减少网络传输</h4><h4 id="2-2-大量-key-集中过期问题"><a href="#2-2-大量-key-集中过期问题" class="headerlink" title="2.2 大量 key 集中过期问题"></a>2.2 大量 key 集中过期问题</h4><h4 id="2-3-大-Key"><a href="#2-3-大-Key" class="headerlink" title="2.3 大 Key"></a>2.3 大 Key</h4><h4 id="2-4-热-Key"><a href="#2-4-热-Key" class="headerlink" title="2.4 热 Key"></a>2.4 热 Key</h4><h4 id="2-5-慢查询问题"><a href="#2-5-慢查询问题" class="headerlink" title="2.5  慢查询问题"></a>2.5  慢查询问题</h4><h4 id="2-6-Redis-内存碎片"><a href="#2-6-Redis-内存碎片" class="headerlink" title="2.6 Redis 内存碎片"></a>2.6 Redis 内存碎片</h4><blockquote><p>什么是内存碎片</p></blockquote><p>内存碎片是不可用的空闲内存, </p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240202075109.png" alt="image.png|500"></p><blockquote><p>Redis 为什么会有内存碎片</p></blockquote><p>常见的两个原因：</p><ul><li><ol><li><strong>Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></li></ol></li><li><ol start="2"><li><strong>频繁修改 Redis 中的数据也会产生内存碎片。</strong></li></ol></li></ul><p>Redis 的内存碎片化是指随着 Redis 运行时间的增长和数据的频繁更新，内存分配和释放可能导致可用内存被分割成小块，从而降低了内存的利用效率。内存碎片化在 Redis 中是一个重要的问题，因为它可以影响性能并导致内存使用量不必要地增加。</p><blockquote><p>何时产生内存碎片</p></blockquote><ol><li><p><strong>频繁的小对象分配和释放</strong>：</p><ul><li>当应用频繁地创建和删除小对象时，如频繁地设置和删除键值对。</li><li>这种操作会导致内存中出现很多小的、不连续的空间，造成碎片。</li></ul></li><li><p><strong>特定的数据类型操作</strong>：</p><ul><li>某些数据类型的操作，如对列表、集合和哈希的频繁修改，也可能导致内存碎片化。</li></ul></li><li><p><strong>大量写入后的删除</strong>：</p><ul><li>当大量数据被写入 Redis 并且之后又被删除时，尤其是这些数据的大小不一时。</li></ul></li></ol><blockquote><p>如何处理和减少内存碎片化</p></blockquote><ol><li><p><strong>监控内存碎片率</strong>：</p><ul><li>使用 <code>INFO memory</code> 命令监控内存碎片率（<code>mem_fragmentation_ratio</code>）。如果碎片率高（例如大于 1.5），则可能需要采取措施。</li></ul></li><li><p><strong>定期重启</strong>：</p><ul><li>定期重启 Redis 服务可以减少碎片化，但这可能会导致服务中断。</li></ul></li><li><p><strong>内存碎片整理</strong>：</p><ul><li>在 Redis 4.0 及以上版本中，可以使用 <code>MEMORY PURGE</code> 命令（在某些版本中可用）来尝试减少内存碎片。</li><li>使用 <code>redis-cli --intrinsic-latency</code> 命令检测内存碎片整理过程中的延迟。</li></ul></li><li><p><strong>使用更大的对象</strong>：</p><ul><li>对于高频操作的数据，考虑将多个小对象合并成一个更大的对象。</li></ul></li><li><p><strong>调整内存分配器配置</strong>：</p><ul><li>调整 Jemalloc 分配器的配置，可能有助于减少碎片化。</li></ul></li><li><p><strong>应用层优化</strong>：</p><ul><li>在应用层优化数据访问模式，减少频繁的小对象写入和删除。</li></ul></li><li><p><strong>数据结构选择</strong>：</p><ul><li>根据使用场景合理选择数据结构，有些数据结构可能更容易产生内存碎片。</li></ul></li></ol><blockquote><p>实际业务场景下的应对策略</p></blockquote><p>在实际业务中，需要根据具体的使用场景和数据模式来确定最佳的处理内存碎片化的策略。通常，需要定期监控 Redis 的内存碎片率，并在碎片化达到一定程度时采取相应措施。例如，可以在业务低峰期进行 Redis 的重启或内存碎片整理，以减少对业务的影响。同时，优化数据访问模式和选择合适的数据结构，也可以在长期内有效减少内存碎片化的发生。</p><h3 id="3、Redis-生产问题"><a href="#3、Redis-生产问题" class="headerlink" title="3、Redis 生产问题"></a>3、Redis 生产问题</h3><div style="background-color: #f2c867; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>Redis 生产问题：</strong>缓存穿透、缓存击穿、缓存雪崩、数据一致性、Redis 阻塞</div><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询不存在的数据。由于这些数据不在缓存中，每次查询都会穿过缓存，直接访问数据库。</p><p>如果有大量此类查询，<strong>数据库可能会因此承受过大的压力</strong>。</p><blockquote><p>成因</p></blockquote><ul><li>频繁查询不存在的数据（可能是由于错误的输入或恶意攻击）。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>空对象缓存</strong>：即使某个值在数据库中不存在，也可以在缓存中存储一个特殊的空对象或空值，并设置较短的过期时间。</li><li><strong>布隆过滤器</strong>：在查询之前使用布隆过滤器判断数据是否可能存在。布隆过滤器是一种空间效率高但可能有一定误判率的数据结构。</li></ul><p>布隆过滤器： <a href="https://mp.weixin.qq.com/s/DeqJfw51tPJvdwAkq3iPdg">https://mp.weixin.qq.com/s/DeqJfw51tPJvdwAkq3iPdg</a></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指某个热点数据（即被频繁访问的数据）在缓存中失效的瞬间，大量请求同时涌向数据库。</p><blockquote><p>成因</p></blockquote><ul><li>热点数据在缓存中突然过期，而此时正有大量并发请求这些数据。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>设置热点数据永不过期</strong>：对于一些极其热门的数据，可以设置为永不过期。</li><li><strong>互斥锁</strong>：在缓存失效的瞬间，使用互斥锁或分布式锁，确保只有一个请求去数据库查询数据并重新缓存。</li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指缓存中大量数据同时过期，导致所有的请求都直接访问数据库，可能会使数据库压力过大甚至崩溃。</p><blockquote><p>成因</p></blockquote><ul><li>缓存设置了相同的过期时间，导致大量数据同时过期。</li><li>缓存服务崩溃，所有数据丢失。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>不同的过期时间</strong>：为缓存数据设置不同的过期时间，避免同时过期。</li><li><strong>缓存数据预热</strong>：系统启动时预先加载热点数据到缓存中。</li><li><strong>使用高可用的缓存架构</strong>：比如使用Redis集群，提高缓存系统的稳定性和容错能力。</li></ul><h4 id="如何保证缓存和数据库的数据一致性"><a href="#如何保证缓存和数据库的数据一致性" class="headerlink" title="如何保证缓存和数据库的数据一致性"></a>如何保证缓存和数据库的数据一致性</h4><p>阅读：</p><ul><li>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a>。</li></ul><p>不推荐更新数据库 + 更新缓存的方案：</p><ul><li>写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中</li></ul><blockquote><p>缓存和数据库不一致</p></blockquote><p>一般是采用：Cache Aside Pattern（旁路缓存模式）: 遇到写请求的时候是先更新数据库，再删除 cache</p><p>这种情况下发生数据不一致的情况比较小，</p><p>在这种情况下，在数据库更新和缓存删除之间有读取请求，它也只会读到旧的数据，一旦缓存被删除，下一个读取请求将从数据库中获取最新的数据，并更新缓存，从而保持了一致性。</p><p>需要避免缓存和数据库不一致需要考虑的点：避免第二步操作【删除 cache】失败</p><p>解决方案：</p><ol><li>缓存失效时间变短（不推荐，治标不治本）<ol><li>我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li></ol></li><li>增加 cache 更新重试机制（常用）<ol><li>如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol></li></ol><p>第二种方式采用方案：</p><ol><li>引入消息队列来进行异步重试操作（将删除 cache 操作放在消费者这步操作） </li><li>订阅数据库变更日志，再操作缓存</li></ol><hr><h4 id="哪些情况可能导致-Redis-阻塞"><a href="#哪些情况可能导致-Redis-阻塞" class="headerlink" title="哪些情况可能导致 Redis 阻塞"></a>哪些情况可能导致 Redis 阻塞</h4><h3 id="4、Redis-集群"><a href="#4、Redis-集群" class="headerlink" title="4、Redis 集群"></a>4、Redis 集群</h3><p>看一下这篇文字： <a href="https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k">https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k</a></p><p>里面讲述了从 主从节点复制 →  哨兵机制 Sentinel  → Redis 集群Cluster （自动配置了哨兵模式，且建议至少一主一从节点，三个主节点以上的单数节点集群模式）</p><h3 id="5、Reids-使用规范"><a href="#5、Reids-使用规范" class="headerlink" title="5、Reids 使用规范"></a>5、Reids 使用规范</h3><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/redis/redis-questions-02.html">https://javaguide.cn/database/redis/redis-questions-02.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RocketMQ_安装与使用</title>
    <link href="/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下载地址： <a href="https://rocketmq.apache.org/download/">https://rocketmq.apache.org/download/</a></p><p>这里下载 4.8.0 版本：<a href="https://rocketmq.apache.org/release-notes/2020/12/21/4.8.0">Release Notes - Apache RocketMQ - Version 4.8.0 | RocketMQ</a></p><p>选择Binary 进行下载。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312211150403.png" alt="image.png"></p><blockquote><p>NameServer</p></blockquote><p>注册中心，用于管理 Broker</p><blockquote><p>Broker</p></blockquote><p>用来保持 Topic 主题的信息，接收生产者的消息。</p><h4 id="搭建可视化监控平台"><a href="#搭建可视化监控平台" class="headerlink" title="搭建可视化监控平台"></a>搭建可视化监控平台</h4><p>rocketmq-dashboard是RocketMQ的一个拓展开源项目，可以对MQ进行可视化监控。 </p><p>下载地址： <a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a></p><h4 id="RocketMQ的基本使用"><a href="#RocketMQ的基本使用" class="headerlink" title="RocketMQ的基本使用"></a>RocketMQ的基本使用</h4><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/xianren95/article/details/121924194">https://blog.csdn.net/xianren95/article/details/121924194</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ul><li>接口中默认方法与静态方法</li><li>函数式接口（Functional Interface）</li><li>Lambda表达式（Lambda Expressions）</li><li>流API（Streams API）</li><li>Optional 类</li><li>新的日期时间API（New Date-Time API）</li></ul><h3 id="1、接口中默认方法与静态方法"><a href="#1、接口中默认方法与静态方法" class="headerlink" title="1、接口中默认方法与静态方法"></a>1、接口中默认方法与静态方法</h3><p>在Java 8之前，接口只能有方法声明，而不能有方法实现。这意味着一旦接口被更改（比如添加新方法），所有实现了该接口的类都必须随之修改以实现新添加的方法。</p><p>Java 8引入的<code>default</code>和<code>static</code>方法正是为了解决这个问题。</p><blockquote><p><code>default</code> 方法</p></blockquote><ul><li><p><strong>作用</strong>: <code>default</code>方法允许我们在接口中添加有具体实现的非抽象方法。这意味着实现接口的类可以不用实现这些<code>default</code>方法。</p></li><li><p><strong>用途</strong>: 这对于向现有接口添加新功能非常有用，因为它不会破坏实现该接口的现有类的功能。</p></li><li><p><strong>类比</strong>: 想象一下，有一个标准的建筑蓝图（接口）。突然，需要在所有这样的建筑中添加一个新的功能（比如中央供暖）。<code>default</code>方法就像是一个标准的中央供暖系统设计，可以直接加入到现有的蓝图中，而不需要重新设计整个建筑。</p></li></ul><blockquote><p><code>static</code> 方法</p></blockquote><ul><li><p><strong>作用</strong>: <code>static</code>方法允许我们在接口中添加静态方法。这些方法可以直接通过接口来调用，而不需要一个接口的实例。</p></li><li><p><strong>用途</strong>: <code>static</code>方法通常用于提供一些与接口相关的工具方法。</p></li><li><p><strong>类比</strong>: 如果接口是一种服务的标准（比如邮寄服务），那么<code>static</code>方法就像是可以直接从服务标准本身获得的额外帮助或工具，如一个在线邮资计算器。</p></li></ul><p>具体使用示例</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 一个默认方法</span><br>    <span class="hljs-keyword">default</span> void <span class="hljs-keyword">new</span><span class="hljs-type">Method</span>() &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a default method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个静态方法</span><br>    <span class="hljs-keyword">static</span> void anotherNewMethod() &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类</span><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyInterface</span></span> </span>&#123;<br>    <span class="hljs-comment">// 不需要实现newMethod()</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> <span class="hljs-type">MyClass</span>();<br>        myClass.<span class="hljs-keyword">new</span><span class="hljs-type">Method</span>(); <span class="hljs-comment">// 调用默认方法</span><br><br>        MyInterface.anotherNewMethod(); <span class="hljs-comment">// 直接调用接口的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code>实现了<code>MyInterface</code>但没有实现<code>newMethod()</code>方法，因为它是一个默认方法。</p><p>同时，可以直接通过<code>MyInterface</code>调用静态方法<code>anotherNewMethod()</code>。</p><hr><p>有一种情况需要重写 default 的接口方法，注意一下，示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceNew</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sm</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface提供的方式实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sm2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface提供的方式实现&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface default方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface default2方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//须要实现类重写</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceNew1</span> &#123;<br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;InterfaceNew1 default方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。</p><p>不然的话，编译的时候就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceNewImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceNew</span> , <span class="hljs-title class_">InterfaceNew1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">InterfaceNewImpl</span> interfaceNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterfaceNewImpl</span>();<br>        interfaceNew.<span class="hljs-title function_">def</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">InterfaceNew1</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">def</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>Java8中，接口和抽象类的区别</p></blockquote><ul><li>interface 和 class 的区别，主要有：<ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li>interface 的方法是<strong>更像是一个扩展插件</strong>。而 abstract class 的方法是要继承的。</li></ul><p>interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。</p><h3 id="2、函数式接口（Functional-Interface）"><a href="#2、函数式接口（Functional-Interface）" class="headerlink" title="2、函数式接口（Functional Interface）"></a>2、函数式接口（Functional Interface）</h3><p>函数式接口（Functional Interface）是Java 8引入的一个<strong>重要概念</strong>，它是Java对函数式编程支持的一部分。</p><blockquote><p>定义</p></blockquote><p>函数式接口<strong>是只有一个抽象方法的接口</strong>。尽管接口可以包含多个默认方法、静态方法，<strong>但只能有一个抽象方法</strong>。这种接口的主要目的是为了与Lambda表达式结合使用。</p><blockquote><p><code>@FunctionalInterface</code> 注解</p></blockquote><p>虽然不是强制性的，但通常会使用<code>@FunctionalInterface</code>注解来标记函数式接口。这个注解有助于编译器识别意图，并在接口不是有效的函数式接口时生成编译时错误。</p><blockquote><p>函数式接口示例：</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>Greeting</code>接口定义了一个接受一个字符串参数并返回一个字符串的方法。</p><p>由于它只有一个抽象方法，所以它是一个函数式接口。</p><blockquote><p>使用场景</p></blockquote><p>函数式接口在Java 8中引入Lambda表达式时变得非常重要。Lambda表达式提供了一种简洁的方式来实现函数式接口，从而使代码更简洁、更易读。</p><p>可以将函数式接口想象成一种特殊的工具套件。这个套件里只有一个工具槽（抽象方法），但你可以以多种方式（Lambda表达式、方法引用）填充这个槽。这就像是一个可定制的工具，你可以根据需要插入不同的功能。</p><p>函数式接口在Java中的很多地方都有使用，例如：</p><ul><li>在<code>java.util.function</code>包中，Java 8引入了一系列标准的函数式接口，如<code>Predicate&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Consumer&lt;T&gt;</code>等。</li><li>在集合框架中，它们被用于简化迭代、过滤和转换操作。</li><li>在并发编程中，例如使用<code>Runnable</code>或<code>Callable</code>接口。</li></ul><h3 id="3、Lambda-表达式"><a href="#3、Lambda-表达式" class="headerlink" title="3、Lambda 表达式"></a>3、Lambda 表达式</h3><p>Lambda表达式是Java 8中一个非常重要的新特性，它为Java带来了一种简洁的方式来表示函数式接口的实例。</p><p>Lambda表达式主要用于提供一种简洁、表达式风格的方法来表示可以传递的匿名函数。这种表达方式非常适合创建简短的、只使用一次的方法版本。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><blockquote><p>语法格式</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span> expression 或<br><span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span>&#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>parameters<ul><li>与方法定义中的参数列表类似。对于单个参数，可以省略括号</li></ul></li><li><code>-&gt;</code><ul><li>Lambda表达式的核心，用于分隔参数列表和Lambda体</li></ul></li><li><strong>Lambda体</strong><ul><li>可以是一个表达式或一个代码块。表达式体会返回一个值，而代码块可以包含零个或多个语句。</li></ul></li></ul><h4 id="简易示例"><a href="#简易示例" class="headerlink" title="简易示例"></a>简易示例</h4><blockquote><p>使用示例</p></blockquote><p>Lambda表达式通常与函数式接口一起使用。函数式接口是只有一个抽象方法的接口，这意味着Lambda表达式可以为该抽象方法提供实现。</p><p>假设我们有一个简单的函数式接口：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StringOperation</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(String s)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不使用Lambda表达式，我们可能需要这样实现：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">StringOperation operation = <span class="hljs-keyword">new</span> StringOperation() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> s.<span class="hljs-title">length</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用Lambda表达式，我们可以这样简化：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">StringOperation operation <span class="hljs-operator">=</span> s -&gt; s.length()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>平时开发经常会用到 Runnable 接口、Comparator 接口、Listener 接口 这三个接口，下面分别就看一下他们的使用示例。</p><blockquote><p>Runnable 接口</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> Thread(<span class="hljs-built_in">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run() &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;The runable now is using!&quot;);<br>            &#125;<br>&#125;).<span class="hljs-keyword">start</span>();<br>//用lambda<br><span class="hljs-built_in">new</span> Thread(() -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;It&#x27;s a lambda function!&quot;)).<span class="hljs-keyword">start</span>();<br></code></pre></td></tr></table></figure><blockquote><p>Comparator 接口</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;<span class="hljs-type">Integer</span>&gt; strings = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Collections.sort(strings, <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>    <span class="hljs-keyword">return</span> o1 - o2;&#125;<br>&#125;);<br><br>//Lambda<br>Collections.sort(strings, (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) -&gt; o1 - o2);<br>//分解开<br>Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator = (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) -&gt; o1 - o2;<br>Collections.sort(strings, comparator);<br></code></pre></td></tr></table></figure><blockquote><p>Listener 接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>button.addItemListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">itemStateChanged</span><span class="hljs-params">(ItemEvent e)</span> &#123;<br>   e.getItem();<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda</span><br>button.addItemListener(e -&gt; e.getItem());<br></code></pre></td></tr></table></figure><h4 id="集合上使用"><a href="#集合上使用" class="headerlink" title="集合上使用"></a>集合上使用</h4><blockquote><p>在集合上的应用</p></blockquote><p>Lambda表达式特别适合用在集合的操作上，比如<code>forEach</code>、<code>map</code>、<code>filter</code>等方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;String&gt; list = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;);<br><br>// 使用Lambda表达式迭代<br>list.<span class="hljs-keyword">forEach</span>(element -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(element));<br><br>// 使用Lambda表达式和Stream API进行过滤<br>list.stream()<br>    .<span class="hljs-keyword">filter</span>(s -&gt; s.startsWith(&quot;J&quot;))<br>    .<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> lamndaFor() &#123;<br>        List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);<br>        //传统<span class="hljs-keyword">foreach</span><br>        <span class="hljs-keyword">for</span> (String s : strings) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s);<br>        &#125;<br>        //Lambda <span class="hljs-keyword">foreach</span><br>        strings.<span class="hljs-keyword">forEach</span>((s) -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s));<br>        //<span class="hljs-keyword">or</span><br>        strings.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br> //map<br>        Map&lt;<span class="hljs-type">Integer</span>, String&gt; map = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>        map.<span class="hljs-keyword">forEach</span>((k,v)-&gt;<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(v));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClassSuper</span> &#123;<br>    LambdaInterface <span class="hljs-title function_">sf</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LambdaClassSuper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LambdaInterface <span class="hljs-title function_">staticF</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> LambdaInterface <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//1.调用静态函数，返回类型必须是functional-interface</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> LambdaClass::staticF;<br><br>        <span class="hljs-comment">//2.实例方法调用</span><br>        <span class="hljs-type">LambdaClass</span> <span class="hljs-variable">lambdaClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaClass</span>();<br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">lambdaInterface</span> <span class="hljs-operator">=</span> lambdaClass::f;<br><br>        <span class="hljs-comment">//3.超类上的方法调用</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">superf</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>::sf;<br><br>        <span class="hljs-comment">//4. 构造方法调用</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> LambdaClassSuper::<span class="hljs-keyword">new</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问变量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>Collections.sort(<span class="hljs-built_in">string</span>s, (Integer o1, Integer o2) -&gt; o1 - i);<br><span class="hljs-comment">//i =3;</span><br></code></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><p>to be contined……</p><h3 id="4、Stream"><a href="#4、Stream" class="headerlink" title="4、Stream"></a>4、Stream</h3><blockquote><p>Stream 是什么</p></blockquote><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何 CRUD。</p><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><blockquote><p>流类型</p></blockquote><ol><li>stream 串行流</li><li>parallelStream 并行流，可多线程执行</li></ol><h4 id="Stream-常用方法"><a href="#Stream-常用方法" class="headerlink" title="Stream 常用方法"></a>Stream 常用方法</h4><ul><li><code>stream()</code>, <code>parallelStream()</code></li><li><code>filter()</code></li><li><code>findAny()</code> <code>findFirst()</code></li><li><code>sort</code></li><li><code>forEach</code> void</li><li><code>map(), reduce()</code></li><li><code>flatMap()</code> - 将多个Stream连接成一个Stream</li><li><code>collect(Collectors.toList())</code></li><li><code>distinct</code>, <code>limit</code></li><li><code>count</code></li><li><code>min</code>, <code>max</code>, <code>summaryStatistics</code></li></ul><h3 id="5、Optional"><a href="#5、Optional" class="headerlink" title="5、Optional"></a>5、Optional</h3><p>参考： <a href="https://javaguide.cn/java/new-features/java8-common-new-features.html#optional">https://javaguide.cn/java/new-features/java8-common-new-features.html#optional</a></p><p><code>Optional</code>是Java 8引入的一个容器类，用于表示一个值可能存在或不存在。它提供了一种更优雅的方法来处理可空值，从而减少<code>NullPointerException</code>的风险。</p><p>to be contined…</p><h3 id="6、Date-Time-API"><a href="#6、Date-Time-API" class="headerlink" title="6、Date-Time API"></a>6、Date-Time API</h3><p>to be contined….</p><hr><p>参考</p><ul><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7">https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7</a></li><li><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">https://javaguide.cn/java/new-features/java8-common-new-features.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JDK8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot学习_SpringBoot 自动装配原理</title>
    <link href="/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是Spring-Boot-的自动装配"><a href="#1、什么是Spring-Boot-的自动装配" class="headerlink" title="1、什么是Spring Boot 的自动装配"></a>1、什么是Spring Boot 的自动装配</h3><h4 id="基础介绍"><a href="#基础介绍" class="headerlink" title="基础介绍"></a>基础介绍</h4><blockquote><p>面试题：讲述一下Spring Boot 的自动装配原理。</p></blockquote><p>Spring Boot 的自动装配原理基于 Spring 框架的依赖注入和条件注册特性，通过一系列的“启动器”（starters）和自动配置（auto-configuration）类简化了配置过程。</p><p>Spring Boot的自动配置原理涉及到了几个关键核心概念：@SpringBootApplication注解、条件注解<code>@Conditional...</code>、<code>spring.factories</code>文件、自动配置类<code>@Configuration</code></p><p>原理简述：</p><ul><li>当Spring应用启动时，<code>@EnableAutoConfiguration</code>注解触发了一个自动配置的过程。</li><li>这个过程从<code>classpath</code>中的<code>META-INF/spring.factories</code>文件中读取并加载所有可用的自动配置类。</li><li>每个自动配置类可以根据条件（比如classpath中是否存在某个类、是否存在某个bean、某个属性是否有特定的值等）决定配置是否应用。</li><li>如果条件满足，相应的配置被应用（比如创建一个bean、添加属性值等）。</li></ul><p>这种自动配置机制大大简化了Spring应用的配置，尤其是在构建独立的、生产级别的Spring应用时。</p><hr><p>先了解一下自动装配类主要用的注解和自动配置类，了解其概念，并继续往下进行学习。</p><p>Spring Boot 的自动装配原理是基于 Spring 框架的依赖注入和条件装配特性。</p><p>自动装配主要通过 <code>@EnableAutoConfiguration</code> 注解和一系列的自动配置类 (<code>*AutoConfiguration</code> 类) 来实现。</p><p>以下是从源码角度对其原理的解析：</p><blockquote><ol><li>@EnableAutoConfiguration</li></ol></blockquote><ul><li><code>@EnableAutoConfiguration</code> 注解是 Spring Boot 自动装配的入口。它通常与 <code>@SpringBootApplication</code> 注解一起使用，在应用启动时被激活。</li><li>该注解背后使用了 <code>@Import</code> 注解来导入 <code>EnableAutoConfigurationImportSelector</code> 类，这是启动自动装配的关键。</li></ul><blockquote><ol start="2"><li>EnableAutoConfigurationImportSelector</li></ol></blockquote><ul><li><code>EnableAutoConfigurationImportSelector</code> 实现了 <code>ImportSelector</code> 接口，负责选择需要导入的配置类。</li><li>它读取 <code>META-INF/spring.factories</code> 文件中的内容，这个文件列出了所有可用的自动配置类。</li><li>每个自动配置类都是以条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>）标注的，这些注解确保只有在特定条件满足时，相关配置才会被应用。</li></ul><blockquote><ol start="3"><li>条件注解</li></ol></blockquote><ul><li>条件注解是 Spring Framework 的核心特性之一，Spring Boot 在此基础上实现了自动装配。</li><li><code>@Conditional</code> 注解家族（比如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）允许在满足特定条件时，才执行某些操作（如实例化 Bean）。</li><li>这些注解确保了只有当相关的类存在于类路径上、或者某个 Bean 尚未定义时，对应的自动配置类才会被激活。</li></ul><blockquote><ol start="4"><li>自动配置类 (<code>*AutoConfiguration</code>)</li></ol></blockquote><ul><li>自动配置类通常命名为 <code>*AutoConfiguration</code>，它们包含了一系列的 Bean 定义和条件逻辑。</li><li>这些类利用 Spring 的依赖注入特性，定义了如何创建和配置 Bean，从而简化了许多常见场景的配置工作。</li><li>例如，<code>DataSourceAutoConfiguration</code> 可以在类路径上检测到数据库连接池实现时自动配置数据源（DataSource）。</li></ul><p>示例：DataSourceAutoConfiguration</p><p>以 <code>DataSourceAutoConfiguration</code> 为例，展示自动配置类的典型结构：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)<br>public class DataSourceAutoConfiguration &#123;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    <span class="hljs-variable">@Configuration</span><br>    <span class="hljs-variable">@Conditional</span>(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)<br>    public static class DataSourceConfiguration &#123;<br>        <span class="hljs-comment">// Bean 定义和配置</span><br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    static class DataSourceAvailableCondition extends SpringBootCondition &#123;<br>        <span class="hljs-comment">// 条件判断逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p>Spring Boot 的自动装配是通过一系列的自动配置类以及条件注解实现的。</p><p>这些自动配置类位于应用的类路径上，并在满足特定条件时被 <code>@EnableAutoConfiguration</code> 注解激活。</p><p>这种机制极大地简化了 Spring 应用的配置过程，允许开发者以最少的努力实现强大的功能。</p><hr><h4 id="什么是-SpringBoot-的自动配置（视频学习）"><a href="#什么是-SpringBoot-的自动配置（视频学习）" class="headerlink" title="什么是 SpringBoot 的自动配置（视频学习）"></a>什么是 SpringBoot 的自动配置（视频学习）</h4><p>视频地址学习： <a href="https://www.bilibili.com/video/BV1NY411P7VX">https://www.bilibili.com/video/BV1NY411P7VX</a></p><blockquote><p>什么是 SpringBoot 的自动配置</p></blockquote><p>Spring 自动配置，英文是 Auto-Configuratioin</p><ul><li>他是指基于引入的依赖 Jar 包，对 SpringBoot 应用进行自动配置</li><li>它为 SpringBoot 框架的 “ 开箱即用” 提供了基础支撑。</li></ul><p>同时需要区别两个概念：</p><ul><li>自动配置： Auto-Configuration</li><li>自动装配： Autowire</li></ul><p>术语：“配置类”</p><p>配置类的英文是 Configuration </p><ul><li>广义的“配置类”<ul><li>被注解 @Component 直接或间接修饰的某个类</li><li>这个指的是我们常说的 Spring 组件，其中包括了 @Configuratioin 类</li></ul></li><li>狭义的“配置类”<ul><li>特指被注解 @Configration 所修饰的某个类</li><li>又称为 @Configuration 类</li></ul></li></ul><p>配置类示例：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261517334.png" alt="image.png"></p><p>SpringBoot 自动配置的实例：</p><p>实例：Redis 的自动配置</p><ul><li><ol><li>引入依赖</li></ol></li><li><ol start="2"><li>配置Redis 服务器的配置信息</li></ol></li><li><ol start="3"><li>直接使用 RedisTempate 或 StringRedis Template 等对象</li></ol></li></ul><p>SpringBoot 启动流程（简化版）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261518878.png" alt="image.png"></p><p>run 方法简易版流程示例：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261519947.png" alt="image.png"></p><p>这里对于第三步 processConfigurationClasses 进行讲解阐述（代码进行了部分简化，主要理解一下逻辑）：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261521277.png" alt="image.png"></p><p>parse 方法</p><ul><li><ol><li>我们会从启动类的 @ComponentScan 注解开始处理，会先根据 @ComponentScan 注解下配置内容，扫描指定的 package ，得到一系列的配置类；然后进行递归处理</li></ol></li><li><ol start="2"><li>接着会处理注解 @Import ；导入一系列配置类后，再进行递归处理</li></ol></li><li><ol start="3"><li>最后，是解析配置类中的 @Bean 方法，以及之前导入的 BeanDefinition 注册器</li></ol></li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261522420.png" alt="image.png"></p><p>递归过程图解：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261526019.png" alt="image.png"></p><p>注解 @ComponentScan 和 @Import 的使用建议单独去稍微看一下</p><p>注解 Import 的常用的几种用法：</p><ul><li>示例1： 注解@Import 导入普通类</li><li>示例2： 注解@Import 导入接口 ImportSelector 实现类</li><li>示例3： 导入接口 ImportBeanDefinitionRegistrar 实现类</li></ul><hr><p>总结一下 SpringBoot 加载配置类的方式</p><ul><li>使用注解 @ComponentScan</li><li>使用注解 @Import<ul><li>导入普通类</li><li>导入接口 ImportSelector 实现类</li><li>导入接口 ImportBeanDefinitionRegistrar 实现类</li></ul></li></ul><p>从上面的几种配置方式中的具体使用中可以看出，如果要实现自动导入配置类，需要使用 注解 @Import +  导入接口 ImportSelector 实现类 的方式来实现（其他几种都不太适合）；</p><p>接下来我们来从 注解 @SpringBootApplication 看一下这个具体的使用</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261534577.png" alt="image.png"></p><blockquote><p>如何实现类 AutoConfigurationImportSelector</p></blockquote><ul><li>SpringFactories 机制<ul><li>Java SPI 机制的延伸和扩展</li><li>Spring 框架的基础机制，在 Spring 以及 SpringBoot 源码中到处可见</li><li>可以基于它来实现 SpringBoot 的自动配置功能</li></ul></li></ul><p>SpringFactories 机制的核心逻辑是从 classpath 中读取到 所有 Jar 包中的配置文件 META-IF&#x2F;spring.factories，然后根据指定的 key 从配置文件中解析出对应的 value 值</p><blockquote><p>SpringFactories 与 SPI 机制的对比</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261538309.png" alt="image.png"></p><blockquote><p>类 AutoConfigurationImportSelector  的关键源码</p></blockquote><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br>        <span class="hljs-comment">//SpringBoot 自动配置的入口方法</span><br>        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <br>                <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 getAutoConfigurationEntry 方法是自动配置的入口</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;  <br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;  <br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>        <span class="hljs-comment">//1. 获取 annotationMetadata 的注解 @EnableAutoConfiguration 的属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);  <br>        <span class="hljs-comment">//2. 从资源文件 spring.factories 中获取 EnableAutoConfiguration 对应的所有的类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);  <br>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);  <br>        <span class="hljs-comment">//3. 通过在注解 @EnableAutoConfiguration 设置 exclued 的相关属性，可以排除指定的自动配置类</span><br>        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);  <br>        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);  <br>        configurations.removeAll(exclusions);  <br>        <span class="hljs-comment">//4. 根据注解 @Conditional 来判断是否需要排除某些自动配置类</span><br>        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);  <br>        <span class="hljs-comment">//5. 触发 AutoConfiguration 导入的相关事件</span><br>        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);  <br>        <span class="hljs-keyword">return</span> new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其中第二步 getCandidateConfigurations  方法是 基于 SpringFactories 机制，来获取第三方 Jar 包中的所有自动配置类的方法</p><p>注意到从配置文件获取自动配置类时使用的 key 是类 EnableAutoConfiguration 的全限定类名</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">protected</span> <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; <span class="hljs-title function_">getCandidateConfigurations</span>(<span class="hljs-params">AnnotationMetadata metadata, AnnotationAttributes attributes</span>) &#123;  <br><span class="hljs-comment">// 通过 SpringFactories 机制，从配置文件 spring.factories 中找到所有的配置类</span><br>    <span class="hljs-title class_">List</span>&lt;<span class="hljs-title class_">String</span>&gt; configurations = <span class="hljs-title class_">SpringFactoriesLoader</span>.<span class="hljs-title function_">loadFactoryNames</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getSpringFactoriesLoaderFactoryClass</span>(), <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">getBeanClassLoader</span>());  <br>    <span class="hljs-title class_">Assert</span>.<span class="hljs-title function_">notEmpty</span>(configurations, <span class="hljs-string">&quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;</span>);  <br>    <span class="hljs-keyword">return</span> configurations;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>总结一下 AutoConfigurationImportSelector 的注解流程</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261548596.png" alt="image.png"></p><blockquote><p>注解 @Conditional</p></blockquote><p>Spring 框架提供了一系列常用的 Confitional 扩展注解，如下表所示：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261549713.png" alt="image.png"></p><blockquote><p>小结</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261549082.png" alt="image.png"></p><blockquote><p>SpringBoot 自动配置实例- Redis</p></blockquote><p>以 spring-boot-starter-data-redis  为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- spring data redis --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>查看对应的 pom 文件，可以看到对应的 依赖项</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261556211.png" alt="image.png"></p><p>在 spring-boot-autoconfigure 项目中查看配置文件以及源码：</p><ul><li>先查看 项目中的 META-IF&#x2F;spring.factories 配置文件</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261557230.png" alt="image.png"></p><ul><li>接口查看其中的自动配置类之一 RedisAutoConfiguration</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261558233.png" alt="image.png"></p><h4 id="Spring-Boot自动配置原理是什么？（小程序）"><a href="#Spring-Boot自动配置原理是什么？（小程序）" class="headerlink" title="Spring Boot自动配置原理是什么？（小程序）"></a>Spring Boot自动配置原理是什么？（小程序）</h4><blockquote><p>自动配置原理</p></blockquote><p>Spring Boot的自动配置原理是通过<strong>条件化配置</strong>和Spring的<strong>注解机制</strong>来实现的，当应用启动时，Spring Boot会自动扫描应用中的依赖，根据依赖自动配置Spring应用程序上下文，以便开箱即用。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261616336.png" alt="image.png"></p><blockquote><p>Spring Boot自动配置的关键步骤：</p></blockquote><ul><li>Spring Boot会扫描应用中的所有类路径下的META-lNF&#x2F;spring.factories文件，这个文件包含了Spring Boot自动配置的核心。</li><li>Spring Boot将读取到的自动配置类加载到Spring应用程序上下文中，这些自动配置类都实现了AutoConfiguration 自动配置接口。</li><li>Spring Boot根据条件进行自动配置，它会检查一些条件，如果这些条件满足，则启用相应的自动配置类。</li><li>Spring Boot自动配置类会向Spring容器中添加需要的Bean定义和组件，这些Bean定义和组件是根据应用的配置和Spring Boot的默认值创建的。</li><li>Spring Boot还提供了一些 Starter 依赖，这些 Starter 依赖包含了一些常用的库和框架，可以帮助我们更方便地进行开发。这些Starter依赖会自动引入相关的依赖，使我们能够更快地进行开发。</li></ul><blockquote><p>自动配置加载源码</p></blockquote><p>Spring Boot的自动配置注解是@EnableAutoConfiguration,  从注解上面的@Import的类可以找到下面自动加载自动配置的映射：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs swift">org.springframework.core.io.support.<span class="hljs-type">SpringFactoriesLoader</span>.loadFactoryNames(<span class="hljs-type">Class</span>&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">ClassLoader</span> classLoader)<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">List</span>&lt;<span class="hljs-type">String</span>&gt; loadFactoryNames(<span class="hljs-type">Class</span>&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> <span class="hljs-type">ClassLoader</span> classLoader)<br></code></pre></td></tr></table></figure><p>这个方法会加载类路径及所有jar包下META-INF&#x2F;spring.factories配置中映射的自动配置的类：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/spring.factories<br></code></pre></td></tr></table></figure><p>查看Spring Boot自带的自动配置的包：spring-boot-autoconfigure-Xxx.RELEASE.jar,</p><p>打开其中的META-lNF&#x2F;spring.factories文件会找到自动配置的映射。</p><p>示例：数据源自动配置的实现注解</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@ConditionalOnClass</span>(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)  <br><span class="hljs-variable">@EnableConfigurationProperties</span>(&#123;DataSourceProperties.class&#125;)  <br><span class="hljs-variable">@Import</span>(&#123;DataSourcePoolMetadataProvidersConfiguration.class, DataSourceInitializationConfiguration.class&#125;)  <br>public class DataSourceAutoConfiguration&#123;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>@Configuration和@ConditionalOnClass就是自动配置的核心，首先它得是一个配置文件，其次根据类路径下是否有这个类去自动配置。</p><blockquote><p>版本差异</p></blockquote><p>自动配置加载源码，不同的的版本可能大有不同，尤其在Spring Boot2.7.x及3.x中，</p><p>SpringBoot 2.7 + 新变化</p><p>Spring Boot 2.7 中的自动配置注册有了一个比较大的调整，之前都是写在文件 META-INF&#x2F;spring.factories 中；</p><p>现在改名了：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">META-INF/spring/org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span><span class="hljs-selector-class">.AutoConfiguration</span>.imports<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261628810.png" alt="image.png"></p><p>另外格式也变了，Spring Boot 2.7 中直接每一行是一个自动配置类（编写格式比之前方便很多）：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261629632.png" alt="image.png"></p><p>需要注意的是： 在 2.7 x 中，虽然 META-INF&#x2F;spring.factories  被标识废弃中，但是为了向后兼容，在 2.7 x 仍然是可以使用的，后续会被彻底删除，建议使用新的规范。</p><p><strong>Spring Boot 3.0 新变化</strong></p><p>最新Spring Boot3.0中，老的自动配置文件META-NF&#x2F;spring.factories已经正式被废除了，虽然配置文件还在，但仅保留系统级的组件注册，不再作为应用级的自动配置类加载了，</p><p>也就是说，它已经不能再注册自定义的自动配置类了，必须使用新的自动配置文件规范进行注册。</p><h3 id="2、解读-SpringBootApplication-注解（第一版）"><a href="#2、解读-SpringBootApplication-注解（第一版）" class="headerlink" title="2、解读@SpringBootApplication 注解（第一版）"></a>2、解读@SpringBootApplication 注解（第一版）</h3><p>上述内容也谈论到 条件注解是 Spring Framework 的核心特性之一，Spring Boot 在其基础上，通过 SPI 的方式，做了进一步优化，并进而实现了自动装配。</p><blockquote><p>我们从启动类开始了解其自动装配原理</p></blockquote><p>本地的版本是：org.springframework.boot:spring-boot-autoconfigure:2.2.5.RELEASE</p><h4 id="2-1-SpringBootApplication"><a href="#2-1-SpringBootApplication" class="headerlink" title="2.1  SpringBootApplication"></a>2.1  SpringBootApplication</h4><p>@SpringBootApplication注解是放置在 Spring Boot 应用的主类上，注解的作用是启用组件扫描和自动配置。</p><p>我们找到一个启动类，进入其注解代码，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE) <span class="hljs-comment">// 注解作用于类型上（比如类、接口）</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME) <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-variable">@Documented</span> <span class="hljs-comment">// 将此注解包含在 Javadoc 中</span><br><span class="hljs-variable">@Inherited</span> <span class="hljs-comment">// 注解可以被继承</span><br><span class="hljs-variable">@SpringBootConfiguration</span> <span class="hljs-comment">// 特殊的@Configuration，表明这是一个 Spring Boot 配置类</span><br><span class="hljs-variable">@EnableAutoConfiguration</span> <span class="hljs-comment">// 启用 Spring Boot 的自动配置机制</span><br><span class="hljs-comment">//启用组件扫描，让 Spring 自动发现和注册应用中的 Beans。通常，它会扫描与主类相同的包以及子包中的组件。</span><br><span class="hljs-comment">//`excludeFilters` 属性用于排除某些类型的组件，这里特别排除了 `TypeExcludeFilter` 和 `AutoConfigurationExcludeFilter` 类型的组件</span><br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;TypeExcludeFilter.class&#125;<br>        ),<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>        )<br>    &#125;<br>) <br>public <span class="hljs-variable">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">// ... 其他属性定义 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 EnableAutoConfiguration"></a>2.2 EnableAutoConfiguration</h4><blockquote><p>作用</p></blockquote><p><code>@EnableAutoConfiguration</code> 是 Spring Boot 的核心注解之一，用于启动自动配置的机制。这个注解通过 <code>@Import</code> 注解导入 <code>AutoConfigurationImportSelector</code>，后者负责根据条件选择和应用自动配置类。</p><blockquote><p>代码</p></blockquote><p><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解继续往下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> <span class="hljs-comment">// 指定注解可以应用于类型级别（类、接口等）</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-meta">@Documented</span> <span class="hljs-comment">// 注解将被包含在javadoc中</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">// 注解可以被子类继承</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">// 自动配置包，将主配置类的包视为自动配置包</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">// 导入AutoConfigurationImportSelector</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <br>    <span class="hljs-comment">// 用于覆盖自动配置是否启用的属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    <span class="hljs-comment">// 排除特定的自动配置类</span><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 通过名称排除特定的自动配置类</span><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用示例</p></blockquote><p>通常，我们是不会显式地使用 <code>@EnableAutoConfiguration</code>，它已经包含在 <code>@SpringBootApplication</code> 注解中。</p><p>但如果需要单独使用，可以像下面这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableAutoConfiguration</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)<br>public class MyConfiguration &#123;<br>    <span class="hljs-comment">// 配置内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>@EnableAutoConfiguration</code> 注解用于启动自动配置，但排除了特定的自动配置类 <code>DataSourceAutoConfiguration</code>。</p><hr><h4 id="2-3-AutoConfigurationImportSelector"><a href="#2-3-AutoConfigurationImportSelector" class="headerlink" title="2.3 AutoConfigurationImportSelector"></a>2.3 AutoConfigurationImportSelector</h4><p><code>AutoConfigurationImportSelector</code> 是 Spring Boot 自动装配机制的关键组成部分。这个类实现了多个 Spring 框架的接口，使其能够在启动时选择和注册自动配置类。</p><p>先看一下这个类 <code>AutoConfigurationImportSelector</code>的继承体系：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AutoConfigurationImportSelector</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">DeferredImportSelector, <span class="hljs-symbol">BeanClassLoaderAware</span>, <span class="hljs-symbol">ResourceLoaderAware</span>, <span class="hljs-symbol">BeanFactoryAware</span>, <span class="hljs-symbol">EnvironmentAware</span>, <span class="hljs-symbol">Ordered</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">DeferredImportSelector</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br>    String[] selectImports(AnnotationMetadata var1);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的两层继承关系可以看出 <code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，这意味着它实现了这个接口中的 <code>selectImports</code>方法，</p><p><code>selectImports</code> 方法是 <code>AutoConfigurationImportSelector</code> 类的核心部分，用于根据当前的应用上下文环境选择合适的自动配置类。</p><p>以下是对这个方法的代码注释解释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-comment">// 检查是否启用自动配置</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-comment">// 如果自动配置没有启用，则不导入任何配置</span><br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 加载自动配置的元数据</span><br>        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br><br>        <span class="hljs-comment">// 获取自动配置条目（即自动配置类的列表）</span><br>        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <br>                <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br><br>        <span class="hljs-comment">// 将自动配置类转换为字符串数组并返回</span><br>        <span class="hljs-comment">// 这些类名将被 Spring 容器进一步处理，以实现自动配置</span><br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法解释</p></blockquote><ol><li><strong>isEnabled 方法</strong>:<ul><li>检查是否启用了自动配置。这通常是通过检查某个特定的属性或条件来决定的。如果自动配置被禁用，则此方法返回一个空的数组，意味着不进行任何自动配置。</li></ul></li><li><strong>加载自动配置元数据</strong>:<ul><li>使用 <code>AutoConfigurationMetadataLoader</code> 加载自动配置的元数据。这些元数据通常从 <code>META-INF/spring.factories</code> 文件中读取，其中列出了所有可用的自动配置类。</li></ul></li><li><strong>获取自动配置条目</strong>:<ul><li><code>getAutoConfigurationEntry</code> 方法根据当前的应用上下文环境和已加载的元数据确定哪些自动配置类应该被激活。这涉及到一系列条件匹配，例如检查类路径上是否存在特定的类。</li></ul></li><li><strong>返回自动配置类的名称</strong>:<ul><li>最后，该方法返回一个包含应该激活的自动配置类名称的字符串数组。Spring 容器随后将使用这些类名来实例化相应的 Bean 定义。</li></ul></li></ol><h4 id="2-4-getAutoConfigurationEntry"><a href="#2-4-getAutoConfigurationEntry" class="headerlink" title="2.4 getAutoConfigurationEntry"></a>2.4 getAutoConfigurationEntry</h4><p>重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法的主要职责是收集所有应该被激活的自动配置类，并根据给定的条件来筛选和排除某些配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(<br>    AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;<br>    <br>    <span class="hljs-comment">// 检查自动配置是否被启用，如果没有，则返回一个空的配置条目</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取注解的属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>        <br>        <span class="hljs-comment">// 获取所有候选的配置类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 移除重复的配置</span><br>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);<br>        <br>        <span class="hljs-comment">// 获取需要排除的配置类</span><br>        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 检查排除的类是否真的存在于候选配置中，并抛出异常如果有的话</span><br>        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 从候选配置中移除排除的配置</span><br>        configurations.removeAll(exclusions);<br>        <br>        <span class="hljs-comment">// 过滤配置，可能使用条件服务等进一步筛选配置</span><br>        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);<br>        <br>        <span class="hljs-comment">// 触发自动配置导入相关事件</span><br>        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 返回一个新的 AutoConfigurationEntry 对象，包含最终确定的配置类和排除的类</span><br>        <span class="hljs-keyword">return</span> new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法解释</p><ol><li><strong>isEnabled</strong>:<ul><li>检查是否在注解元数据中设置了启用自动配置的属性。</li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> boolean isEnabled(AnnotationMetadata metadata) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass() == AutoConfigurationImportSelector.<span class="hljs-keyword">class</span> ? (<span class="hljs-built_in">Boolean</span>)<span class="hljs-keyword">this</span>.getEnvironment().getProperty(<span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>, <span class="hljs-built_in">Boolean</span>.<span class="hljs-keyword">class</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>isEnabled</code> 方法会判断自动装配开关是否打开。</p><p>默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><ol start="2"><li><strong>getAttributes</strong>:<ul><li>提取注解元数据中的属性，这些属性可能会影响自动配置的选择。</li><li>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></li></ul></li><li><strong>getCandidateConfigurations</strong>:<ul><li>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></li></ul></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">spring-<span class="hljs-keyword">boot</span>/spring-<span class="hljs-keyword">boot</span>-project/spring-<span class="hljs-keyword">boot</span>-autoconfigure/src/main/resources/<span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/spring.factories<br></code></pre></td></tr></table></figure><p>不光是单个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>你可以看一下 druid 数据库连接池的 Spring Boot Starter ，在它里面就创建了<code>META-INF/spring.factories</code>文件。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219202949.png" alt="image.png"></p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><ol start="4"><li><strong>removeDuplicates</strong>:<ul><li>保证配置列表中没有重复的条目。</li></ul></li><li><strong>getExclusions</strong>:<ul><li>读取注解元数据，找出需要从自动配置中排除的类。</li></ul></li><li><strong>checkExcludedClasses</strong>:<ul><li>确保排除的类是候选配置列表中的成员，如果不是，则抛出异常。</li></ul></li><li><strong>configurations.removeAll(exclusions)</strong>:<ul><li>实际从候选配置列表中移除被排除的类。</li></ul></li><li><strong>filter</strong>:<ul><li>使用 <code>AutoConfigurationMetadata</code> 对候选配置进行进一步的条件筛选。</li></ul></li><li><strong>fireAutoConfigurationImportEvents</strong>:<ul><li>发布事件，这可能会影响后续处理过程，例如通过监听器来进一步修改配置列表。</li></ul></li><li><strong>返回 AutoConfigurationEntry</strong>:<ul><li>创建并返回一个 <code>AutoConfigurationEntry</code> 对象，该对象包含了最终确定要导入的自动配置类和已排除的类。</li></ul></li></ol><p>我们在具体使用的时候，<code>spring.factories</code>中会有很多配置，但每次启动并不是全部加载；</p><p>我们会在配置类上使用 ConditionalOnxxx 注解，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><p>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123; RabbitTemplate.class, Channel.class &#125;)<br><span class="hljs-variable">@EnableConfigurationProperties</span>(RabbitProperties.class)<br><span class="hljs-variable">@Import</span>(RabbitAnnotationDrivenConfiguration.class)<br>public class RabbitAutoConfiguration &#123;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3、新建一个-starter"><a href="#3、新建一个-starter" class="headerlink" title="3、新建一个 starter"></a>3、新建一个 starter</h3><h4 id="流程介绍"><a href="#流程介绍" class="headerlink" title="流程介绍"></a>流程介绍</h4><p>创建过程：</p><blockquote><ol><li>创建项目结构</li></ol></blockquote><p>需要创建一个 Maven项目。</p><p>为了遵循 Spring Boot Starter 命名约定，项目的名称通常以 <code>spring-boot-starter-</code> 开头，例如 <code>spring-boot-starter-myfeature</code>。</p><blockquote><ol start="2"><li>添加必要的依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Boot 以及其他所需库的依赖。</p><p>示例 Maven <code>pom.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加其他自己 Starter 需要的依赖 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>创建自动配置类</li></ol></blockquote><p>在项目中创建一个或多个配置类，使用 <code>@Configuration</code> 注解，并根据需要使用 <code>@Conditional</code> 注解来条件化配置。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(MyFeature.class)<br><span class="hljs-variable">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>, name = <span class="hljs-string">&quot;enabled&quot;</span>, havingValue = <span class="hljs-string">&quot;true&quot;</span>, matchIfMissing = true)<br>public class MyFeatureAutoConfiguration &#123;<br><br>    <span class="hljs-variable">@Bean</span><br>    <span class="hljs-variable">@ConditionalOnMissingBean</span><br>    public MyFeature <span class="hljs-built_in">myFeature</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">MyFeature</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>创建 <code>spring.factories</code> 文件</li></ol></blockquote><p>在项目的资源目录中创建一个 <code>META-INF/spring.factories</code> 文件，并指定自动配置类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.example</span>.MyFeatureAutoConfiguration<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>配置属性类（可选）</li></ol></blockquote><p>如果你的 Starter 需要配置属性，创建一个属性类使用 <code>@ConfigurationProperties</code> 注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFeatureProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> boolean enabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// ... 其他属性和getter/setter</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>测试 Starter</li></ol></blockquote><p>创建一个简单的 Spring Boot 应用来验证 Starter 是否按预期工作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStarterTestApp</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">MyStarterTestApp</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="7"><li>打包和发布</li></ol></blockquote><p>使用 Maven 将 Starter 打包，并发布到 Maven 中央仓库或私有仓库，使得其他项目可以添加依赖使用。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`mvn clean install`</span><br></code></pre></td></tr></table></figure><p>同时最好编写清晰的文档，说明如何添加 Starter 的依赖，以及如何配置和使用提供的功能。</p><blockquote><p>总结</p></blockquote><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，</p><p>通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，</p><p>自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p><hr><p>常见的一些问题：</p><blockquote><p>SpringBoot 的 starter 和 打包为 maven 依赖有什么区别，在什么实际使用场景下会考虑使用？</p></blockquote><p>前者 starter 更倾向于某个程序启动，它内部是包含了 SpringBoot 启动类的，通常封装了统一配置，隐藏了实现细节。</p><p>后者更倾向于是某一个公共服务，然后在多个模块中引入这个依赖（可以将这个公共服务打包为一个 mavne 依赖以供其他模块调用）</p><hr><h4 id="手撸一个-Starter（视频学习）"><a href="#手撸一个-Starter（视频学习）" class="headerlink" title="手撸一个 Starter（视频学习）"></a>手撸一个 Starter（视频学习）</h4><p>视频学习： <a href="https://www.bilibili.com/video/BV1Zu4116714">https://www.bilibili.com/video/BV1Zu4116714</a></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261636199.png" alt="image.png"></p><blockquote><p>Maven 中的可选依赖</p></blockquote><p>可选依赖(Optional) 的作用：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401261638244.png" alt="image.png"></p><blockquote><p>从 0 开始，手撸一个 Starter 的应用实例</p></blockquote><p><strong>应用实例的背景介绍</strong></p><p>在SpringCloud微服务架构中，往往需要在A服务中调用B服务的。</p><p>例如，营销微服务 ms-marketing 需要调用用户微服务 ms-user 中的接口。</p><p>痛点： ms-marketing 如何 “一站式” 地调用 ms-user 中的接口</p><ul><li>不用关心被调用接口的 uri</li><li>不需要自动构建被调用接口的参数和返回值的类型</li></ul><p>最佳实践：使用 SpringBoot 的自动配置，构建 me-user 的 Starter</p><p>Gitee 地址： <a href="https://gitee.com/cnmemset/spring-boot-starter-example/tree/master/ms-user">https://gitee.com/cnmemset/spring-boot-starter-example/tree/master/ms-user</a></p><h5 id="1、新建一个-Maven-项目-ms-user"><a href="#1、新建一个-Maven-项目-ms-user" class="headerlink" title="1、新建一个 Maven 项目 ms-user"></a>1、新建一个 Maven 项目 ms-user</h5><p> 先不建议模块，删除多余的文件夹</p><p>引入一下依赖（父模块依赖管理）</p><p>pom.xml 文件内容</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-user-parent<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>用户微服务项目<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring.cloud.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring.cloud.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>ms-user-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>ms-user-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>ms-user-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>这里主要是引入了： spring-cloud-starter、spring-cloud-starter-openfeign 依赖</p><p>同时使用 properties 进行依赖版本管理，通过 dependencyManagement 标签进行 多模块项目中管理依赖项的版本号和范围</p><p>父依赖是 spring-boot-starter-parent；注意一下版本。</p><h5 id="2、新建模块-ms-user-web"><a href="#2、新建模块-ms-user-web" class="headerlink" title="2、新建模块 ms-user-web"></a>2、新建模块 ms-user-web</h5><p>ms-user-web</p><p>新建启动类，添加一个 Controller 类</p><p>Application</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.<span class="hljs-property">memset</span>.<span class="hljs-property">user</span>.<span class="hljs-property">web</span>;  <br>  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;  <br>  <br><span class="hljs-meta">@SpringBootApplication</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;  <br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>UserController</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> cn.memset.user.web.controllers;  <br>  <br><span class="hljs-keyword">import</span> cn.memset.user.api.dto.User;  <br><span class="hljs-keyword">import</span> cn.memset.user.api.feign.UserFeignClient;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.GetMapping;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.PathVariable;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.annotation.RestController;  <br>  <br><span class="hljs-keyword">import</span> java.util.HashMap;  <br><span class="hljs-keyword">import</span> java.util.Map;  <br>  <br><span class="hljs-meta">@RestController  </span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">UserFeignClient</span></span> </span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;Long, User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-type">HashMap</span>&lt;&gt;();  <br>  <br>    <span class="hljs-keyword">static</span> &#123;  <br>        users.put(<span class="hljs-number">10000</span>L, <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(<span class="hljs-number">10000</span>L, <span class="hljs-string">&quot;张三&quot;</span>));  <br>        users.put(<span class="hljs-number">10001</span>L, <span class="hljs-keyword">new</span> <span class="hljs-type">User</span>(<span class="hljs-number">10001</span>L, <span class="hljs-string">&quot;李四&quot;</span>));  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Override  </span><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/get/&#123;userId&#125;&quot;</span>)  <br>    <span class="hljs-keyword">public</span> User getUserById(<span class="hljs-meta">@PathVariable</span>(<span class="hljs-string">&quot;userId&quot;</span>) long userId) &#123;  <br>        <span class="hljs-keyword">return</span> users.<span class="hljs-keyword">get</span>(userId);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在 resources 对应文件夹下新建文件：application.yml、banner.txt、logback-spring.xml</p><p>logback-spring.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;APP_NAME&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;spring.application.name&quot;</span> <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 开发环境的日志 --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;logs&quot;</span>/&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 生产环境的日志 --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prd&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/var/www/logs/$</span></span></span><span class="hljs-template-variable">&#123;APP_NAME&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">/&quot;</span>/&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 当spring-boot未成功加载的时候，默认的日志路径 --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;LOG_PATH&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$</span></span></span><span class="hljs-template-variable">&#123;LOG_PATH:-$&#123;LOG_TEMP:-$&#123;java.io.tmpdir:-/tmp&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&#125;&#125;&quot;</span>/&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- Console appender --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d</span><span class="hljs-template-variable">&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;</span><span class="language-xml"> [%thread] %-5level %logger::%M - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- File appender  --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 按天回滚 daily --&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;LOG_PATH&#125;</span><span class="language-xml">/info-%d</span><span class="hljs-template-variable">&#123;yyyy-MM-dd&#125;</span><span class="language-xml">.log<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-comment">&lt;!-- 日志最大的历史 60天 --&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>60<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d</span><span class="hljs-template-variable">&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;</span><span class="language-xml"> [%thread] %-5level %logger::%M - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">charset</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">charset</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 开发环境的日志 --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;CONSOLE&quot;</span>/&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- 生产环境的日志 --&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prd&quot;</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;FILE&quot;</span>/&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>banner.txt</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext">   <span class="hljs-bullet">-</span> <span class="hljs-string">` -  </span><br>(*￣(エ)￣)  <br>   <span class="hljs-bullet">-</span> <span class="hljs-string">  -</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span>  <br>  <span class="hljs-attr">servlet:</span>  <br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span>  <br>    <span class="hljs-attr">session:</span>  <br>      <span class="hljs-attr">timeout:</span> <span class="hljs-number">60</span>  <br><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">jackson:</span>  <br>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span>  <br>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>  <br>    <span class="hljs-attr">joda-date-time-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>  <br>  <span class="hljs-attr">profiles:</span>  <br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>  <br>  <span class="hljs-attr">application:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">ms-user</span><br></code></pre></td></tr></table></figure><p>启动测试一下访问：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">http</span>://localhost:<span class="hljs-number">8080</span>/get/<span class="hljs-number">10000</span><br></code></pre></td></tr></table></figure><h5 id="3、新建模块-ms-user-api"><a href="#3、新建模块-ms-user-api" class="headerlink" title="3、新建模块 ms-user-api"></a>3、新建模块 ms-user-api</h5><p>pom.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>微服务ms-user提供的API工具库<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义一个实体类 User</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package cn.memset.user.api.dto;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">long</span> id;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> name;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(<span class="hljs-type">long</span> id, <span class="hljs-type">String</span> name)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>.id = id;  <br>        <span class="hljs-keyword">this</span>.name = name;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> id;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>.id = id;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;  <br>        <span class="hljs-keyword">return</span> name;  <br>    &#125;  <br>  <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(<span class="hljs-type">String</span> name)</span> </span>&#123;  <br>        <span class="hljs-keyword">this</span>.name = name;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个远程调用的类：UserFeignClient</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.memset.user.api.feign;  <br>  <br><span class="hljs-keyword">import</span> cn.memset.user.api.dto.User;  <br><span class="hljs-keyword">import</span> org.slf4j.Logger;  <br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;  <br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FallbackFactory;  <br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;  <br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PathVariable;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.ResponseBody;  <br>  <br><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;ms-user&quot;</span>,  </span><br><span class="hljs-meta">        url = <span class="hljs-string">&quot;<span class="hljs-subst">$&#123;cnmemset.ms-user.url:<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">8080</span>&#125;</span>&quot;</span>,  </span><br><span class="hljs-meta">        fallbackFactory = UserFeignClient.UserFallbackFactory.class)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">UserFeignClient</span> &#123;  <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/get/&#123;userId&#125;&quot;</span>)</span>  <br>    <span class="hljs-meta">@ResponseBody</span>  <br>    <span class="hljs-keyword">public</span> User getUserById(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;userId&quot;</span>)</span> long userId);  <br>  <br>    <span class="hljs-meta">@Component</span>  <br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserFallbackFactory</span> <span class="hljs-title">implements</span> <span class="hljs-title">FallbackFactory</span>&lt;<span class="hljs-type">UserFeignClient</span>&gt; &#123;  <br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(UserFallbackFactory.<span class="hljs-keyword">class</span>);  <br>  <br>        <span class="hljs-meta">@Override</span>  <br>        <span class="hljs-keyword">public</span> UserFeignClient create(Throwable cause) &#123;  <br>            <span class="hljs-keyword">return</span> new UserFeignClient() &#123;  <br>                <span class="hljs-meta">@Override</span>  <br>                <span class="hljs-keyword">public</span> User getUserById(long userId) &#123;  <br>                    logger.error(<span class="hljs-string">&quot;调用ms-user发生异常：&quot;</span>, cause);  <br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;  <br>                &#125;  <br>            &#125;;  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>UserFeignMarker</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> cn.memset.user.api.feign;  <br>  <br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFeignMarker</span> </span>&#123;  <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4、新建模块-ms-user-autoconfigure"><a href="#4、新建模块-ms-user-autoconfigure" class="headerlink" title="4、新建模块  ms-user-autoconfigure"></a>4、新建模块  ms-user-autoconfigure</h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-user-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>ms-user的自动配置模块<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 必要的依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 可选的依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 一些可选的、但强烈建议使用的注解解析器 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 单元测试 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>新建配置类：MsUserAutoConfiguration</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.memset.user.autoconfigure;  <br>  <br><span class="hljs-keyword">import</span> cn.memset.user.api.feign.UserFeignClient;  <br><span class="hljs-keyword">import</span> cn.memset.user.api.feign.UserFeignMarker;  <br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.condition.ConditionalOnClass;  <br><span class="hljs-keyword">import</span> org.springframework.boot.context.properties.EnableConfigurationProperties;  <br><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.EnableFeignClients;  <br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Configuration;  <br><span class="hljs-keyword">import</span> org.springframework.context.<span class="hljs-keyword">annotation</span>.Import;  <br>  <br><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span>  <br><span class="hljs-meta">@ConditionalOnClass(UserFeignMarker.class)</span>  <br><span class="hljs-meta">@EnableFeignClients(basePackageClasses = UserFeignMarker.class)</span>  <br><span class="hljs-meta">@EnableConfigurationProperties(MsUserConfiguration.class)</span>  <br><span class="hljs-meta">@Import(&#123;UserFeignClient.UserFallbackFactory.class&#125;)</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsUserAutoConfiguration</span> &#123;  <br>  <br>&#125;<br></code></pre></td></tr></table></figure><p>注解使用讲述：</p><ul><li><code>@Configuration</code> 注解表明该类是一个配置类</li><li><code>@ConditionalOnClass</code> 注解表示条件配置。当类路径上存在特定的类时，相关的配置才会生效。</li><li><code>@EnableFeignClients</code> 注解用于启用 Feign 客户端；<ul><li>通过指定 <code>basePackageClasses</code> 或 <code>basePackages</code> 属性，Spring 会在指定的包或类中查找 <code>@FeignClient</code> 注解，并为它们创建代理。</li><li><code>basePackageClasses = UserFeignMarker.class</code> 指示 Spring 在 <code>UserFeignMarker</code> 所在的包中查找 <code>@FeignClient</code> 注解并进行处理</li></ul></li><li><code>@EnableConfigurationProperties</code> 注解用于启用对 <code>@ConfigurationProperties</code> 注解类的支持，这些类通常用于定义配置属性。</li><li><code>@Import</code> 注解用于导入其他配置类或一组组件类。</li></ul><p>MsUserConfiguration</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.<span class="hljs-property">memset</span>.<span class="hljs-property">user</span>.<span class="hljs-property">autoconfigure</span>;  <br>  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">context</span>.<span class="hljs-property">properties</span>.<span class="hljs-property">ConfigurationProperties</span>;  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Configuration</span>;  <br>  <br><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)  <br><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;cnmemset.ms-user&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsUserConfiguration</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 微服务ms-user的url  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> url = <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUrl</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> url;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUrl</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> url</span>) &#123;  <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在 resources 新建文件夹  META-INF</p><p>该文件夹下新建文件  spring.factories</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Auto Configure  </span><br>org.springframework.boot.autoconfigure.<span class="hljs-attribute">EnableAutoConfiguration</span>=\  <br>cn.memset.user.autoconfigure.MsUserAutoConfiguration<br></code></pre></td></tr></table></figure><h5 id="5、新建模块-ms-user-spring-boot-starter"><a href="#5、新建模块-ms-user-spring-boot-starter" class="headerlink" title="5、新建模块 ms-user-spring-boot-starter"></a>5、新建模块 ms-user-spring-boot-starter</h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-user-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>ms-user的自动配置Starter模块<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 必需的基础的 spring-boot 的 starter 依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 自动配置模块的依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- API模块的依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- 单元测试的依赖 --&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其他内容不用添加。</p><h5 id="6、ms-user-项目总结-🔺"><a href="#6、ms-user-项目总结-🔺" class="headerlink" title="6、ms-user 项目总结  🔺"></a>6、ms-user 项目总结  🔺</h5><p>在上述步骤中，我们已经创建了一个基于 Spring Boot 的微服务项目 <code>ms-user</code>，</p><p>它包括了几个子模块，如 <code>ms-user-web</code>、<code>ms-user-api</code>、<code>ms-user-autoconfigure</code> 和 <code>ms-user-spring-boot-starter</code>。</p><ul><li><code>ms-user-web</code>: Web层，处理HTTP请求，提供RESTful服务。<ul><li><code>UserController</code>: 控制器，响应<code>/get/&#123;userId&#125;</code>路径的请求。</li></ul></li><li><code>ms-user-api</code>: API层，定义了服务接口和数据传输对象（DTO）。<ul><li><code>User</code>: 用户实体类，表示用户数据。</li><li><code>UserFeignClient</code>: 定义了一个Feign客户端，用于微服务间的通信。</li></ul></li><li><code>ms-user-autoconfigure</code>: 自动配置模块，用于配置项目中的特定Bean和属性。<ul><li>自动配置的核心模块<ul><li>自动配置类<ul><li><code>MsUserAutoConfiguration</code> 类使用了 <code>@ConditionalOnClass</code> 和 <code>@EnableFeignClients</code> 注解，确保在正确的条件下自动配置 Feign 客户端。</li></ul></li><li><code>spring.factories</code> 配置文件<ul><li><code>spring.factories</code> 文件在 <code>ms-user-autoconfigure</code> 模块中定义了自动配置类，确保 Spring Boot 能够自动加载配置。</li></ul></li><li>所需的配置项（通过注解 @EnableConfigurationProperties 和 @ConfigurationProperties 来实现）</li></ul></li><li>值得注意：他可选依赖于 ms-user-api</li></ul></li><li><code>ms-user-spring-boot-starter</code>: Starter模块，便于其他服务引入该模块的功能。<ul><li>通常是一个空的 Jar 包</li><li>对依赖进行集中管理<ul><li>必要是 SpringBoot 核心 starter</li><li>ms-user-autoconfigure 模块</li><li>ms-user-api 模块</li></ul></li></ul></li></ul><p>如果要使用 <code>ms-user-spring-boot-starter</code> 的话，只需添加 <code>ms-user-spring-boot-starter</code> 依赖。</p><p>例如，在另一个 Spring Boot 项目的 <code>pom.xml</code> 中添加以下依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="7、新建项目-ms-marketing"><a href="#7、新建项目-ms-marketing" class="headerlink" title="7、新建项目 ms-marketing"></a>7、新建项目 ms-marketing</h5><p>父 pom.xml</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>ms-marketing-web<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.marketing<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-marketing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-marketing-parent<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">spring.cloud.version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">spring.cloud.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring.cloud.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;spring.cloud.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.10.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h5 id="8、新建模块-ms-marketing-web"><a href="#8、新建模块-ms-marketing-web" class="headerlink" title="8、新建模块 ms-marketing-web"></a>8、新建模块 ms-marketing-web</h5><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-marketing<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.marketing<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-marketing-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>ms-marketing-web<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>营销微服务的web应用<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span>  <br>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!-- ms-user 自动配置的 Starter --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>resources 文件夹下新建 application.yml、banner.txt、logback-spring.xml</p><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span>  <br>  <span class="hljs-attr">port:</span> <span class="hljs-number">12080</span>  <br>  <span class="hljs-attr">servlet:</span>  <br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/</span>  <br>    <span class="hljs-attr">session:</span>  <br>      <span class="hljs-attr">timeout:</span> <span class="hljs-number">60</span>  <br><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">jackson:</span>  <br>    <span class="hljs-attr">time-zone:</span> <span class="hljs-string">GMT+8</span>  <br>    <span class="hljs-attr">date-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>  <br>    <span class="hljs-attr">joda-date-time-format:</span> <span class="hljs-string">yyyy-MM-dd</span> <span class="hljs-string">HH:mm:ss</span>  <br>  <span class="hljs-attr">profiles:</span>  <br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span>  <br>  <span class="hljs-attr">application:</span>  <br>    <span class="hljs-attr">name:</span> <span class="hljs-string">ms-marketing</span>  <br>  <br><span class="hljs-attr">feign:</span>  <br>  <span class="hljs-attr">circuitbreaker:</span>  <br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>  <br>  <br><span class="hljs-attr">cnmemset:</span>  <br>  <span class="hljs-attr">ms-user:</span>  <br>    <span class="hljs-attr">url:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8080</span><br></code></pre></td></tr></table></figure><p>添加启动类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package cn.<span class="hljs-property">memset</span>.<span class="hljs-property">marketing</span>.<span class="hljs-property">web</span>;  <br>  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">SpringApplication</span>;  <br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">boot</span>.<span class="hljs-property">autoconfigure</span>.<span class="hljs-property">SpringBootApplication</span>;  <br>  <br><span class="hljs-meta">@SpringBootApplication</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Application</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;  <br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">Application</span>.<span class="hljs-property">class</span>, args);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>新建 Controller 类  GreetingController</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">package</span> cn.memset.marketing.web.controllers;  <br>  <br><span class="hljs-keyword">import</span> cn.memset.user.api.dto.User;  <br><span class="hljs-keyword">import</span> cn.memset.user.api.feign.UserFeignClient;  <br><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Autowired;  <br><span class="hljs-keyword">import</span> org.springframework.util.StringUtils;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PathVariable;  <br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;  <br>  <br><span class="hljs-meta">@RestController</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">GreetingController</span> &#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> UserFeignClient userFeignClient;  <br>  <br>    <span class="hljs-meta">@Autowired</span>  <br>    <span class="hljs-keyword">public</span> GreetingController(UserFeignClient userFeignClient) &#123;  <br>        <span class="hljs-keyword">this</span>.userFeignClient = userFeignClient;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello/&#123;userId&#125;&quot;</span>)</span>  <br>    <span class="hljs-keyword">public</span> String sayHi(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;userId&quot;</span>)</span> long userId) &#123;  <br>        User user = userFeignClient.getUserById(userId);  <br>  <br>        <span class="hljs-keyword">if</span> (user == <span class="hljs-literal">null</span> || !StringUtils.hasLength(user.getName())) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, 匿名者&quot;</span>;  <br>        &#125;  <br>  <br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, &quot;</span> + user.getName();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>在子模块中，也可以选择引入  API 模块依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- API模块的依赖 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.memset.user<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>ms-user-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>区别：</p><ul><li>如果你需要快速启动并且愿意接受 Starter 提供的默认配置，那么引入 <code>ms-user-spring-boot-starter</code> 是一个好选择。</li><li>如果你需要更精细的控制，或者 Starter 包含你不需要的功能，那么直接使用 <code>ms-user-api</code> 可能是更好的选择。</li></ul><h5 id="9、注解解析器"><a href="#9、注解解析器" class="headerlink" title="9、注解解析器"></a>9、注解解析器</h5><p>一些可选的、但强烈建议使用的注解解析器</p><p>在上面的项目中，模块 ms-user-autoconfigure  有引入过下面两个依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 一些可选的、但强烈建议使用的注解解析器 --&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>在 Spring Boot 中，<code>spring-boot-configuration-processor</code> 和 <code>spring-boot-autoconfigure-processor</code> 是两种特别的注解处理器。</p><p>它们在编译阶段工作，用于生成和处理注解的元数据。</p><p><code>spring-boot-configuration-processor</code> 主要用于增强配置属性的开发体验，而 <code>spring-boot-autoconfigure-processor</code> 用于优化 Spring Boot 的自动配置机制。</p><h6 id="spring-boot-configuration-processor"><a href="#spring-boot-configuration-processor" class="headerlink" title="spring-boot-configuration-processor"></a>spring-boot-configuration-processor</h6><ol><li><p><strong>作用</strong>: <code>spring-boot-configuration-processor</code> 是用于处理 <code>@ConfigurationProperties</code> 注解的注解处理器。它在编译阶段运行，生成有关用 <code>@ConfigurationProperties</code> 注解的类的元数据。</p></li><li><p><strong>元数据的作用</strong>: 这些元数据主要用于两个目的：</p><ul><li><strong>提供自动完成和文档提示</strong>：当你在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置属性时，IDE（如 IntelliJ IDEA）可以利用这些元数据来提供自动完成建议和配置属性的文档说明。</li><li><strong>校验支持</strong>：这些元数据还可以用于在运行时验证配置属性的值，确保它们符合预期的格式和约束。</li></ul></li><li><p><strong>使用方式</strong>: 只需将 <code>spring-boot-configuration-processor</code> 作为依赖添加到项目中，它就会在编译时自动工作。</p></li></ol><p>★</p><p>如果你在项目中引入了这个依赖，这个的作用的分析注解</p><p>比如在模块 ms-user-autoconfigure 中的  MsUserConfiguration 类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span>(proxyBeanMethods = <span class="hljs-literal">false</span>)  <br><span class="hljs-meta">@ConfigurationProperties</span>(prefix = <span class="hljs-string">&quot;cnmemset.ms-user&quot;</span>)  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MsUserConfiguration</span> &#123;  <br>    <span class="hljs-comment">/**  </span><br><span class="hljs-comment">     * 微服务ms-user的url  </span><br><span class="hljs-comment">     */</span>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> url = <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getUrl</span>(<span class="hljs-params"></span>) &#123;  <br>        <span class="hljs-keyword">return</span> url;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setUrl</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> url</span>) &#123;  <br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">url</span> = url;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>他会进行分析 注解   @ConfigurationProperties  进行生成了配置项的描述信息</p><p>并存放在配置文件 target&#x2F;ms-user-autoconfigure-1.0.0.jar::META&#x2F;INF&#x2F;spring-configuration-metada.json </p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240127203152.png" alt="image.png"></p><p>从而 使得 IDE可以进行自动提示，方便开发人员的使用。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240127203258.png" alt="image.png"></p><h6 id="spring-boot-autoconfigure-processor"><a href="#spring-boot-autoconfigure-processor" class="headerlink" title="spring-boot-autoconfigure-processor"></a>spring-boot-autoconfigure-processor</h6><ol><li><p><strong>作用</strong>: <code>spring-boot-autoconfigure-processor</code> 是用于处理 Spring Boot 的自动配置类（使用 <code>@Configuration</code> 注解的类）的注解处理器。它在编译阶段生成 <code>spring.factories</code> 文件中 <code>@Configuration</code> 类的元数据。</p></li><li><p><strong>元数据的作用</strong>: 生成的元数据有助于优化 Spring Boot 应用程序的启动时间。这是通过减少在类路径上进行的昂贵的检查来实现的，因为 Spring Boot 可以直接查找 <code>spring.factories</code> 文件来找到所有自动配置类，而不是扫描整个类路径。</p></li><li><p><strong>使用方式</strong>: 类似于 <code>spring-boot-configuration-processor</code>，将它作为依赖添加到你的自动配置模块中。</p></li></ol><p>★</p><p> 该依赖会在编译阶段，进行分析注解 @EnableAutoConfiguration</p><p>生成所有自动配置类的过滤条件的元数据；然后存放在配置文件中</p><p>META&#x2F;INF&#x2F;spring-configuration-metada.properties</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240127203650.png" alt="image.png"></p><p>从而使得 SpringBoot 在启动的时候能快速的过滤掉不符合条件的自动配置类，加快启动速度。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的生命周期</title>
    <link href="/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>本篇讲述一下关于Bean的生命周期。</p><p>bean的作用域有很多种，这里讨论一下完全被 IOC容器控制的单例 Bean。</p><h3 id="1、Spring-Bean-生命周期的四个阶段"><a href="#1、Spring-Bean-生命周期的四个阶段" class="headerlink" title="1、Spring Bean 生命周期的四个阶段"></a>1、Spring Bean 生命周期的四个阶段</h3><blockquote><p>普通的 Java 对象</p></blockquote><p>对于普通的 Java 对象来说，它们的生命周期是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><blockquote><p>Spring Bean</p></blockquote><p>而对于 Spring Bean 的生命周期来说，可以分为四个阶段：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>其中初始化完成之后，就代表这个 Bean 可以使用了</p><p>上述四个阶段的大概的一个逻辑</p><p>前面三个阶段的操作（先大概了解有这个印象，具体内容继续往下面看）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = (BeanWrapper)<span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 实例化阶段</span><br>        instanceWrapper = <span class="hljs-built_in">this</span>.createBeanInstance(beanName, mbd, args);<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 属性赋值阶段</span><br>        <span class="hljs-built_in">this</span>.populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化阶段</span><br>        exposedObject = <span class="hljs-built_in">this</span>.initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>销毁操作，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p><h3 id="2、Spring-Bean-的生命周期的扩展点"><a href="#2、Spring-Bean-的生命周期的扩展点" class="headerlink" title="2、Spring Bean 的生命周期的扩展点"></a>2、Spring Bean 的生命周期的扩展点</h3><p>上面讲述到Bean的生命周期有四个阶段，分别是：实例化  →  属性赋值  →  初始化  →  销毁；</p><p>在不同阶段中间，Spring 框架会进行一些功能的扩展点，下面分四个部分分别讲解这些扩展点。</p><ul><li>Bean 自身方法</li><li>容器级别方法</li><li>工厂后处理器方法</li><li>Bean 级生命周期方法</li></ul><h4 id="2-1-Bean-自身的方法"><a href="#2-1-Bean-自身的方法" class="headerlink" title="2.1  Bean 自身的方法"></a>2.1  Bean 自身的方法</h4><p>在Bean的生命周期中，Bean自身是有一些特定方法是能够被调用的，以便完成其生命周期过程。</p><p>比如构造函数、getter&#x2F;setter 以及 init-method 和 destory-method 所指定的方法等，而这些方法又分别对应着上文说的四个阶段：例化、属性赋值、初始化和销毁。</p><p>这些Bean自身的方法一般是我们在配置Bean的时候就已经定义好的，下面我们通过一个简单 Bean 的使用来看一下其用法。</p><blockquote><p>Bean 示例</p></blockquote><p>我们定义一个简单的 Bean，名为 <code>MyBean</code>，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-comment">// 构造函数 - 实例化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBean</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean Constructor: Bean is being instantiated.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Setter 方法 - 属性赋值阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">String <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean setValue: Setting property value.&quot;</span>);<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化方法 - 初始化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean init: Bean is being initialized.&quot;</span>);<br>        <span class="hljs-comment">// 执行初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 销毁方法 - 销毁阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean destroy: Bean is being destroyed.&quot;</span>);<br>        <span class="hljs-comment">// 执行清理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们通过注解或者xml 配置声明  init-method 和 destory-method  对应的方法。</p><blockquote><p>xml 配置</p></blockquote><p><strong>在 Spring 配置中定义 Bean</strong></p><p>在 Spring 的 XML 配置文件中，如下配置这个 Bean，并指定 <code>init-method</code> 和 <code>destroy-method</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.MyBean&quot;</span> init-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;init&quot;</span> destroy-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;destroy&quot;</span>&gt;<br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;value&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;Some value&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注解配置</p></blockquote><p>在基于 Java 的配置中，可以使用 <code>@Bean</code> 注解：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;init&quot;</span>, destroyMethod = <span class="hljs-string">&quot;destroy&quot;</span>)<br>    <span class="hljs-keyword">public</span> MyBean myBean() &#123;<br>        MyBean myBean = <span class="hljs-keyword">new</span> <span class="hljs-type">MyBean</span>();<br>        myBean.setValue(<span class="hljs-string">&quot;Some value&quot;</span>);<br>        <span class="hljs-keyword">return</span> myBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Bean</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;appContext.xml&quot;</span>);<br>        SimpleBean simpleBean = context.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;myBean&quot;</span>, MyBean.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 使用 simpleBean ...</span><br>        ((ClassPathXmlApplicationContext) context).<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭上下文以触发销毁方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>四个主要阶段以及代码解释</p></blockquote><p>通过注解或者xml配置的方式，我们指定了初始化和销毁方法，并在 <code>MyBean</code> 定义了 Setter 方法，具体在容器执行的时候，会进行以下的操作：</p><ol><li><strong>实例化阶段</strong>:<ul><li>当 Spring 容器创建 <code>MyBean</code> 的实例时，首先调用其构造函数。</li></ul></li><li><strong>属性赋值阶段</strong>:<ul><li>接着，Spring 容器通过调用 <code>setValue</code> 方法来注入属性值。</li></ul></li><li><strong>初始化阶段</strong>:<ul><li>在所有属性都设置之后，Spring 容器调用指定的 <code>init</code> 方法。</li></ul></li><li><strong>销毁阶段</strong>:<ul><li>当 Spring 容器关闭时，它会调用 <code>destroy</code> 方法。</li></ul></li></ol><h4 id="2-2-容器级别方法"><a href="#2-2-容器级别方法" class="headerlink" title="2.2  容器级别方法"></a>2.2  容器级别方法</h4><p>将这个容器级别方法理解为阶段中间容器会进行的一些操作，这些方法一般是 BeanPostProcessor 的一系列接口。</p><p>在上述讲到的Bean 四个阶段，在这四个阶段的执行过程中，进行一些前置或者后置的操作。</p><p>这些操作独立于 Bean 之外，并且会注册到 Spring 容器中，在Spring 容器创建Bean的时候，会进行一些处理。</p><p>具体的一个关系看下图（比较清晰）：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png" alt="image.png"></p><p>你可以理解  <code>InstantiationAwareBeanPostProcessor</code> 接口方法是 作为 实例化阶段的”产前产后护理”；<code>BeanPostProcessor</code> 是 初始化阶段的 “关键调整和增强”。</p><h5 id="源码内容分析（容器级别方法）"><a href="#源码内容分析（容器级别方法）" class="headerlink" title="源码内容分析（容器级别方法）"></a>源码内容分析（容器级别方法）</h5><p>需要去了解Bean的生命周期，这个源码对应的方法是必须去了解和看的。</p><h5 id="InstantiationAwareBeanPostProcessor-接口分析"><a href="#InstantiationAwareBeanPostProcessor-接口分析" class="headerlink" title="InstantiationAwareBeanPostProcessor 接口分析"></a>InstantiationAwareBeanPostProcessor 接口分析</h5><p>查看源码，可以看到 InstantiationAwareBeanPostProcessor 接口是继承  BeanPostProcessor</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">InstantiationAwareBeanPostProcessor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BeanPostProcessor</span><br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractAutowireCapableBeanFactory#createBean</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建Bean实例的方法，接收Bean的名称、RootBeanDefinition（Bean的定义信息）和参数数组</span><br>protected Object createBean(<span class="hljs-keyword">String</span> beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable Object[] args) throws BeanCreationException &#123;</span><br>    <span class="hljs-comment">// 如果启用了跟踪日志，输出创建Bean实例的跟踪信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析Bean的类信息，如果已经有解析过的类信息，使用之前解析得到的类信息</span><br>    RootBeanDefinition mbdToUse = mbd;<br>    Class&lt;?&gt; resolvedClass = <span class="hljs-built_in">this</span>.resolveBeanClass(mbd, beanName, <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 如果解析得到的类信息不为空，且当前Bean的定义信息没有指定类信息，则更新Bean的定义信息</span><br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-type">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 准备处理方法的覆盖，即准备解析方法注解</span><br>        mbdToUse.prepareMethodOverrides();<br>    &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException var9) &#123;<br>        <span class="hljs-comment">// 如果方法注解解析失败，抛出BeanDefinitionStoreException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, var9);<br>    &#125;<br><br>    Object beanInstance;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在实例化Bean之前，尝试调用BeanPostProcessor的beforeInstantiation方法</span><br>        beanInstance = <span class="hljs-built_in">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-comment">// 如果beforeInstantiation方法返回非空，表示已经创建了Bean实例，直接返回该实例</span><br>        <span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> beanInstance;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>        <span class="hljs-comment">// 如果beforeInstantiation方法抛出异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var10);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行真正的Bean创建逻辑，包括实例化、属性注入等过程</span><br>        beanInstance = <span class="hljs-built_in">this</span>.doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">// 如果启用了跟踪日志，输出Bean实例创建完成的跟踪信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 返回创建的Bean实例</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125; <span class="hljs-keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了异常，抛出异常</span><br>        <span class="hljs-keyword">throw</span> var7;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了未捕获的异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, var8);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-工厂后处理器方法"><a href="#2-3-工厂后处理器方法" class="headerlink" title="2.3 工厂后处理器方法"></a>2.3 <strong>工厂后处理器方法</strong></h4><p><strong>BeanFactoryProcessor 一系列接口</strong></p><p>包括 AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor 等。</p><p>这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能</p><blockquote><p>BeanFactoryProcessor 接口 vs  BeanPostProcessor接口</p></blockquote><p><code>BeanFactoryPostProcessor</code> 接口和 <code>BeanPostProcessor</code> 接口都是 Spring 框架中用于定制和扩展 Bean 的关键接口，但它们的作用和时机略有不同。</p><p>BeanFactoryPostProcessor 接口：</p><ol><li><p><strong>作用：</strong> <code>BeanFactoryPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 之前修改或定制 BeanFactory 的配置。</p></li><li><p><strong>时机：</strong> 在 Spring 容器读取了 Bean 的定义（配置元数据）但在实例化任何 Bean 之前，<code>BeanFactoryPostProcessor</code> 接口提供了机会来修改 Bean 的定义，例如修改属性值、添加属性等。</p></li><li><p><strong>实现方法：</strong> 实现 <code>postProcessBeanFactory</code> 方法，该方法传递了 BeanFactory 对象，可以在此方法中修改 BeanFactory 的配置。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">ConfigurableListableBeanFactory</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistryPostProcessor</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistry</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanFactory</span>(<span class="hljs-params">ConfigurableListableBeanFactory beanFactory</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以修改 BeanFactory 的配置</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span>(<span class="hljs-params">BeanDefinitionRegistry registry</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以注册新的 BeanDefinition</span><br>        <span class="hljs-title class_">BeanDefinitionBuilder</span> builder = <span class="hljs-title class_">BeanDefinitionBuilder</span>.<span class="hljs-title function_">genericBeanDefinition</span>(<span class="hljs-title class_">MyBean</span>.<span class="hljs-property">class</span>);<br>        registry.<span class="hljs-title function_">registerBeanDefinition</span>(<span class="hljs-string">&quot;myBean&quot;</span>, builder.<span class="hljs-title function_">getBeanDefinition</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor 接口</p></blockquote><ol><li><p><strong>作用：</strong> <code>BeanPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 后，在 Bean 的初始化前后执行一些自定义的逻辑。</p></li><li><p><strong>时机：</strong> 当 Bean 被实例化后，但在调用其初始化方法（如果有的话）之前，<code>BeanPostProcessor</code> 提供了 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code> 方法用于在初始化阶段进行定制操作。</p></li><li><p><strong>实现方法：</strong> 实现 <code>BeanPostProcessor</code> 接口的两个方法，可以在这两个方法中添加定制逻辑。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">BeanPostProcessor</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之前的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之后的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><code>BeanFactoryPostProcessor</code> 主要用于修改整个 BeanFactory 的配置，它在 Bean 实例化之前执行。</li><li><code>BeanPostProcessor</code> 主要用于在每个 Bean 的初始化阶段添加自定义逻辑，它在 Bean 实例化后，初始化方法调用前后执行。</li></ul><p>在实际应用中，可以同时使用这两个接口来完成更复杂的定制需求。</p><h4 id="2-4-Bean-级生命周期方法"><a href="#2-4-Bean-级生命周期方法" class="headerlink" title="2.4  Bean 级生命周期方法"></a>2.4  <strong>Bean 级生命周期方法</strong></h4><p>关于 Bean 级生命周期方法的理解：</p><ul><li>这些方法提供了针对 Bean 实例的<strong>个性化行为</strong>，允许 Bean 在其生命周期的关键点做出响应。</li></ul><p>通过这些方法，是可以对于某个Bean实例进行个性化操作的。</p><p>可以理解为 Bean 类直接实现接口的方法，比如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等方法，这些方法只对当前 Bean 生效。</p><p>Aware 类型的接口</p><p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。</p><p>基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。</p><h3 id="3、Spring-Bean-详细生命周期"><a href="#3、Spring-Bean-详细生命周期" class="headerlink" title="3、Spring Bean 详细生命周期"></a>3、Spring Bean 详细生命周期</h3><blockquote><p>Bean 的生命周期</p></blockquote><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 set() 方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName() 方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader() 方法，传入 ClassLoader 对象的实例。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory() 方法，传入 BeanFactory 对象的实例。</li><li>与上面的类似，如果实现了其他 * .Aware 接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessBeforeInitialization() 方法</li><li>如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><h3 id="4、Bean-创建流程入口-refresh"><a href="#4、Bean-创建流程入口-refresh" class="headerlink" title="4、Bean 创建流程入口 refresh()"></a>4、Bean 创建流程入口 refresh()</h3><h4 id="相关概念回顾"><a href="#相关概念回顾" class="headerlink" title="相关概念回顾"></a>相关概念回顾</h4><h5 id="Spring上下文"><a href="#Spring上下文" class="headerlink" title="Spring上下文"></a>Spring上下文</h5><p>从代码级别来说，就是指Spring Context</p><p>从源码级别，我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境。</p><h5 id="Spring-初始化操作"><a href="#Spring-初始化操作" class="headerlink" title="Spring 初始化操作"></a>Spring 初始化操作</h5><p>具体操作可以见下#ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用</p><p>使用前需要引入 spring-context 相关的依赖，初始化Bean可以通过注解的方式也可以通过xml的方式。</p><h5 id="BeanFactory-与-ApplicationContext"><a href="#BeanFactory-与-ApplicationContext" class="headerlink" title="BeanFactory  与  ApplicationContext"></a><code>BeanFactory</code>  与  <code>ApplicationContext</code></h5><p>先了解一下  <code>BeanFactory</code> 与  <code>ApplicationContext</code> 接口两个的作用与概念：</p><ul><li><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是Spring Framework的IoC容器的基础。 </li><li><code>BeanFactory</code> 提供了配置框架和基本功能，提供了一种高级配置机制，能够管理任何类型的对象。</li><li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子接口，相比于 <code>BeanFactory</code>  来说，增加了更多的企业特定功能, 是 <code>BeanFactory</code> 的一个完整的超集。</li><li><code>BeanFactory</code> 实现了<strong>延迟</strong>加载（懒加载），只有在请求获取Bean时（例如，通过<code>getBean()</code>方法），容器才会创建该Bean。这意味着如果应用中未使用某个Bean，它就不会被实例化。</li><li><code>ApplicationContext</code>其下管理的 Bean 是<strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li></ul><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。</p><h5 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a><code>AbstractApplicationContext</code></h5><p><code>AbstractApplicationContext</code> 实现了 <code>ApplicationContext</code> 接口，提供了这个接口的大部分通用功能。</p><p>它是实际应用上下文类（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>）的父类</p><p>通过继承和扩展 <code>AbstractApplicationContext</code>，Spring 允许开发者自定义应用上下文的行为，以满足特定的业务需求。</p><h5 id="ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？"><a href="#ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？" class="headerlink" title="ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？"></a>ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？</h5><p>以下是几个典型场景，其中可能会加载并使用 <code>ClassPathXmlApplicationContext</code> 的构造方法：</p><ol><li>Java 应用的主方法 (main)</li></ol><p>在一个标准的 Java 应用程序中，你可以在 <code>main</code> 方法中创建 <code>ClassPathXmlApplicationContext</code> 的实例来启动 Spring 容器。这是最常见的用法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">// 使用 context 获取 Bean 实例...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ClassPathXmlApplicationContext</code> 用于加载名为 “applicationContext.xml” 的配置文件。</p><ol start="2"><li>Web 应用程序</li></ol><p>在基于 Servlet 的传统 Web 应用程序中，可以在 Servlet 的 <code>init</code> 方法中创建 <code>ClassPathXmlApplicationContext</code>，或者使用 Spring 的 <code>ContextLoaderListener</code> 在 Web 应用启动时自动加载 Spring 上下文。</p><ol start="3"><li>单元测试</li></ol><p>在编写 Spring 应用的单元测试时，可以在测试类中创建 <code>ClassPathXmlApplicationContext</code> 来加载所需的 Spring 配置，并进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;testContext.xml&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        <span class="hljs-comment">// 执行测试...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，测试使用了单独的配置文件 “testContext.xml”。</p><ol start="4"><li>Spring Boot 应用</li></ol><p>使用 Spring Boot 时通常不直接使用 <code>ClassPathXmlApplicationContext</code></p><p> Spring Boot 提供了基于注解的配置和自动配置的能力，一般是使用注解配置的方式进行声明Bean操作 ，但在一些旧的或特殊的情况下，可能仍然需要手动加载 XML 配置的方式。</p><hr><h4 id="Bean-创建流程入口"><a href="#Bean-创建流程入口" class="headerlink" title="Bean 创建流程入口"></a>Bean 创建流程入口</h4><p>这里直接跟一下源码看一下相关内容</p><p>下面的代码是从 spring-context-5.2.4.RELEASE 版本中的 AbstractApplicationContext 抽象类下相关方法和内容说明。</p><p>在实际应用上下文类中（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>），他们的构造方法中会调用这个 refresh() 方法类进行初始化 Spring 容器。</p><p>因此可以判断出  Bean 创建流程入口 是定义在 AbstractApplicationContext 抽象类下 refresh() 方法。</p><h5 id="refressh方法"><a href="#refressh方法" class="headerlink" title="refressh方法"></a>refressh方法</h5><p>这里实际看一下相关代码 AbstractApplicationContext#refresh()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void refresh() throws BeansException, IllegalStateException &#123;<br>    <span class="hljs-comment">// 同步锁确保容器刷新时的线程安全</span><br>    synchronized (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br><br>        <span class="hljs-comment">// 准备刷新，设置启动日期和活跃状态等</span><br>        <span class="hljs-keyword">this</span>.prepareRefresh();<br><br>        <span class="hljs-comment">// 获取新的 BeanFactory，初始化 BeanFactory，并加载 Bean 定义</span><br>        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 配置 BeanFactory，设置类加载器、事件处理器等</span><br>        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 允许在 BeanFactory 标准初始化之后进行定制修改</span><br>            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// 调用在容器中注册的 BeanFactoryPostProcessor</span><br>            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 注册 BeanPostProcessor，这些处理器影响所有 Bean 的创建</span><br>            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 初始化 MessageSource 组件，用于国际化处理</span><br>            <span class="hljs-keyword">this</span>.initMessageSource();<br><br>            <span class="hljs-comment">// 初始化 ApplicationEventMulticaster，用于事件广播</span><br>            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 特定于 ApplicationContext 的刷新操作</span><br>            <span class="hljs-keyword">this</span>.onRefresh();<br><br>            <span class="hljs-comment">// 注册监听器到事件广播器</span><br>            <span class="hljs-keyword">this</span>.registerListeners();<br><br>            <span class="hljs-comment">// 初始化所有剩余的非懒加载单例</span><br>            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 完成刷新过程，通知生命周期处理器以及发布相应的事件</span><br>            <span class="hljs-keyword">this</span>.finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;<br>            <span class="hljs-comment">// 在上下文初始化过程中捕获并处理异常</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);<br>            &#125;<br><br>            <span class="hljs-comment">// 销毁已创建的 Bean，以防有些 Bean 已经初始化了，但后续的初始化过程失败了</span><br>            <span class="hljs-keyword">this</span>.destroyBeans();<br><br>            <span class="hljs-comment">// 取消刷新操作，重置上下文的同步标志</span><br>            <span class="hljs-keyword">this</span>.cancelRefresh(var9);<br><br>            <span class="hljs-comment">// 重新抛出异常，通知外部调用者</span><br>            <span class="hljs-keyword">throw</span> var9;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 重置公共缓存（例如 Reflection 缓存）</span><br>            <span class="hljs-keyword">this</span>.resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>可以看到初始化单例这步操作是在 this.finishBeanFactoryInitialization(beanFactory); 这里进行的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 BeanFactory 包含名为 &quot;conversionService&quot; 的 Bean，并且这个 Bean 适配于 ConversionService 类型</span><br>    <span class="hljs-keyword">if</span> (beanFactory.<span class="hljs-built_in">containsBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>) &amp;&amp; beanFactory.<span class="hljs-built_in">isTypeMatch</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>)) &#123;<br>        <span class="hljs-comment">// 将这个 Bean 设置为容器的 ConversionService</span><br>        beanFactory.<span class="hljs-built_in">setConversionService</span>((ConversionService)beanFactory.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 BeanFactory 还没有嵌入的值解析器</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.<span class="hljs-built_in">hasEmbeddedValueResolver</span>()) &#123;<br>        <span class="hljs-comment">// 添加一个嵌入的值解析器，用于解析占位符</span><br>        beanFactory.<span class="hljs-built_in">addEmbeddedValueResolver</span>(strVal -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getEnvironment</span>().<span class="hljs-built_in">resolvePlaceholders</span>(strVal);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有实现 LoadTimeWeaverAware 接口的 Bean 的名称</span><br>    <span class="hljs-type">String</span>[] weaverAwareNames = beanFactory.<span class="hljs-built_in">getBeanNamesForType</span>(LoadTimeWeaverAware.<span class="hljs-keyword">class</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 遍历这些 Bean 名称</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> weaverAwareName : weaverAwareNames) &#123;<br>        <span class="hljs-comment">// 初始化相应的 Bean，以确保它们能够执行加载时织入（Load Time Weaving）的相关逻辑</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getBean</span>(weaverAwareName);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 BeanFactory 的临时类加载器设置为 null</span><br>    beanFactory.<span class="hljs-built_in">setTempClassLoader</span>(null);<br><br>    <span class="hljs-comment">// 冻结所有的 Bean 定义，表示注册的 Bean 定义将不再被修改或任何进一步的处理</span><br>    beanFactory.<span class="hljs-built_in">freezeConfiguration</span>();<br><br>    <span class="hljs-comment">// 预实例化单例，确保所有非懒加载的单例都被实例化</span><br>    beanFactory.<span class="hljs-built_in">preInstantiateSingletons</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实例化 Instantiation</p></blockquote><p>其中第一阶段 —— 实例化 Instantiation，</p><p>Bean 实例化的时机分为两种，一种是 BeanFactory，还有一种是  ApplicationContext；</p><p>下面是两者差别：</p><ul><li>BeanFactory<ul><li>其下管理的Bean <strong>在使用到Bean的时候</strong> 才会进行实例化Bean操作（懒加载策略）</li></ul></li><li>ApplicationContext  <ul><li>其下管理的 Bean <strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li><li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，复杂程度更高一些。</li><li>如<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>等，提供了多种方便的方式来创建ApplicationContext实例</li></ul></li></ul><hr><p>视频地址：  <a href="https://www.bilibili.com/video/BV1584y1r7n6/">https://www.bilibili.com/video/BV1584y1r7n6/</a></p><h4 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231218215844.png" alt="image.png"></p><p>生产 →  使用  →  销毁</p><h5 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h5><p>启动，准备容器&#x2F;环境等</p><p>① 加载 Bean 定义（BeanDefinitions)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">加载Bean定义<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>通过 loadBeanDefinitions 扫描所有xml配置、注解将Bean记录在 Bean定义集合 beanDefinitionMap 中</p><p>②创建 Bean 对象（createBean)</p><p>遍历“Bean定义”集合</p><p>通过 createBean 遍历 beanDefinitionMap 创建bean</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">创建Bean<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">preInstantiateSingletioins</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">doGetBean</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">createBean</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><blockquote><p>2.1.构造对象</p></blockquote><p>通过 createBeanInstance 方法进行对象的构造</p><p>使用反射机制从“Bean定义”中的BeanClass拿到类的构造方法</p><p>准备参数：在单例池中，根据参数的Class类进行查找</p><p>构造对象：通过反射进行Bean的构造（如果是无参则无需准备参数直接构造）</p><hr><p>查找Class类<br>    当匹配到多个实例，<br>    会再根据参数名进行匹配</p><blockquote><p>2.2.填充属性</p></blockquote><p>通过 populateBean 方法对 Bean 内部所需属性进行属性填充, 通常是 @Autowired 注解的变量</p><p>三级缓存进行依赖注入</p><blockquote><p>2.3.初始化实例</p></blockquote><p>通过 initializeBean 方法对实例进行初始化</p><p>初始化操作：</p><ol><li>初始化容器相关信息<br>通过 invokeAwareMethods 方法为实现各种 Aware 接口的Bean设置诸如 beanName, beanFactory 等容器信息<br>Aware 接口指代：信息感知接口</li><li>通过 invokeInitMethods 方法执行 Bean 的初始化方法</li></ol><p>该 invokeInitMethods 方法是通过实现 InitializingBean 接口而实现的 afterPropertiesSet 方法<br>【Bean填充属性后执行】  ((InitializingBean)bean).afterPropertiesSet()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">afterPropertiesSet <br><br>↓ <br><br><span class="hljs-keyword">init</span>-Methods<br><br>↓<br><br>BeanPostProcessors<br></code></pre></td></tr></table></figure><hr><h5 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h5><p>销毁操作<br>销毁前<br>    销毁之前会执行 postProcessBeforeDestruction “销毁前处理器“，这步会执行 Bean 中 @PreDestroy 注解的方法<br>容器销毁<br>    后续通过 destoryBeans 方法逐一“销毁”容器中的Bean，销毁的时候会执行 destroy 方法（通过registerDisposableBean方法注册的Bean，该接口只有一个方法 destroy。在Bean销毁的时候，Spring容器会调用这个方法。）<br>Bean自定义销毁方法<br>    “客户销毁方法”invokeCustomDestroyMethod; →  执行Bean上自定义的 destoryMethod 方法</p><h3 id="5、Spring-Bean-生命周期流程图"><a href="#5、Spring-Bean-生命周期流程图" class="headerlink" title="5、Spring Bean 生命周期流程图"></a>5、<strong>Spring Bean 生命周期流程图</strong></h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312160247944.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html">https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html</a></li><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://www.bilibili.com/video/BV1584y1r7n6">https://www.bilibili.com/video/BV1584y1r7n6</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li><li><a href="https://blog.csdn.net/qq_20021569/article/details/109178816">https://blog.csdn.net/qq_20021569/article/details/109178816</a></li><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></li><li><a href="https://cloud.tencent.com/developer/article/2216932">https://cloud.tencent.com/developer/article/2216932</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_性能优化</title>
    <link href="/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>性能优化参考： <a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a></p><p>规范</p><p>略</p><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html</a></li><li><a href="https://mp.weixin.qq.com/s/NM-aHaW6TXrnO6la6Jfl5A">https://mp.weixin.qq.com/s/NM-aHaW6TXrnO6la6Jfl5A</a></li><li><a href="https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q">https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q</a></li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的作用域</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>复习概念</p></blockquote><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些"></a>Spring 中的 bean 的作用域有哪些</h3><p>这个问题是面试题场景的一个问题，我们首先来看一下基本的一个回答。</p><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><blockquote><p>如何配置 bean 的作用域</p></blockquote><p>xml 方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public Person <span class="hljs-built_in">personPrototype</span>() &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>具体怎么配置的看你实际使用，这里大概讲一下使用场景，通过不同场景下的使用示例对 Spring 中 Bean 的作用域有一个基本认知。</p><h4 id="Singleton-Bean（默认作用域）"><a href="#Singleton-Bean（默认作用域）" class="headerlink" title="Singleton Bean（默认作用域）"></a>Singleton Bean（默认作用域）</h4><p><strong>场景</strong>: 在一个在线书店应用中，有一个库存管理服务负责跟踪所有书籍的库存。这个服务需要是单例的，因为它维护着整个应用中书籍库存的统一视图。</p><p>代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; bookInventory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(String isbn, <span class="hljs-type">int</span> quantity)</span> &#123;<br>        bookInventory.put(isbn, bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) + quantity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkStock</span><span class="hljs-params">(String isbn)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他与库存管理相关的方法 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>InventoryService</code> 是一个singleton作用域的Bean，它在应用的整个生命周期内只会有一个实例。</p><p>所有对书籍库存的操作都通过这个单一实例进行，确保了库存数据的一致性。</p><h4 id="Prototype作用域"><a href="#Prototype作用域" class="headerlink" title="Prototype作用域"></a>Prototype作用域</h4><p><strong>场景</strong>: 在同一在线书店应用中，当用户想要购买书籍时，每个购物车都应该是独立的。因此，每个用户的购物车应该有其自己的状态。</p><p>代码逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Scope</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Component</span>;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> isbn</span>) &#123;<br>        items.<span class="hljs-title function_">put</span>(isbn, items.<span class="hljs-title function_">getOrDefault</span>(isbn, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">getItems</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> items;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 购物车的其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApplicationContext</span> context;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ShoppingCart</span> <span class="hljs-title function_">createNewShoppingCart</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">ShoppingCart</span>.<span class="hljs-property">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ShoppingService</code> 使用Spring的应用上下文来为每个用户创建一个新的<code>ShoppingCart</code>实例。</p><p>每次调用<code>createNewShoppingCart</code>方法时，都会返回一个全新的购物车实例，保证了用户之间购物车的隔离。</p><h4 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h4><p><strong>场景</strong>: 在一个新闻网站应用中，你需要跟踪每个HTTP请求的访问信息，例如用户的地理位置和设备类型，以便为他们提供定制化的新闻内容。</p><p>代码逻辑</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.springframework.web.context.annotation.RequestScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequestScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> location;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> deviceType;<br><br>    <span class="hljs-keyword">public</span> UserContext(HttpServletRequest request) &#123;<br>        <span class="hljs-comment">// 通过请求获取用户的位置和设备类型</span><br>        <span class="hljs-built_in">this</span>.location = request.getHeader(<span class="hljs-string">&quot;Location&quot;</span>);<br>        <span class="hljs-built_in">this</span>.deviceType = request.getHeader(<span class="hljs-string">&quot;Device-Type&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation() &#123;<br>        <span class="hljs-keyword">return</span> location;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getDeviceType() &#123;<br>        <span class="hljs-keyword">return</span> deviceType;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserContext userContext;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/news&quot;</span>)<br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;NewsItem&gt;&gt; getNews() &#123;<br>        List&lt;NewsItem&gt; <span class="hljs-keyword">new</span><span class="hljs-type">s</span> = <span class="hljs-keyword">new</span><span class="hljs-type">sService</span>.getNewsForLocation(userContext.getLocation());<br>        <span class="hljs-comment">// 返回定制化的新闻内容</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>UserContext</code>是一个request作用域的Bean，它为每个HTTP请求提供了一个新实例，</p><p>包含了请求特定的用户上下文信息，如位置和设备类型。</p><h4 id="Session作用域"><a href="#Session作用域" class="headerlink" title="Session作用域"></a>Session作用域</h4><p><strong>场景</strong>: 在一个在线考试平台上，每个用户的考试过程需要被追踪。用户可能会在考试中断后返回继续考试，所以考试状态需要在会话中保持。</p><p>代码逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.web.context.<span class="hljs-keyword">annotation</span>.SessionScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@SessionScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamSession</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Exam currentExam;<br>    <span class="hljs-keyword">private</span> int currentQuestionIndex;<br><br>    <span class="hljs-comment">// 考试会话的方法，例如开始考试、回答问题等</span><br>&#125;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ExamSession examSession;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/start&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String startExam() &#123;<br>        examSession.startNewExam();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;exam_started&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/answer&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String answerQuestion(Answer answer) &#123;<br>        examSession.answerQuestion(answer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;answer_recorded&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ExamSession</code> 是一个session作用域的Bean，它记录了用户的当前考试状态。每个用户会话都有自己的<code>ExamSession</code>实例。</p><blockquote><p>Session vs Global-Session vs WebSocket</p></blockquote><ol><li><strong>Session</strong>:<ul><li><strong>作用域</strong>: 限定在一个用户的HTTP会话中。</li><li><strong>典型用例</strong>: 在用户登录到网站后，你可能需要跟踪该用户的特定状态（比如购物车、偏好设置等）。这种情况下，每个用户都有自己的会话，每个会话都有自己的Bean实例。</li></ul></li><li><strong>Global-Session</strong>:<ul><li><strong>作用域</strong>: 限定在Portlet环境的全局HTTP会话中。在Spring 5及之后的版本中已不再使用，因为Spring 5不再支持Portlet。</li><li><strong>典型用例</strong>: 在Portlet环境中，多个Portlet可能需要共享全局会话数据。例如，用户的语言偏好可能需要跨多个Portlet保持一致。</li></ul></li><li><strong>WebSocket</strong>:<ul><li><strong>作用域</strong>: 绑定到WebSocket的会话中。</li><li><strong>典型用例</strong>: 当用户通过WebSocket连接到你的服务器时，你可能需要为每个WebSocket会话保存状态，例如游戏中的玩家状态或聊天应用中的用户会话</li></ul></li></ol><h4 id="Singleton-vs-Prototype"><a href="#Singleton-vs-Prototype" class="headerlink" title="Singleton vs Prototype"></a>Singleton vs Prototype</h4><blockquote><p>Singleton vs Prototype</p></blockquote><ol><li><strong>Singleton</strong>:<ul><li><strong>描述</strong>: 在Spring IoC容器中只创建一个Bean实例。</li><li><strong>典型用例</strong>: 大多数服务层和数据访问层的组件都是无状态的，可以被应用中的所有其他Bean共享。例如，数据库连接池、业务服务等。</li></ul></li><li><strong>Prototype</strong>:<ul><li><strong>描述</strong>: 每次请求时，Spring IoC容器都会创建一个新的Bean实例。</li><li><strong>典型用例</strong>: 比如在一个应用中，你想要为每个文件上传创建一个新的处理器（FileUploadHandler）实例，以防不同用户上传的数据相互冲突。</li></ul></li></ol><p>两种作用域的使用主要取决于Bean的状态管理需求。</p><p>Singleton用于那些不需要维护状态信息的共享组件，而Prototype适用于每次使用都需要一个新状态的场景。</p><blockquote><p>Singleton vs Prototype   对比两者的生命周期区别</p></blockquote><p>单例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 只有一个Bean实例被创建。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 如果Bean实现了<code>InitializingBean</code>接口或定义了自定义的初始化方法（如使用<code>@PostConstruct</code>注解或在XML配置中指定<code>init-method</code>），将会执行。</li><li><strong>后处理</strong>: <code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean现在可以被应用中的其他Bean使用。</li><li><strong>销毁</strong>: 当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口或定义了自定义的销毁方法（如使用<code>@PreDestroy</code>注解或在XML配置中指定<code>destroy-method</code>），将会执行。</li></ol><p>多例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 每次请求时都创建一个新的Bean实例。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 与单例Bean相同，如果有指定的初始化方法，将会执行。</li><li><strong>后处理</strong>: 与单例Bean相同，<code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean被客户端获取并使用。</li><li><strong>销毁</strong>: 容器不会管理多例Bean的完整生命周期；销毁由客户端负责。</li></ol><p>区别：</p><ul><li><strong>实例化频率</strong>:<ul><li><strong>单例</strong>: 只在Spring IoC容器创建时实例化一次。</li><li><strong>多例</strong>: 每次请求时实例化。</li></ul></li><li><strong>依赖注入时机</strong>:<ul><li><strong>单例</strong>: 依赖项在容器创建单例Bean时注入。</li><li><strong>多例</strong>: 依赖项在每次创建新实例时注入。</li></ul></li><li><strong>生命周期管理</strong>:<ul><li><strong>单例</strong>: 容器负责整个生命周期，包括销毁。</li><li><strong>多例</strong>: 容器启动后，不再管理Bean的生命周期；Bean的销毁不由Spring容器管理，需要用户手动管理。</li></ul></li><li><strong>销毁回调</strong>:<ul><li><strong>单例</strong>: 容器关闭时，可以调用销毁方法。</li><li><strong>多例</strong>: 容器不自动调用销毁方法，必须由获取Bean的客户端代码来处理。</li></ul></li></ul><p>在实际应用中，单例Bean通常用于无状态的服务，例如业务逻辑组件和数据访问对象。</p><p>而多例Bean则用于有明确状态的操作，这些状态不能共享给其他实例或线程，例如用户的会话或独立的任务处理器。</p><p>多例Bean 的销毁操作有兴趣可以了解一下： <a href="https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype">https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype</a></p><blockquote><p>为了让Spring容器释放由 prototype scopeBean 持有的资源，可以尝试使用自定义 <a href="https://springdoc.cn/spring/core.html#beans-factory-extension-bpp">Bean后处理器</a>，它持有对需要清理的Bean的引用。</p></blockquote><hr><p>参考</p><ul><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B">Spring常见面试题总结 | JavaGuide(Java面试 + 学习指南)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_IOC</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、IOC是什么"><a href="#1、IOC是什么" class="headerlink" title="1、IOC是什么"></a>1、IOC是什么</h3><p>IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p><p>IOC （Inversion of Control ）指的是控制反转&#x2F;反转控制。</p><blockquote><p>IOC 理论说明</p></blockquote><p>例如：现有类 A 依赖于类 B</p><ul><li>在传统的开发方式中，往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li>使用IOC思想的开发方式：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面获取。</li></ul><p>控制反转主要指的是将对象的创建和对象之间的关系维护交给IOC容器去管理，而不是由程序员手动进行管理。在传统的应用中，对象的创建通常是由程序员通过<code>new</code>关键字来完成的，而对象之间的关系也需要由程序员进行硬编码。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312051438413.png" alt="image.png"></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li></ul><blockquote><p>IOC 和 DI  的关系</p></blockquote><p>其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p><div style="background-color: #3498db; color: white; padding: 10px;">    IoC是设计思想，DI是实现方式。</div><hr><blockquote><p>IOC 容器</p></blockquote><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="2、IOC-配置的三种方式"><a href="#2、IOC-配置的三种方式" class="headerlink" title="2、IOC 配置的三种方式"></a>2、IOC 配置的三种方式</h3><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    主流方式是 注解 + Java 配置.</div><p>Spring框架提供了三种主要的IoC配置方式：XML配置、注解配置和Java配置。开发者可以选择其中一种或混合使用这些方式，来声明对象的依赖关系和配置信息。</p><p>Spring容器会根据这些配置信息，自动扫描并加载所需的对象，实现对象的创建、装配和管理。</p><h4 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h4><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p><p>这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><ul><li><strong>优点</strong>： 可以使用于任何场景，结构清晰，通俗易懂</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><p><strong>举例</strong>：</p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。</p><p>其本质上就是把在XML上的配置声明转移到Java配置类中</p><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><p><strong>举例</strong>：</p><ol><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">pdai</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user dao</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userDao&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-title function_">userDao</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user service</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userService&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">UserServiceImpl</span> userService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.<span class="hljs-title function_">setUserDao</span>(<span class="hljs-title function_">userDao</span>());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><p><strong>举例</strong>：</p><ol><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author pdai</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user dao impl.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return user list</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; findUserList() &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3、依赖注入的三种方式"><a href="#3、依赖注入的三种方式" class="headerlink" title="3、依赖注入的三种方式"></a>3、依赖注入的三种方式</h3><p>参考看一下这个： <a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></p><p>依赖注入有三种主要的实现方式：属性注入、Setter注入和构造方法注入。</p><p>属性注入最简单，但通用性较差。Spring官方推荐使用构造方法注入，因为它支持注入不可变对象，通用性更强。对于可变对象，可以考虑使用Setter注入。</p><p><strong>代码示例</strong></p><blockquote><ol><li>属性注入（Field Injection）</li></ol></blockquote><p><strong>属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式</strong>(直接在类的字段上注入依赖)</p><p>这种方式在某些场景下很方便，但可能会导致难以测试和难以维护的代码，因为它隐藏了类的依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class MyService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private DependencyClass dependency;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-variable">@Component</span><br>public class DependencyClass &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优点是简单易用，缺点也随之而来</p><ol><li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li><li>通用性问题：只能适应于 IoC 容器；</li><li>设计原则问题：更容易违背单一设计原则。</li></ol><blockquote><ol start="2"><li>Setter注入（Setter Injection）</li></ol></blockquote><p>在Setter注入中，Spring通过调用类的setter方法来注入依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> void setDependency(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>setter 的方式可能会麻烦一点，不过他是完全符合单一职责的设计原则，每一个 Setter 只针对一个对象。</p><p>缺点：</p><ol><li>不能注入不可变对象（final 修饰的对象）；</li><li>注入的对象可被修改</li></ol><blockquote><ol start="3"><li>构造方法注入（Constructor Injection）</li></ol></blockquote><p>这种方式通过类的构造方法来注入依赖。这是最推荐的方式，因为它可以确保所需的依赖项在对象创建时即被提供，从而保证了对象的不变性和依赖的不可更改性。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyService</code> 类依赖于 <code>DependencyClass</code>。</p><p>当Spring创建 <code>MyService</code> 的实例时，它会查找 <code>DependencyClass</code> 的实例并通过构造方法注入它。</p><p>从Spring 4.3开始，当一个类只有一个构造函数时，<code>@Autowired</code> 注解是可选的(可以省略）。Spring会自动将这个唯一的构造函数用作依赖注入的入口。</p><p>上面的代码可以简化为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法符合“约定优于配置”的原则，减少了不必要的注解使用。</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html</a></li><li><a href="https://www.martinfowler.com/articles/injection.html">https://www.martinfowler.com/articles/injection.html</a></li><li><a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">https://www.iteye.com/blog/jinnianshilongnian-1413846</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F</a></li><li><a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day04</title>
    <link href="/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/"/>
    <url>/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/</url>
    
    <content type="html"><![CDATA[<p>继续讲述蘑菇博客里面一些写法的使用说明</p><p>解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AvoidRepeatableCommit</span>  <br><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@OperationLogger</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>)  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>, notes = <span class="hljs-string">&quot;增加博客&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/add&quot;</span>)  <br>public String <span class="hljs-built_in">add</span>(<span class="hljs-variable">@Validated</span>(&#123;Insert.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-comment">// 参数校验  </span><br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">blogService</span><span class="hljs-selector-class">.addBlog</span>(blogVO);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解AvoidRepeatableCommit的使用"><a href="#1、自定义注解AvoidRepeatableCommit的使用" class="headerlink" title="1、自定义注解AvoidRepeatableCommit的使用"></a>1、自定义注解<code>AvoidRepeatableCommit</code>的使用</h3><p><code>@AvoidRepeatableCommit</code> 注解用于防止用户在指定时间内重复提交表单或请求。</p><p>与Spring AOP（面向切面编程）一起使用，以便在方法执行之前执行某些预处理操作。</p><h4 id="自定义注解-AvoidRepeatableCommit"><a href="#自定义注解-AvoidRepeatableCommit" class="headerlink" title="自定义注解 AvoidRepeatableCommit"></a>自定义注解 AvoidRepeatableCommit</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-variable">@interface</span> AvoidRepeatableCommit &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定时间内不可重复提交,单位毫秒，默认1秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-selector-tag">long</span> <span class="hljs-selector-tag">timeout</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表明这个注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表明这个注解在运行时保留，可以通过反射读取。</li><li><code>timeout()</code>: 注解的属性，表示不允许重复提交的时间窗口，默认为1000毫秒（1秒）。</li></ul><p>使用场景：在Spring MVC的控制器方法上使用此注解，防止用户在短时间内重复提交相同的请求</p><h4 id="防止重复提交"><a href="#防止重复提交" class="headerlink" title="防止重复提交"></a>防止重复提交</h4><p><code>AvoidRepeatableCommitAspect</code> 类是一个Spring AOP切面，用于防止接口的重复提交。</p><p>这个切面通过拦截被 <code>@AvoidRepeatableCommit</code> 注解标记的方法，并在Redis中记录请求的状态来实现。</p><p>下面是对这个切面类实现的详细解释和注释：</p><blockquote><p>AvoidRepeatableCommitAspect 切面</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AvoidRepeatableCommitAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于处理带有 <span class="hljs-doctag">@AvoidRepeatableCommit</span> 注解的方法。</span><br><span class="hljs-comment">     * 防止同一个用户在指定时间内重复提交相同的请求。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点，提供对连接点的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行的返回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(com.moxi.mogublog.admin.annotion.AvoidRepeatableCommit.AvoidRepeatableCommit)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br>        <span class="hljs-comment">// 获取请求者的IP地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br><br>        <span class="hljs-comment">// 获取注解标记的方法</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br>        <span class="hljs-comment">// 获取类名和方法名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipKey</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s#%s&quot;</span>, className, methodName);<br><br>        <span class="hljs-comment">// 生成基于IP和方法的唯一标识</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> Math.abs(ipKey.hashCode());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s:%s_%d&quot;</span>, RedisConf.AVOID_REPEATABLE_COMMIT, ip, hashCode);<br>        log.info(<span class="hljs-string">&quot;ipKey=&#123;&#125;, hashCode=&#123;&#125;, key=&#123;&#125;&quot;</span>, ipKey, hashCode, key);<br><br>        <span class="hljs-type">AvoidRepeatableCommit</span> <span class="hljs-variable">avoidRepeatableCommit</span> <span class="hljs-operator">=</span> method.getAnnotation(AvoidRepeatableCommit.class);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> avoidRepeatableCommit.timeout();<br><br>        <span class="hljs-comment">// 检查Redis中是否已存在该请求的标记</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisUtil.get(key);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(value)) &#123;<br>            log.info(<span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>            <span class="hljs-keyword">return</span> ResultUtil.result(SysConf.ERROR, <span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置Redis标记以防止在timeout时间内重复提交</span><br>        redisUtil.setEx(key, StringUtils.getUUID(), timeout, TimeUnit.MILLISECONDS);<br><br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Around(&quot;@annotation(...AvoidRepeatableCommit)&quot;)</code>: <ul><li>表明这个切面的方法会在所有标记有 <code>@AvoidRepeatableCommit</code> 注解的方法之前执行。</li></ul></li><li>切面的实现逻辑是：<ul><li>首先检查Redis中是否已经存储了针对该请求的标记。</li><li>如果存在，表示该请求在指定时间内已经提交过，因此拒绝重复提交。</li><li>如果不存在，允许执行方法，并在Redis中设置一个标记，以防止在指定时间内的重复提交。</li></ul></li></ul><p>在这个类中：</p><ol><li>使用 <code>@Aspect</code> 标记这个类为一个切面，并通过 <code>@Component</code> 注册到Spring容器。</li><li><code>@Around</code> 注解定义了一个环绕通知，拦截所有使用 <code>@AvoidRepeatableCommit</code> 注解的方法。</li><li>在通知方法内，首先获取请求者的IP地址和目标方法的信息，然后构建一个唯一的Redis key。</li><li>通过检查Redis中该key的存在与否来判断是否已经提交过相同的请求。如果已经提交过，返回错误信息，防止重复处理。</li><li>如果没有提交过，将该key存储到Redis中，并设置过期时间为注解中指定的超时时间。</li><li>最后，执行被拦截的方法。</li></ol><p>这种实现方式有效地利用了Redis来防止短时间内的重复提交，适用于表单提交等需要防止重复操作的场景。<br>通过这个切面，可以增强应用的健壮性，防止由于重复提交导致的数据问题或资源浪费。</p><h3 id="2、自定义注解-OperationLogger-的使用"><a href="#2、自定义注解-OperationLogger-的使用" class="headerlink" title="2、自定义注解 OperationLogger 的使用"></a>2、自定义注解 <code>OperationLogger</code> 的使用</h3><p><code>@OperationLogger</code> 是一个自定义注解，用于记录操作日志。结合Spring AOP，在方法执行前后添加日志记录的逻辑。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Target</span>(ElementType.METHOD)<br><span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-keyword">@interface</span> OperationLogger &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务名称。</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-built_in">value</span>() default &quot;&quot;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 平台</span><br><span class="hljs-comment">     */</span><br>    PlatformEnum <span class="hljs-built_in">platform</span>() default PlatformEnum<span class="hljs-selector-class">.ADMIN</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否将当前日志记录到数据库中。</span><br><span class="hljs-comment">     */</span><br>    boolean <span class="hljs-built_in">save</span>() default true;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表示该注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表示该注解在运行时有效，可以通过反射获取。</li><li><code>value()</code>: 提供业务名称，默认为空。</li><li><code>platform()</code>: 指定操作发生的平台，默认为 <code>ADMIN</code>。</li><li><code>save()</code>: 指示是否将日志记录保存到数据库，默认为 <code>true</code>。</li></ul><h4 id="LoggerAspect"><a href="#LoggerAspect" class="headerlink" title="LoggerAspect"></a>LoggerAspect</h4><p><code>LoggerAspect</code> 是一个切面类，用于处理带有 <code>@OperationLogger</code> 注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间，用于计算方法执行时长</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date startTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义切点，匹配带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(OperationLogger operationLogger)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于在方法执行前后添加日志记录逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, OperationLogger operationLogger)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 日志收集</span><br>            handle(joinPoint);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;日志记录出错!&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志处理逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.getMethod(point);<br>        <span class="hljs-type">OperationLogger</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(OperationLogger.class);<br><br>        <span class="hljs-comment">// 判断是否需要保存日志</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> annotation.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(point.getArgs(), annotation.value());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ua</span> <span class="hljs-operator">=</span> RequestUtil.getUa();<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; | &#123;&#125; - &#123;&#125; &#123;&#125; - &#123;&#125;&quot;</span>, bussinessName, IpUtils.getIpAddr(request), RequestUtil.getMethod(), RequestUtil.getRequestUrl(), ua);<br><br>        <span class="hljs-keyword">if</span> (!save) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取参数名称和值</span><br>        Map&lt;String, Object&gt; nameAndArgsMap = AopUtils.getFieldsName(point);<br>        <span class="hljs-type">SecurityUser</span> <span class="hljs-variable">securityUser</span> <span class="hljs-operator">=</span> (SecurityUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramsJson</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(nameAndArgsMap);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> request.getMethod();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 异步存储日志</span><br>        threadPoolTaskExecutor.execute(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLogHandle</span>(ip, type, url, securityUser, paramsJson, point.getTarget().getClass().getName(),<br>                        point.getSignature().getName(), bussinessName, startTime, redisUtil));<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在执行带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法时抛出异常后执行的通知。</span><br><span class="hljs-comment"> * 用于记录异常信息和相关操作日志。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> joinPoint 连接点，提供对目标方法的访问</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operationLogger 操作日志的自定义注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e 抛出的异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AfterThrowing(value = &quot;pointcut(operationLogger)&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, OperationLogger operationLogger, Throwable e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">// 创建一个异常日志对象</span><br><span class="hljs-type">ExceptionLog</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionLog</span>();<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br><span class="hljs-comment">// 获取请求IP地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>exception.setIp(ip);<br><br><span class="hljs-comment">// 解析操作名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">operationName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(joinPoint.getArgs(), operationLogger.value());<br><br><span class="hljs-comment">// 尝试从Redis中获取IP来源信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonResult</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip);<br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(jsonResult)) &#123;<br><span class="hljs-comment">// 如果Redis中没有IP来源信息，则查询并保存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">addresses</span> <span class="hljs-operator">=</span> IpUtils.getAddresses(SysConf.IP + SysConf.EQUAL_TO + ip, SysConf.UTF_8);<br><span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(addresses)) &#123;<br>exception.setIpSource(addresses);<br>redisUtil.setEx(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip, addresses, <span class="hljs-number">24</span>, TimeUnit.HOURS);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果Redis中已有IP来源信息，直接使用</span><br>exception.setIpSource(jsonResult);<br>&#125;<br><br><span class="hljs-comment">// 设置异常日志的其他信息</span><br>exception.setIp(ip);<br>exception.setMethod(joinPoint.getSignature().getName());<br>exception.setExceptionJson(JSON.toJSONString(e,<br>SerializerFeature.DisableCircularReferenceDetect,<br>SerializerFeature.WriteMapNullValue));<br>exception.setExceptionMessage(e.getMessage());<br>exception.setOperation(operationName);<br>exception.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>exception.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><span class="hljs-comment">// 将异常日志保存到数据库</span><br>exception.insert();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SysLogHandle-类"><a href="#SysLogHandle-类" class="headerlink" title="SysLogHandle 类"></a><code>SysLogHandle</code> 类</h4><p><code>SysLogHandle</code> 是一个Runnable实现，用于异步记录日志信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysLogHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractRequestAwareRunnable</span> &#123;<br><br>    <span class="hljs-comment">// Redis工具类，用于操作Redis</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RedisUtil</span> redisUtil;<br><br>    <span class="hljs-comment">// 请求的参数列表，以JSON字符串格式保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> paramsJson;<br><br>    <span class="hljs-comment">// 被调用的类的完整路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> classPath;<br><br>    <span class="hljs-comment">// 被调用的方法名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> methodName;<br><br>    <span class="hljs-comment">// 方法请求的开始时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Date</span> startTime;<br><br>    <span class="hljs-comment">// 操作名称，通常从注解中获取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> operationName;<br><br>    <span class="hljs-comment">// 请求的IP地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> ip;<br><br>    <span class="hljs-comment">// 请求类型（如GET、POST）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>;<br><br>    <span class="hljs-comment">// 请求的URL</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> requestUrl;<br><br>    <span class="hljs-comment">// 当前操作的安全用户信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">SecurityUser</span> securityUser;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，初始化日志处理所需的各种参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip           请求的IP地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type         请求类型（如GET、POST）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestUrl   请求的URL</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> securityUser 当前操作的安全用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> paramsJson   请求的参数列表（JSON格式）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> classPath    被调用的类的完整路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodName   被调用的方法名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationName 操作名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startTime    方法请求的开始时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisUtil    Redis工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">SysLogHandle</span>(<span class="hljs-title class_">String</span> ip, <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>, <span class="hljs-title class_">String</span> requestUrl, <span class="hljs-title class_">SecurityUser</span> securityUser,<br>                        <span class="hljs-title class_">String</span> paramsJson, <span class="hljs-title class_">String</span> classPath,<br>                        <span class="hljs-title class_">String</span> methodName, <span class="hljs-title class_">String</span> operationName,<br>                        <span class="hljs-title class_">Date</span> startTime, <span class="hljs-title class_">RedisUtil</span> redisUtil) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ip</span> = ip;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestUrl</span> = requestUrl;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">securityUser</span> = securityUser;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">paramsJson</span> = paramsJson;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">classPath</span> = classPath;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = methodName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">operationName</span> = operationName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = startTime;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisUtil</span> = redisUtil;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行日志记录的逻辑。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onRun</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">SysLog</span> sysLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLog</span>();<br><br>        <span class="hljs-comment">// 从Redis中获取IP来源信息</span><br>        <span class="hljs-title class_">String</span> jsonResult = redisUtil.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isEmpty</span>(jsonResult)) &#123;<br>            <span class="hljs-title class_">String</span> addresses = <span class="hljs-title class_">IpUtils</span>.<span class="hljs-title function_">getAddresses</span>(<span class="hljs-title class_">SysConf</span>.<span class="hljs-property">IP</span> + <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">EQUAL_TO</span> + ip, <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">UTF_8</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotEmpty</span>(addresses)) &#123;<br>                sysLog.<span class="hljs-title function_">setIpSource</span>(addresses);<br>                redisUtil.<span class="hljs-title function_">setEx</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip, addresses, <span class="hljs-number">24</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">HOURS</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sysLog.<span class="hljs-title function_">setIpSource</span>(jsonResult);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置日志的其他属性</span><br>        sysLog.<span class="hljs-title function_">setIp</span>(ip);<br>        sysLog.<span class="hljs-title function_">setClassPath</span>(classPath);<br>        sysLog.<span class="hljs-title function_">setMethod</span>(methodName);<br>        sysLog.<span class="hljs-title function_">setType</span>(<span class="hljs-keyword">type</span>);<br>        sysLog.<span class="hljs-title function_">setUrl</span>(requestUrl);<br>        sysLog.<span class="hljs-title function_">setOperation</span>(operationName);<br>        sysLog.<span class="hljs-title function_">setCreateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUserName</span>(securityUser.<span class="hljs-title function_">getUsername</span>());<br>        sysLog.<span class="hljs-title function_">setAdminUid</span>(securityUser.<span class="hljs-title function_">getUid</span>());<br>        sysLog.<span class="hljs-title function_">setParams</span>(paramsJson);<br><br>        <span class="hljs-comment">// 计算并设置请求耗时</span><br>        <span class="hljs-title class_">Date</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-title class_">Long</span> spendTime = <span class="hljs-title class_">DateUtil</span>.<span class="hljs-title function_">between</span>(startTime, endTime, <span class="hljs-title class_">DateUnit</span>.<span class="hljs-property">MS</span>);<br>        sysLog.<span class="hljs-title function_">setSpendTime</span>(spendTime);<br><br>        <span class="hljs-comment">// 将日志信息保存到数据库</span><br>        sysLog.<span class="hljs-title function_">insert</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SysLogHandle</code> 继承自 <code>AbstractRequestAwareRunnable</code>，它是一个Runnable实现，用于异步执行日志记录任务。</li><li>构造函数接收所有必要的参数，包括请求信息、用户信息和方法信息。</li><li><code>onRun</code> 方法是日志记录逻辑的实现。它首先从Redis中获取IP来源信息，然后创建一个 <code>SysLog</code> 对象并设置各种属性，包括请求信息、用户信息、操作名称、参数等。</li><li>最后，计算请求耗时并将日志信息保存到数据库。</li></ul><p>这个类的主要作用是异步记录每次请求的详细日志，包括请求参数、执行时间等，</p><p>通过异步处理，它还有助于减少日志记录对应用性能的影响。</p><h4 id="异步日志记录的功能"><a href="#异步日志记录的功能" class="headerlink" title="异步日志记录的功能"></a>异步日志记录的功能</h4><p>在切面的时候，handle 方法保存日志的操作是异步进行的，这里单独拿出来分析一下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 异步存储日志</span><br><span class="hljs-selector-tag">threadPoolTaskExecutor</span><span class="hljs-selector-class">.execute</span>(<br>        new <span class="hljs-built_in">SysLogHandle</span>(ip, type, url, securityUser,<br>                        paramsJson, point.<span class="hljs-built_in">getTarget</span>().<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getName</span>(),<br>                        point.<span class="hljs-built_in">getSignature</span>().<span class="hljs-built_in">getName</span>(), bussinessName,<br>                        startTime, redisUtil));<br><br></code></pre></td></tr></table></figure><ol><li><strong>使用线程池</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这部分代码利用Spring框架中的 <code>ThreadPoolTaskExecutor</code> 来执行一个任务。<code>ThreadPoolTaskExecutor</code> 是一个基于线程池的TaskExecutor实现，允许异步执行任务。</li></ul></li><li><strong>创建日志处理任务</strong>:<ul><li><code>new SysLogHandle(...)</code>: 这里创建了一个 <code>SysLogHandle</code> 对象，它是一个实现了 <code>Runnable</code> 接口的类，用于处理日志记录的具体逻辑。</li></ul></li><li><strong>传递参数给日志处理任务</strong>:<ul><li>向 <code>SysLogHandle</code> 构造器传递了多个参数，包括请求的IP地址 (<code>ip</code>)、请求类型 (<code>type</code>)、请求URL (<code>url</code>)、当前安全用户 (<code>securityUser</code>)、请求参数的JSON字符串 (<code>paramsJson</code>)、被调用的类名和方法名（通过 <code>point.getTarget().getClass().getName()</code> 和 <code>point.getSignature().getName()</code> 获取）、业务名称 (<code>bussinessName</code>)、方法开始执行的时间 (<code>startTime</code>)，以及Redis工具类 (<code>redisUtil</code>)。</li></ul></li><li><strong>执行任务</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这个方法将 <code>SysLogHandle</code> 的实例提交到线程池进行异步执行，不会阻塞当前线程的执行。这意味着原方法（被 <code>@OperationLogger</code> 注解的方法）的执行和日志的记录是并发进行的。</li></ul></li></ol><blockquote><p>实际应用</p></blockquote><p>在实际应用中，这种异步日志记录方法非常有用，尤其是在高流量的Web应用中。它允许应用快速响应用户请求，同时将耗时的日志记录操作放在后台线程中执行，从而不会显著影响用户体验和应用性能。</p><p>通过将日志记录逻辑从主执行路径中分离出来，可以减少对主业务逻辑的干扰，同时确保了重要的操作日志被正确记录和存储。</p><h4 id="工具类AspectUtil"><a href="#工具类AspectUtil" class="headerlink" title="工具类AspectUtil"></a>工具类AspectUtil</h4><p>对于上面使用到的工具类 AspectUtil 进行记录说明</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-variable">enum</span> <span class="hljs-title class_">AspectUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例实例，枚举类型保证全局唯一。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">INSTANCE</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取以类路径为前缀的键。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix 前缀字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 以类路径为前缀的键字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getKey</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>, <span class="hljs-params">String</span> <span class="hljs-params">prefix</span>) &#123;<br>        <span class="hljs-title class_">String</span> <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span><span class="hljs-title class_">StringUtils</span>.<span class="hljs-property">isEmpty</span>(<span class="hljs-variable">prefix</span>)) &#123;<br>            <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">prefix</span>;<br>        &#125;<br>        <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-variable">point</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">keyPrefix</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法所在的类的名称，替换所有的点为下划线。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 处理后的类名字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>().<span class="hljs-property">getClass</span>().<span class="hljs-property">getName</span>().<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法的Method对象。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前执行方法的Method对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NoSuchMethodException 如果无法找到相应的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Method</span> <span class="hljs-title function_">getMethod</span>(<span class="hljs-title class_">JoinPoint</span> <span class="hljs-variable">point</span>) <span class="hljs-variable">throws</span> <span class="hljs-title class_">NoSuchMethodException</span> &#123;<br>        <span class="hljs-title class_">Signature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getSignature</span>();<br>        <span class="hljs-title class_">MethodSignature</span> <span class="hljs-variable">msig</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">MethodSignature</span>) <span class="hljs-variable">sig</span>;<br>        <span class="hljs-title class_">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">target</span>.<span class="hljs-property">getClass</span>().<span class="hljs-property">getMethod</span>(<span class="hljs-variable">msig</span>.<span class="hljs-property">getName</span>(), <span class="hljs-variable">msig</span>.<span class="hljs-property">getParameterTypes</span>());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析业务名称中的占位符，并用方法参数替换。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 方法参数数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bussinessName 带占位符的业务名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 解析后的业务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">parseParams</span>(<span class="hljs-params">Object</span>[] <span class="hljs-params">params</span>, <span class="hljs-params">String</span> <span class="hljs-params">bussinessName</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)) &#123;<br>            <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">RegexUtils</span>.<span class="hljs-property">match</span>(<span class="hljs-variable">bussinessName</span>, <span class="hljs-string">&quot;(?&lt;=<span class="hljs-char escape_">\\</span>&#123;)(<span class="hljs-char escape_">\\</span>d+)&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-variable">s</span> : <span class="hljs-variable">result</span>) &#123;<br>                int index <span class="hljs-operator">=</span> <span class="hljs-title class_">Integer</span>.<span class="hljs-property">parseInt</span>(<span class="hljs-variable">s</span>);<br>                <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>&#123;&quot;</span> <span class="hljs-operator">+</span> index <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&#125;&quot;</span>, <span class="hljs-variable">JSON</span>.<span class="hljs-property">toJSONString</span>(<span class="hljs-variable">params</span>[index <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">bussinessName</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>AspectUtil</code> 是一个枚举类型，提供了一个全局唯一的实例 <code>INSTANCE</code>。</li><li><code>getKey</code> 方法根据连接点 (<code>JoinPoint</code>) 和给定的前缀生成一个字符串键。该键通常用于识别特定的方法或类。</li><li><code>getClassName</code> 方法获取连接点指向的目标类的名称，并将其中的点替换为下划线。这在需要基于类名生成唯一标识时很有用。</li><li><code>getMethod</code> 方法返回连接点指向的具体方法的 <code>Method</code> 对象，用于进一步的反射操作。</li><li><code>parseParams</code> 方法解析业务名称字符串中的占位符，并用方法的实际参数替换这些占位符。这对于生成动态的日志消息或错误消息非常有用，特别是当消息内容依赖于方法的输入参数时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day03</title>
    <link href="/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/"/>
    <url>/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/</url>
    
    <content type="html"><![CDATA[<p>这里讲述蘑菇博客里面一些写法的使用说明</p><p>下面的章节都是为了解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解-AuthorityVerify-的使用"><a href="#1、自定义注解-AuthorityVerify-的使用" class="headerlink" title="1、自定义注解 AuthorityVerify 的使用"></a>1、自定义注解 AuthorityVerify 的使用</h3><h4 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AuthorityVerify &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</code>：这表明这个注解可以应用于方法和类。如果放在类上，通常意味着类中的所有方法都应用这个注解；如果放在方法上，则只针对该方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：这指定了注解的保留策略是在运行时。这意味着这个注解不仅被保存在class文件中，还可以通过反射在运行时被读取。</li><li><code>String value() default &quot;&quot;</code>：这是一个可选的注解元素，允许在使用注解时设置一个字符串值。它的默认值是空字符串。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>这个注解可以应用于类或方法来实现权限验证。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span><br>public class SomeController &#123;<br><br>    <span class="hljs-variable">@AuthorityVerify</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/someSecureMethod&quot;</span>)<br>    public String <span class="hljs-built_in">someSecureMethod</span>() &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@AuthorityVerify</code> 应用于一个控制器方法。<br>你可以将其放在任何Spring Controller的方法上，表示该方法需要进行权限验证。<br>注解中的 <code>&quot;admin&quot;</code> 字符串可以用来指定需要哪种权限才能访问该方法。</p><p>要让这个注解真正起作用，还需要编写额外的代码来处理这个注解。通常是通过Spring的AOP（面向切面编程）功能来实现的，可以创建一个切面来拦截带有 <code>@AuthorityVerify</code> 注解的方法调用，然后执行权限验证逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityAspect</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取注解中的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> authorityVerify.value();<br><br>        <span class="hljs-comment">// 这里实现权限验证逻辑</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 继续执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里蘑菇博客项目也是这样使用的。</p><p>上面的示例是通过注解的值，然后在环绕通知里面的方法，根据获取值来进行下一步操作。</p><p>蘑菇博客的这个方法有所不同的是，他是通过判断添加该注解的方法，获取访问请求路径，获取用户，判定该用户下是否有该访问路径的权限。</p><p>getList 方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AuthorityVerifyAspect"><a href="#AuthorityVerifyAspect" class="headerlink" title="AuthorityVerifyAspect"></a><code>AuthorityVerifyAspect</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 权限校验 切面实现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-06-19:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityVerifyAspect</span> &#123;<br><br>    <span class="hljs-comment">// 自动注入所需的服务和工具类</span><br>    <span class="hljs-meta">@Autowired</span><br>    CategoryMenuService categoryMenuService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RoleService roleService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    AdminService adminService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisUtil redisUtil;<br><br>    <span class="hljs-comment">// 定义切点，指向使用AuthorityVerify注解的方法</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(AuthorityVerify authorityVerify)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，用于在方法执行前后添加额外的处理</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-comment">// 获取当前HTTP请求的属性</span><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attribute.getRequest();<br><br>        <span class="hljs-comment">// 获取请求路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 解析出请求者的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">adminUid</span> <span class="hljs-operator">=</span> request.getAttribute(SysConf.ADMIN_UID).toString();<br><br>        <span class="hljs-comment">// 尝试从Redis获取管理员能够访问的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">visitUrlStr</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.ADMIN_VISIT_MENU + RedisConf.SEGMENTATION + adminUid);<br>        LinkedTreeMap&lt;String, String&gt; visitMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedTreeMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 判断Redis中是否有数据</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(visitUrlStr)) &#123;<br>            <span class="hljs-comment">// 从Redis中获取</span><br>            visitMap = (LinkedTreeMap&lt;String, String&gt;) JsonUtils.jsonToMap(visitUrlStr, String.class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Redis中没有，则查询数据库</span><br>            <span class="hljs-type">Admin</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> adminService.getById(adminUid);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">roleUid</span> <span class="hljs-operator">=</span> admin.getRoleUid();<br>            <span class="hljs-type">Role</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> roleService.getById(roleUid);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">categoryMenuUids</span> <span class="hljs-operator">=</span> role.getCategoryMenuUids();<br>            String[] uids = categoryMenuUids.replace(<span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>            List&lt;String&gt; categoryMenuUids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(uids));<br><br>            <span class="hljs-comment">// 只查询访问的按钮</span><br>            QueryWrapper&lt;CategoryMenu&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>            queryWrapper.in(SQLConf.UID, categoryMenuUids);<br>            queryWrapper.eq(SQLConf.MENU_TYPE, EMenuType.BUTTON);<br>            queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br>            List&lt;CategoryMenu&gt; buttonList = categoryMenuService.list(queryWrapper);<br><br>            <span class="hljs-keyword">for</span> (CategoryMenu item : buttonList) &#123;<br>                <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(item.getUrl())) &#123;<br>                    visitMap.put(item.getUrl(), item.getUrl());<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将访问URL存储到Redis中</span><br>            redisUtil.setEx(RedisConf.ADMIN_VISIT_MENU + SysConf.REDIS_SEGMENTATION + adminUid, JsonUtils.objectToJson(visitMap), <span class="hljs-number">1</span>, TimeUnit.HOURS);<br>        &#125;<br><br>        <span class="hljs-comment">// 判断该角色是否能够访问该接口</span><br>        <span class="hljs-keyword">if</span> (visitMap.get(url) != <span class="hljs-literal">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;用户拥有操作权限，访问的路径: &#123;&#125;，拥有的权限接口：&#123;&#125;&quot;</span>, url, visitMap.get(url));<br>            <span class="hljs-comment">// 用户有权限，继续执行业务</span><br>            <span class="hljs-keyword">return</span> joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;用户不具有操作权限，访问的路径: &#123;&#125;&quot;</span>, url);<br>            <span class="hljs-comment">// 用户无权限，返回无权限的响应</span><br>            <span class="hljs-keyword">return</span> ResultUtil.result(ECode.NO_OPERATION_AUTHORITY, MessageConf.RESTAPI_NO_PRIVILEGE);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、-Validated-注解的使用"><a href="#2、-Validated-注解的使用" class="headerlink" title="2、@Validated 注解的使用"></a>2、@Validated 注解的使用</h3><h4 id="解释如何使用的"><a href="#解释如何使用的" class="headerlink" title="解释如何使用的"></a>解释如何使用的</h4><p>Spring框架中，<code>@Validated</code> 注解是用来启用方法参数级别的验证的。这个注解告诉Spring需要对被注解的参数执行验证。</p><blockquote><p>如何使用 <code>@Validated</code></p></blockquote><p>一般会结合 验证组、<code>@RequestBody</code>、<code>BindingResult</code> 结合使用</p><ol><li><strong>指定验证组</strong>:<ul><li><code>@Validated</code> 可以指定一个或多个验证组，例如 <code>@Validated(&#123;GetList.class&#125;)</code>。这意味着只有在 <code>GetList</code> 组中定义的验证规则会被应用于 <code>blogVO</code> 对象。如果没有指定组，将应用默认的验证规则。</li></ul></li><li><strong>与 <code>@RequestBody</code> 结合</strong>:<ul><li>在REST控制器中，<code>@Validated</code> 通常与 <code>@RequestBody</code> 结合使用，用于验证JSON请求体映射到的Java对象。</li></ul></li><li><strong>处理验证结果</strong>:<ul><li>通常与 <code>BindingResult</code> 结合使用，后者用于捕获验证过程中发现的错误。如果存在错误，可以通过检查 <code>BindingResult</code> 对象来响应相应的错误信息。</li></ul></li></ol><h4 id="基本使用用法"><a href="#基本使用用法" class="headerlink" title="基本使用用法"></a>基本使用用法</h4><blockquote><p>使用示例</p></blockquote><p>展示如何在Spring Boot应用中对一个REST API端点的请求体进行验证。</p><p><strong>场景描述</strong></p><p>假设我们正在编写一个博客应用程序，需要一个API来创建新的博客文章。</p><p>我们希望确保传入的数据满足某些条件，比如标题不为空，内容长度不低于一定字符数等。</p><p><strong>实体类定义</strong></p><p>首先，我们定义一个 <code>BlogPost</code> 类，它包含文章的标题和内容，这些字段都有特定的验证规则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">NotBlank</span>;<br><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">Size</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogPost</span> &#123;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Title is required&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Content is required&quot;</span>)<br>    <span class="hljs-meta">@Size</span>(min = <span class="hljs-number">100</span>, message = <span class="hljs-string">&quot;Content must be at least 100 characters long&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> content;<br><br>    <span class="hljs-comment">// Getters and setters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getTitle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTitle</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> title</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getContent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setContent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制器方法</strong></p><p>接下来，我们创建一个REST控制器方法来接收博客文章的数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.validation.BindingResult;<br><span class="hljs-keyword">import</span> org.springframework.validation.<span class="hljs-keyword">annotation</span>.Validated;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/createBlog&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String createBlog(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> BlogPost blogPost, BindingResult result) &#123;<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            <span class="hljs-comment">// 处理验证错误，例如返回错误信息</span><br>            <span class="hljs-keyword">return</span> result.getFieldError().getDefaultMessage();<br>        &#125;<br>        <span class="hljs-comment">// 如果数据有效，执行业务逻辑，例如保存博客文章</span><br>        <span class="hljs-comment">// saveBlogPost(blogPost);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blog post created successfully&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下上面的用法</p><ul><li><code>BlogPost</code> 类中的字段 <code>title</code> 和 <code>content</code> 使用了JSR 380（Hibernate Validator）注解来声明验证规则。<code>@NotBlank</code> 确保字段不为空，<code>@Size</code> 指定了 <code>content</code> 字段的最小长度。</li><li>在 <code>BlogController</code> 的 <code>createBlog</code> 方法中，<code>@Validated</code> 注解用于启用对 <code>@RequestBody</code> 注解的 <code>BlogPost</code> 对象的自动验证。</li><li><code>BindingResult</code> 参数用于捕获任何验证错误。如果存在错误，可以从 <code>BindingResult</code> 中获取错误信息并适当响应。</li></ul><p>在接口调用的时候，当客户端发送POST请求到 <code>/createBlog</code> 端点，并提供JSON格式的博客文章数据时，Spring将自动验证该数据是否符合 <code>BlogPost</code> 类中定义的规则。如果数据不符合规则，将返回相应的错误信息。</p><h4 id="如果需要使用验证组，是如何使用的"><a href="#如果需要使用验证组，是如何使用的" class="headerlink" title="如果需要使用验证组，是如何使用的"></a>如果需要使用验证组，是如何使用的</h4><blockquote><p>使用示例2</p></blockquote><p>这里主要说明一下验证组的使用</p><p>在Spring框架中，当 <code>@Validated</code> 注解被应用于一个方法参数，并且指定了一个或多个组类，进行验证时只会考虑那些属于指定组的验证约束。</p><p><strong>验证组的作用</strong></p><ol><li><strong>分组验证</strong>:<ul><li>验证组允许你将一个实体类（如 <code>BlogVO</code>）的验证规则分成不同的组。这样，你可以在不同的场景下应用不同的验证规则集合。</li><li>例如，一个实体在创建时可能需要一组验证规则，在更新时需要另一组规则。</li></ul></li><li><strong>定义验证组</strong>:<ul><li>验证组通常是空接口，用于标识验证规则属于哪个组。</li><li>例如，<code>public interface GetList &#123;&#125;</code> 可以作为一个验证组的声明。</li></ul></li></ol><p><strong>代码示例</strong></p><p>实体类中的验证规则</p><p>在 <code>BlogVO</code> 实体类中，验证注解可能像这样使用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span>VO &#123;<br><br>    <span class="hljs-variable">@NotBlank</span>(groups = <span class="hljs-title class_">GetList</span>.<span class="hljs-keyword">class</span>, message = <span class="hljs-string">&quot;Title cannot be empty when getting list&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-regexp">//</span> 其他字段和getter/setter<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中：</p><ul><li><code>@NotBlank</code> 注解只有在执行针对 <code>GetList</code> 组的验证时才会生效。</li><li>如果在一个方法中使用了 <code>@Validated(&#123;GetList.class&#125;)</code> 对 <code>BlogVO</code> 实例进行验证，那么只有那些指定为 <code>GetList</code> 组的验证规则（如上面的 <code>title</code> 字段）会被考虑。</li><li>这种方式提供了灵活性，允许在不同的操作（如获取列表、创建、更新等）中重复使用同一个实体类，同时应用不同的验证规则。</li></ul><p>控制器方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><p>GetList 接口定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * GetList Group  用于getList方法查询时  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2019年12月4日22:49:01  </span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetList</span> &#123;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Validated(&#123;GetList.class&#125;)</code> 表明只有标记为 <code>GetList</code> 组的验证约束会被应用于 <code>BlogVO</code> 对象。</li><li>这意味着 <code>BlogVO</code> 类中的某些验证注解可能被指定为仅在 <code>GetList</code> 组上下文中有效。</li></ul><hr><h3 id="3、抛出异常工具类ThrowableUtils"><a href="#3、抛出异常工具类ThrowableUtils" class="headerlink" title="3、抛出异常工具类ThrowableUtils"></a>3、抛出异常工具类ThrowableUtils</h3><p>这个类主要用法是处理验证结果，当传入接口数据时，映射对象  BlogVO 里面的参数校验，对应的验证结果  result ，对验证结果进行处理</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抛出异常工具类</span><br><span class="hljs-comment"> * 用于处理和格式化由Spring Validation框架抛出的验证错误。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @author 陌溪</span><br><span class="hljs-comment"> * @date 2019年12月4日22:47:18</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ThrowableUtils &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验参数正确性，如果发现验证错误，则拼装并抛出自定义异常。</span><br><span class="hljs-comment">     * 这个方法主要用于处理由Spring Validation框架产生的验证错误。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param result BindingResult对象，包含验证过程中产生的错误信息。</span><br><span class="hljs-comment">     */</span><br>    public static void checkParamArgument(BindingResult result) &#123;<br>        <span class="hljs-comment">// 检查是否存在验证错误</span><br>        <span class="hljs-keyword">if</span> (result != null &amp;&amp; result.hasErrors()) &#123;<br>            StringBuilder sb = new StringBuilder();<br><br>            <span class="hljs-comment">// 获取所有字段级别的错误</span><br>            <span class="hljs-keyword">List</span>&lt;FieldError&gt; errors = result.getFieldErrors();<br>            <span class="hljs-keyword">if</span> (CollectionUtil.isNotEmpty(errors)) &#123;<br>                <span class="hljs-comment">// 只处理第一个错误</span><br>                FieldError <span class="hljs-keyword">error</span> = errors.<span class="hljs-built_in">get</span>(0);<br>                <br>                <span class="hljs-comment">// 获取被拒绝的值（即不合法的输入值）</span><br>                String rejectedValue = Objects.<span class="hljs-keyword">toString</span>(<span class="hljs-keyword">error</span>.getRejectedValue(), <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-comment">// 获取默认错误信息</span><br>                String defMsg = <span class="hljs-keyword">error</span>.getDefaultMessage();<br><br>                <span class="hljs-comment">// 排除在类级别上的注解提示</span><br>                <span class="hljs-keyword">if</span> (rejectedValue.contains(Constants.DELIMITER_TO)) &#123;<br>                    <span class="hljs-comment">// 对于类级别的错误，直接使用错误信息</span><br>                    sb.<span class="hljs-keyword">append</span>(defMsg);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 对于字段级别的错误，拼接字段名和错误信息</span><br>                    <span class="hljs-keyword">if</span> (Constants.DELIMITER_COLON.contains(defMsg)) &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理非字段级别的错误（如类级别的错误）</span><br>                String msg = result.getAllErrors().<span class="hljs-built_in">get</span>(0).getDefaultMessage();<br>                sb.<span class="hljs-keyword">append</span>(msg);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 抛出自定义异常，包含处理过的错误信息</span><br>            throw new ApiInvalidParamException(sb.<span class="hljs-keyword">toString</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、自定义异常-ApiInvalidParamException-的使用"><a href="#4、自定义异常-ApiInvalidParamException-的使用" class="headerlink" title="4、自定义异常 ApiInvalidParamException 的使用"></a>4、自定义异常 ApiInvalidParamException 的使用</h3><p><code>ApiInvalidParamException</code> 类是一个自定义异常类，继承自 <code>RuntimeException</code>。其主要作用是封装和表示与API参数相关的错误或异常情况。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的运行时异常类，用于表示API操作中的参数无效或不符合预期的情况。</span><br><span class="hljs-comment"> * 这个类主要用于在API层抛出参数相关的异常，并能够被全局异常处理器捕获和处理，</span><br><span class="hljs-comment"> * 以便返回统一格式的错误响应给客户端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiInvalidParamException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无参构造函数。</span><br><span class="hljs-comment">     * 创建一个没有详细错误消息的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息和原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述和原因的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含原因的ApiInvalidParamException异常实例，但不提供详细信息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><p>类中定义了几个构造函数，允许在创建异常实例时提供不同类型的信息：</p><ol><li><p><strong>无参构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException()</code>: 创建一个没有详细错误消息的异常实例。</li></ul></li><li><p><strong>带消息的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message)</code>: 创建一个带有具体错误描述的异常实例。</li></ul></li><li><p><strong>带消息和原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message, Throwable cause)</code>: 创建一个异常实例，同时提供错误描述和一个原始异常（原始异常表示这个新异常的原因）。</li></ul></li><li><p><strong>带原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(Throwable cause)</code>: 创建一个异常实例，只包含一个原始异常。</li></ul></li></ol><blockquote><p>自定义异常类的使用</p></blockquote><p><strong>使用场景</strong></p><p>在API的各个层面（如控制器、服务或数据访问层）中，当遇到不符合要求的参数或其他与参数相关的问题时，可以抛出 <code>ApiInvalidParamException</code>。</p><p>然后，全局异常处理器可以捕获这些异常，并将它们转换为统一的、用户友好的响应格式，如JSON，包含错误代码和错误消息。</p><p><strong>作用和用途</strong></p><ol><li><strong>自定义异常处理</strong>:<ul><li>这个类用于表示在API中遇到的特定类型的参数错误。通过创建这样的自定义异常，可以更清晰地表达代码中可能出现的特定错误情况。</li></ul></li><li><strong>全局异常拦截</strong>:<ul><li>在一个基于Spring Boot的REST API项目中，通常会有一个全局异常处理器（如使用 <code>@ControllerAdvice</code> 注解的类）。</li><li><code>ApiInvalidParamException</code> 可以被这样的全局处理器捕获，并转换为统一的响应格式发送给API的调用者。这有助于维持API的响应格式的一致性。</li></ul></li><li><strong>错误消息定制</strong>:<ul><li>这个异常类允许在抛出异常时附带一个自定义的错误消息，这对于提供更详细的错误信息（例如，哪个参数错误以及为什么错误）非常有用。</li></ul></li></ol><h3 id="5、全局异常处理"><a href="#5、全局异常处理" class="headerlink" title="5、全局异常处理"></a>5、全局异常处理</h3><p><code>GlobalExceptionConfig</code> 类和 <code>HandlerExceptionResolver</code> 类是Spring框架中用于全局异常处理的配置和实现</p><p>针对蘑菇博客相关实现，进行说明</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration  </span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionConfig</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@Bean  </span><br>    <span class="hljs-keyword">public</span> HandlerExceptionResolver getHandlerExceptionResolver() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">HandlerExceptionResolver</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Configuration</code>: 表示这个类包含Spring容器的bean定义。</li><li><code>@Bean</code>: 表示该方法将返回一个对象，该对象应该被注册为Spring应用程序上下文中的bean。</li><li><code>getHandlerExceptionResolver()</code>: 这个方法创建并返回 <code>HandlerExceptionResolver</code> 的一个实例，用于全局异常处理</li></ul><blockquote><p>HandlerExceptionResolver 类解释</p></blockquote><p><code>HandlerExceptionResolver</code> 类实现了Spring的 <code>HandlerExceptionResolver</code> 接口，用于处理Spring MVC抛出的所有异常。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">HandlerExceptionResolver</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolveException</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, <span class="hljs-built_in">Object</span> handler, Exception exception</span>) &#123;<br>        <span class="hljs-comment">// 异常处理逻辑...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Slf4j</code>: Lombok库提供的注解，为类提供了一个日志对象 <code>log</code>。</li><li><code>resolveException(...)</code>: 这是异常处理的核心方法，它接收发生异常的HTTP请求和响应、处理器（handler）对象以及实际抛出的异常。</li><li>在这个方法内部，可以根据不同类型的异常进行处理，并生成适当的响应</li></ul><p>具体代码分析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理Spring MVC抛出的所有异常。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request   当前的HTTP请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response  当前的HTTP响应</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler   处理当前请求的处理器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exception 抛出的异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ModelAndView - Spring MVC的模型和视图对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>, Exception exception)</span> </span>&#123;<br>        log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;系统统一异常处理：&quot;</span>, exception);<br><br>        <span class="hljs-comment">// 检查响应是否已经提交</span><br>        <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化错误代码和信息</span><br>        String errorCode = ErrorCode.ERROR;<br>        String message = BaseMessageConf.OPERATION_FAIL;<br><br>        <span class="hljs-comment">// 根据异常类型设置不同的错误代码和消息</span><br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BusinessException) &#123;<br>            errorCode = ((BusinessException) exception).getCode();<br>            message = exception.getMessage();<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(exception <span class="hljs-keyword">instanceof</span> ApiInvalidParamException)</span> </span>&#123;<br>            errorCode = ErrorCode.PARAM_INCORRECT;<br>            message = exception.getMessage();<br>        &#125;<br>        <span class="hljs-comment">// ...处理其他自定义异常</span><br><br>        <span class="hljs-comment">// 设置响应类型为JSON</span><br>        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);<br><br>        <span class="hljs-comment">// 向客户端输出错误信息</span><br>        <span class="hljs-keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;<br>            writer.write(ResultUtil.resultWithMessage(errorCode, message));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;响应输出失败！原因如下：&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回一个空的ModelAndView表示已手动处理响应</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，<code>resolveException</code> 方法根据捕获到的异常类型，对错误信息进行定制，并将定制的错误消息以JSON格式写入HTTP响应。</p><p>这种方式有助于实现统一的错误处理逻辑，使得API的错误响应更加一致和标准化。</p><h3 id="6、返回统一接口ResultUtil"><a href="#6、返回统一接口ResultUtil" class="headerlink" title="6、返回统一接口ResultUtil"></a>6、返回统一接口ResultUtil</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工具类用于构建统一的API响应格式。</span><br><span class="hljs-comment"> * 提供了一系列方法来生成标准化的JSON字符串响应，</span><br><span class="hljs-comment"> * 包括成功或错误的状态代码、消息和数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultUtil</span> &#123;<br>    <span class="hljs-comment">// 常量定义</span><br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">CODE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;code&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">DATA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_TWO</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_THREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成包含状态码和数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">code</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成同时包含数据和消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_THREE</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，同时包含数据和消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ResultUtil</code> 是一个工具类，用于创建和格式化API响应。它提供了一系列静态方法来生成标准化的JSON字符串响应。这些方法允许包含各种类型的信息，如状态码、数据、消息等。</p><blockquote><p>类的作用</p></blockquote><ol><li><strong>统一API响应格式</strong>:<ul><li><code>ResultUtil</code> 类用于生成具有一致格式的API响应。这有助于前端开发者理解和处理后端发送的数据。</li></ul></li><li><strong>灵活的响应构建</strong>:<ul><li>提供了多种方法来构建响应，可以只包含数据、只包含消息或同时包含数据和消息。</li></ul></li></ol><blockquote><p>方法说明</p></blockquote><ul><li><code>result(Object code, Object data)</code>: 生成包含指定代码和数据的响应。</li><li><code>resultWithData(Object code, Object data)</code>: 生成只包含数据的响应。</li><li><code>resultWithMessage(Object code, String message)</code>: 生成只包含消息的响应。</li><li><code>resultWithDataAndMessage(Object code, Object data, String message)</code>: 生成同时包含数据和消息的响应。</li><li><code>successWithData(Object data)</code>: 生成表示操作成功的响应，只包含数据。</li><li><code>successWithMessage(String message)</code>: 生成表示操作成功的响应，只包含消息。</li><li><code>successWithDataAndMessage(Object data, String message)</code>: 生成表示操作成功的响应，包含数据和消息。</li><li><code>errorWithMessage(String message)</code>: 生成表示操作失败的响应，只包含消息。</li><li><code>errorWithData(Object data)</code>: 生成表示操作失败的响应，只包含数据。</li></ul><blockquote><p>使用示例</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 返回成功响应，只包含数据<br>String response <span class="hljs-operator">=</span> ResultUtil.successWithData(someData)<span class="hljs-comment">;</span><br><br>// 返回失败响应，只包含错误消息<br>String errorResponse <span class="hljs-operator">=</span> ResultUtil.errorWithMessage(<span class="hljs-string">&quot;An error occurred&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个类在实际的API开发中非常有用，它可以简化响应的创建过程，并确保API的返回格式统一和标准化。</p><p>对于维护API的一致性和可用性非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_基础概念</title>
    <link href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>消息队列的核心使用场景</li><li>技术选型</li><li>JMS和AMQP</li><li>RPC 和消息队列的区别</li></ul><blockquote><p>Start</p></blockquote><p>在面试的时候，当你的简历上面写了用过<code>MQ</code> ,那么面试官的面试这个时候便开始了：</p><ul><li><ol><li>你在系统里用过消息队列吗</li></ol></li><li><ol start="2"><li>你们在项目里是如何使用消息队列的。</li></ol></li><li><ol start="3"><li>为什么你们这里要使用消息队列呢，为什么不直接调用接口处理呢。</li></ol></li><li><ol start="4"><li>说说消息队列有哪些优点和缺点吧。</li></ol></li><li><ol start="5"><li>消息队列的选型，他们之间的区别。</li></ol></li><li><ol start="6"><li>如何保证消息不被重复消息，如何保证消费的时候是幂等，如何保证消息的可靠性，如何保证消息的顺序性。</li></ol></li><li><ol start="7"><li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该如何处理？有几百万消息持续堆积几小时，要怎么解决？</li></ol></li><li><ol start="8"><li>让你去设计一个MQ，该如何进行架构设计，说一下你的思路。</li></ol></li></ul><p>前几个问题的思考主要是围绕：为什么要使用消息队列；</p><p>陈述回答的时候需要从消息队列利弊、优缺点、风险点等方面考虑，在进行技术选型的时候，主要还是围绕使用场景来决定。</p><div style="box-shadow: 2px 2px 5px #888888; padding: 10px; border: 1px solid #3271ae;">    每一个 MQ 没有绝对的好坏，但是要看用在哪个场景可以扬长避短，利用其优势，规避其劣势。</div><h3 id="1、消息队列的核心使用场景"><a href="#1、消息队列的核心使用场景" class="headerlink" title="1、消息队列的核心使用场景"></a>1、消息队列的核心使用场景</h3><p>消息队列（MQ）的核心使用场景主要包括三个方面：解耦、异步处理和削峰。</p><blockquote><p>解耦</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，你在组织一个大型派对，你需要通知很多朋友。如果你直接一个个打电话，每当新朋友加入或某人退出，你都需要更新你的通知列表。这很麻烦，对吧？</p><p>现在，假设你创建了一个在线活动页面，你只需要更新这个页面，而你的朋友们自己决定是否查看这个页面。这就大大简化了你的工作。</p><p><strong>技术解释</strong></p><p>在没有消息队列的情况下，系统 A 需要直接和多个系统（如 B、C、D、E）进行通信。这种紧密耦合的方式使得系统 A 需要不断更新与其他系统的交互逻辑。使用消息队列后，系统 A 只需将消息发布到队列，而其他系统根据需要从队列中取出消息。</p><p>这种发布&#x2F;订阅模式（Pub&#x2F;Sub）使得系统 A 与其他系统解耦，简化了维护和扩展的复杂性。</p><blockquote><p>异步处理</p></blockquote><p><strong>类比解释</strong></p><p>假设你在一家餐厅点餐。如果厨师需要等待一个菜做完才开始做下一个，这将非常低效。但如果他们能同时处理多个订单，每道菜完成时就直接上菜，这样效率会更高。</p><p><strong>技术解释</strong></p><p>在同步处理模式中，系统 A 在完成所有操作（如更新多个数据库）之前不会响应用户请求，导致延迟。<br>而异步处理使用消息队列，系统 A 可以快速响应用户请求，将后续任务（如数据库更新）放入队列中，由其他系统或服务慢慢处理。这减少了用户的等待时间，提高了系统的响应能力。</p><blockquote><p>削峰</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，一个公交车站在高峰时段面临大量乘客。如果每个人都立即上车，公交车会被迅速塞满。但如果有一个等候区，让乘客按顺序上车，这样既保持了公交车的正常运行，又避免了拥挤。</p><p><strong>技术解释</strong></p><p>在流量削峰场景中，消息队列充当缓冲区，帮助处理短时的高流量。当系统 A 在高峰时段面临大量请求时，这些请求首先被放入消息队列。<br>系统 A 根据自己的处理能力逐渐从队列中取出并处理这些请求。这样可以避免在高峰期对系统造成过大的压力，同时保证了系统的稳定性和可用性。</p><p>上面提及到的削峰、解耦、异步就是<strong>在特殊场景下其对应的好处</strong>，而缺点对应的是系统的复杂性变高，可用性降低，以及还有一致性问题。</p><blockquote><p>使用消息队列会带来哪些问题？</p></blockquote><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况</li></ul><h3 id="2、技术选型"><a href="#2、技术选型" class="headerlink" title="2、技术选型"></a>2、技术选型</h3><p>技术选型可以参考看一下下面的内容</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><blockquote><p>Kafka</p></blockquote><p>优点</p><ol><li><strong>高吞吐量</strong>：Kafka 设计用于处理高吞吐量数据，适合大规模消息处理应用。</li><li><strong>分布式系统</strong>：它天生就是分布式的，易于扩展。</li><li><strong>持久性和可靠性</strong>：Kafka 可以持久化消息到磁盘，因此对消息不会因为系统故障而丢失。</li><li><strong>高效</strong>：Kafka 使用顺序磁盘I&#x2F;O，提供高性能与数据吞吐。</li></ol><p>缺点</p><ol><li><strong>复杂性</strong>：Kafka 的设置和管理相对复杂。</li><li><strong>消息积压</strong>：在高负载下，消息延迟可能会增加。</li><li><strong>不支持优先级队列</strong>。</li></ol><blockquote><p>ActiveMQ</p></blockquote><p>优点</p><ol><li><strong>支持多种传输协议</strong>：如 OpenWire, STOMP, MQTT 等。</li><li><strong>易于使用和配置</strong>：相比 Kafka，ActiveMQ 配置和管理较为简单。</li><li><strong>JMS 支持</strong>：完全支持 JMS API 和 J2EE 集成。</li></ol><p>缺点</p><ol><li><strong>较低的吞吐量</strong>：相比 Kafka，ActiveMQ 的吞吐量较低。</li><li><strong>可扩展性问题</strong>：在非常大的数据负载下，扩展性可能是一个问题。</li></ol><blockquote><p>RabbitMQ</p></blockquote><p>优点</p><ol><li><strong>灵活的路由</strong>：支持复杂的路由。</li><li><strong>多种消息协议</strong>：支持 AMQP, MQTT, STOMP 等。</li><li><strong>管理界面友好</strong>：提供易于使用的管理界面。</li></ol><p>缺点</p><ol><li><strong>性能问题</strong>：在高吞吐量时，性能可能会受限。</li><li><strong>持久化开销</strong>：消息持久化可能会导致性能问题。</li></ol><blockquote><p>RocketMQ</p></blockquote><p>优点</p><ol><li><strong>高性能和低延迟</strong>：在分布式系统中表现出色。</li><li><strong>丰富的功能</strong>：提供了大量的特性，如消息顺序、事务消息等。</li><li><strong>可靠性和扩展性</strong>：保证了消息的可靠传输，同时支持水平和垂直扩展。</li></ol><p>缺点</p><ol><li><strong>社区和生态</strong>：相比 Kafka，RocketMQ 的社区和生态相对较小。</li><li><strong>复杂性</strong>：配置和管理稍微复杂。</li></ol><blockquote><p>技术选型考虑因素</p></blockquote><ol><li><strong>吞吐量需求</strong>：如果你的系统需要处理大量的数据，Kafka 或 RocketMQ 可能是更好的选择。</li><li><strong>系统复杂性</strong>：如果你需要一个易于设置和管理的系统，ActiveMQ 或 RabbitMQ 可能更合适。</li><li><strong>功能需求</strong>：根据你需要的特定功能（如消息排序、事务处理等）选择相应的系统。</li><li><strong>社区支持和生态系统</strong>：强大的社区可以提供更好的支持和更多的资源。</li><li><strong>可靠性和持久性</strong>：如果这些是你的主要关注点，Kafka 和 RocketMQ 是不错的选择</li></ol><p>选择建议：</p><ul><li><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；</li><li><strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，Kafka 是业内标准，社区活跃度很高，几乎是全世界该领域的事实性规范。</li><li>ActiveMQ，最近逐年使用减少，没经过大规模吞吐量场景的验证，社区不是很活跃。</li></ul><h3 id="3、JMS和AMQP"><a href="#3、JMS和AMQP" class="headerlink" title="3、JMS和AMQP"></a>3、JMS和AMQP</h3><p>JMS（Java Message Service）和 AMQP（Advanced Message Queuing Protocol）都是消息传递的标准和规范，但它们在设计理念、实现方式和使用场景上有所不同</p><blockquote><p>JMS（Java Message Service）</p></blockquote><p>定义</p><ul><li>JMS 是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul><p>特点</p><ul><li><strong>Java 标准</strong>：JMS 是 Java EE 的一部分，主要用于 Java 应用程序。</li><li><strong>API 规范</strong>：定义了一个通用的 API 来与消息服务进行交互，而不是一个网络协议。</li><li><strong>提供者依赖</strong>：JMS API 可以由多种供应商实现，如 ActiveMQ、IBM MQ 等。</li><li><strong>两种消息模型</strong>：支持点对点（Queue）和发布&#x2F;订阅（Topic）模型。</li><li><strong>不跨语言</strong>：主要用于 Java 应用程序，不适用于不同语言之间的通信。</li></ul><blockquote><p>AMQP（Advanced Message Queuing Protocol）</p></blockquote><p>定义</p><ul><li>AMQP 是一个开放标准的应用层协议，专为异步消息传递提供一个统一的框架，支持跨平台和跨语言的消息通信。</li></ul><p>特点</p><ul><li><strong>协议标准</strong>：AMQP 定义了网络协议，包括消息的格式、传输方式和队列的行为。</li><li><strong>供应商中立</strong>：旨在允许从不同供应商的消息系统中互操作。</li><li><strong>跨语言支持</strong>：不限于 Java，支持多种编程语言和平台。</li><li><strong>多种消息模式</strong>：支持灵活的消息模式，包括点对点、发布&#x2F;订阅、请求&#x2F;响应等。</li><li><strong>可靠性和安全性</strong>：提供了消息确认、交易、安全等机制。</li></ul><blockquote><p>主要区别</p></blockquote><ul><li><strong>设计范围</strong>：JMS 是一个针对 Java 的 API 规范，而 AMQP 是一个跨语言、跨平台的网络协议。</li><li><strong>适用范围</strong>：JMS 主要用于 Java 应用，AMQP 适用于任何支持该协议的客户端。</li><li><strong>实现依赖</strong>：使用 JMS 时，需要依赖特定供应商的实现，而 AMQP 的实现是供应商中立的，理论上任何 AMQP 兼容的客户端都可以与任何 AMQP 兼容的服务器通信。</li><li><strong>兼容性</strong>：AMQP 的设计目标是实现不同消息系统之间的互操作性，而 JMS 无法做到这一点。</li></ul><p><strong>ActiveMQ（已被淘汰） 是基于 JMS 规范实现的。</strong></p><p><strong>RabbitMQ 是基于 AMQP 协议实现的。</strong></p><blockquote><p>JMS vs AMQP</p></blockquote><table><thead><tr><th>对比方向</th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java API</td><td>协议</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>支持消息类型</td><td>提供两种消息模型：①Peer-2-Peer;②Pub&#x2F;sub</td><td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td>支持消息类型</td><td>支持多种消息类型 ，我们在上面提到过</td><td>byte[]（二进制）</td></tr></tbody></table><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 <code>TextMessage</code>、<code>MapMessage</code> 等复杂的消息类型；而 AMQP 仅支持 <code>byte[]</code> 消息类型（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题&#x2F;订阅 方式两种</li></ul><h3 id="4、RPC-和消息队列的区别"><a href="#4、RPC-和消息队列的区别" class="headerlink" title="4、RPC 和消息队列的区别"></a>4、RPC 和消息队列的区别</h3><p>RPC（Remote Procedure Call）和消息队列是分布式系统中的两种不同的通信机制，它们在设计目的、通信方式、架构要求和时效性等方面存在显著差异。</p><blockquote><p>用途</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>目的是实现不同服务之间的直接同步调用。</li><li>类似于本地函数调用，用于服务与服务之间的紧密协作。</li><li>适用于对响应时间有严格要求的场景。</li></ul></li><li><strong>消息队列</strong>：<ul><li>目的是提供异步通信能力，解耦服务之间的依赖关系。</li><li>用于任务的异步处理、流量削峰和分布式事务等。</li><li>适用于处理高峰期流量或者执行耗时操作。</li></ul></li></ul><blockquote><p>通信方式</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>是一种同步操作，调用方发起请求并等待响应，直到远程过程执行完成并返回结果。</li><li>依赖直接的网络连接和即时的数据传输。</li></ul></li><li><strong>消息队列</strong>：<ul><li>提供了一种异步通信方式，发送方将消息发送到队列，接收方可以在任何时间从队列中获取消息。</li><li>引入了中间件作为消息传递的中间层，增加了消息的持久性。</li></ul></li></ul><blockquote><p>架构</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>没有消息存储的需求，因为它依赖即时的请求-响应模型。</li><li>通常不需要中间层来缓存或管理消息。</li></ul></li><li><strong>消息队列</strong>：<ul><li>必须要有消息存储和管理的机制，因为消息需要在队列中等待被处理。</li><li>消息中间件负责保证消息的持久性和可靠性。</li></ul></li></ul><blockquote><p>时效性</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>一般期望立即处理，调用方通常会阻塞等待直到得到响应。</li><li>更适合于需要快速完成的交互式操作。</li></ul></li><li><strong>消息队列</strong>：<ul><li>消息可能不会立即处理，允许在系统资源允许的情况下随后处理。</li><li>支持高峰期的流量平滑，允许系统按照自己的节奏和能力处理消息。</li></ul></li></ul><p><strong>总结</strong></p><p>RPC 和消息队列解决的是分布式系统中不同的问题。</p><p>RPC 强调的是即时性和同步，适合于需要迅速响应的场景。而消息队列强调的是异步性和解耦，适合于需要提高系统整体效率和稳定性的场景。</p><p>在实际应用中，两者往往相互补充，共同支撑起一个高效、可靠、可扩展的分布式系统架构。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html">https://javaguide.cn/high-performance/message-queue/message-queue.html</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview">https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day02</title>
    <link href="/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/"/>
    <url>/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/</url>
    
    <content type="html"><![CDATA[<h3 id="Part01-我们应该去了解什么东西呢"><a href="#Part01-我们应该去了解什么东西呢" class="headerlink" title="Part01: 我们应该去了解什么东西呢"></a>Part01: 我们应该去了解什么东西呢</h3><p>这部分内容主要讲述一下基础的博客管理是怎么做的，如果需要做一个基础的博客系统需要怎么做，考虑哪些方面。</p><p>up 主 CodeSheep  在视频对于项目学习的一些建议，记录一下 <a href="https://www.bilibili.com/video/BV1y4411p74E/">https://www.bilibili.com/video/BV1y4411p74E/</a></p><ul><li><ol><li>运行项目并跑起来</li></ol></li><li><ol start="2"><li>阅读项目源码并调试（可以结合某个运行的功能入手，一个组件一个组件弄熟、看报错、看日志、看打印变量）</li></ol></li><li><ol start="3"><li>记录文档，从业务逻辑出发（逻辑很重要，你先学习这个，前端页面实现和二次改造想法先放后面，先去了解，再去摸索）</li></ol></li></ul><p>视频中推荐过这个项目（一个单体项目），有空也可以学习一下： <a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></p><p>在后台管理界面中，有一个很明显的模块是：博客管理</p><p>博客管理（界面）</p><ul><li>博客管理</li><li>分类管理</li><li>收藏管理</li><li>标签管理</li><li>推荐管理</li><li>专题管理</li></ul><h3 id="Part02-蘑菇博客中博客管理是如何实现的。"><a href="#Part02-蘑菇博客中博客管理是如何实现的。" class="headerlink" title="Part02: 蘑菇博客中博客管理是如何实现的。"></a>Part02: 蘑菇博客中博客管理是如何实现的。</h3><p>先了解这个问题，我们需要先回到技术栈的使用，知道他使用的是什么技术栈，才能对后面有更好的了解。</p><p>具体内容看一下 <a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></p><p>这里就不一一列举，需要知道的一个是项目中使用的 Java 持久层框架 是 MyBatis-Plus。</p><p>通过这个框架，你可以实现 <strong>代码生成器</strong>、<strong>自动 CRUD（Create, Read, Update, Delete）</strong> 等操作。</p><h4 id="博客管理"><a href="#博客管理" class="headerlink" title="博客管理"></a>博客管理</h4><blockquote><p>查找</p></blockquote><p>查询并分页获取博客列表</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据条件获取博客列表，并进行分页。</span><br><span class="hljs-comment"> * 使用MyBatis-Plus的QueryWrapper来构建查询条件。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param blogVO 包含查询条件的VO对象</span><br><span class="hljs-comment"> * @return 分页后的博客列表</span><br><span class="hljs-comment"> */</span><br>@Override<br>public IPage&lt;Blog&gt; getPageList(BlogVO blogVO) &#123;<br>    <span class="hljs-comment">// 创建查询包装器</span><br>    QueryWrapper&lt;Blog&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br><br>    <span class="hljs-comment">// 构建搜索条件</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(blogVO.getKeyword()) &amp;&amp; !StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getKeyword().<span class="hljs-built_in">trim</span>())) &#123;<br>        queryWrapper.like(SQLConf.TITLE, blogVO.getKeyword().<span class="hljs-built_in">trim</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getTagUid())) &#123;<br>        queryWrapper.like(SQLConf.TAG_UID, blogVO.getTagUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getBlogSortUid())) &#123;<br>        queryWrapper.like(SQLConf.BLOG_SORT_UID, blogVO.getBlogSortUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getLevelKeyword())) &#123;<br>        queryWrapper.eq(SQLConf.LEVEL, blogVO.getLevelKeyword());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsPublish())) &#123;<br>        queryWrapper.eq(SQLConf.IS_PUBLISH, blogVO.getIsPublish());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsOriginal())) &#123;<br>        queryWrapper.eq(SQLConf.IS_ORIGINAL, blogVO.getIsOriginal());<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getType())) &#123;<br>        queryWrapper.eq(SQLConf.TYPE, blogVO.getType());<br>    &#125;<br><br>    <span class="hljs-comment">// 设置分页参数</span><br>    Page&lt;Blog&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;();<br>    page.setCurrent(blogVO.getCurrentPage());<br>    page.setSize(blogVO.getPageSize());<br>    queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br><br>    <span class="hljs-comment">// 设置排序方式</span><br>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByAscColumn())) &#123;<br>        <span class="hljs-comment">// 将驼峰命名转换成下划线命名</span><br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByAscColumn())).toString();<br>        queryWrapper.orderByAsc(column);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByDescColumn())) &#123;<br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByDescColumn())).toString();<br>        queryWrapper.orderByDesc(column);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 默认排序</span><br>        <span class="hljs-keyword">if</span> (blogVO.getUseSort() == <span class="hljs-number">0</span>) &#123;<br>            queryWrapper.orderByDesc(SQLConf.CREATE_TIME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queryWrapper.orderByDesc(SQLConf.<span class="hljs-built_in">SORT</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行分页查询</span><br>    IPage&lt;Blog&gt; pageList = blogService.page(page, queryWrapper);<br>    List&lt;Blog&gt; list = pageList.getRecords();<br><br>    <span class="hljs-comment">// 若结果为空，直接返回</span><br>    <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> pageList;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理查询结果，例如添加分类、标签等额外信息</span><br>    <span class="hljs-comment">// ... 省略了额外信息处理的代码 ...</span><br><br>    <span class="hljs-comment">// 返回处理后的分页结果</span><br>    pageList.setRecords(list);<br>    <span class="hljs-keyword">return</span> pageList;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理查询结果</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pf">// ...省略方法的其它部分...<br><br>List<span class="hljs-variable">&lt;Blog&gt;</span> list = pageList.getRecords();<br><br>// 若查询结果为空，直接返回<br>if (list.isEmpty()) &#123;<br>    return pageList;<br>&#125;<br><br>// 初始化存储分类UID和标签UID的集合<br>List<span class="hljs-variable">&lt;String&gt;</span> sortUids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br>List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>Uids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br><br>// 遍历查询结果，收集分类UID和标签UID<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    if (StringUtils.isNotEmpty(blog.getB<span class="hljs-keyword">log</span>SortUid())) &#123;<br>        sortUids.add(blog.getB<span class="hljs-keyword">log</span>SortUid());<br>    &#125;<br>    if (StringUtils.isNotEmpty(blog.getTagUid())) &#123;<br>        <span class="hljs-keyword">tag</span>Uids.addAll(StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION));<br>    &#125;<br>&#125;<br><br>// 根据分类UIDs和标签UIDs获取对应的分类和标签对象<br>Collection<span class="hljs-variable">&lt;BlogSort&gt;</span> sortList = blogSortService.listByIds(sortUids);<br>Collection<span class="hljs-variable">&lt;Tag&gt;</span> <span class="hljs-keyword">tag</span>List = <span class="hljs-keyword">tag</span>Service.listByIds(<span class="hljs-keyword">tag</span>Uids);<br><br>// 将分类和标签对象转换为Map，便于快速查找<br>Map<span class="hljs-variable">&lt;String, BlogSort&gt;</span> sortMap = sortList.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(B<span class="hljs-keyword">log</span>Sort::getUid, Function.identity()));<br>Map<span class="hljs-variable">&lt;String, Tag&gt;</span> <span class="hljs-keyword">tag</span>Map = <span class="hljs-keyword">tag</span>List.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(Tag::getUid, Function.identity()));<br><br>// 遍历查询结果，设置每个博客的分类和标签<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    blog.<span class="hljs-built_in">set</span>B<span class="hljs-keyword">log</span>Sort(sortMap.get(blog.getB<span class="hljs-keyword">log</span>SortUid()));<br>    List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>UidList = StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION);<br>    List<span class="hljs-variable">&lt;Tag&gt;</span> blogTags = <span class="hljs-keyword">tag</span>UidList.stream()<br>        .map(<span class="hljs-keyword">tag</span>Map::get)<br>        .collect(Collectors.<span class="hljs-keyword">to</span>List());<br>    blog.<span class="hljs-built_in">set</span>TagList(blogTags);<br>&#125;<br><br>// 更新处理后的查询结果<br>pageList.<span class="hljs-built_in">set</span>Records(list);<br><br>// ...省略方法的其余部分...<br></code></pre></td></tr></table></figure><ol><li>首先检查查询结果列表是否为空，如果为空则直接返回。</li><li>遍历博客列表，从每个博客对象中提取分类和标签的UID。</li><li>使用收集的UIDs从服务层获取相应的分类和标签对象。</li><li>将分类和标签对象转换成Map，方便后续根据UID快速查找。</li><li>再次遍历博客列表，为每个博客设置对应的分类和标签列表。</li><li>最后，将更新后的博客列表设置回分页结果对象中。</li></ol><p>这个过程允许在返回博客列表之前丰富每个博客对象的信息，如添加分类和标签数据。以便提供更详细的信息给前端显示。</p><blockquote><p>添加博客</p></blockquote><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务场景和技术选型</title>
    <link href="/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <url>/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="业务场景和技术选型需要考虑的因素"><a href="#业务场景和技术选型需要考虑的因素" class="headerlink" title="业务场景和技术选型需要考虑的因素"></a>业务场景和技术选型需要考虑的因素</h3><h3 id="成长和思考"><a href="#成长和思考" class="headerlink" title="成长和思考"></a>成长和思考</h3><h4 id="1、当小A-接到需求后的反应-🏌️"><a href="#1、当小A-接到需求后的反应-🏌️" class="headerlink" title="1、当小A 接到需求后的反应 🏌️"></a>1、当小A 接到需求后的反应 🏌️</h4><p>对于一个需求来说，我们应该站在一个评审的态度去看待他。</p><p>接到产品经理的需求后，我们应该从有利于业务的角度出发思考，对这个需求进行删、改、增。</p><p>同时最重要的一个地方是，你需要有自己的一个思考和自己的实践，并去落实他和推动一些东西，让你的思考能够落地并看到成效。</p><p>有自己的思考和整体业务的理解，将有助于你整体的一个职业生涯，对于你目前所做的事情，也许在未来某个地方，能够结合你当时的一个背景，做出有点酷并很有用的东西。</p><h4 id="2、提高某件事情的效率-🦖"><a href="#2、提高某件事情的效率-🦖" class="headerlink" title="2、提高某件事情的效率  🦖"></a>2、提高某件事情的效率  🦖</h4><p>对于项目中的现成代码，我们应该去理性思考，</p><ul><li>第一，这些代码为什么这么写呢，写的逻辑是什么，有什么好处呢。</li><li>第二，这些代码能够优化吗，哪些地方存在瓶颈呢，如何优化。优化的解决方案有哪些，我们应该怎么处理。</li><li>第三，保持持续学习，了解程序实现的底层逻辑，对于计算机操作系统、数据结构、组成原理等能够有比较好的认识和理解。</li><li>第四，对于 ToC  的项目，我们应该考虑一下服务 QPS 能支撑多少，心里对于流量阈值有一个清楚认知，针对这个阈值如何提高优化，性能是否符合预期，是一个需要考虑很多方面和内容的问题。</li><li>第五，对于生产环境和测试环境的区别，是非常大的，生产环境遇到的复杂性问题，我们需要随时养成关注线上服务运行的一个情况；一些基础的内容，比如请求峰值的时候 CPU、内存的消耗、网络端口消耗等都是我们需要去关注的一些点，并在实践中养成这个习惯。</li><li>第六，了解整个项目整体业务，不要给自己的工作设定边界。</li><li>第七，归纳总结复盘。</li></ul><p>关于第二点，在 JavaGuide 网站文章中一句话写的很好，借鉴引用一下：</p><div style="background-color: #3498db; color: white; padding: 10px;">   主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！</div><h4 id="3、学习的时候一些坑不要去碰-🤕"><a href="#3、学习的时候一些坑不要去碰-🤕" class="headerlink" title="3、学习的时候一些坑不要去碰 🤕"></a>3、学习的时候一些坑不要去碰 🤕</h4><ul><li>多去看官方文档，多去看实际的源码，尽量少的去看一下垃圾博客</li><li>关注细节</li><li>及时反馈</li><li>规范，以及规范（代码，注释，接口，方法名称，文档，技术名称，日志，测试）</li><li>多实际去写代码（不要一说就会，一写就废）</li><li>重要的变更和接口内容一定要写文档</li><li>理解需求后，再开始写代码</li><li>多思考，有自己的理解后再去询问一些东西（积极沟通）</li><li>生产环境不要动</li></ul><h3 id="未来就业方向选择"><a href="#未来就业方向选择" class="headerlink" title="未来就业方向选择"></a>未来就业方向选择</h3><p>在目前这种趋势的未来中，对于顶层设计的要求从业人员其实是越来越高的，需求量也要减少（已经有很多现成的解决方案），未来的就业市场需要的反而是中低层人员，而随着GPT等人工智能的发展，技术人员的可替代性其实是很强的。</p><div style="background: linear-gradient(to right, #6dd5fa, #ff758c); color: white; padding: 15px;">  义无反顾的抓住每一个管理岗机会。</div><ul><li>驾驭管理<ul><li>模仿周围优秀管理者</li><li>找机会锻炼 展示能力</li></ul></li><li>顶层架构<ul><li>大量研读吸收  架构设计方案</li></ul></li></ul><p>推荐书籍：《软件平台管理架构设计与技术管理之道》</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_基础概念</title>
    <link href="/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Redis 是什么</li><li>Redis 的常用数据类型</li><li>Redis为什么这么快</li><li>Redis 和 Memcached 的区别和共同点</li><li>Redis的缓存读写策略</li><li>Redis 能做什么</li><li>Redis持久化机制</li><li>Redis线程模型</li><li>Redis内存管理</li></ul><h3 id="1、Redis-是什么"><a href="#1、Redis-是什么" class="headerlink" title="1、Redis 是什么"></a>1、Redis 是什么</h3><p>Redis是一种支持key-value等多种数据结构的存储系统；数据保存在内存中，支持持久化。</p><p>可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，支持事务、持久化、Lua脚本，集群。</p><p>下面是部分特性：</p><ul><li><strong>读写性能优异</strong><ul><li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （基于内存，基于Reactor 模式）</li></ul></li><li><strong>数据类型丰富</strong><ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li><strong>原子性</strong><ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li><strong>丰富的特性</strong><ul><li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li></ul></li><li><strong>持久化</strong><ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li><strong>分布式</strong><ul><li>Redis Cluster</li></ul></li></ul><h3 id="2、Redis-的常用数据类型"><a href="#2、Redis-的常用数据类型" class="headerlink" title="2、Redis 的常用数据类型"></a>2、Redis 的常用数据类型</h3><ul><li><strong>5种基础数据类型</strong>，分别是：String、List、Set、Zset、Hash。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><ul><li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置)</li></ul><p>Redis 的数据表示</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312251645493.png" alt="image.png"></p><h3 id="3、Redis为什么这么快？"><a href="#3、Redis为什么这么快？" class="headerlink" title="3、Redis为什么这么快？"></a>3、Redis为什么这么快？</h3><ul><li>基于内存操作</li><li>数据结构优化</li><li>单线程事件驱动模型</li><li>专门为高性能而设计（专注于核心功能，设计简洁，功能强大）</li></ul><h3 id="4、Redis-和-Memcached-的区别和共同点"><a href="#4、Redis-和-Memcached-的区别和共同点" class="headerlink" title="4、Redis 和 Memcached 的区别和共同点"></a>4、Redis 和 Memcached 的区别和共同点</h3><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>区别点：</strong>实际回答的时候建议通过从Redis 的一些特性去回答，如果问到 Memcached 到时候可以从 数据类型、过期策略、集群、持久化方面去回答主要区别点。</div><p>Redis和Memcached都是广泛使用的高性能内存缓存系统，但它们在设计、功能和使用案例方面有一些显著的区别和共同点。</p><p>共同点</p><ol><li><strong>基于内存的存储</strong>：Redis和Memcached都是基于内存的键值存储系统，提供快速的数据读写能力。</li><li><strong>高性能</strong>：两者都是为了提高数据访问速度而设计的，能够处理大量并发请求。</li><li><strong>简单的键值数据模型</strong>：它们使用简单的键值对模型来存储数据。</li><li><strong>缓存用途</strong>：通常被用作数据库前的缓存系统，以减少对后端数据库的访问压力。</li></ol><p>区别</p><ol><li><strong>数据类型支持</strong>：<ul><li><strong>Redis</strong>：支持更丰富的数据类型，如字符串、哈希、列表、集合、有序集合、位图、HyperLogLogs等。</li><li><strong>Memcached</strong>：主要支持简单的键值数据类型。</li></ul></li><li><strong>持久化</strong>：<ul><li><strong>Redis</strong>：提供数据持久化功能，可以将内存中的数据保存到硬盘中，防止数据丢失。Redis支持RDB（快照）和AOF（追加文件）两种持久化方式。</li><li><strong>Memcached</strong>：不提供持久化功能，主要用作纯内存缓存。</li></ul></li><li><strong>数据过期机制</strong>：<ul><li><strong>Redis</strong>和<strong>Memcached</strong>都支持设置键的过期时间，但Redis在处理过期键方面更为灵活。</li></ul></li><li><strong>分布式支持</strong>：<ul><li><strong>Redis</strong>：有原生的集群模式，支持数据分片和高可用性。</li><li><strong>Memcached</strong>：通常依赖客户端来实现数据分布，没有内置的集群功能。</li></ul></li><li><strong>原子操作和脚本</strong>：<ul><li><strong>Redis</strong>：支持事务、原子操作和Lua脚本，这增加了其在复杂操作方面的能力。</li><li><strong>Memcached</strong>：提供有限的原子操作，不支持脚本。</li></ul></li><li><strong>发布&#x2F;订阅模式</strong>：<ul><li><strong>Redis</strong>：支持发布&#x2F;订阅消息模式，适用于消息队列等应用。</li><li><strong>Memcached</strong>：不支持发布&#x2F;订阅模式。</li></ul></li></ol><p>使用场景</p><ul><li><strong>Redis</strong>：<ul><li>由于其丰富的数据类型和功能，适用于需要复杂数据结构和原子操作的场景。</li><li>适用于需要数据持久化的场景。</li><li>可用作消息队列、会话存储、全页缓存等。</li></ul></li><li><strong>Memcached</strong>：<ul><li>由于其简单性和高效性，适用于需要快速轻量级缓存的场景。</li><li>适合作为纯内存缓存使用，如简单的会话缓存。</li></ul></li></ul><p>Redis和Memcached虽然都是内存缓存系统，但Redis提供了更丰富的数据类型和功能，包括数据持久化、复杂的操作和消息队列功能。</p><p>而Memcached则更加轻量级，适用于简单的缓存需求。选择哪一个取决于具体的应用需求和环境。</p><p>JavaGudie 的一些内容总结，也可以参考下:</p><p><strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong>：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h3 id="5、常用的缓存读写策略"><a href="#5、常用的缓存读写策略" class="headerlink" title="5、常用的缓存读写策略"></a>5、常用的缓存读写策略</h3><div style="background-color: #f2c867; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>缓存常用的三种读写策略：</strong>Cache Aside Pattern（旁路缓存模式）、Read/Write Through Pattern（读写穿透）、Write Behind Pattern（异步缓存写入）</div><p><strong>三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。</strong></p><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p>适合读比较多的情况</p><p>写：</p><ul><li>先更新 db</li><li>然后直接删除 cache</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225211100.png" alt="image.png"></p><p><strong>读</strong> :</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回</li><li>再把数据放到 cache 中。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225211235.png" alt="image.png"></p><blockquote><p><strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong></p></blockquote><p>这种操作不能进行，会造成数据库和缓存数据不一致。</p><p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p><p>说明：</p><p>当有一个请求（我们称之为请求1）来更新某个数据项（称为数据A）时，你面临一个选择：是先更新数据库中的数据A，然后再删除缓存中的数据A，还是先删除缓存中的数据A，然后更新数据库？</p><p>如果选择后者（即先删除缓存，后更新数据库），会有以下风险：</p><ol><li><strong>请求1</strong>先删除了缓存中的数据A。</li><li>然后，在<strong>请求1</strong>更新数据库中的数据A之前，另一个请求（称之为请求2）来读取数据A。</li><li><strong>请求2</strong>在缓存中找不到数据A（因为已经被删除），所以它从数据库中读取了旧的数据A。</li><li>此时，<strong>请求1</strong>更新了数据库中的数据A。</li><li>结果是，缓存中没有数据A的记录（已被删除），而数据库中有新的数据A。<strong>请求2</strong>持有的是过时的数据。</li></ol><p>这种情况就导致了数据不一致：缓存失效了，但是请求2读取到了旧的数据。下次有请求来读取数据A时，它会再次从数据库中读取并缓存新的数据A，但在这之前，系统中存在数据不一致的状态。</p><p>通常，更好的做法是：</p><ol><li><strong>先更新数据库</strong>中的数据A。</li><li><strong>然后删除缓存</strong>中的数据A。</li></ol><p>这样，即使在数据库更新和缓存删除之间有读取请求，它也只会读到旧的数据，一旦缓存被删除，<strong>下一个读取请求将从数据库中获取最新的数据，并更新缓存</strong>，从而保持了一致性。</p><blockquote><p><strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong></p></blockquote><p>理论上仍然是会出现的，但概率非常小，缓存的写入速度比数据库的写入速度快很多。</p><p>特定情况：</p><ul><li>在数据库更新之后，但在缓存删除之前，如果另一个请求（称为请求2）来读取同一数据，它将从缓存中获取到旧的数据。因为此时缓存尚未被更新或删除。</li><li>一旦缓存被删除，随后的请求将从数据库中读取最新的数据，并更新缓存。但在这个短暂的时期内，旧的缓存数据和新的数据库数据之间存在不一致。</li></ul><blockquote><p><strong>Cache Aside Pattern 的缺陷</strong>以及解决方案</p></blockquote><p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入 cache 中。</p><p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景：<ul><li>更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li></ul></li><li>可以短暂地允许数据库和缓存数据不一致的场景：<ul><li>更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小</li></ul></li></ul><h4 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。</p><p>cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 db。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225212801.png" alt="image.png"></p><p><strong>读(Read Through)：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225212846.png" alt="image.png"></p><p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p><p>Read&#x2F;Write Through Pattern（读写穿透）这种方式使用的不多，我们常用的分布式缓存Redis并没有提供 cache 将数据写入 db 的功能。</p><h4 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h4><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p><p>不同点：</p><ul><li>**Read&#x2F;Write Through 是同步更新 cache 和 db，</li><li>Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</li></ul><p>数据一致性风险很大，不过Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p><h3 id="6、Redis-能做什么"><a href="#6、Redis-能做什么" class="headerlink" title="6、Redis 能做什么"></a>6、Redis 能做什么</h3><ul><li>缓存</li><li><strong>分布式锁</strong></li><li>限流</li><li>消息队列</li><li>延时队列</li><li>分布式 session</li><li>复杂业务场景 …..</li></ul><h3 id="7-、Redis-持久化机制"><a href="#7-、Redis-持久化机制" class="headerlink" title="7 、Redis 持久化机制"></a>7 、Redis 持久化机制</h3><p>to be contined….</p><h3 id="8、Redis-线程模型"><a href="#8、Redis-线程模型" class="headerlink" title="8、Redis 线程模型"></a>8、Redis 线程模型</h3><h3 id="9、Redis-内存管理"><a href="#9、Redis-内存管理" class="headerlink" title="9、Redis 内存管理"></a>9、Redis 内存管理</h3><p>阅读：</p><ul><li><a href="https://cloud.tencent.com/developer/article/1530553">https://cloud.tencent.com/developer/article/1530553</a></li><li><a href="https://javaguide.cn/database/redis/redis-memory-fragmentation.html">https://javaguide.cn/database/redis/redis-memory-fragmentation.html</a></li></ul><p>Redis 是一个高性能的键值对数据库，内存管理是其中一个非常重要的功能；</p><p>关于 Redis 内存管理的一些常见概念：</p><ul><li>内存分配器<ul><li><strong>Jemalloc</strong>：Redis 默认使用 Jemalloc 作为内存分配器，它对碎片化处理得比标准的 libc malloc 更加高效。</li></ul></li><li>过期键和内存淘汰<ul><li>过期策略<ul><li>Redis 允许为键设置生存时间（TTL）。键到期后会被删除，释放内存。</li></ul></li><li>内存淘汰策略（在内存使用达到限制时，Redis 提供了多种淘汰策略）<ul><li><code>noeviction</code>：不淘汰任何数据，只是返回错误。</li><li><code>allkeys-lru</code>：根据最近最少使用算法（LRU）淘汰数据。</li><li><code>volatile-lru</code>：只从设置了过期时间的键中选择淘汰。</li><li><code>allkeys-random</code>：随机淘汰。</li><li><code>volatile-random</code>：从设置了过期时间的键中随机淘汰。</li><li><code>volatile-ttl</code>：淘汰即将过期的键。</li></ul></li></ul></li><li>内存配置<ul><li><strong>maxmemory 配置</strong>：可以在 Redis 配置文件中设置 <code>maxmemory</code> 选项来限制 Redis 使用的最大内存量。</li><li><strong>maxmemory-policy</strong>：定义当内存达到限制时 Redis 应该执行的淘汰策略。</li></ul></li><li>内存使用监控<ul><li><strong>内存使用指标</strong>：Redis 提供了丰富的指标来监控内存使用情况，例如 <code>used_memory</code>、<code>used_memory_rss</code>、<code>used_memory_peak</code> 等</li><li><strong>内存优化命令</strong>：如 <code>MEMORY PURGE</code>（在某些版本中可用）可以用来尝试减少内存碎片。</li></ul></li><li>数据结构优化</li><li>内存回收</li></ul><h4 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h4><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1:6379</span>&gt; expire key <span class="hljs-number">60</span> # 数据在 60s 后过期<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127.0.0.1:6379</span>&gt; setex key <span class="hljs-number">60</span> value # 数据在 60s 后过期 (setex:<span class="hljs-string">[set]</span> + <span class="hljs-string">[ex]</span>pire)<br>OK<br><span class="hljs-number">127.0.0.1:6379</span>&gt; ttl key # 查看数据还有多久过期<br>(integer) <span class="hljs-number">56</span><br></code></pre></td></tr></table></figure><blockquote><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p></blockquote><p>过期时间还可以用于某些业务场景：比如手机短信验证码的有效期保持在 1 分钟，token 登录的有效期在 1 天内。</p><h4 id="如何判断键是否过期"><a href="#如何判断键是否过期" class="headerlink" title="如何判断键是否过期"></a>如何判断键是否过期</h4><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/redis/cache-basics.html">https://javaguide.cn/database/redis/cache-basics.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis">https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis</a></li><li><a href="https://www.cnblogs.com/powertoolsteam/p/redis.html">https://www.cnblogs.com/powertoolsteam/p/redis.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_进阶内容</title>
    <link href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>线程模型</li><li>悲观锁</li><li>乐观锁</li><li>ReentrantLock<ul><li>AQS</li><li>CAS</li></ul></li></ul><p><strong>悲观锁和乐观锁</strong></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401191517637.png" alt="image.png"></p><h3 id="1、什么是线程模型？"><a href="#1、什么是线程模型？" class="headerlink" title="1、什么是线程模型？"></a>1、什么是线程模型？</h3><blockquote><p>先回顾一下线程和进程的区分</p></blockquote><ul><li>进程：<ul><li>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul></li><li>线程<ul><li>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><blockquote><p>什么是线程模型</p></blockquote><p>并发编程在计算机中如何实现的，在 Java 开发领域中，JVM线程对不同操作系统上的原生线程进行了高级抽象，使开发者大多数情况下可以不用关注下层细节，而只要专注上层开发。</p><p>JVM线程与操作系统线程之间存在着某种映射关系，这两种<strong>不同维度的线程之间的规范和协议</strong>，就是线程模型。</p><blockquote><p>用户线程和内核线程</p></blockquote><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><blockquote><p>线程模型类型</p></blockquote><p>JVM线程模型有三种模型：一对一、多对一、多对多。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161619698.png" alt="image.png"></p><p><strong>一对一</strong></p><p>在Jva线程（用户线程）与操作系统线程(KLT)之间建立一对一的关系，简单粗暴，但好用。</p><ul><li>优点：<ul><li>每个线程都是独立的调度单元，直接利用操作系统内核提供的调度功能。</li></ul></li><li>缺点：<ul><li>用户线程的阻塞唤醒，会直接映射到内核线程上，容易<strong>引起频繁切换，降低性</strong>能。但是一些语言引入了CAS来避免一部分的内核调用，比如Java 引入了AQS这种函数级别的锁，<strong>减少使用内核级别的锁</strong>，就能提升性能。</li></ul></li></ul><p>目前大部分主流 JVM 上都是采用的这种线程模型。</p><p><strong>多对一模型</strong></p><ul><li>优点<ul><li>用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快：</li></ul></li><li>缺点<ul><li>如果其中一个用户线程阻塞，其他用户线程也无法执行</li><li>这种模型下，内核并不知道用户态有哪些线程，调度和优先级等不完整。</li></ul></li></ul><p><strong>多对多模型</strong></p><ul><li>优点：兼具前两者的优点</li><li>缺点：实现复杂</li></ul><p>目前主流语言中，Java 使用的是 一对一线程模型；Go 语言使用的是 多对多线程模型；Python 的 gevent 使用的多对一线程模型。</p><h3 id="2、悲观锁机制"><a href="#2、悲观锁机制" class="headerlink" title="2、悲观锁机制"></a>2、悲观锁机制</h3><p>在了解悲观锁机制前，我们先来了解一下什么是锁。</p><h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>在并发环境下，会出现多个线程对同一个资源进行争抢的情况，假设A线程对资源正在进行修改，此时<br>B线程此时又对资源进行了修改，这就可能会导致数据不一致的问题。</p><p>为了解决这个问题，引入了锁机制，<strong>通过一种抽象的“锁”来对资源进行锁定</strong>，当一个线程持有“锁”的时候，其他线程必须等待“锁”，本质上是在临界资源上对线程进行一种串行化。</p><h4 id="Java语言的锁机制"><a href="#Java语言的锁机制" class="headerlink" title="Java语言的锁机制"></a>Java语言的锁机制</h4><blockquote><p>Java 虚拟机的内存结构</p></blockquote><p>在了解 Java语言锁机制之前，我们先对简单了解一下 Java 虚拟机的内存结构。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116222015.png" alt="image.png"></p><p>JVM 运行时内存结构主要包含了五个部分：</p><ul><li>程序计数器(PC寄存器)、</li><li>JVM栈、</li><li>Native方法栈、</li><li>堆、</li><li>方法区。</li></ul><p>上图中，红色区域是各个线程私有的。这个区域中的数据，不会出现线程竞争的关系。</p><p>而蓝色区域中的数据被所有线程共享，其中Jva堆中存放的是大量对象，方法区中<strong>存放类信息、常量、静态变<br>量</strong>等数据。</p><p>当多个线程在竞争其中的一些数据时，可能会发生难以预料的异常情况。在程序开发中，锁的主要应用范围就是在数据共享区域。</p><p>在代码层面，Jvva 主要采用了两种实现方式：</p><ul><li>1.基于Object的悲观锁。</li><li>2.基于CAS的乐观锁。</li></ul><p>本章主要讲解基于Object的悲观锁。</p><blockquote><p>悲观锁机制</p></blockquote><p>悲观锁总是假设最坏的情况，认为共享资源<strong>每次被访问的时候就会出现问题</strong>(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</p><p>也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><blockquote><p>基于Object的悲观锁</p></blockquote><p>在Java中，每个Object,也就是每个对象都拥有一把锁，这把锁存放在对象头中，记录了当前对象被哪个线程占用。</p><blockquote><p>对象和对象头的结构</p></blockquote><p><strong>Java 对象</strong></p><p>Java对象分为三个部分：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充字节</li></ul><p>其中对齐填充字节是为了满足“Java对象大小是8字节的倍数”这一条件而设计的，为对象对齐填充了一些无用字节。</p><p>实例数据是在初始化对象时设定的属性和状态等内容。</p><p><strong>对象头</strong></p><p>对象头存放了一些对象本身的运行时信息。对象头包含了两部分：</p><ul><li>Mark Word</li><li>Class Pointer</li></ul><p>相较于实例数据，对象头属于一些额外的存储开销，它被设计得极小（一般为232bt或264bt) 来提升效率。</p><p>Class Pointer是一个指针，指向当前对象类型所在方法区中的Class信息；</p><p>Mark Word 存储了<strong>很多当前对象的运行时状态信息</strong>，比如 HashCode.、锁状态标志、指向锁记录的指针、偏向线程 ID、锁标志位等等。</p><p>可以通过下面这张表对 Mark Word有一个更直观的认识：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116223405.png" alt="image.png"></p><p>“锁”的信息存储在对象头的Mark Word中。Mark Word 的最后两位，代表锁标志位，分别对应“无锁”、“偏向锁”、“轻量级锁”、“重量级锁”四种状态。</p><p>在Java中，启用对象锁的方式是使用<code>synchronized</code>关键字。</p><h4 id="对象锁的四种状态"><a href="#对象锁的四种状态" class="headerlink" title="对象锁的四种状态"></a>对象锁的四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p><p>锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><h3 id="3、乐观锁机制"><a href="#3、乐观锁机制" class="headerlink" title="3、乐观锁机制"></a>3、乐观锁机制</h3><p>乐观锁：乐观锁总是假设最好的情况，即不会去考虑别的线程修改数据，所以不会上锁，但是在更新的时候会判断在此期间别的线程有没有去更新这个数据。</p><p>Java 中的乐观锁一般是<strong>基于 CAS 原语 来</strong>进行的（如<code>AtomicInteger</code>）；而CAS 是一种原语操作，他也用于了悲观锁中  ReentrantLock 的锁状态管理。</p><hr><p>在多个线程对于同一个资源进行访问的访问，互斥锁的方式是悲观的，在线程访问的时候，互斥锁会锁定资源，<strong>只供一个线程调用，而阻塞其他线程</strong>，让其他线程等待。</p><p>在一些情况下，同步代码块执行的耗时远远小于线程切换的耗时，这种情况下使用互斥锁对性能是不太划算的。在这种场景下，直接在用户态对线程的切换进行管理，效率更高。实际操作的时候是通过每次使用同步原语对共享资源进行锁定，让线程反复“乐观”地去尝试获取共享资源，如果发现空闲，那么使用，如果被占用，那么继续“乐观”地重试。</p><blockquote><p>乐观锁和悲观锁<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231207231904.png" alt="image.png"></p></blockquote><blockquote><p>CAS</p></blockquote><p>在 Java 中，实现这种同步原语的算法是 CAS (Compare And Swap)。</p><p>简单翻译是：比较然后交换</p><p>CAS操作包含三个操作数：内存位置（要更新的变量）、预期原值和新值。</p><p><strong>工作原理</strong></p><ol><li><strong>检查和更新</strong>：<ul><li>CAS首先检查<strong>目标内存位置的当前值</strong>是否与预期原值相同。如果相同，它会将该内存位置的值更新为新值。</li><li>如果目标值已被其他线程改变（不等于预期原值），CAS操作失败。</li></ul></li><li><strong>无锁操作</strong>：<ul><li>CAS提供了一种无需锁定的方式来实现并发控制，减少了锁的开销和复杂性。</li></ul></li></ol><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    CAS操作是原子性的。</div><h3 id="4、悲观锁和乐观锁"><a href="#4、悲观锁和乐观锁" class="headerlink" title="4、悲观锁和乐观锁"></a>4、悲观锁和乐观锁</h3><h4 id="悲观锁示例"><a href="#悲观锁示例" class="headerlink" title="悲观锁示例"></a>悲观锁示例</h4><p>在Java中，悲观锁通常是通过<code>synchronized</code>关键字或<code>ReentrantLock</code>类实现的。</p><p><code>synchronized</code> 使用示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PessimisticLockExample &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> increment() &#123;<br>        <span class="hljs-keyword">count</span>++;  <span class="hljs-comment">// 仅当持有对象锁时，才能执行此操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> getCount() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;  <span class="hljs-comment">// 同样，需要持有对象锁才能执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们用<code>synchronized</code>关键字锁定了整个方法。</p><p>当一个线程进入<code>increment</code>或<code>getCount</code>方法时，它必须先获得这个对象的锁。在这段时间内，其他任何试图进入这些同步方法的线程都会被阻塞。</p><h4 id="乐观锁示例"><a href="#乐观锁示例" class="headerlink" title="乐观锁示例"></a>乐观锁示例</h4><p>乐观锁通常是通过CAS（比较并交换）操作实现的。</p><p>在Java中，<code>AtomicInteger</code>类提供了一种使用乐观锁的方式。以下是一个使用<code>AtomicInteger</code>实现乐观锁的示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimisticLockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> void increment() &#123;<br>        int currentValue;<br>        int <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = count.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 获取当前值</span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">Value</span> = currentValue + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!count.compareAndSet(currentValue, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)); <span class="hljs-comment">// CAS操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int getCount() &#123;<br>        <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>AtomicInteger</code>的<code>compareAndSet</code>方法实现了CAS操作。</p><p>它会比较<code>count</code>的当前值和<code>currentValue</code>。如果相同，它会更新<code>count</code>为<code>newValue</code>。这个过程是无锁的，即使在并发环境下也不会阻塞其他线程。如果<code>count</code>的值在此期间被其他线程修改，<code>compareAndSet</code>会返回<code>false</code>，循环继续，直到更新成功。</p><blockquote><p>对比</p></blockquote><ul><li><strong>悲观锁</strong>（<code>synchronized</code>，<code>ReentrantLock</code>）适用于写操作多的场景，因为它防止了多个线程同时写入，减少了冲突。</li><li><strong>乐观锁</strong>（如<code>AtomicInteger</code>的CAS操作）适用于读操作多的场景，它不会阻塞线程，但在写操作频繁的情况下可能会导致高重试成本。</li></ul><h3 id="5、ReentrantLock-☆"><a href="#5、ReentrantLock-☆" class="headerlink" title="5、ReentrantLock   ☆"></a>5、ReentrantLock   ☆</h3><p>线程考察的一个重点，一个是 <code>synchronized</code>关键字，另外一个就是 <code>ReentrantLock</code>类。</p><p>这句话可以阐述 ReentrantLock 的大部分操作：</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS（<code>AbstractQueuedSynchronizer</code>），添加锁和释放锁的大部分操作实际上都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p>建议可以直接看一下“源码解析”这一部分。</p><h4 id="ReentrantLock-的基础使用"><a href="#ReentrantLock-的基础使用" class="headerlink" title="ReentrantLock 的基础使用"></a>ReentrantLock 的基础使用</h4><p>在并发编程中，悲观锁是一种策略，它假设最坏的情况：即在多个线程尝试同时访问共享资源时，会发生冲突。因此，悲观锁在访问任何共享资源之前会先锁定它，以防止其他线程的访问，直到它完成操作并释放锁。</p><blockquote><p>ReentrantLock（可重入锁）</p></blockquote><p><code>ReentrantLock</code> 是一个可重入的互斥锁，它提供了比 <code>synchronized</code> 关键字更高级的功能，如可中断的锁获取操作、公平锁策略、锁绑定多个条件等。</p><blockquote><p>基于 AQS 的实现</p></blockquote><ul><li>AQS 提供了一种管理锁状态的框架，并处理了线程的排队和阻塞。在 <code>ReentrantLock</code> 的实现中，AQS 负责维护一个表示锁状态的变量和一个由等待锁的线程组成的队列。</li><li>当一个线程尝试获取 <code>ReentrantLock</code> 时，AQS 会检查锁的状态，然后要么授予锁（如果当前未被其他线程持有），要么将尝试获取锁的线程放入等待队列。</li></ul><blockquote><p>悲观锁的特性</p></blockquote><ul><li><code>ReentrantLock</code> 作为一种悲观锁，是基于这样的假设：如果不采取措施，多个线程同时修改同一个资源会导致问题。因此，它在修改资源之前先加锁，防止其他线程同时进行写操作。</li><li>这与乐观锁的策略不同，乐观锁允许多个线程进入临界区，但在实际修改数据时检查是否存在冲突。</li></ul><p>示例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>()</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();  <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们在修改 <code>count</code> 变量之前获取了锁，并在操作完成后释放了锁。</p><p>这确保了即使多个线程尝试同时调用 <code>increment</code> 方法，<code>count</code> 的增加也是线程安全的。</p><h4 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h4><p><code>ReentrantLock</code> 是 Java 并发包中的一个重要组件，基于 AQS 实现。</p><p>基本原理</p><ol><li><strong>可重入性</strong>：<ul><li><code>ReentrantLock</code> 是一个可重入锁。这意味着同一个线程可以多次获取同一个锁而不会发生死锁。这是通过为每个锁维护一个持有计数和一个指向当前持有锁的线程的引用来实现的。</li></ul></li><li><strong>基于 AQS</strong>：<ul><li><code>ReentrantLock</code> 的实现依赖于 AQS。AQS 使用一个整型的 volatile 变量来表示同步状态，并使用一个 FIFO 队列来管理那些等待获取锁的线程。</li></ul></li><li><strong>锁的状态</strong>：<ul><li>在 <code>ReentrantLock</code> 中，锁的状态是由 AQS 的同步状态变量来表示的。状态为 0 表示锁是可用的，状态为 1 表示锁被一个线程持有，大于 1 表示同一个线程重入了这个锁。</li></ul></li><li><strong>获取锁</strong>：<ul><li>当一个线程尝试获取锁时，如果同步状态为 0，AQS 会尝试通过 CAS（比较并交换）操作将状态设置为 1，从而获取锁。</li><li>如果锁已经被其他线程持有（同步状态非 0），那么尝试获取锁的线程会被加入到 AQS 维护的等待队列中。</li></ul></li><li><strong>释放锁</strong>：<ul><li>当线程完成任务后，它会调用 <code>unlock</code> 方法来释放锁。这将减少 AQS 同步状态的计数。当计数降到 0 时，锁被完全释放，等待队列中的下一个线程将有机会获取锁。</li></ul></li></ol><p>公平性和非公平性</p><ul><li><strong>公平锁</strong>：在公平模式下，<code>ReentrantLock</code> 会按照线程在等待队列中的等待顺序来获取锁。这意味着首先进入等待队列的线程将先获得锁。</li><li><strong>非公平锁</strong>：在非公平模式下，当锁可用时，任何请求它的线程都有机会获取锁。这可能不会遵守等待队列中的顺序。</li></ul><p>性能考量</p><ul><li><strong>选择公平性</strong>：公平锁通常会有较低的性能，因为它严格按照等待队列来分配锁，但它可以减少线程饥饿的情况。</li><li><strong>选择非公平性</strong>：非公平锁可能会有更好的性能，但可能导致线程饥饿，因为某些线程可能会长时间等待而不得不频繁地重新调度。</li></ul><p><code>ReentrantLock</code> 提供了一种灵活的锁定机制，通过 AQS 实现了可重入性和可选的公平性。</p><p>它允许更细粒度的锁控制，从而在高度竞争的环境中提供比内置 <code>synchronized</code> 更高的性能和更强的功能。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h5><p><code>ReentrantLock</code> 本身是一个相对简单的类，它依赖于内部类 <code>Sync</code> 的实现，而 <code>Sync</code> 是 <code>AbstractQueuedSynchronizer</code> 的子类。</p><p>在 <code>ReentrantLock</code> 中，有两个主要的内部类：<code>FairSync</code> 和 <code>NonfairSync</code>，分别对应公平锁和非公平锁的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-title">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> sync;<br><br>    <span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-comment">// ... 实现细节</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 非公平锁实现</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 公平锁实现</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数等其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Sync-类"><a href="#Sync-类" class="headerlink" title="Sync 类"></a>Sync 类</h5><p><code>Sync</code> 类是 <code>AbstractQueuedSynchronizer</code> 的一个扩展，提供了大部分与锁状态管理相关的功能。</p><p>它使用 AQS 的状态变量来表示锁的持有次数，以及持有锁的线程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean isHeldExclusively() &#123;<br>        <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == <span class="hljs-type">Thread</span>.currentThread();<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> void lock() &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法，包括 tryAcquire, tryRelease 等</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="公平锁和非公平锁的实现"><a href="#公平锁和非公平锁的实现" class="headerlink" title="公平锁和非公平锁的实现"></a>公平锁和非公平锁的实现</h5><p><code>FairSync</code> 和 <code>NonfairSync</code> 类重写了 <code>tryAcquire</code> 方法以提供不同的锁获取策略。</p><ul><li><strong>非公平锁</strong>（<code>NonfairSync</code>）：在尝试获取锁时，会立即尝试改变状态，而不检查等待队列。</li><li><strong>公平锁</strong>（<code>FairSync</code>）：在尝试获取锁之前，会检查等待队列，以确保队列中的线程先获得服务。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现非公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br><br>static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h5><p>AQS 是实现锁和其他同步器的框架。它使用一个 int 类型的 volatile 变量来表示同步状态，并使用一个队列来管理那些未能成功获取同步状态的线程。</p><ul><li><strong>状态管理</strong>：AQS 提供了一系列方法来操作其状态变量，如 <code>getState()</code>, <code>setState(int)</code> 和 <code>compareAndSetState(int, int)</code>。</li><li><strong>队列管理</strong>：AQS 维护了一个等待队列，当线程尝试获取资源失败时，它会被加入到这个队列中。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> head;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> tail;<br>    <span class="hljs-keyword">private</span> volatile int state;<br><br>    <span class="hljs-comment">// 内部类 Node，队列节点的定义</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-comment">// Node 的结构和方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 状态管理和队列操作的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="锁的获取与释放"><a href="#锁的获取与释放" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h5><ul><li><strong>获取锁</strong>：当 <code>ReentrantLock</code> 的 <code>lock()</code> 方法被调用时，实际上是调用了 <code>Sync</code> 类的 <code>acquire</code> 方法，该方法又会调用 <code>tryAcquire</code> 方法。<code>tryAcquire</code> 的具体实现取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>。</li><li><strong>释放锁</strong>：<code>unlock()</code> 方法调用 <code>Sync</code> 类的 <code>release</code> 方法，进而调用<code>tryRelease</code> 方法。这个方法会更新同步状态，并在状态变为 0 时（即锁被完全释放时），唤醒等待队列中的线程.</li></ul><h5 id="获取锁的过程"><a href="#获取锁的过程" class="headerlink" title="获取锁的过程"></a>获取锁的过程</h5><ol><li>当一个线程调用 <code>lock()</code> 方法时，它实际上调用的是 <code>Sync</code> 类中的 <code>acquire(int)</code> 方法。</li><li><code>acquire(int)</code> 方法会调用重写的 <code>tryAcquire(int)</code> 方法（取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>）。<ul><li>在 <code>NonfairSync</code> 中，它会立即尝试获取锁，不管其他线程是否在等待。</li><li>在 <code>FairSync</code> 中，它会先检查队列，以确保没有其他线程在等待时间更长。</li></ul></li></ol><h5 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h5><ol><li>当线程调用 <code>unlock()</code> 方法时，实际上是调用 <code>Sync</code> 类的 <code>release(int)</code> 方法。</li><li><code>release(int)</code> 方法内部会调用 <code>tryRelease(int)</code> 方法，该方法检查当前线程是否是锁的持有者，并尝试将同步状态设置回 0。</li><li>如果同步状态成功设置回 0，表示锁已经被释放，等待队列中的其他线程可能会被唤醒并尝试获取锁。</li></ol><h5 id="AQS-中的等待队列"><a href="#AQS-中的等待队列" class="headerlink" title="AQS 中的等待队列"></a>AQS 中的等待队列</h5><p>AQS 使用一个内部的 FIFO 队列来管理那些无法获取到锁的线程。</p><p>每个节点代表一个线程。当一个线程无法获取到锁时，它会被包装成一个节点加入到队列的末尾。当锁被释放时，队列头部的节点会被唤醒并尝试再次获取锁。</p><h5 id="CAS-在-AQS-中的使用"><a href="#CAS-在-AQS-中的使用" class="headerlink" title="CAS 在 AQS 中的使用"></a>CAS 在 AQS 中的使用</h5><p>AQS 使用 CAS 操作来安全地修改同步状态。这是一种无锁的原子操作，可以保证即使在多个线程同时尝试修改状态时，同步状态的更新也是一致的。</p><blockquote><p>总结</p></blockquote><p><code>ReentrantLock</code> 的实现依赖于 AQS 的强大功能，提供了一种灵活且高效的方式来处理并发编程中的同步问题。</p><p>通过将锁的具体实现细节委托给 AQS，<code>ReentrantLock</code> 不仅提供了基本的锁功能，还支持如公平性&#x2F;非公平性选择、条件变量、以及锁的可重入性等高级特性。</p><h3 id="5、synchronized"><a href="#5、synchronized" class="headerlink" title="5、synchronized"></a>5、synchronized</h3><p>这部分内容的锁升级状态相关内容有必要阐述一下（无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态）</p><h4 id="锁升级过程"><a href="#锁升级过程" class="headerlink" title="锁升级过程"></a>锁升级过程</h4><blockquote><p>说一下偏向锁、轻量级锁、重量级锁（锁升级过程）。</p></blockquote><p>在Java中，为了优化同步操作的性能，引入了偏向锁、轻量级锁和重量级锁的概念。</p><p>这些锁是对<code>synchronized</code>关键字的优化，旨在减少锁操作的开销。在不同竞争条件下，锁可以从偏向锁升级到轻量级锁，再升级到重量级锁。</p><p>偏向锁（Biased Locking）</p><ul><li><strong>目的</strong>：在只有一个线程访问同步块的情况下，减少不必要的锁竞争开销。</li><li><strong>原理</strong>：当锁被第一次获取时，它会将锁对象的头部信息标记为偏向模式，并记录获取它的线程ID。之后，该线程进入同步块时不需要再进行同步。</li><li><strong>升级条件</strong>：当有另一个线程尝试获取这个锁时，偏向锁会升级为轻量级锁。</li></ul><p> 轻量级锁（Lightweight Locking）</p><ul><li><strong>目的</strong>：在无明显线程竞争的情况下，减少传统的锁机制（重量级锁）的性能消耗。</li><li><strong>原理</strong>：线程在获取锁时，会在栈帧中创建一个锁记录（Lock Record）空间，用于存储锁对象的头部信息。然后，尝试使用CAS（Compare And Swap）操作替换对象头部信息，将其指向锁记录。如果成功，线程获得锁；如果失败，表示其他线程竞争锁。</li><li><strong>升级条件</strong>：当多个线程竞争同一个锁时，轻量级锁会升级为重量级锁。</li></ul><p>重量级锁（Heavyweight Locking）</p><ul><li><strong>目的</strong>：在强竞争条件下，保证线程安全。</li><li><strong>原理</strong>：当锁处于重量级状态时，线程尝试获取锁失败，会进入阻塞状态。这需要操作系统的帮助，代价比轻量级锁和偏向锁要高。</li><li><strong>特点</strong>：重量级锁是最传统的同步方式，当有多个线程频繁竞争同一个锁时，使用重量级锁可以确保线程安全。</li></ul><p>锁升级过程</p><ol><li><strong>初始状态</strong>：新创建的锁对象默认是无锁状态。</li><li><strong>偏向锁</strong>：当第一个线程访问同步块时，锁会变为偏向锁。该线程后续进入同步块不需要真正的锁操作。</li><li><strong>轻量级锁</strong>：当有另一个线程尝试获取这个偏向锁时，如果持有偏向锁的线程不活跃，偏向锁可以撤销并升级为轻量级锁。</li><li><strong>重量级锁</strong>：如果轻量级锁的自旋失败（即多个线程竞争同一个锁），则升级为重量级锁。</li></ol><p>类比</p><p>可以将这些锁的升级过程类比为不同安全级别的门禁系统：</p><ul><li><strong>偏向锁</strong>：类似于一扇只允许一个特定员工进入的门。只要是这个员工，门会自动打开，无需任何验证。</li><li><strong>轻量级锁</strong>：类似于有一个简单的锁系统，员工需要刷卡（CAS操作）进入，如果门没有被其他人使用，这个过程很快。</li><li><strong>重量级锁</strong>：如果门经常被多人同时尝试使用，系统会升级到一个有保安的更复杂的门禁系统，来确保每次只有一个人进入。</li></ul><p>to be contined….</p><hr><p>参考:</p><ul><li><a href="https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866">https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866</a></li><li><a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></li><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.bilibili.com/video/BV1z44y1X7BJ">https://www.bilibili.com/video/BV1z44y1X7BJ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_SpringMVC</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是SpringMVC"><a href="#1、什么是SpringMVC" class="headerlink" title="1、什么是SpringMVC"></a>1、什么是SpringMVC</h3><p>SpringMVC是Spring框架中的一个模块，用于构建Web应用程序，采用了经典的MVC设计模式。</p><p>MVC英文是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><ol><li><strong>模型（Model）：</strong><ul><li>模型代表应用程序的业务逻辑和数据。在SpringMVC中，模型通常是一个POJO（Plain Old Java Object）类，负责封装业务数据。</li><li>模型对象存储应用程序的状态，与数据库进行交互，执行业务逻辑等。</li></ul></li><li><strong>视图（View）：</strong><ul><li>视图负责渲染模型数据并展示给用户。在SpringMVC中，视图通常是JSP（JavaServer Pages）或Thymeleaf等模板引擎。</li><li>视图负责将模型的数据以用户友好的方式呈现，与用户进行交互。</li></ul></li><li><strong>控制器（Controller）：</strong><ul><li>控制器接收用户的请求并决定调用哪个业务逻辑处理方法。在SpringMVC中，控制器通常是一个类，使用注解来标识处理请求的方法。</li><li>控制器处理请求后，调用适当的业务逻辑，获取或更新模型数据，然后选择合适的视图来渲染响应。</li></ul></li><li><strong>前端控制器（Front Controller）：</strong><ul><li>SpringMVC 使用DispatcherServlet作为前端控制器，它是Servlet的一个子类，负责拦截所有进入应用的请求。</li><li>DispatcherServlet将请求分发给相应的处理器（Controller），并将模型数据传递给合适的视图进行渲染。</li></ul></li><li><strong>处理器映射器和视图解析器：</strong><ul><li>处理器映射器负责将请求映射到合适的控制器，根据请求URL找到对应的处理器。</li><li>视图解析器负责将逻辑视图名解析为实际的视图对象，决定使用哪个视图来呈现模型数据。</li></ul></li></ol><h3 id="2、SpringMVC的核心组件"><a href="#2、SpringMVC的核心组件" class="headerlink" title="2、SpringMVC的核心组件"></a>2、SpringMVC的核心组件</h3><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="3、SpringMVC的工作原理"><a href="#3、SpringMVC的工作原理" class="headerlink" title="3、SpringMVC的工作原理"></a>3、SpringMVC的工作原理</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312061453227.png" alt="image.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html">https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc</a></li><li><a href="https://blog.csdn.net/Zhangsama1/article/details/131237139">https://blog.csdn.net/Zhangsama1/article/details/131237139</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_AOP</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h3><p>AOP（Aspect-Oriented Programming:面向切面编程）是一种编程范式，通过在代码中横向插入关注点（如日志、事务），实现对应用程序模块化、可维护性和可重用性的提升。</p><p>AOP 切面编程涉及到的一些专业术语：</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="2、Spring-AOP-的实现"><a href="#2、Spring-AOP-的实现" class="headerlink" title="2、Spring AOP 的实现"></a>2、Spring AOP 的实现</h3><p>Spring AOP基于动态代理实现，</p><ul><li>对于实现了接口的对象，使用JDK Proxy创建代理对象；</li><li>对于未实现接口的对象，使用Cglib生成被代理对象的子类。</li></ul><p>Spring AOP还集成了AspectJ，AspectJ是Java生态系统中最完整的AOP框架，拥有更多功能，特别在切面较多的情况下，选择AspectJ相比Spring AOP更为高效。</p><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-aop.html">https://www.pdai.tech/md/spring/spring-x-framework-aop.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Stream</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/</url>
    
    <content type="html"><![CDATA[<p>Stream 组件是用于封装消息队列来使用的，Bus这个组件一般会结合 Stream 使用；</p><p>看一般性文档解释，主要是围绕 Bus 可以做到配置的动态刷新、事件的传递。具体使用的时候可以看一下相关内容。</p><p>下面内容是引用 ChatGpt 的内容，分别是 Stream 和 Bus 的基本使用。</p><h3 id="1、Spring-Cloud-Stream的使用"><a href="#1、Spring-Cloud-Stream的使用" class="headerlink" title="1、Spring Cloud Stream的使用"></a>1、Spring Cloud Stream的使用</h3><p>Spring Cloud Stream 是一个用于构建消息驱动微服务架构的框架，它基于Spring Boot和Spring Integration，提供了一种简单的方式来实现各个微服务组件之间的消息通信。</p><p>以下是Spring Cloud Stream的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Cloud Stream 的依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-</span><span class="hljs-template-variable">&#123;binder&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>&#123;binder&#125;</code> 可以是不同的消息中间件的名称，比如 RabbitMQ、Kafka 等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置消息中间件的连接信息，以 RabbitMQ 为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">bindings:</span><br>        <span class="hljs-attr">output:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">my-output-topic</span><br>          <span class="hljs-attr">binder:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># RabbitMQ的binder</span><br>      <span class="hljs-attr">rabbit:</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-attr">exchangeType:</span> <span class="hljs-string">topic</span><br>            <span class="hljs-attr">routingKeyExpression:</span> <span class="hljs-string">&#x27;my-output-topic&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>发送消息</li></ol></blockquote><p>在应用程序中使用 <code>Source</code> 接口定义消息发送的输出通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.Output;<br><span class="hljs-keyword">import</span> org.springframework.messaging.MessageChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MySource</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;output&quot;</span>;<br><br>    <span class="hljs-meta">@Output(OUTPUT)</span><br>    MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在需要发送消息的地方注入 <code>MySource</code>，并使用 <code>output()</code> 方法发送消息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">Message</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">support</span>.<span class="hljs-property">MessageBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSenderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MySource</span> mySource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> payload</span>) &#123;<br>        <span class="hljs-title class_">Message</span>&lt;<span class="hljs-title class_">String</span>&gt; message = <span class="hljs-title class_">MessageBuilder</span>.<span class="hljs-title function_">withPayload</span>(payload).<span class="hljs-title function_">build</span>();<br>        mySource.<span class="hljs-title function_">output</span>().<span class="hljs-title function_">send</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>接收消息</li></ol></blockquote><p>在应用程序中使用 <code>@StreamListener</code> 注解定义消息接收的输入通道：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.<span class="hljs-keyword">annotation</span>.StreamListener;<br><span class="hljs-keyword">import</span> org.springframework.messaging.handler.<span class="hljs-keyword">annotation</span>.Payload;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageReceiverService</span> &#123;<br><br>    <span class="hljs-meta">@StreamListener(MySource.INPUT)</span><br>    <span class="hljs-keyword">public</span> void receiveMessage(<span class="hljs-meta">@Payload</span> String payload) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Received message: &quot;</span> + payload);<br>        <span class="hljs-comment">// 处理接收到的消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>运行时绑定</li></ol></blockquote><p>Spring Cloud Stream 会在运行时将消息通道绑定到消息中间件上，使得消息的发送和接收可以与底层的消息中间件解耦。根据配置的 <code>&#123;binder&#125;</code> 不同，可以支持 RabbitMQ、Kafka、ActiveMQ 等多种消息中间件。</p><p>通过以上步骤，你就可以使用 Spring Cloud Stream 在微服务中实现消息的发送和接收，从而构建消息驱动的微服务架构。</p><h3 id="2、SpringCloud-Bus-的使用"><a href="#2、SpringCloud-Bus-的使用" class="headerlink" title="2、SpringCloud Bus 的使用"></a>2、SpringCloud Bus 的使用</h3><p>Spring Cloud Bus是一个用于在分布式系统中传播事件的工具，它建立在Spring Cloud Stream之上。它允许微服务架构中的组件之间进行消息推送，实现配置的动态刷新、事件的传递等功能。</p><p>以下是Spring Cloud Bus的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的<code>pom.xml</code>文件中添加Spring Cloud Bus的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述示例中使用了AMQP（Advanced Message Queuing Protocol）作为消息传递的中间件，你也可以选择其他消息中间件，如Kafka等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在<code>application.properties</code>或<code>application.yml</code>中配置消息中间件的连接信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>配置Bus</li></ol></blockquote><p>在微服务的<code>application.properties</code>或<code>application.yml</code>中，添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">bus:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>4.发送消息</p></blockquote><p>在任意微服务中，可以使用Spring Cloud Bus发送消息来触发事件。可以使用HTTP POST请求向<code>/actuator/bus-refresh</code>端点发送刷新请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/actuator/</span>bus-refresh<br></code></pre></td></tr></table></figure><p>这样就会触发Spring Cloud Bus发送一个刷新事件，然后各个微服务都会接收到这个事件，从而触发配置的刷新操作。</p><blockquote><ol start="5"><li>接收消息</li></ol></blockquote><p>在微服务中，可以使用<code>@RefreshScope</code>注解标记一个类，使得该类中的配置在接收到刷新事件时能够重新加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;my.property&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String myProperty;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/property&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getProperty() &#123;<br>        <span class="hljs-keyword">return</span> myProperty;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，<code>@RefreshScope</code>注解使得<code>MyController</code>类中的配置在接收到刷新事件时会重新加载。</p><p>通过这些步骤，你就可以使用Spring Cloud Bus实现在分布式系统中传播事件，例如动态刷新配置、传递消息等。</p><p>to be contined…..</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Seata</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是分布式事务"><a href="#1、什么是分布式事务" class="headerlink" title="1、什么是分布式事务"></a>1、什么是分布式事务</h3><p>首先理解一下，为什么会用到分布式事务。</p><p>在分布式服务中，服务A中通过feign来调用服务B的方法，但是服务B的方法并不归属于服务A的事务体系中，因此如果此时服务B报错，并不会导致已经执行了的服务A的操作回退。</p><p>想要让服务A回退，那么就要让服务B纳入到服务A的事务体系中，也就是两者是同一个事务ID。这就是我们的分布式事务，它<strong>可以跨越服务来实现事务</strong>。</p><p>想要实现分布式事务，我们有多种方式，可以通过像redis这样的中间件来实现。</p><p>但也可以用到我们今天介绍的seata组件来实现。甚至发展至今，一般我们谈到分布式事务，基本上seata已经成了我们的不二选择。</p><h3 id="2、Seata-是什么"><a href="#2、Seata-是什么" class="headerlink" title="2、Seata 是什么"></a>2、Seata 是什么</h3><p>Seata 是一款分布式事务解决方案，为微服务架构提供了强一致性的分布式事务支持。提供了全局事务管理和本地事务协调的功能，可以用于确保多个微服务之间的事务操作的一致性；提供了 AT、TCC、SAGA和XA等几种事务模式。</p><p>常见的两种分布式事务模型：AT 模型（基于 TCC，Try-Confirm-Cancel）和 TCC 模型（基于两阶段提交）。</p><blockquote><p>AT模型</p></blockquote><p>默认使用的是AT模式</p><ol><li>在业务表所在的数据库中创建一个名为undo_log的表，用于记录回滚SQL，即与执行SQL相反的SQL（例如，执行insert则对应delete）。</li><li>当业务表执行操作时，Seata会解析执行的SQL，生成回滚SQL并存储到undo_log表中。</li><li>在本地事务提交前，向Seata服务端注册分支，申请业务表中对应数据行的全局锁，阻止其他事务对该数据进行更新操作。</li><li>本地事务提交时，业务数据的更新和生成的undo log一起提交。</li><li>将本地事务执行结果报告给Seata服务端，多个服务的本地事务使用相同的事务ID和分支ID记录在Seata服务端。</li><li>如果某个本地事务发生错误，Seata服务端发起对应分支的回滚请求。</li><li>同时开启本地事务，通过事务ID和分支ID查询undo_log表，执行回滚SQL，并将执行结果报告给Seata服务端。</li><li>如果没有错误发生，Seata服务端会在对应分支上发起请求，异步批量删除undo_log表中的记录。</li></ol><p>总体来说，Seata服务端记录了所有本地事务，同时在每个库中记录了undo log。</p><p>当发生错误时，通过事务ID和分支ID找到同一组的所有本地事务，利用记录的undo log统一回退数据。</p><h3 id="3、使用-Seata-的基本步骤"><a href="#3、使用-Seata-的基本步骤" class="headerlink" title="3、使用 Seata 的基本步骤"></a>3、使用 Seata 的基本步骤</h3><p>seata分为服务端（TC）和客户端（TM,RM）,</p><p>客户端通过引入jar包来使用。服务端需要我们单独安装。</p><ul><li>TC(Transaction Coordinator)：事务协调器，维护全局事务的运行状态，协调和落实全局事务的回滚提交</li><li>TM(Transaction Manager)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局事务提交或回滚的决议</li><li>RM(Resource Manager)：控制分支（本地）事务，负责分支注册、状态汇报，并接受TC的指令，驱动本地事务的提交和回滚</li></ul><h4 id="1-部署-Seata-服务器"><a href="#1-部署-Seata-服务器" class="headerlink" title="1. 部署 Seata 服务器"></a>1. 部署 Seata 服务器</h4><p>服务端下载地址： <a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p><p>部署过程：略</p><h4 id="2-seata客户端配置"><a href="#2-seata客户端配置" class="headerlink" title="2. seata客户端配置"></a>2. seata客户端配置</h4><p>在微服务的项目中，添加 Seata 的依赖。如果使用 Maven，可以在项目的 <code>pom.xml</code> 文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 请根据实际情况选择版本 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><p>在微服务的配置文件中，配置 Seata 客户端。通常需要指定 Seata 服务器的地址等信息。以下是一个示例配置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">seata:</span><br>  application-id: my-app<br>  tx-service-group: my-tx-group<br><span class="hljs-symbol">  enabled:</span> true<br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  registry:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  service:</span><br><span class="hljs-symbol">    vgroup:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br><span class="hljs-symbol">    group:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br></code></pre></td></tr></table></figure><h4 id="添加事务注解"><a href="#添加事务注解" class="headerlink" title="添加事务注解"></a>添加事务注解</h4><p>使用 @GlobalTransactional 注解</p><p>在需要分布式事务的方法上，使用 <code>@GlobalTransactional</code> 注解标记。这个注解表示这个方法需要参与全局事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.seata.spring.annotation.GlobalTransactional;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@GlobalTransactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">businessMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/github_38592071/article/details/131136986">https://blog.csdn.net/github_38592071/article/details/131136986</a></li><li><a href="https://juejin.cn/post/7087551217781620749">https://juejin.cn/post/7087551217781620749</a></li><li><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_OpenFeign</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/</url>
    
    <content type="html"><![CDATA[<h3 id="1、服务调用"><a href="#1、服务调用" class="headerlink" title="1、服务调用"></a>1、服务调用</h3><h4 id="服务注册、服务发现、服务调用"><a href="#服务注册、服务发现、服务调用" class="headerlink" title="服务注册、服务发现、服务调用"></a>服务注册、服务发现、服务调用</h4><p>在Spring Cloud Alibaba生态系统中，服务调用的核心组件是 <strong>Nacos Discovery</strong> 和 <strong>Feign</strong>。</p><blockquote><p>Nacos Discovery</p></blockquote><p>Nacos是一个开源的服务发现和配置管理平台，它提供了服务注册与发现的功能，可以让微服务应用在注册到Nacos注册中心后，方便地发现其他服务，并实现服务之间的调用。通过Nacos Discovery，服务之间的关系和位置信息能够得到维护，实现了服务注册和服务发现。</p><blockquote><p>Feign</p></blockquote><p>Feign是一个声明式的Web服务客户端，它简化了服务调用的过程。通过在接口上添加注解，Feign能够自动构造HTTP请求并将其发送到服务提供方。在Spring Cloud Alibaba中，Feign与Nacos Discovery集成，可以使用Feign来发起服务调用，而Nacos Discovery则用于服务的注册和发现。</p><h4 id="微服务间的调用方式"><a href="#微服务间的调用方式" class="headerlink" title="微服务间的调用方式"></a>微服务间的调用方式</h4><blockquote><p>微服务调用</p></blockquote><p>微服务之间的通信方式常见的方式有两种：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">RPC</span> 代表：dubbo  <br>HTTP 代表：SpringCloud<br></code></pre></td></tr></table></figure><p>在微服务架构中，最常见的场景就是微服务间的相互调用。</p><p>在 SpringCloud 中，默认是使用 HTTP  来进行微服务的通信，微服务间的相互调用方式主要有<code>RestTemplate</code>、<code>Feign</code> 、和<code>OpenFeign</code></p><blockquote><p>RestTemplate</p></blockquote><p>RestTemplate 是从 Spring3.0 开始支持的一个 http 请求工具，这个请求工具是 Spring 自带的</p><p>RestTemplate 提供了常见的 REST 请求方法模板，如 GET、POST、PUT、DELETE 请求以及一些通用的请求执行方法 exchange 和 execute 方法</p><blockquote><p>Feign</p></blockquote><p>Feign 是 Spring Cloud 组件中的一个<code>声明式</code>的<code>轻量级 RESTful 的 HTTP 服务客户端</code></p><p>Feign 内置了 Ribbon，用来做<code>客户端负载均衡</code>，去调用服务注册中心的服务；</p><blockquote><p>OpenFeign</p></blockquote><p>OpenFeign 是 Spring Cloud 在 Feign 的基础上支持 SpringMVC 的注解，如 @RequesMapping 等等。</p><p>OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p><blockquote><p>OpenFeign 和 Feign 组件的区别和关联</p></blockquote><p>OpenFeign 是 Feign 的增强版，它是 Spring Cloud 对 Feign 进行了扩展和优化的结果。虽然两者有关联，但在一些功能和使用上存在一些区别。</p><p><strong>Feign:</strong></p><ul><li>Feign 是一个声明式的Web服务客户端，用于简化服务调用的过程。</li><li>它基于接口定义，通过添加注解，可以轻松地发起HTTP请求。</li><li>在原始的 Spring Cloud 中，Feign 的默认实现不支持 Spring MVC 注解，因此使用起来有一些限制。</li></ul><p><strong>OpenFeign:</strong></p><ul><li>OpenFeign 是对 Feign 的增强，它引入了对 Spring MVC 注解的支持，使得 Feign 在使用上更加灵活。</li><li>OpenFeign 提供了更丰富的功能，例如继承性、支持 Spring Cloud Contract、支持多部分请求和响应等。</li><li>OpenFeign 可以通过 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性来实现多个 Feign 客户端实例之间的隔离。</li></ul><p>在Spring Cloud项目中，如果你使用 <code>@FeignClient</code> 注解，实际上默认是使用的 OpenFeign。</p><p>Spring Cloud 在 Hoxton.RELEASE 版本之后<strong>默认使用 OpenFeign，而不是原始的 Feign。</strong></p><p>关于使用 <code>@FeignClient</code> 注解创建 Feign 客户端的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>@FeignClient</code> 注解指定了服务的名称和URL，<code>ExampleFeignClient</code> 接口定义了服务调用的契约。通过添加 <code>@GetMapping</code> 注解，实现了对服务提供者的 <code>/hello</code> 接口的调用。</p><p>总体而言，OpenFeign 是对 Feign 的增强版本，提供了更多的功能和更好的灵活性，而在 Spring Cloud 中，我们常常通过 <code>@FeignClient</code> 注解来使用 OpenFeign。</p><h3 id="2、OpenFeign-的使用"><a href="#2、OpenFeign-的使用" class="headerlink" title="2、OpenFeign 的使用"></a>2、OpenFeign 的使用</h3><h4 id="FeignClient的基本使用方法"><a href="#FeignClient的基本使用方法" class="headerlink" title="@FeignClient的基本使用方法"></a><code>@FeignClient</code>的基本使用方法</h4><p><code>@FeignClient</code> 是 Spring Cloud 中用于声明式REST客户端的注解。通过使用该注解，可以定义一个接口，而不需要实现该接口，Spring Cloud会在运行时自动生成该接口的实现类，用于发起服务间的HTTP请求。</p><p>以下是<code>@FeignClient</code>的基本使用方法：</p><blockquote><p><strong>简单使用：</strong></p></blockquote><p>在一个接口上添加 <code>@FeignClient</code> 注解，并指定要调用的服务名称</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><br><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>ExampleFeignClient</code> 接口用于调用名为 “example-service” 的微服务，其中 <code>@GetMapping(&quot;/hello&quot;)</code> 定义了调用服务的路径。</p><blockquote><p>指定 URL</p></blockquote><p>可以通过 <code>url</code> 属性指定服务的URL，而不是通过服务名称进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，服务的URL被硬编码为 “<a href="http://example.com"./">http://example.com&quot;。</a></p><blockquote><p><strong>指定Fallback</strong></p></blockquote><p>可以通过 <code>fallback</code> 属性指定一个实现了 <code>ExampleFeignClient</code> 接口的类，作为调用失败时的降级处理。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;example-service&quot;</span>, fallback = ExampleFeignClientFallback.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExampleFeignClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/hello&quot;</span>)<br>    <span class="hljs-keyword">String</span> hello();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleFeignClientFallback</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ExampleFeignClient</span></span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fallback Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当调用服务失败时，会执行 <code>ExampleFeignClientFallback</code> 中的逻辑。</p><blockquote><p><strong>指定Decoder和Encoder</strong></p></blockquote><p>可以通过 <code>decoder</code> 和 <code>encoder</code> 属性指定自定义的解码器和编码器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, decoder = MyDecoder.class, encoder = MyEncoder.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyDecoder</code> 和 <code>MyEncoder</code> 分别是自定义的解码器和编码器。</p><p>这些是 <code>@FeignClient</code> 注解的基本用法，通过灵活使用这些属性，可以实现更多定制化的服务调用配置。</p><p>to be continued….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/IT__learning/article/details/116349843">https://blog.csdn.net/IT__learning/article/details/116349843</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Gateway</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/</url>
    
    <content type="html"><![CDATA[<h3 id="1、微服务网关是什么"><a href="#1、微服务网关是什么" class="headerlink" title="1、微服务网关是什么"></a>1、微服务网关是什么</h3><p>微服务网关是一个位于微服务架构前端的服务，作为客户端和后端微服务之间的中介。它的作用是集中处理和管理微服务系统的一些共享的非业务功能，提供统一的入口，同时可以进行路由、转发、过滤、监控等操作。</p><blockquote><p>Gateway 的基本功能</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041349886.png" alt="image.png"></p><ol><li><strong>路由转发：</strong><ul><li>网关负责接收客户端的请求，根据配置的路由规则将请求转发到不同的微服务。这有助于实现前后端的解耦，使得微服务可以独立演进。</li></ul></li><li><strong>流量控制：</strong><ul><li>网关可以对请求进行流量控制，限制每个微服务的访问频率，防止某个微服务被过度请求而影响整体系统的稳定性。</li></ul></li><li><strong>熔断保护：</strong><ul><li>网关可以实现熔断保护，当某个微服务出现故障或超时时，网关可以快速拦截请求，避免请求堆积导致整个系统的崩溃。Sentinel是一种专注于流量控制、熔断降级、系统自适应保护的开源框架，它提供了更丰富的熔断保护功能，因此有些项目选择引入Sentinel来增强熔断保护能力。</li></ul></li><li><strong>日志监控：</strong><ul><li>网关通常会记录请求和响应的日志信息，这有助于进行系统的监控和故障排查。业务日志和链路追踪也是重要的监控手段。</li></ul></li><li><strong>安全认证：</strong><ul><li>网关可以提供安全认证机制，确保只有经过认证和授权的用户才能访问微服务。这可以通过集成框架（如Spring Security）或使用专门的认证服务来实现。</li></ul></li></ol><blockquote><p>关于 Gateway 的熔断保护功能的说明</p></blockquote><p>Spring Cloud Gateway自身具备基本的熔断保护机制，可以在配置中设置断路器的一些参数，但相对简单。对于一些更复杂的熔断、限流、降级等场景，可能需要引入专门的框架如Sentinel。</p><p>在实际使用中，可以根据具体的需求来选择是否引入Sentinel。如果项目对熔断保护等功能的需求相对简单，Gateway的基本熔断保护足够使用。如果需要更复杂的流量控制和熔断降级策略，引入Sentinel可能会更为合适。</p><blockquote><p>服务网关和流量网关的区别</p></blockquote><p>对于 Nginx 和 Gateway 的两者区别：</p><p>流量网关（如Nignx)提供全局性的、与后端业务应用无关的策略，例如 HTTPS证书卸载、Web防火墙、全局流量监控等。</p><p>微服务网关（如Spring Cloud Gateway）是指与业务紧耦合的、提供单个业务域级别的策略，如服务治理、身份认证等。</p><p>流量网关负责南北向流量调度及安全防护，微服务网关负责东西向流量调度及服务治理。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041354467.png" alt="image.png|400"></p><h3 id="2、Gateway-的搭建和使用"><a href="#2、Gateway-的搭建和使用" class="headerlink" title="2、Gateway 的搭建和使用"></a>2、Gateway 的搭建和使用</h3><blockquote><p>网关的搭建</p></blockquote><p>略</p><blockquote><p>Spring Cloud Gateway 的配置项</p></blockquote><p>Spring Cloud Gateway的核心概念包括路由（Route）、断言（Predicate）和过滤器（Filter）。</p><p>这些概念共同构成了Gateway的基础，用于定义请求的路由规则、请求的匹配条件和请求的处理流程。</p><blockquote><p>路由</p></blockquote><p>路由定义了请求应该被定向到哪个目标服务。每个路由都包含一个唯一的ID、目标URI、一组断言和过滤器。通过配置多个路由，可以实现对请求的动态路由和负载均衡。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>上述配置表示将以<code>/example/**</code>路径开头的请求转发到<code>http://example.com</code>，并在转发时去掉路径的第一个段（StripPrefix&#x3D;1）。</p><blockquote><p>断言</p></blockquote><p>断言定义了请求匹配的条件，当条件满足时，对应的路由规则生效。断言可以基于请求的路径、方法、头部信息等进行匹配。</p><blockquote><p>过滤器</p></blockquote><p>过滤器是处理请求和响应的逻辑的组件，它们可以修改请求和响应，实现一些额外的功能，如添加头信息、修改请求体、进行认证等</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Header=foo</span><br></code></pre></td></tr></table></figure><p>上述配置中的过滤器<code>AddRequestHeader=X-Header=foo</code>表示在转发请求前，向请求头中添加一个名为<code>X-Header</code>的头，其值为<code>foo</code>。</p><blockquote><p>Gateway集成 nacos 注册中心实现服务发现</p></blockquote><p>略</p><blockquote><p>Gateway 整合 Apollo 实现动态路由配置</p></blockquote><p>略</p><blockquote><p>自定义全局异常处理器</p></blockquote><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yao583224426/article/details/122216804">https://blog.csdn.net/yao583224426/article/details/122216804</a></li><li><a href="https://cloud.tencent.com/developer/article/2135737">https://cloud.tencent.com/developer/article/2135737</a></li><li><a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Sentinel</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/</url>
    
    <content type="html"><![CDATA[<p>使用类似于 Sleuth，在对应服务添加依赖和注解配置后，Sentinel 能够对服务做一个服务流量监听，进行熔断降级、系统负载等操作。</p><p><strong>Sentinel控制台的下载</strong></p><p>下载地址： <a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.3">https://github.com/alibaba/Sentinel/releases/tag/1.8.3</a></p><p>注意的一些内容</p><ul><li>注解使用（服务程序中使用）</li><li>流控规则</li><li>熔断规则</li><li>系统规则</li></ul><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106899215">https://blog.csdn.net/qq_36903261/article/details/106899215</a></li><li><a href="https://blog.csdn.net/qq_38374397/article/details/125603109">https://blog.csdn.net/qq_38374397/article/details/125603109</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的安装与使用</title>
    <link href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、windows下rabbitMQ-的安装"><a href="#1、windows下rabbitMQ-的安装" class="headerlink" title="1、windows下rabbitMQ 的安装"></a>1、windows下rabbitMQ 的安装</h3><p>RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是需要安装一下Erlang</p><p>Erlang 下载地址： <a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p><p>环境变量配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">ERLANG_HOME<br><span class="hljs-tag">%<span class="hljs-selector-tag">ERLANG_HOME</span></span>%\bin<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203233950.png" alt="image.png"></p><p>打开 cmd 输入 erl -version 出现版本号即安装成功</p><blockquote><p>RabbitMQ</p></blockquote><p>rabbitmq 下载地址： <a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>下载进行安装操作。</p><p>CMD 进入终端 进入到安装目录 执行 rabbitmq-plugins enable rabbitmq_management 命令安装管理页面的插件，</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203234341.png" alt="image.png"></p><p>启动rabbitMQ服务：rabbitmq-service.bat start</p><p>双击 rabbitmq-service.bat 即完成安装。（关闭的话手动在服务列表进行关闭一下）</p><p>登陆： <a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></p><p>初始的默认用户及密码都是 <code>guest</code> ， 输入后即可登录</p><h3 id="2、centos-系统下-rabbitMQ-的安装"><a href="#2、centos-系统下-rabbitMQ-的安装" class="headerlink" title="2、centos 系统下 rabbitMQ 的安装"></a>2、centos 系统下 rabbitMQ 的安装</h3><h4 id="RabbitMQ-服务安装"><a href="#RabbitMQ-服务安装" class="headerlink" title="RabbitMQ 服务安装"></a>RabbitMQ 服务安装</h4><p>略</p><h4 id="Docker容器方式安装RabbitMQ"><a href="#Docker容器方式安装RabbitMQ" class="headerlink" title="Docker容器方式安装RabbitMQ"></a>Docker容器方式安装RabbitMQ</h4><p>1、拉取镜像（默认安装最新版本）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker pull rabbitmq<br></code></pre></td></tr></table></figure><p>2、启动RabbitMQ容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --hostname myRabbitMQ --name rabbit -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> rabbitmq<br></code></pre></td></tr></table></figure><p>这个命令的组成部分解释如下：</p><ul><li><code>docker run</code>：启动一个新的容器。</li><li><code>-d</code>：以守护进程模式运行容器，即容器在后台运行。</li><li><code>--hostname myRabbitMQ</code>：为容器设置主机名（<code>myRabbitMQ</code>）。你可以根据需要更改这个值。</li><li><code>--name rabbit</code>：设置容器的名称（<code>rabbit</code>）。这也可以根据你的命名约定来更改。</li><li><code>-p 5672:5672</code>：将容器内部的 5672 端口映射到宿主机的 5672 端口。5672 端口是 RabbitMQ 的默认AMQP端口。</li><li><code>-p 15672:15672</code>：将容器内的 15672 端口映射到宿主机的 15672 端口。15672 端口是 RabbitMQ 管理界面（Management Console）的默认端口。</li><li><code>rabbitmq</code>：指定要使用的 Docker 镜像。</li></ul><p>在 Docker 命令中使用 <code>-p</code> 参数来映射端口时，格式为 <code>-p &lt;宿主机端口&gt;:&lt;容器端口&gt;</code>。</p><p>开放一下端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=5672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=15672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><p>访问控制台界面</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//linuxip:15672</span><br></code></pre></td></tr></table></figure><p>用户名和密码默认都是guest</p><p>3、开启 Web 界面管控台插件</p><p>对于 Docker 容器中的 RabbitMQ</p><p>如果你是通过 Docker 容器运行 RabbitMQ，并且想要启用管理控制台，通常最简单的方式是直接使用带有管理插件的 RabbitMQ 镜像。例如：</p><p><code>docker run -d --hostname myRabbitMQ --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p><p>在这个命令中，<code>rabbitmq:3-management</code> 镜像已经包含了管理插件。如果你已经运行了一个不包含管理插件的 RabbitMQ 容器，你可以按照以下步骤启用管理插件：</p><ol><li><p>找出你的 RabbitMQ 容器的 ID 或名称：</p><p> <code>docker ps</code></p></li><li><p>进入容器：</p><p> <code>docker exec -it [容器ID或名称] bash</code></p></li><li><p>在容器内部，运行以下命令来启用管理插件：</p><p> <code>rabbitmq-plugins enable rabbitmq_management</code></p></li><li><p>退出容器：</p><p> <code>exit</code></p></li><li><p>重启 RabbitMQ 容器以应用更改。</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart<span class="hljs-meta"> [容器名称或ID]</span><br></code></pre></td></tr></table></figure><p>一旦完成，你就可以通过<code>http://linuxip:15672</code></p><p>访问 RabbitMQ 的管理界面。确保你已经将 15672 端口映射到了宿主机上。</p><hr><p>参考： </p><ul><li><a href="https://blog.csdn.net/u011709538/article/details/131396367">https://blog.csdn.net/u011709538/article/details/131396367</a></li><li><a href="https://zhuanlan.zhihu.com/p/609676322?utm_id=0">https://zhuanlan.zhihu.com/p/609676322?utm_id=0</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端依赖常见报错解决方案</title>
    <link href="/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题1： npm错误——npm ERR! code ERESOLVE 解决方法</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">npm ERR! code ERESOLVE<br>npm ERR! ERESOLVE unable to resolve dependency tree<br>npm ERR!<br>npm ERR! While resolving: vol.vue3@<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>npm ERR! Found: vue@<span class="hljs-number">3.2</span>.<span class="hljs-number">20</span><br>npm ERR! node_modules/vue<br>npm ERR!   vue@<span class="hljs-string">&quot;^3.0.0&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Could not resolve dependency:<br>npm ERR! peer vue@<span class="hljs-string">&quot;^2.5.17&quot;</span> from element-ui@<span class="hljs-number">2.15</span>.<span class="hljs-number">6</span><br>npm ERR! node_modules/element-ui<br>npm ERR!   element-ui@<span class="hljs-string">&quot;*&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Fix the upstream dependency conflict, or retry<br>npm ERR! this command with --force, or --legacy-peer-deps<br>npm ERR! to accept an incorrect (and potentially broken) dependency resolution.<br>npm ERR!<br>npm ERR! See C:\Users\Administrator\AppData\Local\npm-cache\eresolve-report.txt for a full report.<br> <br>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Users\Administrator\AppData\Local\npm-cache\_logs\<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">11</span>T06_27_44_908Z-debug.log<br></code></pre></td></tr></table></figure><p>在安装组件的时候出现以上问题，npm版本问题报错</p><p>解决方法：</p><p>在命令后面加上</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--legacy-peer-deps</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python环境安装</title>
    <link href="/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、python-3-9-版本安装"><a href="#1、python-3-9-版本安装" class="headerlink" title="1、python 3.9 版本安装"></a>1、python 3.9 版本安装</h3><p>下载地址： <a href="https://www.python.org/downloads/release/python-396/">https://www.python.org/downloads/release/python-396/</a></p><p>参考： <a href="https://blog.csdn.net/qq_53280175/article/details/121107748">https://blog.csdn.net/qq_53280175/article/details/121107748</a></p><p>下载链接： <a href="https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe">https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe</a></p><p>这里下载的是 win 64 位安装版</p><p>安装的时候勾选一下  Add Python 3.9 to PATH</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214357.png" alt="image.png"></p><p>选择自定义安装</p><p>查看是否安装成功，cmd 窗口输入一下 <code>python</code> 看一下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214605.png" alt="image.png"></p><h3 id="2、降级python为2-0-版本"><a href="#2、降级python为2-0-版本" class="headerlink" title="2、降级python为2.0 版本"></a>2、降级python为2.0 版本</h3><p>由于版本前端项目 node-sass 安装失败，部分建议是降级 Python 为 2.x 版本，这里记录一下实际操作。</p><p>找了一个 2.7.2 版本：<a href="https://www.python.org/downloads/release/python-273/">https://www.python.org/downloads/release/python-273/</a></p><p>仍然选择安装版本</p><p>安装完成后加一下 Path 环境变量（删除之前的）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">xxx\Pytho<span class="hljs-symbol">n27</span><br></code></pre></td></tr></table></figure><p>输入 <code>Python -V</code> 验证释放安装成功</p><p>实际操作在这一步输入后，没反映，<strong>使用完整路径运行 Python</strong> 却又是正常的</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">D</span>:\<span class="hljs-number">02</span>_Soft\xxxxx\Python27\python.exe -V<br></code></pre></td></tr></table></figure><p>实际的一个操作，<strong>需要设置path优先级，把python的路径放置顶部</strong></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统下 java环境变量的配置</title>
    <link href="/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="linux系统下-java环境变量的配置"><a href="#linux系统下-java环境变量的配置" class="headerlink" title="linux系统下 java环境变量的配置"></a>linux系统下 java环境变量的配置</h3><p>输入<code>echo $JAVA_HOME</code>结果为空，说明没有配置java环境变量</p><p>查看yum安装的jdk在哪个目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /etc/alternatives/java<br></code></pre></td></tr></table></figure><p>默认安装路径是在 <code>/usr/lib/jvm</code></p><p>配置环境变量  <code>vim /etc/profile</code></p><p>追加内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/lib/java/jdk1.8.0_231 <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib  <br><span class="hljs-built_in">export</span>  <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p>刷新环境变量配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><blockquote><p>卸载重装</p></blockquote><p>卸载参考（Linux上卸载JDK）： <a href="https://blog.csdn.net/weixin_44990104/article/details/117589372">https://blog.csdn.net/weixin_44990104/article/details/117589372</a></p><p>linux安装jdk8详细步骤，参考： <a href="https://blog.csdn.net/qq_33794744/article/details/107838128">https://blog.csdn.net/qq_33794744/article/details/107838128</a></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7 安装 nacos 操作</title>
    <link href="/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="centos7-安装-nacos-操作"><a href="#centos7-安装-nacos-操作" class="headerlink" title="centos7 安装 nacos 操作"></a>centos7 安装 nacos 操作</h3><p>前提需要：项目运行环境需要安装 nacos </p><p>在 centos 中进行安装nacos，这里演示安装版本是 1.3.2，</p><p>下载地址： <a href="https://github.com/alibaba/nacos/releases/tag/1.3.2">https://github.com/alibaba/nacos/releases/tag/1.3.2</a></p><p>nacos 运行需要先安装一下 JDK 环境，注意一下</p><p>可以自己点击下载   <code>nacos-server-1.3.2.tar.gz</code></p><p>或者在 Linux系统中下载命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://github.com/alibaba/nacos/releases/download/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>/nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>下载完压缩包之后，上传指服务器任意目录，进行解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压后会生成 nacos 文件夹，进入到 nacos 目录，输入命令启动(以单机的形式启动)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/startup.sh -m standalone<br></code></pre></td></tr></table></figure><p>如果需要持久化 配置到mysql，则调整nacos的配置</p><p>如果你的服务器开了防火墙，则需要开放相应的端口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#开放端口</span><br>firewall-cmd <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=8848/tcp</span> <span class="hljs-params">--permanent</span> <br><span class="hljs-comment"># 重启防火墙 </span><br>firewall-cmd <span class="hljs-params">--reload</span><br><span class="hljs-comment"># 查看开放的端口列表 </span><br>firewall-cmd <span class="hljs-params">--list-port</span><br></code></pre></td></tr></table></figure><p>nacos默认的启动端口是 8848，访问 <code>http://ip:端口/nacos</code> 即可看到登录页面.默认的用户名密码是 <code>nacos/naocs</code>，登录即可使用</p>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透工具Neutrino-Proxy</title>
    <link href="/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/"/>
    <url>/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基本介绍"><a href="#1、基本介绍" class="headerlink" title="1、基本介绍"></a>1、基本介绍</h3><p>一款简单易用的内网穿透使用工具</p><p>官网： <a href="https://neutrino-proxy.dromara.org/">https://neutrino-proxy.dromara.org/</a></p><p>项目地址： <a href="https://gitee.com/dromara/neutrino-proxy/releases">https://gitee.com/dromara/neutrino-proxy/releases</a></p><p>部署方式有三种，这里通过原生部署的方式进行启动</p><p>原生部署的方式需要下载zip包，进行解压，然后启动 exe 文件。部分exe程序同一目录下有Pom.xml配置文件，可进行修改对应配置。</p><p>服务器下载<code>neutrino-proxy-server-ubuntu-20.04-native.zip</code>文件，</p><p>客户端下载<code>neutrino-proxy-client-windows-2022-native.zip</code></p><h3 id="2、服务端部署"><a href="#2、服务端部署" class="headerlink" title="2、服务端部署"></a>2、服务端部署</h3><blockquote><p>部署服务器端</p></blockquote><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>默认先采用原生配置h2数据库，（这种数据库的缺点是数据放在内存中，如果需要持久化放到本地，建议修改配置为 mysql 数据库）</p><p>原配置</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">data:</span><br>  <span class="hljs-symbol">db:</span><br>    <span class="hljs-comment"># 数据库类型，目前支持h2、mysql、mariadb</span><br>    <span class="hljs-symbol">type:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_TYPE</span><span class="hljs-symbol">:h2</span>&#125;<br>    <span class="hljs-comment"># 数据库连接URL</span><br>    <span class="hljs-symbol">url:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_URL</span><span class="hljs-symbol">:jdbc</span><span class="hljs-symbol">:h2</span><span class="hljs-symbol">:file</span><span class="hljs-symbol">:</span>./data/db;<span class="hljs-variable constant_">MODE</span>=<span class="hljs-title class_">My</span>SQL;<span class="hljs-variable constant_">AUTO_SERVER</span>=<span class="hljs-variable constant_">TRUE</span>&#125;<br>    <span class="hljs-comment"># 数据库用户名</span><br>    <span class="hljs-symbol">username:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_USER</span><span class="hljs-symbol">:</span>&#125;<br>    <span class="hljs-comment"># 数据库密码</span><br>    <span class="hljs-symbol">password:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_PASSWORD</span><span class="hljs-symbol">:</span>&#125;<br></code></pre></td></tr></table></figure><p>修改配置(修改为MySQL数据库)</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-symbol">data:</span><br>  <span class="hljs-symbol">db:</span><br>    <span class="hljs-comment"># 数据库类型，目前支持h2、mysql、mariadb</span><br>    <span class="hljs-symbol">type:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_TYPE</span><span class="hljs-symbol">:mysql</span>&#125; <br>    <span class="hljs-symbol">url:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_URL</span><span class="hljs-symbol">:jdbc</span><span class="hljs-symbol">:mysql</span><span class="hljs-symbol">://localhost</span><span class="hljs-symbol">:</span><span class="hljs-number">3306</span>/neutrino-proxy&#125;<br>    <span class="hljs-comment"># 数据库用户名</span><br>    <span class="hljs-symbol">username:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_USER</span><span class="hljs-symbol">:root</span>&#125;<br>    <span class="hljs-comment"># 数据库密码</span><br>    <span class="hljs-symbol">password:</span> <span class="hljs-variable">$&#123;</span><span class="hljs-variable constant_">DB_PASSWORD</span><span class="hljs-symbol">:yourpassword</span>&#125;<br></code></pre></td></tr></table></figure><p>关于上面的配置项，如果不清楚，建议直接下载Gitee项目，自己查看项目代码，搜索对应配置内容参数。</p><p>源码建议也学习一下，它这里对应的配置文件是：DbConfiguration</p><h4 id="部署运行"><a href="#部署运行" class="headerlink" title="部署运行"></a>部署运行</h4><p>实际操作：</p><p>1、将下载文件复制到服务器的某个目录下，进行解压操作：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">unzip  neutrino-proxy-<span class="hljs-keyword">server</span>-ubuntu<span class="hljs-number">-20.04</span>-native.zip<br><br><span class="hljs-meta">#启动服务端可执行程序</span><br>./neutrino-proxy-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><ul><li>服务端部署成功后，访问http:&#x2F;&#x2F;{服务端IP}:8888打开后台管理页面。使用默认的管理员帐号登录：admin&#x2F;123456</li><li>打开代理配置&gt;License管理页面，系统已经自动为管理员初始化了一条License记录，复制该LicenseKey备用，后续客户端配置需要。</li></ul><p>2、将 exe 程序后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./neutrino-proxy-server &amp;<br></code></pre></td></tr></table></figure><p><code>nohup</code> 命令用于忽略挂断信号（SIGHUP），并且 <code>&amp;</code> 符号用于将程序放到后台运行。</p><p><code>nohup.out</code> 文件通常会生成在你运行 <code>nohup</code> 命令的当前工作目录（current working directory）。如果你没有指定具体的输出文件路径，<code>nohup</code> 默认将输出重定向到 <code>nohup.out</code> 文件</p><p>关闭后台程序</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#查看进程号PID</span><br>ps aux | <span class="hljs-keyword">grep</span> neutrino-proxy-server<br><span class="hljs-comment">#杀死进程</span><br><span class="hljs-keyword">kill</span> &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>后台运行的时候发现使用 xshell 直接启动程序会随着关闭 ssh 连接而中断运行，这里是采用 screen + nohup 的方式运行程序。</p><p>上面这种方式在关闭 ssh 连接后，会话中的进程就直接关闭了。尝试一下 screen 的使用</p><p><code>screen</code> 是一个终端复用工具，它允许你在一个终端窗口中创建多个虚拟终端，并在这些虚拟终端中运行不同的程序。通过使用 <code>screen</code>，你可以在一个会话中保持你的程序在后台运行，即使你关闭了SSH连接也不会影响这些程序的执行</p><p>安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> screen<br></code></pre></td></tr></table></figure><ol><li><p><strong>启动一个新的 <code>screen</code> 会话：</strong><br> <code>screen</code><br> 这将创建一个新的 <code>screen</code> 会话，并将你切换到该会话中。</p></li><li><p><strong>在 <code>screen</code> 会话中运行你的程序：</strong></p><p> 在 <code>screen</code> 会话中，你可以运行你的程序，比如：</p><p> <code>./your_program.exe</code><br> 如果你需要在程序后台运行，你可以使用 <code>Ctrl + A</code> 然后按下 <code>d</code> 键，这会将 <code>screen</code> 会话放入后台，但会话中的程序仍在运行。</p></li><li><p><strong>列出 <code>screen</code> 会话：</strong><br> <code>screen -ls</code><br> 这将显示当前所有的 <code>screen</code> 会话。</p></li><li><p><strong>重新连接到 <code>screen</code> 会话：</strong></p><p> 如果你关闭了终端或断开了SSH连接，你可以重新连接到之前创建的 <code>screen</code> 会话：<br> <code>screen -r</code><br> 如果有多个会话，你可能需要指定要连接的会话ID，例如：<br> <code>screen -r &lt;session_id&gt;</code></p></li><li><p><strong>退出 <code>screen</code> 会话：</strong></p><p> 在 <code>screen</code> 会话中，你可以使用 <code>exit</code> 或者 <code>Ctrl + D</code> 来退出。</p></li></ol><p>这是 <code>screen</code> 的基本用法。</p><h3 id="3、客户端部署"><a href="#3、客户端部署" class="headerlink" title="3、客户端部署"></a>3、客户端部署</h3><blockquote><p>部署客户端</p></blockquote><p>需要下载后修改一下配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neutrino:</span><br>  <span class="hljs-attr">proxy:</span><br>    <span class="hljs-attr">tunnel:</span><br>      <span class="hljs-comment"># ssl证书密钥（使用jjar包内自带的证书，则此处无需修改）</span><br>      <span class="hljs-attr">key-store-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-comment"># ssl证书管理密钥（使用jjar包内自带的证书，则此处无需修改。自定义证书，则此处配置对应的路径）</span><br>      <span class="hljs-attr">jks-path:</span> <span class="hljs-string">classpath:/test.jks</span><br>      <span class="hljs-comment"># 代理服务端IP</span><br>      <span class="hljs-attr">server-ip:</span> <span class="hljs-string">xxxx</span><br>      <span class="hljs-comment"># 代理服务端IP, 若是非ssl端口，则ssl-enable需要配置为false</span><br>      <span class="hljs-attr">server-port:</span> <span class="hljs-number">9002</span><br>      <span class="hljs-comment"># 是否启用ssl</span><br>      <span class="hljs-attr">ssl-enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># licenseKey，客户端凭证。此处需要配置刚刚从管理后台复制的LicenseKey</span><br>      <span class="hljs-attr">license-key:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>这里有一个注意的地方就是 9002 这个端口，需要我们去看一下服务器端的配置文件对应的端口，它默认是 9002 ，需要在防火墙端口开启一下，<strong>或者改一下这个端口配置</strong></p><p>如果是 true，对应的是 SSL_PORT  下参数</p><p>server-port  →  服务端端口(对应服务端app.yml中的 tunnel.port、tunnel.ssl-port)</p><p>然后复制一下客户端凭证即可</p><p>如果出现问题，建议先删掉文件重新解压，再配置一遍，重新启动。</p><p>Linux 客户端配置同理。（注意是一个客户端对应一个凭证）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unzip</span>  neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native.zip<br><span class="hljs-attribute">cd</span> neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native<br><br><span class="hljs-attribute">screen</span><br><br><span class="hljs-attribute">nohup</span> ./neutrino-proxy-client &amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Zipkin</title>
    <link href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/"/>
    <url>/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Sleuth"><a href="#1、什么是-Sleuth" class="headerlink" title="1、什么是 Sleuth"></a>1、什么是 Sleuth</h3><p>Sleuth是Spring Cloud的组件之一，它为Spring Cloud实现了一种分布式追踪解决方案。</p><p>一般是和 zipkin 或者其他基于日志的追踪系统一起使用的。</p><p>简单理解：sleuth 是链路追踪器，将链路信息放到日志中，zipkin 是链路分析器，将链路日志进行可视化分析和聚合检索。</p><h3 id="2、Zipkin是什么"><a href="#2、Zipkin是什么" class="headerlink" title="2、Zipkin是什么"></a>2、Zipkin是什么</h3><p>Zipkin是一个分布式追踪系统。它有助于收集对服务架构中的延迟问题进行故障排除所需的计时数据。功能包括收集和查找这些数据。</p><p>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures. Features include both the collection and lookup of this data.</p><p>在微服务架构中，随着业务的不断扩张，服务之间互相调用会越来越复杂。而Zipkin能收集服务中的一些数据，我们能够通过明显的可视化效果去查看链路中的情况（支持日志聚合，进行可视化展示和全文检索）。</p><p><strong>分布式链路追踪（Distributed Tracing）</strong>： 将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p>常用的链路追踪技术还有好几种，有兴趣可以去了解一下。</p><ul><li><a href="https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/">https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/</a></li><li><a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></li><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li></ul><hr><h3 id="3、Sleuth入门"><a href="#3、Sleuth入门" class="headerlink" title="3、Sleuth入门"></a>3、Sleuth入门</h3><blockquote><p>Sleuth 术语</p></blockquote><ul><li>Trace (一条完整链路–包含很多span(微服务接口))<ul><li>由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</li></ul></li><li>Span<ul><li>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</li></ul></li><li>Annotation<ul><li>用它记录一段时间内的事件，内部使用的重要注释：<ul><li>cs（Client Send）客户端发出请求，开始一个请求的生命</li><li>sr（Server Received）服务端接受到请求开始进行处理， sr－cs &#x3D; 网络延迟（服务调用的时间）</li><li>ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr &#x3D; 服务器上的请求处理时间</li><li>cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr &#x3D; 请求的总时间</li></ul></li></ul></li></ul><blockquote><p>Sleuth 使用</p></blockquote><p>在pom.xml文件添加Sleuth依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--sleuth依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目整合 sleuth 后，在日志输出会多一些链路信息。</p><p>我们在启动这个微服务后，调用其中某个请求，可以在控制台观察到sleuth的日志输出</p><h3 id="4、链路解决方案-Sleuth-Zipkin"><a href="#4、链路解决方案-Sleuth-Zipkin" class="headerlink" title="4、链路解决方案 Sleuth + Zipkin"></a>4、链路解决方案 <strong>Sleuth</strong> + <strong>Zipkin</strong></h3><p>使用 Zipkin 需要下载一下他的服务端： <a href="https://zipkin.io/pages/quickstart.html">https://zipkin.io/pages/quickstart.html</a></p><p>官方文档里面有介绍他对应的下载和启动方式。</p><p>通过浏览器访问 <a href="http://localhost:9411/">http://localhost:9411</a>访问</p><p>Zipkin 跟 Nacos 类似，需要启动他的服务端程序，并在微服务模块中添加客户端相关的配置。</p><blockquote><p><strong>Sleuth</strong> + <strong>Zipkin</strong> 集成</p></blockquote><p>这里是选用 ZipKin客户端和Sleuth 进行集成。</p><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置zipkin</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://192.168.31.60:9411</span><br>    <span class="hljs-attr">discovery-client-enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 不要让nacos把zipkin注册进去（可以不写）</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>启动后，便可以在 Zipkin 观察该服务下的请求链路。</p><blockquote><p>持久化操作</p></blockquote><p>Zipkin 默认是将数据保存到内存，生产环境一般是选择持久化到本地。</p><p><strong>Zipkin</strong> 提供可插拔数据存储方式，下面这些都支持：In-Memory、MySql、Cassandra 以及 Elasticsearch。</p><blockquote><p>使用mysql实现数据持久化操作</p></blockquote><p>略，待更新</p><p>to be contined….</p><hr><p>参考：</p><ul><li><a href="https://zipkin.io/pages/quickstart">https://zipkin.io/pages/quickstart</a></li><li><a href="https://blog.csdn.net/qq_40587263/article/details/117338097">https://blog.csdn.net/qq_40587263/article/details/117338097</a></li><li><a href="https://zhuanlan.zhihu.com/p/71024024">https://zhuanlan.zhihu.com/p/71024024</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB_基本操作</title>
    <link href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>mongodb 的数据库中的一种，是面向文档存储的数据库；</p><p>他的概念和关系型数据有些区别。</p><p>跟 MySQL 类似，他能够执行 CRUD，事务，索引 等操作。</p><p>在技术选型的时候，对于高并发、海量数据读写、高可用、搞可扩展有需求，数据量大，写入频率，价值较低，对事务性要求不高的时候，可以考虑使用 MongoDB来实现数据的存储。</p><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301336438.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/efew212efe/article/details/124524863">https://blog.csdn.net/efew212efe/article/details/124524863</a></li><li><a href="https://www.mongodb.com/docs/manual/">https://www.mongodb.com/docs/manual/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows常用操作</title>
    <link href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>windows_查看端口被占用情况、结束进程</p></blockquote><p>查看指定端口占用情况（端口引号有没有都可以，此处以5040为例）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -aon<span class="hljs-string">|findstr 5040</span><br></code></pre></td></tr></table></figure><p>根据PID查看相应的进程或程序(也可以任务管理器查看)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist<span class="hljs-string">|findstr 5340</span><br></code></pre></td></tr></table></figure><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /f /t /im 进程名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用操作</title>
    <link href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h4><ul><li>wq：保存当前文件并退出</li><li>wqa：保存所有文件并退出</li><li>q!： 不保存，强制退出</li><li>qa!： 有多个文件被打开，同时退出</li></ul><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89042423">https://zhuanlan.zhihu.com/p/89042423</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_基础内容</title>
    <link href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Spring 概念</li><li>常用模块</li><li>IOC</li><li>AOP</li><li>Spring 事务</li><li>Spring MVC</li></ul><blockquote><p>什么是Spring</p></blockquote><p>Spring 是一个轻量级的开源Java开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>一般来说，我们常说的 Spring 框架指的是 Spring Framework, 他是多模块的一个集合，这些模块能够比较方便的帮助我们来进行开发。</p><p>Spring 有很多特性，也支持很多功能，了解Spring 框架，我们一般会从它支持的 IOC 和 AOP 这两个核心功能来最开始认识它。</p><p><strong>目前Spring 最大的一个优势是它构建了一个非常不错的Java生态，你能够在这里面找到不同需求需要的处理方案。</strong></p><p>Spring 的官网： <a href="https://spring.io/">https://spring.io/</a></p><p>Github地址： <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p>Spring 的具体模块可以放后面了解，主要模块了解下。</p><p>Spring 5.x 主要模块</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212051.png" alt="image.png"><br>各个模块的依赖关系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212107.png" alt="image.png"></p><blockquote><p>Core Container</p></blockquote><p>其中主要模块中，Core Container  是 Spring 框架的核心模块，也是基础模块，它提供了 IOC 的依赖注入功能，Spring 的<strong>其他模块实现的功能也是在依赖该模块的基础上进行实现的</strong>。</p><p>Core Container 的子模块：</p><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</li></ul><blockquote><p>AOP</p></blockquote><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。(这个模块的使用场景非常有限)</li></ul><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://www.pdai.tech/md/spring/spring.html">https://www.pdai.tech/md/spring/spring.html</a></li><li><a href="https://blog.csdn.net/Mixzi/article/details/123980213">https://blog.csdn.net/Mixzi/article/details/123980213</a></li><li><a href="https://www.moguit.cn/info/794">https://www.moguit.cn/info/794</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows旧电脑重装CentOs7系统制作为个人服务器</title>
    <link href="/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>如果需要将一台 winodws 电脑重装为 centos 系统，需要分为下面几步</p><ul><li>1、先对 windows 进行磁盘格式化操作</li><li>2、通过 iso 文件进行对某个U盘刻录操作</li><li>3、电脑通过这个U盘进行安装 centos 系统</li><li>4、基本配置与使用</li></ul><p>具体操作见如下内容：</p><h3 id="1、格式化windows-的盘符"><a href="#1、格式化windows-的盘符" class="headerlink" title="1、格式化windows 的盘符"></a>1、格式化windows 的盘符</h3><p>重新安装 centos 系统前，需要在 window 系统下先进入PE环境，将原来装有Windows系统的盘符使用分区工具格式化为FAT32格式.</p><blockquote><p>制作U盘启动盘</p></blockquote><p>使用老毛桃U盘启动工具制作U盘启动盘:  <a href="http://lmt.psydrj.com/udisk.html">http://lmt.psydrj.com/udisk.html</a></p><p>模式选择USB—HDD，格式选择“NTFS”；制作完成后，可以选择模拟启动测试，若能够进入老毛桃winpe主菜单，即表示老毛桃U盘启动盘制作成功。【这里主要是要用到他的第四个 DiskGenius 工具】</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126214740.png" alt="image.png"></p><p>重新启动电脑，进入bios</p><p>界面会让你选择一个 boot device ，你这里根据英文选择一下 U 盘启动（界面是显示的U盘名称）</p><p>然后会进入到上面图片的内容（选择  DiskGenius ）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126220736.png" alt="image.png"></p><p>选择快速分区，选择分区类型FAT32，选择 1 个分区，</p><h3 id="2、重装-centos-系统"><a href="#2、重装-centos-系统" class="headerlink" title="2、重装 centos 系统"></a>2、重装 centos 系统</h3><p>下载好 centos7 的镜像文件： </p><ul><li><a href="https://man.linuxde.net/download/CentOS_7_4">https://man.linuxde.net/download/CentOS_7_4</a></li><li><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></li></ul><h4 id="刻录操作"><a href="#刻录操作" class="headerlink" title="刻录操作"></a>刻录操作</h4><p>下载 UltraISO 软碟通 </p><p>格式化之前的U盘，格式化为 FAT32 文件系统（或者准备第二个U盘）</p><p>选择写入硬盘映像</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222516.png" alt="image.png"></p><p>写入方式默认（USB-HDD+），单击便携启动，单击写入新的驱动器引导扇区，单击Syslinux。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222715.png" alt="image.png"></p><p>完毕后，单击下方写入，等待进度条满写入完毕。</p><blockquote><p>记：中间遇到一次 提示格式化重新操作</p></blockquote><p>UltraISO的软件提示其实是准确的，但却是程序员思维下科学素养级别的提示。这里的建议格式化U盘后再试，意思是建议你删除所有分区后重试</p><p>解决处理：</p><ul><li>1、下载 DiskGenius 格式化所有分区 </li><li>2、用win+R打开cmd，输入“diskpart”    输入“list disk”查看所有磁盘   依据大小选中对应磁盘“select disk x”    输入“clean”删除所有分区</li></ul><p>第一种方式的下载地址： <a href="https://xiazai.zol.com.cn/detail/33/327603.shtml">https://xiazai.zol.com.cn/detail/33/327603.shtml</a></p><p>格式化转换盘符为FAT32格式</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126234720.png" alt="image.png|500"></p><p>实际操作的时候显示设备写入错误 55</p><p>也试了一下网上说的通过管理员运行，或者上面说的格式化操作，都不行；最后通过买了一个新的 U 盘解决。</p><blockquote><p>通过 balenaEtcher 进行刻录操作</p></blockquote><p>下载地址：</p><ul><li><a href="https://www.ssdtop.com/balenaetcher.html">https://www.ssdtop.com/balenaetcher.html</a></li><li><a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></li></ul><p>下载  balenaEtcher 进行刻录操作，还是失败</p><p>猜测大概是U盘有问题，或者换一台电脑进行操作；这里选择重新购买一个新的 U 盘进行操作</p><p>Later…</p><p>新 U盘 通过 DiskGenius 格式化U盘分区，再通过 UltraISO 成功进行了刻录操作。</p><hr><h4 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h4><p>将 U 盘 插入需要重装的电脑并开机。如果已经设置完毕以USB为第一启动项，则不用再次进入bios界面。</p><p>没有的话再进入一次，通过 USB 启动。</p><blockquote><p>安装操作</p></blockquote><ul><li>1、选择Install CentOS 7</li><li>2、按回车键</li><li>3、成功进入CentOS系统图形化的安装界面后，进行初始化</li></ul><p>初始化配置</p><ul><li>①中文（语言）</li><li>②软件选择：GNOME桌面</li><li>③安装位置：选择磁盘，手动分区（选择“我要配置分区”）<ul><li>&#x2F;boot     也可以不添加     1G</li><li>&#x2F;swap   交互分区             2G</li><li>&#x2F;            根目录，分配剩下所有空间</li></ul></li></ul><blockquote><p>初始化配置</p></blockquote><p>②软件选择</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234606.png" alt="image.png"></p><p>③添加新挂载点 &#x2F;boot</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234855.png" alt="image.png"></p><p><strong>设置好后点击完成，选择接受更改</strong></p><blockquote><p>网络与主机名</p></blockquote><p>网络与主机名：<strong>打开网络，自己设置一个主机名，然后点击完成</strong></p><blockquote><p>用户设置</p></blockquote><p>开始安装</p><ul><li><strong>点击设置root密码</strong></li><li>等待过程中可以 <strong>创建一个普通用户</strong></li></ul><blockquote><p>重启电脑后配置内容</p></blockquote><p>重启电脑</p><p><strong>重启后进入初始设置界面，接受许可，然后点击完成配置</strong>  → 完成配置</p><p><strong>等待，然后来到登录页面，我们选择未列出，然后输入root和root的密码，然后点击登录。</strong></p><p><strong>来到桌面，我们选择语言为中文</strong></p><p><strong>关闭位置服务</strong></p><p>跳过在线账号</p><hr><h3 id="3、使用-windows-访问同一个局域网下的-linux-系统"><a href="#3、使用-windows-访问同一个局域网下的-linux-系统" class="headerlink" title="3、使用 windows 访问同一个局域网下的 linux 系统"></a>3、使用 windows 访问同一个局域网下的 linux 系统</h3><p>设置完成后，连接同一个wife</p><p>在 windows 中使用 xshell&#x2F;termius 工具访问即可</p><h3 id="4、内网穿透的使用"><a href="#4、内网穿透的使用" class="headerlink" title="4、内网穿透的使用"></a>4、内网穿透的使用</h3><p>略</p><p>暂未有这个需求，后续考虑使用。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/m0_59302403/article/details/132119884">https://blog.csdn.net/m0_59302403/article/details/132119884</a></li><li><a href="https://blog.csdn.net/weixin_42292697/article/details/110285529">https://blog.csdn.net/weixin_42292697/article/details/110285529</a></li><li><a href="https://www.bilibili.com/video/BV1c3411T7Td">https://www.bilibili.com/video/BV1c3411T7Td</a></li><li><a href="https://blog.csdn.net/m0_51545690/article/details/123238360">https://blog.csdn.net/m0_51545690/article/details/123238360</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人在线网盘_ZFile</title>
    <link href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/"/>
    <url>/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/</url>
    
    <content type="html"><![CDATA[<p>看到有一个还不错的项目，有时候需要将文件放置在云端，这里学习使用一下这个工具。（支持预览操作）</p><p>项目地址： <a href="https://github.com/zfile-dev/zfile">https://github.com/zfile-dev/zfile</a></p><p>部署文档地址： <a href="https://docs.zfile.vip/">https://docs.zfile.vip/</a></p><h3 id="1、项目运行"><a href="#1、项目运行" class="headerlink" title="1、项目运行"></a>1、项目运行</h3><p>下载项目后，需要系统里面有 JDK8 的环境</p><blockquote><p>Centos 系统运行</p></blockquote><blockquote><p>安装 JDK8</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk unzip<br></code></pre></td></tr></table></figure><blockquote><p>下载并解压</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ZFILE_INSTALL_PATH=~/zfile                        <span class="hljs-comment"># 声明安装到的路径</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ZFILE_INSTALL_PATH</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>   <span class="hljs-comment"># 创建文件夹并进入</span><br>wget --no-check-certificate https://c.jun6.net/ZFILE/zfile-release.war          <span class="hljs-comment"># 下载 zfile 最新版</span><br>unzip zfile-release.war &amp;&amp; <span class="hljs-built_in">rm</span> -rf zfile-release.war      <span class="hljs-comment"># 解压并删除压缩包</span><br><span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>/bin/*.sh                    <span class="hljs-comment"># 授权启动停止脚本</span><br></code></pre></td></tr></table></figure><p>ZFile 提供了一个 在线下载路径，也可以本地下载后自定义设备某些内容后，打包为 war ，放置在 linux 系统上运行。</p><p>如需修改配置文件，配置文件路径为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>WEB-INF<span class="hljs-regexp">/classes/</span>application.properties<br></code></pre></td></tr></table></figure><hr><p>安装说明</p><p>下面命令中第一行表示默认安装到用户目录下: <code>~/zfile</code> 下。</p><p>对于 <code>root</code> 用户, <code>~</code> &#x3D; <code>/root</code>, <code>~/zfile</code> 表示在 <code>/root/zfile</code> 路径下。</p><p>对于其他用户, <code>~</code> &#x3D; <code>/home/用户名</code> 表示在 <code>/home/用户名/</code> 路径下。如对于 <code>oracle</code> 用户, <code>~/zfile</code> 则表示安装在 <code>/home/oracle/zfile</code> 下。</p><p>如需更改安装路径, 请自行修改，如 <code>export ZFILE_INSTALL_PATH=/data/zfile</code>，表示安装在 <code>/data/zfile</code> 路径下。</p><hr><h3 id="2、启动项目"><a href="#2、启动项目" class="headerlink" title="2、启动项目"></a>2、启动项目</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br></code></pre></td></tr></table></figure><hr><p>启动后浏览器访问 <strong><code>http://ip:8080</code></strong> 即可，如启动后无法访问，请检查 <strong><code>端口是否冲突</code></strong> 或 <code>防火墙/安全组是否开启</code>。</p><p>简单检查方式为在服务器执行 <code>curl http://127.0.0.1:8080</code></p><ul><li>如返回 <code>curl: (7) Failed connect to 127.0.0.1:8080; Connection refused</code> 表示未启动成功。</li><li>如返回 <code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt;……</code> 等字样表示启动成功，如启动成功但通过服务器 IP 无法访问，那一般就是防火墙&#x2F;安全组未放行端口问题。</li></ul><hr><p>更新程序前务必停止程序再进行操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br>~<span class="hljs-regexp">/zfile/</span>bin/stop.sh        <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch_基础内容</title>
    <link href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><code>Elasticsearch</code>是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本  身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p><p>ES也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得  简单。</p><blockquote><p>Elasticsearch比传统关系型数据库如下：</p></blockquote><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Relational</span> <span class="hljs-variable constant_">DB</span> ‐&gt; <span class="hljs-title class_">Databases</span> ‐&gt; <span class="hljs-title class_">Tables</span> ‐&gt; <span class="hljs-title class_">Rows</span> ‐&gt; <span class="hljs-title class_">Columns</span>  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Elasticsearch</span> ‐&gt; <span class="hljs-title class_">Indices</span> ‐&gt; <span class="hljs-title class_">Types</span> ‐&gt; <span class="hljs-title class_">Documents</span> ‐&gt; <span class="hljs-title class_">Fields</span></span><br></code></pre></td></tr></table></figure><p>to be contined…..</p><p>参考</p><ul><li><a href="https://elasticsearch.bookhub.tech/getting_started/">https://elasticsearch.bookhub.tech/getting_started/</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li><a href="https://www.cnblogs.com/coderxz/p/13268417.html">https://www.cnblogs.com/coderxz/p/13268417.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/516698885">https://zhuanlan.zhihu.com/p/516698885</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习_基础内容</title>
    <link href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Vue 基础</li><li>Vue 语法</li><li>组件化开发</li><li>路由</li><li>webpack</li><li>脚手架</li></ul><hr><p>参考</p><ul><li><a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li><li><a href="https://blog.csdn.net/fmk1023/article/details/111381876">https://blog.csdn.net/fmk1023/article/details/111381876</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven工具_基础使用</title>
    <link href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Maven-下载与安装"><a href="#1、Maven-下载与安装" class="headerlink" title="1、Maven 下载与安装"></a>1、Maven 下载与安装</h3><p>略</p><h3 id="2、Maven配置文件修改"><a href="#2、Maven配置文件修改" class="headerlink" title="2、Maven配置文件修改"></a>2、Maven配置文件修改</h3><blockquote><p>maven 配置文件内容</p></blockquote><p>设置本地仓库路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置本地仓库路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\maven\localRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置阿里云私服（或换成自己公司搭建的私服）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在mirrors标签里添加mirror标签，并指定阿里云私服下载依赖会快点 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置 maven 默认jdk版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在已有的profiles标签中添加profile标签，限定maven项目默认的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- 让增加的 profile生效 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置华为云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.huaweicloud.com/repository/maven/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>阿里云:   <a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个论点，配置的时候注意一下：<strong>一个仓库只能对应一个镜像，当有多个镜像的mirrorOf指定了同一个仓库，maven只会从第一个匹配的仓库中进行查找</strong></p><h3 id="3、IDEA-配置-maven"><a href="#3、IDEA-配置-maven" class="headerlink" title="3、IDEA 配置 maven"></a>3、IDEA 配置 maven</h3><blockquote><p>IDEA 配置 maven</p></blockquote><p>快捷查找框中输入maven，查找与maven相关的设置，然后点击maven</p><p>修改maven的路径（使用本地的Maven），以及修改settings文件的位置和本地仓库的位置</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242131645.png" alt="image.png"></p><p>IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，进行勾选</p><p>他的意思是： mvn(directory):  位于项目的顶级目录中，文件 maven.config、jvm.config和extensions.xml 包含运行Maven的项目特定配置。这个目录应该是项目的一部分，需要被版本管理工具管理</p><blockquote><p>推荐配置：设置maven在不联网的情况下使用本地插件</p></blockquote><p>一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。（根据骨架创建项目速度会加快）</p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242133069.png" alt="image.png"></p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><h3 id="4、IDEA导入项目后maven-常见报错"><a href="#4、IDEA导入项目后maven-常见报错" class="headerlink" title="4、IDEA导入项目后maven 常见报错"></a>4、IDEA导入项目后maven 常见报错</h3><p>方法一：改一下 maven 配置文件，修改 mirror 仓库位置，重新导入项目，重新加载 maven 依赖</p><p>方法二：IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，不进行勾选试一下</p><p>方法三：去一下仓库地址，查看是否是否有该版本依赖，如果没有，改一下版本，或者手动下载，手动导入到本地仓库中</p><blockquote><p>报错1：解决Maven ‘parent.relativePath‘ of POM</p></blockquote><p>错误分析  </p><p>子模块的parent写的不是父模块，而是继承了springboot</p><p>解决方法  </p><p>在该<code>&lt;parent&gt;</code>标签中加上<code>&lt;relativePath /&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>   /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>报错2：对于类似于xxx-maven-plugin的插件报红</p></blockquote><p>类似于这样的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>报红就直接用不了了</p><p>我们可以通过添加依赖的方式解决（原来的插件就是上面的代码<strong>不要删</strong>）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yang_yzl11/article/details/120764764">https://blog.csdn.net/yang_yzl11/article/details/120764764</a></li><li><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">https://blog.csdn.net/qq_42057154/article/details/106114515</a></li><li><a href="https://www.cnblogs.com/SherlockLynn/p/15079467.html">https://www.cnblogs.com/SherlockLynn/p/15079467.html</a></li><li><a href="https://blog.csdn.net/qq_38217990/article/details/129257106">https://blog.csdn.net/qq_38217990/article/details/129257106</a></li><li><a href="https://zhuanlan.zhihu.com/p/653017610">https://zhuanlan.zhihu.com/p/653017610</a></li><li><a href="https://blog.csdn.net/qq_39505065/article/details/111559890">https://blog.csdn.net/qq_39505065/article/details/111559890</a></li><li><a href="https://blog.csdn.net/m0_46682011/article/details/120626933">https://blog.csdn.net/m0_46682011/article/details/120626933</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Nacos</title>
    <link href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/"/>
    <url>/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Nacos-是什么"><a href="#1、Nacos-是什么" class="headerlink" title="1、Nacos 是什么"></a>1、Nacos 是什么</h3><p>Nacos 是一个构建云原生应用的动态服务发现、配置管理和服务管理平台；致力于帮助发现、配置和管理微服务。</p><h3 id="2、下载与运行"><a href="#2、下载与运行" class="headerlink" title="2、下载与运行"></a>2、下载与运行</h3><p>下载地址： <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>windows版本使用<code>nacos-server-x.x.x.zip</code>包即可</p><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154048.png" alt="image.png"><br>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154144.png" alt="image.png"></p><blockquote><p>启动命令(Windows)</p></blockquote><p>启动非常简单，进入bin目录</p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><blockquote><p>访问</p></blockquote><p>在浏览器输入地址： <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> </p><p>默认的账号和密码都是nacos</p><blockquote><p>Namespace+Group+DataID三者的关系</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250024118.png" alt="image.png|400"></p><blockquote><p>多环境配置</p></blockquote><p>略</p><h3 id="3、Nacos-的基本使用"><a href="#3、Nacos-的基本使用" class="headerlink" title="3、Nacos 的基本使用"></a>3、Nacos 的基本使用</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>在 spring-cloud-alibaba-service 的主启动类上，使用 @EnableDiscoveryClient 注解开启 Nacos 服务发现功能</p><p>你访问该服务下的某个请求链接，再查看 nacos “服务管理”下的“服务列表”，会发现已经注册上了。</p><p>一般在消费端会引入 spring-cloud-loadbalancer 进行调用服务提供者提供的服务</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p><strong>动态获取配置内容</strong></p></blockquote><p>在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config ，可实现配置的获取与动态刷新</p><p>示例 </p><p>bootstrap.yml 文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span> <span class="hljs-comment">#端口号</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span> <span class="hljs-comment">#服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活 dev 的配置</span><br></code></pre></td></tr></table></figure><p>在 icu.luoqi.nacos.controller 包下，创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;<br><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;config.info&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String ConfigInfo;<br>    <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/config/info&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getConfigInfo()&#123;<br>        <span class="hljs-keyword">return</span> ConfigInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p><p>启动 Nacos Server，并在 Nacos Server 控制台的“配置管理”下的“配置列表”中，点击“+”按钮，新建如下配置</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Data ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">       config-client-dev.yaml</span><br><br><span class="hljs-attribute">Group</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         DEFAULT_GROUP</span><br><br><span class="hljs-attribute">配置格式</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      YAML</span><br><br><span class="hljs-attribute">配置内容</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      config:</span><br>                   <span class="hljs-attribute">info</span><span class="hljs-punctuation">:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>&#123;prefix&#125;-<span class="hljs-symbol">$</span>&#123;spring.profiles.active&#125;.<span class="hljs-symbol">$</span>&#123;<span class="hljs-keyword">file</span>-extension&#125;<br></code></pre></td></tr></table></figure><p>启动该服务，并使用浏览器访问“<a href="http://localhost:3377/config/info%E2%80%9D%EF%BC%8C">http://localhost:3377/config/info”，</a></p><p>在这种情况下，能够实现不重启后台服务，当你手动修改 nacos 的配置时，能够动态获取到配置内容。</p><blockquote><p>Nacos Config配置集的三种方式和加载顺序</p></blockquote><ul><li>通过 spring.cloud.nacos.config.shared-configs 配置项，支持多个共享 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.extension-configs 配置项，支持多个拓展 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.name 配置项，支持一个 Nacos 配置集。</li></ul><p>当三种方式共同使用时，它们的优先级关系是：A &lt; B &lt; C。另外，A 和 B 的命名带有“共享”或是“拓展”，没有任何含义，只是优先级不同</p><h3 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h3><p>命名空间id用于唯一标识命名空间， 新建命名空间时候，如果不填写命名空间id，则系统会自动生成命名空间id，生成规则为UUID方式。</p><p>但在spring 项目中集成nacos 的时候，配置文件中填写的namespace就是命名空间的id</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260000905.png" alt="image.png"></p><p>因此尽量保持nacos的命名空间名称和id 一致</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260002165.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106835279">https://blog.csdn.net/qq_36903261/article/details/106835279</a></li><li><a href="https://m.biancheng.net/springcloud/nacos.html">https://m.biancheng.net/springcloud/nacos.html</a></li><li><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></li><li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></li><li><a href="https://blog.csdn.net/weixin_45397785/article/details/128076533">https://blog.csdn.net/weixin_45397785/article/details/128076533</a></li><li><a href="https://blog.csdn.net/ysj1241267542/article/details/112562611">https://blog.csdn.net/ysj1241267542/article/details/112562611</a></li><li><a href="https://blog.csdn.net/u010520146/article/details/118703413">https://blog.csdn.net/u010520146/article/details/118703413</a></li><li><a href="https://blog.csdn.net/wangwei021933/article/details/129590430">https://blog.csdn.net/wangwei021933/article/details/129590430</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_实现在百度中搜索到自己的博客</title>
    <link href="/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1、注册一个百度站长账号</p></blockquote><p>地址： <a href="https://ziyuan.baidu.com/?castk=LTE=">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><p>验证网站所有权： <a href="https://ziyuan.baidu.com/site/index">https://ziyuan.baidu.com/site/index</a></p><p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Vercel</code>的地址，然后点击下一步。</p><p>站点领域： 信息技术</p><p>验证：选择第二种验证方式  →  HTML 验证</p><p><strong>本博客使用的是 fluid 主题</strong>，</p><p>进入博客目录下 <code>scripts</code> 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容（content 见百度具体验证内容)：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab">hexo.extend.filter.register(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(injects)</span> &#123;</span><br>  injects.head.raw(<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;&lt;meta name=&quot;</span>baidu-site-verification<span class="hljs-string">&quot; content=&quot;</span>xxxxxxxxxxxxxxx<span class="hljs-string">&quot; /&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在博客 <code>_config.yml</code> 文件加一句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_site_verification:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了。</p><p>点击验证按钮，如果没问题则已成功。</p><blockquote><p>2、站点地图功能</p></blockquote><p>需要生成一个站点地图</p><p>先确认一下 <code>_config.yml</code> 配置里面的 URL 值，如果不是改为自己的域名地址。</p><p>博客目录执行命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save        <span class="hljs-comment">#安装sitemap插件</span><br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save  <span class="hljs-comment">#安装baidu-sitemap插件</span><br><br>  <br>hexo g  <span class="hljs-comment">#生成网站静态文件到public文件夹</span><br></code></pre></td></tr></table></figure><blockquote><p>查看根目录下的public目录，会生成两个文件，“sitemap.xml ”和 “baidusitemap.xml”</p></blockquote><p>其中“sitemap.xml”文件是搜索引擎通用的文件，</p><p>“baidusitemap.xml”是百度专用的sitemap文件，</p><blockquote><p>3、提交sitemap到百度资源搜索平台</p></blockquote><p>选择资源提交，点击普通收录，选择sitemap， <a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a></p><p>填写网站地址，例：“域名&#x2F;baidusitemap.xml”，点击提交，过一段时间后博客就可以在百度中搜素到。</p><p>个人使用的时候这一步显示提交上限是 0 ；只能使用他手动提交的方式，而且只能是访问链接。</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/Passerby_Wang/article/details/124704475">https://blog.csdn.net/Passerby_Wang/article/details/124704475</a></li><li><a href="https://py-wang.blog.csdn.net/article/details/121202486">https://py-wang.blog.csdn.net/article/details/121202486</a></li><li><a href="https://cloud.tencent.com/developer/article/2317858">https://cloud.tencent.com/developer/article/2317858</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81</a></li><li><a href="https://zhuanlan.zhihu.com/p/150999914">https://zhuanlan.zhihu.com/p/150999914</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vercel的开箱使用_同步Hexo静态博客</title>
    <link href="/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>官网： <a href="https://vercel.com/">https://vercel.com/</a></p><p>部署无脑式导入 Github 原项目，然后进行 deploy 就行。命令可以自定义设置，一般是 hexo -s 之类的。(Vercels是支持你推送代码到Github的时候你在Vercel的项目也是会进行自动更新的)</p><p>点击部署的时候项目配置添加自定义域名操作：</p><p>Setting →  Domains →  选择添加解析域名</p><p>官网文档参考的解析域名地址</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240050203.png" alt="image.png"></p><p>实际操作记录：</p><p>个人使用的是阿里云的域名解析，在对应域名下添加了这一条记录<br>（对应 的记录值是 <code>cname.vercel-dns.com</code> ，记录类型需要是 CNAME）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240052961.png" alt="image.png"></p><p>domain 选择编辑对应的域名地址: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">varcel. + 你的阿里云域名<br></code></pre></td></tr></table></figure><p>最后部署访问成功。</p><hr><p>参考</p><ul><li><a href="https://juejin.cn/post/7143067114025254919">https://juejin.cn/post/7143067114025254919</a></li><li><a href="https://zhuanlan.zhihu.com/p/646818470">https://zhuanlan.zhihu.com/p/646818470</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day01</title>
    <link href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/"/>
    <url>/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/</url>
    
    <content type="html"><![CDATA[<h3 id="1、项目下载"><a href="#1、项目下载" class="headerlink" title="1、项目下载"></a>1、项目下载</h3><p>项目下载地址： <a href="https://gitee.com/moxi159753/mogu_blog_v2">https://gitee.com/moxi159753/mogu_blog_v2</a></p><h3 id="2、项目后端启动"><a href="#2、项目后端启动" class="headerlink" title="2、项目后端启动"></a>2、项目后端启动</h3><p>后端项目启动：</p><p>相关环境需要先启动和运行</p><p><code>nacos</code>，<code>nginx</code>，<code>rabbitmq</code>， <code>redis</code>，<code>mysql</code>，</p><p>模块启动：</p><p><code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p><blockquote><p>配置 Nacos</p></blockquote><p>模块启动前先配置一下 nacos </p><p>mogu 的启动方式是将数据放在了 mysql 数据库中，因此我们需要先执行它项目中的 nacos_config.sql 脚本</p><p>创建一个数据库 nacos_config，将配置导入到mysql中</p><p>解压nacos 到另外一个文件夹，然后进入 conf目录，打开 application.properties文件</p><p>在文件的末尾添加mysql的配置信息，注意mysql的账号和密码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mysql配置</span><br><span class="hljs-attr">spring.datasource.platform</span>=mysql<br><span class="hljs-attr">db.num</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">db.url.0</span>=jdbc:mysql://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span>/nacos_config?characterEncoding=utf8&amp;connectTimeout=<span class="hljs-number">1000</span>&amp;socketTimeout=<span class="hljs-number">3000</span>&amp;autoReconnect=<span class="hljs-literal">true</span>&amp;serverTimezone=UTC<br><span class="hljs-attr">db.user</span>=root<br><span class="hljs-attr">db.password</span>=root<br></code></pre></td></tr></table></figure><p>到nacos下的 bin 目录，启动服务</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><p>访问： <a href="http://127.0.0.1:8848/nacos/#/login">http://127.0.0.1:8848/nacos/#/login</a></p><p>启动模块前先将 dev 命名空间下的 配置文件对应的 redis, zipkin,mysql,rabbitmq的配置文件改一下</p><p>启动一下 相应服务</p><blockquote><p>执行一下数据库SQL 脚本</p></blockquote><blockquote><p>修改一下 Nacos 配置文件</p></blockquote><blockquote><p>依次启动服务：<code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p></blockquote><p>如果显示 zipkin 连接失败，尝试修改一下配置，添加一下 serviceName</p><p>Spring Cloud Sleuth配置中设置服务名称的示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  sleuth:</span><br><span class="hljs-symbol">    sampler:</span><br><span class="hljs-symbol">      probability:</span> <span class="hljs-number">1.0</span><br><span class="hljs-symbol">    zipkin:</span><br><span class="hljs-symbol">      baseUrl:</span> http:<span class="hljs-comment">//192.168.31.79:9411</span><br><span class="hljs-symbol">      serviceName:</span> your-service-name<br></code></pre></td></tr></table></figure><p>后端启动成功后，能够查看到对应的Swagger接口文档</p><blockquote><p>nacos版本：swagger-ui使用的是3.X，访问的页面是 <a href="http://localhost:8601/swagger-ui/index.html">http://localhost:8601/swagger-ui/index.html</a><br>sms 服务里面有短信和邮箱的配置，也注意改一下</p></blockquote><hr><h3 id="3、前端项目启动"><a href="#3、前端项目启动" class="headerlink" title="3、前端项目启动"></a>3、前端项目启动</h3><blockquote><p>vue_mogu_admin</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 指定node-sass的国内镜像源</span><br>npm i node-sass <span class="hljs-attribute">--sass_binary_site</span>=https://npm.taobao.org/mirrors/node-sass<br><br><span class="hljs-comment"># 使用淘宝镜像源进行依赖安装，解决国内下载缓慢的问题(出现警告可以忽略)</span><br>npm install <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 启动项目</span><br>npm <span class="hljs-built_in">run</span> dev<br><br><span class="hljs-comment">#打包项目（在部署的时候才需要使用）</span><br>npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><p>启动项目成功后，会跳转到：localhost:9528 ，</p><p>默认账号密码： admin, mogu2018 </p><p>实际在运行项目的时候，第一步有些问题，做了以下操作：</p><ul><li><ol><li>更新了一下依赖版本：”html-webpack-plugin”: “3.2.0”,</li></ol></li><li><ol start="2"><li>将windows 下的 3.x 的python 版本降级安装为 2.x 版本，且不超过 2.7</li></ol></li><li><ol start="3"><li>安装了 Visual C++ Build Tools for Visual Studio 2015</li></ol></li></ul><p>关于第三步，下载地址：<a href="https://my.visualstudio.com/Downloads?q=C++%20build">Downloads &amp; Keys - Visual Studio Subscriptions</a></p><p>在类型处选择DVD，然后下载下来，解压缩后运行其中的exe文件</p><blockquote><p>vue_mogu_web</p></blockquote><p>与上面一致，访问界面：localhost:9527</p><p>实际操作，有一些更改</p><ul><li><ol><li>由于依赖中 “node-sass”: “^4.14.1”, 需要和 node 版本对应，这里切换 Node 14 版本（使用NVM)</li></ol></li><li><ol start="2"><li>再次执行上面相同的运行命令</li></ol></li><li><ol start="3"><li>遇到运行命令可以尝试先删除node_module 文件夹再执行，或者执行 <code>npm cache clean --force</code> 再试一下。</li></ol></li></ul><p>至此，项目是能够完整运行并在浏览器上面访问。</p><hr><p>参考</p><ul><li><a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></li><li><a href="https://moxi159753.gitee.io/mogu_blog_doc/#/README">https://moxi159753.gitee.io/mogu_blog_doc/#/README</a></li><li><a href="https://blog.csdn.net/colleges/article/details/123769410">https://blog.csdn.net/colleges/article/details/123769410</a></li><li><a href="https://www.jb51.net/article/281818.htm">https://www.jb51.net/article/281818.htm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Eureka</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Eureka-是什么"><a href="#1、Eureka-是什么" class="headerlink" title="1、Eureka 是什么"></a>1、Eureka 是什么</h3><p>Eureka 是一个Netflix 开源的服务发现组件，包括 Server 和 Client 两部分。在 Spring Cloud 子项目 Spring Cloud Netflix 中。</p><blockquote><p>服务注册与发现</p></blockquote><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。</p><p>而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。</p><p>这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。</p><p>RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何 rpc 远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址）)</p><p>Eureka 系统架构（右图是Dubbo的架构）<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222335266.png" alt="image.png"></p><blockquote><p>Eureka Server 与 Eureka Client</p></blockquote><p>Eureka Server 提供服务注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>Eureka Client通过注册中心进行访问， Eureka Client 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h3 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h3><blockquote><p>服务端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--热部署工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向注册中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#为false表示自己是注册中心</span><br>    <span class="hljs-attr">service-url:</span>    <span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableEurekaServer</span> <span class="hljs-comment">//启动服务发现，接受注册</span><br><span class="hljs-variable">@SpringBootApplication</span><br>public class EurekaServer_7001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目，访问 <a href="http://localhost:7001/">http://localhost:7001/</a></p><blockquote><p>客户端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept-8001</span>   <span class="hljs-comment"># 修改eureka上的默认描述信息</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># true,可以显示服务的IP地址</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br>public class DeptProvider_8001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(DeptProvider_8001.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106551120">https://blog.csdn.net/qq_36903261/article/details/106551120</a></li><li><a href="https://blog.csdn.net/qq_45078781/article/details/118671285">https://blog.csdn.net/qq_45078781/article/details/118671285</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/142941185">https://zhuanlan.zhihu.com/p/142941185</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过RestTemplate进行远程调用</title>
    <link href="/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <url>/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>RestTemplate 是从 Spring3.0 开始支持的一个 HTTP 请求工具，它提供了常见的REST请求方案的模版。对于远程请求进行了一定封装，从而通过建议配置可以实现远程调用。</p><p>他底层用的是 JDK 的 HTTP 请求</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置类</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.demo.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.http.client.ClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RestTemplate配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(factory);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;<br>        SimpleClientHttpRequestFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleClientHttpRequestFactory</span>();<br>        factory.setReadTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        factory.setConnectTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>示例调用操作</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">//因为浏览器只支持get请求，为了方便这里就用get</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/create&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; create(Payment payment)&#123;<br>        log.info(<span class="hljs-string">&quot;********插入的数据：&quot;</span> + payment);<br>        <span class="hljs-comment">//postForObject分别有三个参数：请求地址，请求参数，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/get/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; getPayment(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id)&#123;<br>        log.info(<span class="hljs-string">&quot;********查询的id：&quot;</span> + id);<br>        <span class="hljs-comment">//getForObject两个参数：请求地址，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined… </p><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44073321/article/details/102804615">https://blog.csdn.net/weixin_44073321/article/details/102804615</a></li><li><a href="https://blog.csdn.net/weixin_43702146/article/details/116567707">https://blog.csdn.net/weixin_43702146/article/details/116567707</a></li><li><a href="https://blog.csdn.net/dqxiaoxiao/article/details/114375873">https://blog.csdn.net/dqxiaoxiao/article/details/114375873</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CodeProgram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见工程报错问题</title>
    <link href="/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_基础概念</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SpringCloud是什么"><a href="#1、SpringCloud是什么" class="headerlink" title="1、SpringCloud是什么"></a>1、SpringCloud是什么</h3><p>SpringCloud 提供了一整套的分布式系统解决方案，通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。</p><p>SpringCloud 包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等。</p><p>Spring Cloud 包含很多子项目，国内主要是采用 Netflix 和 Alibaba 两个标准实现，前者由于不再维护，目前一般采用Spring Cloud Alibaba 这一套微服务解决方案。</p><blockquote><p>了解组件</p></blockquote><p>Spring Cloud Netflix 第一代</p><p>针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。</p><ul><li><code>Netflix Eureka</code>：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。</li><li><code>Netflix Ribbon</code>：客户端负载均衡的服务调用组件。</li><li><code>Netflix Hystrix</code>：容错管理工具，实现断路器模式，通过控制服务的节点，从而对延迟和故障提供更强大的容错能力。</li><li><code>Netflix Feign</code>：基于 Ribbon 和 Hystrix 的声明式服务调用组件。</li><li><code>Netflix Zuul</code>：微服务网关，提供动态路由，访问过滤等服务。</li><li><code>Netflix Archaius</code>：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li></ul><p>Spring Cloud Alibaba 第二代</p><p><strong>阿里开源组件</strong></p><ul><li><code>Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><p><strong>阿里商业化组件</strong></p><ul><li><code>Alibaba Cloud ACM</code>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><code>Alibaba Cloud OSS</code>：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><code>Alibaba Cloud SchedulerX</code>：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><code>Alibaba Cloud SMS</code>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><blockquote><p>关于Cloud各种组件的停更升级替换</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221942122.png" alt="image.png"></p><blockquote><p>SpringCloud 版本介绍</p></blockquote><p>略</p><h3 id="2、创建cloud聚合父工程"><a href="#2、创建cloud聚合父工程" class="headerlink" title="2、创建cloud聚合父工程"></a>2、创建cloud聚合父工程</h3><h4 id="初始化工程及配置"><a href="#初始化工程及配置" class="headerlink" title="初始化工程及配置"></a>初始化工程及配置</h4><ol><li>New Project</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221957842.png" alt="image.png"></p><ol start="2"><li>聚合总父工程名字</li><li>Maven选版本</li><li>开启自动导入</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221958787.png" alt="image.png"></p><ol start="5"><li>字符编码</li></ol><p>Settings → Editor →  File Encodings</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222220247.png" alt="image.png"></p><ol start="6"><li>注解生效激活</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222222672.png" alt="image.png"></p><ol start="7"><li>java编译版本选8</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222223525.png" alt="image.png"></p><ol start="8"><li>File Type过滤</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222225655.png" alt="image.png"></p><p>这里File Type 配置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*.idea</span><br><span class="hljs-comment">*.iml</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222226068.png" alt="image.png"></p><h4 id="父工程-pom-配置"><a href="#父工程-pom-配置" class="headerlink" title="父工程 pom 配置"></a>父工程 pom 配置</h4><p>父工程 Pom 文件参考配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.luoqi.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2023<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--统一管理jar包版本--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud alibaba--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mysql--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- druid--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;druid.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mybatis.spring.boot.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--junit--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;junit.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--log4j--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log4j.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><ul><li><ol><li>新建模块</li></ol></li><li><ol start="2"><li>pom文件对应依赖</li></ol></li><li><ol start="3"><li>yml 配置文件</li></ol></li><li><ol start="4"><li>启动类以及其他业务类</li></ol></li></ul><hr><p>参考</p><ul><li><a href="https://gitee.com/lixiaogou/cloud2020">https://gitee.com/lixiaogou/cloud2020</a></li><li><a href="https://blog.csdn.net/qq_36903261/article/details/106507150">https://blog.csdn.net/qq_36903261/article/details/106507150</a></li><li><a href="https://github.com/angenin/cloud2020">https://github.com/angenin/cloud2020</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/110249846">https://zhuanlan.zhihu.com/p/110249846</a></li></ul><p>引用</p><ul><li><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></li><li><a href="https://www.springcloud.cc/">https://www.springcloud.cc/</a></li><li><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapters1_极限与连续</title>
    <link href="/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/"/>
    <url>/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、映射与函数"><a href="#1、映射与函数" class="headerlink" title="1、映射与函数"></a>1、映射与函数</h3><p>学习极限前，先了解一些基础概念，对于函数整个内容有一个认识。</p><h4 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210437941.png" alt="image.png"></p><p>定义：定义域内<strong>任何</strong>元素，都在值域中有<strong>唯一</strong>的元素与之对应。</p><p>函数概念有两个基本要素：定义域、对应法则。</p><p>理解：函数是研究关系的，是在研究两个变量之间的关系。具体来说，函数是研究因变量是怎么随着自变量的变化而变化的。</p><blockquote><p>举例</p></blockquote><p>举个例子，在速度为40km&#x2F;h的匀速运动过程中，路程随时间的变化而变化：</p><ul><li>时间是1时，路程是40；</li><li>时间是2时，路程就是80。</li></ul><p>路程&#x3D;40 * 时间。路程就叫做时间的函数。</p><p>但不是有关系就是函数，不是因变量随自变量变化就是函数。还得满足一个重要的条件：对于自变量的每一个取值，因变量都有唯一的值与它对应！</p><p>例如，上述匀速运动过程中，时间每取一个值，对应计算出路程也是一个值。</p><p>反例：|y|&#x3D;x，在这个式子里，y也随x的变化而变化，但x&#x3D;1时，y&#x3D;1或—1，有两个值了。那y就不是x的函数了。</p><p>所以，函数是两个变量之间的特殊关系</p><h4 id="几个常见函数"><a href="#几个常见函数" class="headerlink" title="几个常见函数"></a>几个常见函数</h4><ul><li>绝对值函数</li><li>符号函数</li><li>取整函数</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210449362.png" alt="image.png"></p><h4 id="函数的特性"><a href="#函数的特性" class="headerlink" title="函数的特性"></a>函数的特性</h4><ul><li>有界性</li><li>单调性</li><li>奇偶性</li><li>周期性</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210452693.png" alt="image.png"></p><h4 id="反函数与复合函数"><a href="#反函数与复合函数" class="headerlink" title="反函数与复合函数"></a>反函数与复合函数</h4><blockquote><p>反函数</p></blockquote><p>定义：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210455686.png" alt="image.png"></p><blockquote><p>复合函数</p></blockquote><p>复合条件：内层函数值域与外层函数定义域的交集非空</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210456045.png" alt="image.png"></p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>函数的运算（加减乘除）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210457870.png" alt="image.png"></p><p>其中函数相除的时候 g(x) 不等于 0 </p><p>相关定理：任何一个函数(定义域对称)都可以找到一个奇函数和一个偶函数，使得这个函数等于偶函数加奇函数</p><blockquote><p>例题（证明题）</p></blockquote><p>以函数的运算证明:任给f(x)的定义域为(-L,L),证明必存在(-L,L)上的偶函数g(x)以及奇函数h(x),使得f(x)&#x3D;g(x)+h(x)</p><p>解析：</p><p>根据前面函数特征中的奇偶性，可以得知 奇函数 h( -x ) &#x3D; -h(x) ; 偶函数 g(-x) &#x3D; g(x)</p><p>先假设存在这样的奇偶函数，</p><p>to be improve….</p><p>解答：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210502430.png" alt="image.png"></p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><p>定义：由常数和基本初等函数经过有限次的加、减、乘、 除和复合所得到且能用一个解析式表示的函数,称为初等函数</p><blockquote><p>基本初等函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210504661.png" alt="image.png"></p><blockquote><p>关于反三角函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210505070.png" alt="image.png"></p><blockquote><p>内容小结</p></blockquote><ul><li>函数的定义及函数的二要素<ul><li>定义域</li><li>对应法则</li></ul></li><li>函数的特性<ul><li>有界性，单调性，奇偶性，周期性</li></ul></li><li>复合函数与反函数</li><li>基本初等函数与初等函数</li></ul><h3 id="2、数列的极限"><a href="#2、数列的极限" class="headerlink" title="2、数列的极限"></a>2、数列的极限</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210548604.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>用定义证明下列极限</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210550053.png" alt="image.png"></p><h4 id="收敛函数的性质"><a href="#收敛函数的性质" class="headerlink" title="收敛函数的性质"></a>收敛函数的性质</h4><p>收敛函数的性质</p><ul><li>唯一性<ul><li>收敛数列的极限唯一</li></ul></li><li>有界性<ul><li>收敛数列必有界</li></ul></li><li>保号性</li><li>任一子数列收敛于同一极限</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210553054.png" alt="image.png"></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210554140.png" alt="image.png"></p><p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/563178651">https://zhuanlan.zhihu.com/p/563178651</a></li><li><a href="https://www.zhihu.com/question/457091692/answer/2763695044">https://www.zhihu.com/question/457091692/answer/2763695044</a></li><li><a href="https://zhuanlan.zhihu.com/p/31206539">https://zhuanlan.zhihu.com/p/31206539</a></li><li>《武忠详高数零基础》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Exam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx_基础概念</title>
    <link href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、启动Nginx"><a href="#1、启动Nginx" class="headerlink" title="1、启动Nginx"></a>1、启动Nginx</h3><blockquote><p>Windows 下启动 nginx</p></blockquote><p>在下载 nginx 后，在nginx安装目录的绝对路径的框框内输入 <code>cmd</code></p><p>直接输入 <code>nginx</code> 或者 <code>start nginx</code>，然后回车，就可以启动nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nginx<br><br><span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>在浏览器地址栏输入 <code>localhost:80</code>，然后再回车, 查看是否有 nginx 访问主页，如果有，则启动成功。</p><p>一般访问问题是端口占用，可以改一下 nginx 访问端口，或者杀掉对应进程。</p><p>关闭nginx的命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nginx -s stop<br></code></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44251179/article/details/129700793">https://blog.csdn.net/weixin_44251179/article/details/129700793</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify使用教程</title>
    <link href="/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、快速开始"><a href="#1、快速开始" class="headerlink" title="1、快速开始"></a>1、快速开始</h3><p>全局安装 <code>docsify-cli</code> 工具，可以方便地创建及在本地预览生成的文档。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i docsify-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><blockquote><p>初始化项目</p></blockquote><p>如果想在项目的 <code>./docs</code> 目录里写文档，直接通过 <code>init</code> 初始化项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docsify init ./docs<br></code></pre></td></tr></table></figure><blockquote><p>开始写文档</p></blockquote><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新文档内容，当然也可以添加更多页面。</p><blockquote><p>本地预览</p></blockquote><p>通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。</p><p>默认访问地址 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docsify serve docs</span><br></code></pre></td></tr></table></figure><h3 id="2、多页文档设置"><a href="#2、多页文档设置" class="headerlink" title="2、多页文档设置"></a>2、多页文档设置</h3><p>在 docsify 中，你访问的文档 URL 路径地址和你的文档文件夹结构是一个映射关系（实现多级路由）；</p><p>比如你在 doc 文件夹中创建<code>guide.md</code>、<code>zh-cn/READEME.md</code>、<code>zh-cn/guide.md</code>，结构如下所示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos">.<br>├── README.<span class="hljs-built_in">md</span><br>├── guide.<span class="hljs-built_in">md</span><br>├── index.html<br>└── zh-cn<br>    ├── README.<span class="hljs-built_in">md</span><br>    └── guide.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>此时我们访问如下url即可以访问到对应的页面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">README.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span><br>guide.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/gui</span>de<br><span class="hljs-regexp">/zh-cn/</span>README.md  =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/<br><span class="hljs-regexp">/zh-cn/gui</span>de.md   =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/guide<br><br></code></pre></td></tr></table></figure><h3 id="3、定制化配置"><a href="#3、定制化配置" class="headerlink" title="3、定制化配置"></a>3、定制化配置</h3><h4 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h4><p>需要先在 docs&#x2F;index.html 中修改一下配置，开启侧边栏的选项添加<code>loadSiderbar: true</code></p><p>这样设置后就会加载 Docsify 目录下的 _ sidebar.md 文件,  进行加载而渲染成我们定制的侧边栏</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span><br>loadSidebar: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311201949003.png" alt="image.png"></p><p>我们在 docs 目录下创建一个 <code>_sidebar.md</code> 文件，里面可以对侧边栏进行配置，比如这里配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>这里使用的是 MarkDown 中的超链接语法，后面的路径对应着上述多页文档的路由路径</p><p>我们还可以指定页面的标题，比如这里指定首页的标题为home 【后面添加双引号进行别名】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/ &quot;home&quot;) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><h4 id="侧边栏嵌套设置"><a href="#侧边栏嵌套设置" class="headerlink" title="侧边栏嵌套设置"></a>侧边栏嵌套设置</h4><p>在对应子目录 docs&#x2F;zh-cn 下创建一个 <code>_sidebar.md</code> 文件，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/zh-cn/_sidebar.md --&gt;</span><br><br>* [zh-ch首页](/zh-cn) <br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>_ sidebar.md 的加载逻辑是从每层目录下获取文件，如果当前目录不存在该文件则回退到上一级目录。<br>例如当前路径为 &#x2F;zh-cn 则从 &#x2F;zh-cn&#x2F;_ sidebar.md 获取文件，如果不存在则从 &#x2F;_ sidebar.md 获取，</p><p>我们也可以在 index.html 中如下配置表示默认都走根路径下的 <code>_sidebar.md</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="开启目录功能"><a href="#开启目录功能" class="headerlink" title="开启目录功能"></a>开启目录功能</h4><p>自定义侧边栏同时也可以开启目录功能。设置 <code>subMaxLevel</code> 配置项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">    <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="目录折叠功能"><a href="#目录折叠功能" class="headerlink" title="目录折叠功能"></a>目录折叠功能</h4><p>需要引入一下 docsify-sidebar-collapse 样式 , 具体配置可以看一下下面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Description&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 文件夹样式 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar-folder.min.css&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 箭头样式 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar.min.css&quot; /&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span></span><br><span class="language-javascript">  <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">  <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Docsify v4 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 侧边栏目录折叠 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>添加导航栏有两种方式，一是直接到 index.html 中添加，二是和侧边栏类似，通过 md 文件的形式来添加。</p><blockquote><p><strong>通过md文件来添加</strong></p></blockquote><p>首先在 index.html 中配置 <code>loadNavbar</code>，默认加载的文件为 <code>_navbar.md</code> </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启导航栏,加载_navbar.md </span><br>loadNavbar: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套列表</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;!-- _navbar<span class="hljs-selector-class">.md</span> --&gt;<br><br>* 入门<br>  * <span class="hljs-selector-attr">[快速开始]</span>(zh-cn/quickstart.md)<br>  * <span class="hljs-selector-attr">[多页文档]</span>(zh-cn/more-pages.md)<br>  * <span class="hljs-selector-attr">[定制导航栏]</span>(zh-cn/custom-navbar.md)<br>  * <span class="hljs-selector-attr">[封面]</span>(zh-cn/cover.md)<br><br><br>* 配置<br>  * <span class="hljs-selector-attr">[配置项]</span>(zh-cn/configuration.md)<br>  * <span class="hljs-selector-attr">[主题]</span>(zh-cn/themes.md)<br>  * <span class="hljs-selector-attr">[使用插件]</span>(zh-cn/plugins.md)<br>  * <span class="hljs-selector-attr">[Markdown 配置]</span>(zh-cn/markdown.md)<br>  * <span class="hljs-selector-attr">[代码高亮]</span>(zh-cn/language-highlight.md)<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311202158957.png" alt="image.png"></p><h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p>在 index.html 中设置 <code>coverpage</code> 参数开启封面功能</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启封面,加载_coverpage.md</span><br>coverpage: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p>在文档根目录创建 <code>_coverpage.md</code> 文件，用于配置封面内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docsify <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span></span>3.5<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span></span></span><br><br><span class="hljs-quote">&gt; 一个神奇的文档网站生成器。</span><br><br><span class="hljs-bullet">-</span> 简单、轻便 (压缩后 ~21kB)<br><span class="hljs-bullet">-</span> 无需生成 html 文件<br><span class="hljs-bullet">-</span> 众多主题<br><br>[<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com/docsifyjs/docsify/</span>)<br></code></pre></td></tr></table></figure><p>目前的背景是随机生成的渐变色，可以自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 网站图标 --&gt;</span><br>![logo](_media/icon.jpg)<br><br># docsify <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br>&gt; 一个神奇的文档网站生成器。<br><br>- 简单、轻便 (压缩后 ~21kB)<br>- 无需生成 html 文件<br>- 众多主题<br><br>[GitHub](https://github.com/docsifyjs/docsify/)<br><br><span class="hljs-comment">&lt;!-- 背景图片 --&gt;</span><br>![](_media/玩家.png)<br><br><span class="hljs-comment">&lt;!-- 背景色 --&gt;</span><br>![color](#f0f0f0)<br></code></pre></td></tr></table></figure><p>通常封面和首页是同时出现的，你可以将封面独立出来</p><p>配置（只在访问主页时加载封面）：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">window</span>.<span class="hljs-variable">$docsify</span> = &#123;<br>  onlyCover:<span class="hljs-built_in"> false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>见： <a href="https://docsify.js.org/#/zh-cn/themes">https://docsify.js.org/#/zh-cn/themes</a></p><h3 id="4、基于nginx-docsify搭建"><a href="#4、基于nginx-docsify搭建" class="headerlink" title="4、基于nginx + docsify搭建"></a>4、基于nginx + docsify搭建</h3><p>nginx 配置文件中，在 <code>http</code> 块内添加一个新的 <code>server</code> 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /docs &#123;<br><span class="hljs-built_in">alias</span> D:/shareDocs/docs; <span class="hljs-comment"># 修改为你的 Docsify 项目绝对路径</span><br>index index.html;<br>try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://docsify.js.org/#/zh-cn/quickstart">https://docsify.js.org/#/zh-cn/quickstart</a></li><li><a href="https://www.cnblogs.com/Can-daydayup/p/15413267.html">https://www.cnblogs.com/Can-daydayup/p/15413267.html</a></li><li><a href="https://ysgstudyhards.github.io/Docsify-Guide/#/README">https://ysgstudyhards.github.io/Docsify-Guide/#/README</a></li><li><a href="https://blog.csdn.net/qq_45173404/article/details/122683872">https://blog.csdn.net/qq_45173404/article/details/122683872</a></li><li><a href="https://developer.aliyun.com/article/1266542">https://developer.aliyun.com/article/1266542</a></li><li><a href="https://clotliu.com/archives/docsify-advanced">https://clotliu.com/archives/docsify-advanced</a></li><li><a href="https://www.cnblogs.com/yangstar/articles/16690435.html">https://www.cnblogs.com/yangstar/articles/16690435.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL_基础概念</title>
    <link href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、NoSQL-是什么"><a href="#1、NoSQL-是什么" class="headerlink" title="1、NoSQL 是什么"></a>1、NoSQL 是什么</h3><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><h4 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h4><table><thead><tr><th></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td>发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td>例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td>ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td>性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td>扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td>用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td>查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h4 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h4><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231119123254.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/nosql.html">https://javaguide.cn/database/nosql.html</a></li><li><a href="https://www.ibm.com/cn-zh/topics/nosql-databases">https://www.ibm.com/cn-zh/topics/nosql-databases</a></li><li><a href="https://zhuanlan.zhihu.com/p/345342966">https://zhuanlan.zhihu.com/p/345342966</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插件实现Obsidian实时同步</title>
    <link href="/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、插件下载和服务安装"><a href="#1、插件下载和服务安装" class="headerlink" title="1、插件下载和服务安装"></a>1、插件下载和服务安装</h3><p>使用插件： Self-hosted LiveSync</p><p>在服务器上面安装 docker 后，</p><p>创建一个文件 <code>local.ini</code></p><p>复制以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[couchdb]</span><br><span class="hljs-attr">single_node</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd_auth]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">authentication_redirect</span> = /_utils/session.html<br><br><span class="hljs-section">[httpd]</span><br><span class="hljs-attr">WWW-Authenticate</span> = Basic realm=<span class="hljs-string">&quot;couchdb&quot;</span><br><span class="hljs-attr">enable_cors</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[cors]</span><br><span class="hljs-attr">origins</span> = app://obsidian.md,capacitor://localhost,http://localhost<br><span class="hljs-attr">credentials</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">headers</span> = accept, authorization, content-type, origin, referer<br><span class="hljs-attr">methods</span> = GET, PUT, POST, HEAD, DELETE<br><span class="hljs-attr">max_age</span> = <span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>将该文件移动到 <code>/opt/couchdb</code>目录下</p><p>运行下面命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d --restart always -e <span class="hljs-attribute">COUCHDB_USER</span>=luo -e <span class="hljs-attribute">COUCHDB_PASSWORD</span>=luo123 -v /opt/couchdb/local.ini:/opt/couchdb/etc/local.ini -p 6900:5984 couchdb<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>COUCHDB_USER</code> 后面的是你的用户名</li><li><code>COUCHDB_PASSWORD</code> 后面的是你的密码</li><li><code>/opt/couchdb/local.ini</code> 是配置文件的路径</li><li><code>/opt/couchdb/db</code> 是数据库的路径</li><li><code>-p 6900:5984</code> 前面的 6900 是暴露在外的端口。</li></ul><p>检查是否运行成功</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo docker <span class="hljs-keyword">ps</span> |<span class="hljs-keyword">grep</span> couchdb<br></code></pre></td></tr></table></figure><h3 id="2、插件配置"><a href="#2、插件配置" class="headerlink" title="2、插件配置"></a>2、插件配置</h3><p>打开Obsidian的设置-第三方插件，在插件市场安装<code>Self-hosted LiveSync</code></p><blockquote><p>客户端配置</p></blockquote><p>安装并启用后打开插件的设置界面，填写箭头内容，URI 为刚刚的<code>http://IP+端口（6900）</code>，例如：<code>http://127.0.0.1:6900</code>，</p><p>Username 和 Password 为前面的参数设置的内容，</p><p>Database name 可以自己取，注意不要填大写字母，完成后点击test 按钮</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230051.png" alt="image.png"></p><p>右上角出现 <code>Connect to 数据库名</code>，则为连接成功</p><p>如果你之前配置连接过，并存放过数据，你连接后会将对应的数据库中的文件同步到你目前的工作空间中；也可以理解他的数据是存放在了服务器中的数据库，设备连接该服务后的同步操作，本质上都是在操作更新服务器上面的数据库文件内容，然后更新对应映射内容到设备的Obsidian文件中。</p><p>完成后点击下面的check ，将所有提示错误的选择fix，然后再次点击check ，直到没有错误</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230528.png" alt="image.png"></p><p>划到最下方，选择端对端加密（End to End Encryption），在输入框中设置密码，点击启用</p><p><strong>如果仅想要同步文章无需开启端对端加密</strong></p><p>在Sync Setting 选项卡中，选择LiveSync（实时同步），点击Apply启用</p><p>建议启用 <code>Use Trash for deleted files</code>（删除文件到回收站）</p><p>建议启用 <code>Miscellaneous</code> 选项卡中的 <code>Show staus inside editor</code> （会在编辑器右上角显示状态）</p><blockquote><p>复制配置到其他设备</p></blockquote><p>在插件Setup wizard 选项卡中，点击 <code>Copy Setup URI</code>，弹出的对话框设置密码，即可复制当前的配置信息</p><p>复制后打开自己需要同步的设备点击Open setup URI 粘贴复制的内容，输入设置的密码，点击第一个</p><hr><p>参考</p><ul><li><a href="https://sspai.com/post/82161#">https://sspai.com/post/82161#</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dokcer入门_基础概念</title>
    <link href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Docker"><a href="#1、什么是-Docker" class="headerlink" title="1、什么是 Docker"></a>1、什么是 Docker</h3><blockquote><p>理解虚拟化技术</p></blockquote><p>人们为了提高系统及硬件资源的利用率而引入了<strong>虚拟化技术</strong>。虚拟化是一种<strong>资源管理技术</strong>，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。</p><p>虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。</p><p>从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。</p><blockquote><p>基于软件的虚拟化</p></blockquote><p>软件虚拟化是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p><p>对软件虚拟化进行细分，又可以分为以下几类：</p><ul><li>完全虚拟化</li><li>硬件辅助虚拟化</li><li>部分虚拟化</li><li>平行虚拟化</li><li>操作系统层虚拟化</li></ul><p>Docker容器技术就是属于操作系统层虚拟化的范畴。</p><p>虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。</p><blockquote><p>虚拟机和Docker</p></blockquote><p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源。</p><p>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p><blockquote><p>虚拟机和 Docker 的对比<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171252304.png" alt="image.png"></p></blockquote><blockquote><p>图解物理机,虚拟机与容器</p></blockquote><p>物理机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456074.png" alt="image.png"></p><p>虚拟机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456887.png" alt="image.png"><br>容器</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171457700.png" alt="image.png"></p><p>虚拟机和Docker容器各自有自己的应用场景，<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。</p><p>而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p><h3 id="2、Docker-基本概念"><a href="#2、Docker-基本概念" class="headerlink" title="2、Docker 基本概念"></a>2、Docker 基本概念</h3><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><blockquote><p><strong>Docker Registry 公开服务和私有 Docker Registry</strong></p></blockquote><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" title="https://hub.docker.com/">https://hub.docker.com/open in new window</a> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171534204.png" alt="image.png"></p><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ docker <span class="hljs-keyword">search</span> mysql<br><span class="hljs-type">NAME</span>                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>mysql                             MySQL <span class="hljs-keyword">is</span> a widely used, <span class="hljs-keyword">open</span>-source relation…   <span class="hljs-number">8763</span>                [OK]<br>mariadb                           MariaDB <span class="hljs-keyword">is</span> a community-developed fork <span class="hljs-keyword">of</span> MyS…   <span class="hljs-number">3073</span>                [OK]<br>mysql/mysql-<span class="hljs-keyword">server</span>                Optimized MySQL <span class="hljs-keyword">Server</span> Docker images. <span class="hljs-keyword">Create</span>…   <span class="hljs-number">650</span>                                     [OK]<br></code></pre></td></tr></table></figure><p>在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" title="阿里云镜像库">阿里云镜像库</a>。</p><p>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。</p><p>Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="3、基本命令"><a href="#3、基本命令" class="headerlink" title="3、基本命令"></a>3、基本命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker <span class="hljs-keyword">version</span> <span class="hljs-comment"># 查看docker版本</span><br>docker images <span class="hljs-comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span><br>docker container <span class="hljs-keyword">ls</span> <span class="hljs-comment"># 查看所有容器</span><br>docker ps <span class="hljs-comment">#查看正在运行的容器</span><br>docker image prune <span class="hljs-comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span><br></code></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search mysql <span class="hljs-comment"># 查看mysql相关镜像</span><br>docker pull mysql:5.7 <span class="hljs-comment"># 拉取mysql镜像</span><br>docker image <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 查看所有已下载镜像</span><br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID 删除）。</p><p>通过我们前面讲的<code>docker ps</code>命令即可查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br>c4cd691d9f80        mysql:5.7           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   7 weeks ago         Up 12 days          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql<br></code></pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code>暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  ~ docker images<br>REPOSITORY              <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>mysql                   <span class="hljs-number">5.7</span>                 f6509bac4980        <span class="hljs-number">3</span> months ago        <span class="hljs-number">373M</span>B<br></code></pre></td></tr></table></figure><p>通过 IMAGE ID 或者 REPOSITORY 名字即可删除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi f6509bac4980 <span class="hljs-comment">#  或者 docker rmi mysql</span><br></code></pre></td></tr></table></figure><h3 id="4、Build-Ship-and-Run"><a href="#4、Build-Ship-and-Run" class="headerlink" title="4、Build Ship and Run"></a>4、Build Ship and Run</h3><p>搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。</p><ul><li><strong>Build（构建镜像）</strong>：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong>Run （运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p>Docker 运行过程是会去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p><p>Docker 也被称为码头工人或码头装卸工，这和 Docker 的中文翻译<strong>搬运工人</strong>如出一辙。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171603190.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html">https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-03-basic2.html">https://www.pdai.tech/md/devops/docker/docker-03-basic2.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_基础概念</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>线程基础概念</li><li>Java 线程</li><li>生命周期</li><li>创建线程</li><li>线程的调用方法</li><li>Synchronized 和 Lock</li></ul><p>线程</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401191403753.png" alt="image.png"></p><h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li></ul><p>并行和并发的区别</p><ul><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行</p><p>同步和异步的区别</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p><h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" alt="image.png"></p><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" alt="image.png"></p><p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p><p>Java线程具有五中基本状态</p><ul><li>新建状态（New）<ul><li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li></ul></li><li>就绪状态（Runnable）<ul><li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li><li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li></ul></li><li>运行状态（Running）<ul><li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li><li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li></ul></li><li>阻塞状态（Blocked）<ul><li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li><li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul><li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li><li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡状态（Dead）<ul><li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul><blockquote><p>Java多线程的就绪、运行和死亡状态</p></blockquote><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p><p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p><p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p><p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p><h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p><ol><li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>Runnable接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure><ul><li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li><li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li><li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li></ul><blockquote><p>写法简化（Java 8)</p></blockquote><ul><li><strong>方式一：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote><p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p></blockquote><table><thead><tr><th>名称</th><th>描述</th><th>注意事项</th></tr></thead><tbody><tr><td>​<code>start()</code>​</td><td>启动一个新线程，<br />在新的线程运行 run 方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td></tr><tr><td>​<code>run()</code>​</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td></tr><tr><td>​<code>join()</code>​</td><td>等待线程运行结束</td><td></td></tr><tr><td>​<code>join(long n)</code>​</td><td>等待线程运行结束，<br />最多等待 n 毫秒</td><td></td></tr><tr><td>​<code>getId()</code>​</td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>​<code>getName()</code>​</td><td>获取线程名</td><td></td></tr><tr><td>​<code>setName(String name)</code>​</td><td>修改线程名</td><td></td></tr><tr><td>​<code>getPriority()</code>​</td><td>获取线程优先级</td><td></td></tr><tr><td>​<code>setPriority(int priority)</code>​</td><td>修改线程优先级</td><td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td></tr><tr><td>​<code>getState()</code>​</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td></tr><tr><td>​<code>interrupt()</code>​</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td></tr><tr><td><font color=Coral>interrupted()</font></td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>​<code>isInterrupted()</code>​</td><td>判断当前线程是否被打断</td><td>不会清除打断标记</td></tr><tr><td>​<code>isAlive()</code>​</td><td>判断当前线程是否存活</td><td></td></tr><tr><td>​<code>isDaemon()</code>​</td><td>判断当前线程是否是守护线程</td><td></td></tr><tr><td>​<code>setDaemon(boolean on)</code>​</td><td>设置当前线程为守护线程</td><td></td></tr><tr><td><font color=Coral>currentThread()</font></td><td>获取当前正在执行的线程</td><td></td></tr><tr><td><font color=Coral>sleep(long n)</font></td><td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td><td></td></tr><tr><td><font color=Coral>yield()</font></td><td>提示线程调度器让出当前线程<br />对 CPU 的使用</td><td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td></tr></tbody></table><h3 id="6、Synchronized-和-Lock-的使用"><a href="#6、Synchronized-和-Lock-的使用" class="headerlink" title="6、Synchronized 和 Lock 的使用"></a>6、Synchronized 和 Lock 的使用</h3><p>并发编程中，锁是经常需要用到的。这里讲述一下 Synchronized 和 Lock 的使用。</p><p>Synchronized 是 Java 并发编程 中很重要的关键字，另外一个很重要的是 volatile。</p><p>Syncronized 的目的是一次<strong>只允许一个线程进入由他修饰的代码段</strong>，从而允许他们进行自我保护。</p><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要<strong>手动加锁和手动解锁</strong>，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><blockquote><p>在方法上使用 Synchronized</p></blockquote><p>方法声明时使用，放在范围操作符之后,返回类型声明之前。即一次只能有一个线程进入该方法，其他线程要想在此时调用该方法，只能排队等候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numIncrease</span><span class="hljs-params">()</span>&#123;<br>  number++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在某个代码段使用 Synchronized</p></blockquote><p>可以在某个代码块上使用 Synchronized 关键字，表示只能有一个线程进入某个代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numDecrease</span><span class="hljs-params">(Object num)</span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (num)&#123;<br>    number++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Synchronized 锁住整个对象</p></blockquote><p>synchronized后面括号里是一对象，此时线程获得的是对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，相关方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用方法</p><ul><li>lock()<ul><li>用来获取锁。如果锁被其他线程获取，则进行等待。</li><li>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁</li></ul></li><li>tryLock()<ul><li>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，</li><li>这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li></ul></li><li>tryLock(long time, TimeUnit unit)<ul><li>和tryLock()方法是类似</li><li>在拿不到锁时<strong>会等待一定的时间</strong>，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li></ul></li><li>lockInterruptibly()<ul><li>去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即<strong>中断线程的等待状态</strong>。</li><li>当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用 threadB.interrupt() 方法能够中断线程B的等待过程。</li><li>由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在try块中或者在调用lockInterruptibly() 的方法外声明抛出 InterruptedException。</li></ul></li></ul><blockquote><p>代码示例：</p></blockquote><p>lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>tryLock()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Lock</span> lock = ...;<br><span class="hljs-keyword">if</span>(lock.<span class="hljs-title function_">tryLock</span>()) &#123;<br>     <span class="hljs-keyword">try</span>&#123;<br>         <span class="hljs-comment">//处理任务</span><br>     &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-title class_">Exception</span> ex)&#123;<br>         <br>     &#125;<span class="hljs-keyword">finally</span>&#123;<br>         lock.<span class="hljs-title function_">unlock</span>();   <span class="hljs-comment">//释放锁</span><br>     &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不能获取锁，则直接做其他事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>    lock.<span class="hljs-title function_">lockInterruptibly</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//.....</span><br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        lock.<span class="hljs-title function_">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将<strong>释放锁的操作放在finally块中进行</strong>，以保证锁一定被被释放，防止死锁的发生。</p><blockquote><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能<strong>中断阻塞过程中的线程</strong>。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，<strong>只有进行等待的情况下，是可以响应中断的</strong>。<br>而<strong>用synchronized修饰的话</strong>，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li><li><a href="https://cloud.tencent.com/developer/article/1497476">https://cloud.tencent.com/developer/article/1497476</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_HashMap学习</title>
    <link href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>HashMap 主要用来存放键值对，基于哈希表的 Map 接口实现，是常用的 Java 集合之一。</p><p>HashMap是非线程安全的，效率较高。</p><p>它可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><strong>底层数据结构</strong>：</p><ul><li>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li><li>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>扩充机制</strong>：<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><blockquote><p>HashMap的常用方法</p></blockquote><p>1、put(K key, V value)： 将键（key）&#x2F;值（value）映射存放到Map集合中。</p><p>2、get(Object key)： 返回指定键所映射的值，没有该key对应的值则返回 null。</p><p>3、size()： 返回Map集合中数据数量。</p><p>4、clear()： 清空Map集合。</p><p>5、isEmpty()： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。</p><p>6、remove(Object key)： 删除Map集合中键为key的数据并返回其所对应value值。</p><p>7、values()： 返回Map集合中所有value组成的以Collection数据类型格式数据。</p><p>8、containsKey(Object key)： 判断集合中是否包含指定键，包含返回 true，否则返回false。</p><p>9、containsValue(Object value)： 判断集合中是否包含指定值，包含返回 true，否则返回false。</p><p>10、keySet()： 返回Map集合中所有key组成的Set集合。</p><p>11、entrySet()： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。</p><blockquote><p>HashMap 常用方法测试</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sas">package map;<br><br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.<span class="hljs-keyword">Set</span>;<br><br>public class HashMapDemo &#123;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>        // 键不能重复，值可以重复<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;san&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王2&quot;</span>);// 老王被覆盖<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;lao&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------直接输出hashmap:-------&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历HashMap</span><br><span class="hljs-comment">         */</span><br>        // 1.获取Map中的所有键<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span>+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 2.获取Map中所有值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);<br>        Collection&lt;String&gt; values = map.values();<br>        for (String value : values) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(value+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 3.得到<span class="hljs-keyword">key</span>的值的同时得到<span class="hljs-keyword">key</span>所对应的值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys2 = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys2) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span> + <span class="hljs-string">&quot;：&quot;</span> + map.get(<span class="hljs-keyword">key</span>)+<span class="hljs-string">&quot;   &quot;</span>);<br><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="hljs-comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="hljs-comment">         */</span><br>        // 当我调用<span class="hljs-meta">put</span>(<span class="hljs-keyword">key</span>,value)方法的时候，首先会把<span class="hljs-keyword">key</span>和value封装到<br>        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取<br>        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来<br>        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了<br>        <span class="hljs-keyword">Set</span>&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();<br>        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;<br>            System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HashMap其他常用方法</span><br><span class="hljs-comment">         */</span><br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.size()：&quot;</span>+map.size());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;san&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.remove()：&quot;</span>+map);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;李四&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四2&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.replace(si, 李四2):&quot;</span>+map);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用（ <strong>链表散列</strong>）。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115224010.png" alt="image.png"></p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<strong>如果相同的话，直接覆盖</strong>，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。</p><p>使用 hash 方法（扰动函数）是为了防止一些实现比较差的 hashCode() 方法 ，使用扰动函数之后可以减少碰撞。</p><p>所谓 <strong>“拉链法”</strong> 是：将链表和数组相结合。也就是说创建一个链表数组，<strong>数组中每一格就是一个链表</strong>。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><strong>hash 方法</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能稍差一点，因为毕竟扰动了 4 次。</p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。</p><p>这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。</p><p>否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115223309.png" alt="image.png"></p><h4 id="HashMap-的类属性"><a href="#HashMap-的类属性" class="headerlink" title="HashMap 的类属性"></a>HashMap 的类属性</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span> &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">362498820763181265</span>L;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    transient Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    transient <span class="hljs-built_in">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    transient <span class="hljs-built_in">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-built_in">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的字段</p><ul><li>loadFactor   负载因子</li><li>threshold   阈值（HashMap 实际能存储的大小）</li><li>DEFAULT_INITIAL_CAPACITY  默认初始容量</li><li>MAXIMUM_CAPACITY  最大容量</li><li>size   HashMap实际存储的元素个数</li><li>modCount     HashMap的结构被修改的次数，用于迭代器</li></ul><blockquote><p>loadFactor 负载因子</p></blockquote><p>loadFactor 负载因子 是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor 的默认值为 0.75f</strong> ，是官方给出的一个比较好的临界值。</p><p>HashMap 给定的默认容量为 16，负载因子为 0.75。<br>Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 , 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><blockquote><p>threshold   阈值</p></blockquote><p><strong>threshold &#x3D; capacity * loadFactor</strong>，阈值(容量 * 负载因子) </p><p>当实际大小超过阈值时，就要考虑对数组的扩增。阈值是衡量数组是否需要扩增的一个标准。</p><h4 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br>static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">K,V</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-type">K,V</span>&gt; &#123;<br>       <span class="hljs-keyword">final</span> int hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       <br>       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String toString() &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int hashCode() &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br><span class="hljs-comment">//相当于把原来的值给覆盖掉，但是返回被覆盖掉的值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V newValue) &#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean equals(Object o) &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 父</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;           <span class="hljs-comment">// 判断颜色</span><br>        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; root() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、HashMap-源码分析"><a href="#3、HashMap-源码分析" class="headerlink" title="3、HashMap 源码分析"></a>3、HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> threshold;<br>   <br>   <span class="hljs-comment">// 默认构造函数。</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    &#125;<br><br>    <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>        <span class="hljs-comment">//指定负载因子</span><br>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在 resize 中再赋值给 newCap 进行table初始化</span><br>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面第二个构造函数中调用了 putMapEntries 方法，下面进行分析：</p><p><strong>putMapEntries 方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> s = m.size();  <br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size  </span><br>            <span class="hljs-comment">//如果未初始化，s 为 m 的实际元素个数；ft=s/loadFactor =&gt; s=ft*loadFactor；其中 ft 指的是要添加 s 个元素所需要的最小的容量</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0</span>F;  <br>            <span class="hljs-comment">//与最大容量作比较，如果小于则 t 为 ft，否则为 MAXIMUM_CAPACITY</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?  <br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);  <br>            <span class="hljs-comment">//根据上面的构造函数，可以得知此时 table 未初始化，threshold 实际上是存放的初始化容量</span><br>            <span class="hljs-comment">//如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。（注意这里不是初始化阈值）</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)  <br>                threshold = tableSizeFor(t);  <br>        &#125;  <br>        <span class="hljs-comment">// 如果已经初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)  <br>            resize();  <br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容    </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet()) &#123;  <br>            K key = e.getKey();  <br>            V value = e.getValue();  <br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor 方法：返回一个最接近 cap 的2的幂次方大小数值</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;  <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;  <br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法是 put 方法调用的一个方法，并没有提供给用户使用。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>putVal 方法 图解</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115230931.png" alt="image.png"></p><p>putVal 方法添加元素分析：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，<ul><li>如果 key 相同就直接覆盖，</li><li>如果 key 不相同，就判断 p 是否是一个树节点，<ul><li>如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</li><li>如果不是就遍历链表插入(插入的是链表尾部)。</li></ul></li></ul></li></ul><blockquote><p>putVal 方法</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对比 JDK1.7 put 方法的代码</strong></p></blockquote><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value)<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    <span class="hljs-title function_">inflateTable</span>(threshold);<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123; <span class="hljs-comment">// 先遍历</span><br>        <span class="hljs-built_in">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">public V get(Object key) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(<span class="hljs-built_in">hash</span>(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br>final Node&lt;K,V&gt; getNode(int <span class="hljs-built_in">hash</span>, Object key) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; int n; K k;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = <span class="hljs-literal">tab</span>[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span>.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">first</span>;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = <span class="hljs-built_in">first</span>.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(<span class="hljs-built_in">hash</span>, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">https://javaguide.cn/java/collection/hashmap-source-code.html</a></li><li><a href="https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507">https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507</a></li><li><a href="https://blog.csdn.net/rain67/article/details/124043769">https://blog.csdn.net/rain67/article/details/124043769</a></li><li><a href="https://segmentfault.com/a/1190000039302830">https://segmentfault.com/a/1190000039302830</a></li><li><a href="https://blog.csdn.net/weixin_47257050/article/details/118926555">https://blog.csdn.net/weixin_47257050/article/details/118926555</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Java基础"><a href="#1、Java基础" class="headerlink" title="1、Java基础"></a>1、Java基础</h3><h4 id="Java-基础"><a href="#Java-基础" class="headerlink" title="Java 基础"></a>Java 基础</h4><ul><li><a href="/2024/01/07/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/" title="Java基础_基础内容01">Java基础_基础内容01</a></li><li><a href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/" title="Java基础_基础内容02">Java基础_基础内容02</a></li><li><a href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/" title="Java基础_基础内容03">Java基础_基础内容03</a></li></ul><h4 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h4><ul><li><a href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_IO%E5%AD%A6%E4%B9%A0/" title="Java基础_基础内容04">Java基础_基础内容04</a></li></ul><h4 id="Java-8"><a href="#Java-8" class="headerlink" title="Java 8"></a><strong>Java 8</strong></h4><ul><li><a href="/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java8新特性">Java8新特性</a></li></ul><h4 id="Java-集合"><a href="#Java-集合" class="headerlink" title="Java 集合"></a><strong>Java 集合</strong></h4><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li><li><a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">Java集合_HashMap学习</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li></ul><h4 id="Java多线程"><a href="#Java多线程" class="headerlink" title="Java多线程"></a><strong>Java多线程</strong></h4><ul><li><a href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java并发编程_基础概念">Java并发编程_基础概念</a></li><li><a href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java并发编程_进阶内容">Java并发编程_进阶内容</a></li><li><a href="/2024/01/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java并发编程_线程池">Java并发编程_线程池</a></li><li><a href="/2024/01/18/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_ThreadLocal/" title="Java并发编程_ThreadLocal">Java并发编程_ThreadLocal</a></li><li><a href="/2024/01/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_AQS/" title="Java并发编程_AQS">Java并发编程_AQS</a></li></ul><h3 id="2、JVM"><a href="#2、JVM" class="headerlink" title="2、JVM"></a>2、JVM</h3><ul><li><a href="/2024/01/23/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="JVM入门_基础概念">JVM入门_基础概念</a></li></ul><h3 id="3、数据库"><a href="#3、数据库" class="headerlink" title="3、数据库"></a>3、数据库</h3><h4 id="数据库基础"><a href="#数据库基础" class="headerlink" title="数据库基础"></a>数据库基础</h4><ul><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据库_基础知识">数据库_基础知识</a></li><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据库_SQL语法基础知识">数据库_SQL语法基础知识</a></li><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="数据库_SQL常见面试题">数据库_SQL常见面试题</a></li></ul><h4 id="MySQL-☆"><a href="#MySQL-☆" class="headerlink" title="MySQL ☆"></a>MySQL ☆</h4><ul><li><a href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/" title="MySQL学习_基础内容01">MySQL学习_基础内容01</a></li><li><a href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/" title="MySQL学习_基础内容02">MySQL学习_基础内容02</a></li><li><a href="/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/" title="MySQL学习_基础内容03">MySQL学习_基础内容03</a></li><li><a href="/2024/01/29/MySQL%E5%AD%A6%E4%B9%A0_%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95/" title="MySQL学习_数据库索引">MySQL学习_数据库索引</a></li><li><a href="/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="MySQL学习_性能优化">MySQL学习_性能优化</a></li></ul><h4 id="NOSQL"><a href="#NOSQL" class="headerlink" title="NOSQL"></a>NOSQL</h4><ul><li><a href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="NoSQL_基础概念">NoSQL_基础概念</a></li></ul><h3 id="4、常用框架"><a href="#4、常用框架" class="headerlink" title="4、常用框架"></a>4、常用框架</h3><h4 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h4><ul><li><a href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Spring学习_基础内容">Spring学习_基础内容</a></li><li><a href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/" title="Spring学习_IOC">Spring学习_IOC</a></li><li><a href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/" title="Spring学习_Spring_Bean的作用域">Spring学习_Spring_Bean的作用域</a></li><li><a href="/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Spring学习_Spring_Bean的生命周期">Spring学习_Spring_Bean的生命周期</a></li><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/" title="Spring学习_AOP">Spring学习_AOP</a></li></ul><h4 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h4><ul><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/" title="Spring学习_SpringMVC">Spring学习_SpringMVC</a></li></ul><h4 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h4><h4 id="MybatisPlus"><a href="#MybatisPlus" class="headerlink" title="MybatisPlus"></a>MybatisPlus</h4><ul><li><a href="/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/" title="框架学习_MyBatis-Plus使用">框架学习_MyBatis-Plus使用</a></li></ul><h4 id="SpringSecurity"><a href="#SpringSecurity" class="headerlink" title="SpringSecurity"></a>SpringSecurity</h4><h4 id="SpringBoot-☆"><a href="#SpringBoot-☆" class="headerlink" title="SpringBoot ☆"></a>SpringBoot ☆</h4><ul><li><a href="/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" title="SpringBoot学习_SpringBoot 自动装配原理">SpringBoot学习_SpringBoot 自动装配原理</a></li></ul><h3 id="5、中间件"><a href="#5、中间件" class="headerlink" title="5、中间件"></a>5、中间件</h3><h4 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a><strong>Redis</strong></h4><ul><li><a href="/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Redis入门_基础概念">Redis入门_基础概念</a></li><li><a href="/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Redis入门_进阶内容">Redis入门_进阶内容</a></li><li><a href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="Redis入门_Redis实战篇">Redis入门_Redis实战篇</a></li></ul><h4 id="MQ"><a href="#MQ" class="headerlink" title="MQ"></a><strong>MQ</strong></h4><ul><li><a href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="消息队列_基础概念">消息队列_基础概念</a></li></ul><h4 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h4><ul><li><a href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_RabbitMQ_基础使用">消息队列_RabbitMQ_基础使用</a></li><li><a href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/" title="RabbitMQ的安装与使用">RabbitMQ的安装与使用</a></li></ul><h4 id="RocketMQ"><a href="#RocketMQ" class="headerlink" title="RocketMQ"></a>RocketMQ</h4><hr><ul><li><a href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_RocketMQ_基础使用">消息队列_RocketMQ_基础使用</a></li><li><a href="/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="消息队列_RocketMQ_安装与使用">消息队列_RocketMQ_安装与使用</a></li></ul><h4 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h4><ul><li><a href="/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_Kafka_基础使用">消息队列_Kafka_基础使用</a></li></ul><h4 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h4><ul><li><a href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Elasticsearch_基础内容">Elasticsearch_基础内容</a></li></ul><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><ul><li><a href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="MongoDB_基本操作">MongoDB_基本操作</a></li></ul><h4 id="Netty"><a href="#Netty" class="headerlink" title="Netty"></a>Netty</h4><ul><li><a href="/2024/01/16/Netty%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="Netty基础使用">Netty基础使用</a></li></ul><h3 id="6、SpringCloud"><a href="#6、SpringCloud" class="headerlink" title="6、SpringCloud"></a>6、SpringCloud</h3><ul><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="SpringCloud_组件基本使用_基础概念">SpringCloud_组件基本使用_基础概念</a></li><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/" title="SpringCloud_组件基本使用_Eureka">SpringCloud_组件基本使用_Eureka</a></li><li><a href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/" title="SpringCloud_组件基本使用_Nacos">SpringCloud_组件基本使用_Nacos</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/" title="SpringCloud_组件基本使用_OpenFeign">SpringCloud_组件基本使用_OpenFeign</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/" title="SpringCloud_组件基本使用_Gateway">SpringCloud_组件基本使用_Gateway</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/" title="SpringCloud_组件基本使用_Seata">SpringCloud_组件基本使用_Seata</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/" title="SpringCloud_组件基本使用_Stream">SpringCloud_组件基本使用_Stream</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/" title="SpringCloud_组件基本使用_Sentinel">SpringCloud_组件基本使用_Sentinel</a></li><li><a href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/" title="SpringCloud_组件基本使用_Zipkin">SpringCloud_组件基本使用_Zipkin</a></li></ul><h3 id="7、Docker"><a href="#7、Docker" class="headerlink" title="7、Docker"></a>7、Docker</h3><ul><li><a href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Dokcer入门_基础概念">Dokcer入门_基础概念</a></li><li><a href="/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Docker入门_Docker的基本使用">Docker入门_Docker的基本使用</a></li><li><a href="/2024/01/22/Kubernetes/" title="Kubernetes">Kubernetes</a></li><li><a href="/2024/01/21/Portainer%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/" title="Portainer环境配置">Portainer环境配置</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、核心源码"><a href="#一、核心源码" class="headerlink" title="一、核心源码"></a>一、核心源码</h3><p>这里以 JDK1.8 为例，分析一下 <code>ArrayList</code> 的底层源码。</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ArrayList</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">extends</span> <span class="hljs-title class_">AbstractList</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span><br>        <span class="hljs-variable">implements</span> <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span>, <span class="hljs-title class_">RandomAccess</span>, <span class="hljs-title class_">Cloneable</span>, <span class="hljs-variable">java</span>.<span class="hljs-property">io</span>.<span class="hljs-property">Serializable</span> &#123;<br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">final</span> <span class="hljs-variable">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">8683452581122892189</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认初始容量大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">final</span> int <span class="hljs-variable">DEFAULT_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 空数组（用于空实例）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">final</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-variable">EMPTY_ELEMENTDATA</span> <span class="hljs-operator">=</span> &#123;&#125;;<br><br>    <span class="hljs-comment">//用于默认大小空实例的共享空数组实例。</span><br>    <span class="hljs-comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">final</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-variable">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="hljs-operator">=</span> &#123;&#125;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 保存ArrayList数据的数组</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">transient</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-variable">elementData</span>; <span class="hljs-comment">// non-private to simplify nested class access</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList 所包含的元素个数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> int <span class="hljs-variable">size</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">ArrayList</span>(int initialCapacity) &#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">Object</span>[initialCapacity];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (initialCapacity <span class="hljs-operator">==</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">//如果传入的参数等于0，创建空数组</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">EMPTY_ELEMENTDATA</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//其他情况，抛出异常</span><br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Illegal Capacity: &quot;</span> <span class="hljs-operator">+</span><br>                    initialCapacity);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认无参构造函数</span><br><span class="hljs-comment">     * DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">ArrayList</span>() &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">ArrayList</span>(<span class="hljs-title class_">Collection</span><span class="hljs-operator">&lt;</span>? <span class="hljs-variable">extends</span> <span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">c</span>) &#123;<br>        <span class="hljs-comment">//将指定集合转换为数组</span><br>        <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">c</span>.<span class="hljs-property">toArray</span>();<br>        <span class="hljs-comment">//如果elementData数组的长度不为0</span><br>        <span class="hljs-keyword">if</span> ((<span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-variable">elementData</span>.<span class="hljs-property">length</span>) <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-variable">elementData</span>.<span class="hljs-property">getClass</span>() <span class="hljs-operator">!=</span> <span class="hljs-title class_">Object</span>[].<span class="hljs-property">class</span>)<br>                <span class="hljs-comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span><br>                <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>, <span class="hljs-title class_">Object</span>[].<span class="hljs-property">class</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 其他情况，用空数组代替</span><br>            <span class="hljs-variable language_">this</span>.<span class="hljs-property">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-variable">EMPTY_ELEMENTDATA</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">trimToSize</span>() &#123;<br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">size</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">elementData</span>.<span class="hljs-property">length</span>) &#123;<br>            <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> (<span class="hljs-variable">size</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>)<br>                    ? <span class="hljs-variable">EMPTY_ELEMENTDATA</span><br>                    : <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>);<br>        &#125;<br>    &#125;<br><span class="hljs-comment">//下面是ArrayList的扩容机制</span><br><span class="hljs-comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><br><span class="hljs-comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> minCapacity 所需的最小容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ensureCapacity</span>(<span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span><br>        int <span class="hljs-variable">minExpand</span> <span class="hljs-operator">=</span> (<span class="hljs-variable">elementData</span> <span class="hljs-operator">!=</span> <span class="hljs-variable">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>)<br>                <span class="hljs-comment">// any size if not default element table</span><br>                ? <span class="hljs-number">0</span><br>                <span class="hljs-comment">// larger than default for default empty table. It&#x27;s already</span><br>                <span class="hljs-comment">// supposed to be at default size.</span><br>                : <span class="hljs-variable">DEFAULT_CAPACITY</span>;<br>        <span class="hljs-comment">//如果最小容量大于已有的最大容量</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">minCapacity</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">minExpand</span>) &#123;<br>            <span class="hljs-title function_">ensureExplicitCapacity</span>(<span class="hljs-variable">minCapacity</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 根据给定的最小容量和当前数组元素来计算所需容量。</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> int <span class="hljs-title function_">calculateCapacity</span>(<span class="hljs-params">Object</span>[] <span class="hljs-params">elementData</span>, <span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-comment">// 如果当前数组元素为空数组（初始情况），返回默认容量和最小容量中的较大值作为所需容量</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">elementData</span> <span class="hljs-operator">==</span> <span class="hljs-variable">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-property">max</span>(<span class="hljs-variable">DEFAULT_CAPACITY</span>, <span class="hljs-variable">minCapacity</span>);<br>        &#125;<br>        <span class="hljs-comment">// 否则直接返回最小容量</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">minCapacity</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 确保内部容量达到指定的最小容量。</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-title function_">ensureExplicitCapacity</span>(<span class="hljs-title function_">calculateCapacity</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">minCapacity</span>));<br>    &#125;<br><br>    <span class="hljs-comment">//判断是否需要扩容</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">ensureExplicitCapacity</span>(<span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>        <span class="hljs-comment">// overflow-conscious code</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">minCapacity</span> <span class="hljs-operator">-</span> <span class="hljs-variable">elementData</span>.<span class="hljs-property">length</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>            <span class="hljs-title function_">grow</span>(<span class="hljs-variable">minCapacity</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 要分配的最大数组大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> <span class="hljs-variable">final</span> int <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span> <span class="hljs-operator">-</span> <span class="hljs-number">8</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">grow</span>(<span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>        int <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-variable">elementData</span>.<span class="hljs-property">length</span>;<br>        <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>        <span class="hljs-comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>        int <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">+</span> (<span class="hljs-variable">oldCapacity</span> <span class="hljs-operator">&gt;&gt;</span> <span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">newCapacity</span> <span class="hljs-operator">-</span> <span class="hljs-variable">minCapacity</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-variable">minCapacity</span>;<br>        <span class="hljs-comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span><br>        <span class="hljs-comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span><br>        <span class="hljs-comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Integer.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">newCapacity</span> <span class="hljs-operator">-</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-variable">newCapacity</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">hugeCapacity</span>(<span class="hljs-variable">minCapacity</span>);<br>        <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:</span><br>        <span class="hljs-variable">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">newCapacity</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//比较minCapacity和 MAX_ARRAY_SIZE</span><br>    <span class="hljs-variable">private</span> <span class="hljs-keyword">static</span> int <span class="hljs-title function_">hugeCapacity</span>(<span class="hljs-params">int</span> <span class="hljs-params">minCapacity</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">minCapacity</span> <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">OutOfMemoryError</span>();<br>        <span class="hljs-title function_">return</span> (<span class="hljs-variable">minCapacity</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">MAX_ARRAY_SIZE</span>) ?<br>                <span class="hljs-title class_">Integer</span>.<span class="hljs-property">MAX_VALUE</span> :<br>                <span class="hljs-variable">MAX_ARRAY_SIZE</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中的元素数。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> int <span class="hljs-title function_">size</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">size</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表不包含元素，则返回 true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">isEmpty</span>() &#123;<br>        <span class="hljs-comment">//注意=和==的区别</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">size</span> <span class="hljs-operator">==</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 如果此列表包含指定的元素，则返回true 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">contains</span>(<span class="hljs-params">Object</span> <span class="hljs-params">o</span>) &#123;<br>        <span class="hljs-comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">indexOf</span>(<span class="hljs-variable">o</span>) <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> int <span class="hljs-title function_">indexOf</span>(<span class="hljs-params">Object</span> <span class="hljs-params">o</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span> <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable">i</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-comment">//equals()方法比较</span><br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span>.<span class="hljs-property">equals</span>(<span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>]))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable">i</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> int <span class="hljs-title function_">lastIndexOf</span>(<span class="hljs-params">Object</span> <span class="hljs-params">o</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span> <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable">i</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> <span class="hljs-number">1</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&gt;=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span><span class="hljs-operator">-</span><span class="hljs-operator">-</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span>.<span class="hljs-property">equals</span>(<span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>]))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-variable">i</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">clone</span>() &#123;<br>        <span class="hljs-title function_">try</span> &#123;<br>            <span class="hljs-title class_">ArrayList</span><span class="hljs-operator">&lt;</span>?<span class="hljs-operator">&gt;</span> <span class="hljs-variable">v</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">ArrayList</span><span class="hljs-operator">&lt;</span>?<span class="hljs-operator">&gt;</span>) <span class="hljs-variable language_">super</span>.<span class="hljs-property">clone</span>();<br>            <span class="hljs-comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span><br>            <span class="hljs-variable">v</span>.<span class="hljs-property">elementData</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>);<br>            <span class="hljs-variable">v</span>.<span class="hljs-property">modCount</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-variable">v</span>;<br>        &#125; <span class="hljs-title function_">catch</span> (<span class="hljs-title class_">CloneNotSupportedException</span> <span class="hljs-variable">e</span>) &#123;<br>            <span class="hljs-comment">// 这不应该发生，因为我们是可以克隆的</span><br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">InternalError</span>(<span class="hljs-variable">e</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。</span><br><span class="hljs-comment">     * 返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。</span><br><span class="hljs-comment">     * 因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Object</span>[] <span class="hljs-title function_">toArray</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;</span><br><span class="hljs-comment">     * 返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。</span><br><span class="hljs-comment">     * 否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。</span><br><span class="hljs-comment">     * 如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。</span><br><span class="hljs-comment">     * （这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）</span><br><span class="hljs-comment">     */</span><br>    @<span class="hljs-title class_">SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>    <span class="hljs-variable">public</span> <span class="hljs-operator">&lt;</span><span class="hljs-variable">T</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">T</span>[] <span class="hljs-title function_">toArray</span>(<span class="hljs-params">T</span>[] <span class="hljs-params">a</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">a</span>.<span class="hljs-property">length</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>)<br>            <span class="hljs-comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span><br>            <span class="hljs-title function_">return</span> (<span class="hljs-variable">T</span>[]) <span class="hljs-title class_">Arrays</span>.<span class="hljs-property">copyOf</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>, <span class="hljs-variable">a</span>.<span class="hljs-property">getClass</span>());<br>        <span class="hljs-comment">//调用System提供的arraycopy()方法实现数组之间的复制</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">a</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">size</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">a</span>.<span class="hljs-property">length</span> <span class="hljs-operator">&gt;</span> <span class="hljs-variable">size</span>)<br>            <span class="hljs-variable">a</span>[<span class="hljs-variable">size</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">a</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// Positional Access Operations</span><br><br>    @<span class="hljs-title class_">SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>    <span class="hljs-variable">E</span> <span class="hljs-title function_">elementData</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-title function_">return</span> (<span class="hljs-variable">E</span>) <span class="hljs-variable">elementData</span>[index];<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">E</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-title function_">rangeCheck</span>(index);<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">elementData</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用指定的元素替换此列表中指定位置的元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">E</span> <span class="hljs-title function_">set</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>, <span class="hljs-params">E</span> <span class="hljs-params">element</span>) &#123;<br>        <span class="hljs-comment">//对index进行界限检查</span><br>        <span class="hljs-title function_">rangeCheck</span>(index);<br><br>        <span class="hljs-variable">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">elementData</span>(index);<br>        <span class="hljs-variable">elementData</span>[index] <span class="hljs-operator">=</span> <span class="hljs-variable">element</span>;<br>        <span class="hljs-comment">//返回原来在这个位置的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">oldValue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">E</span> <span class="hljs-params">e</span>) &#123;<br>        <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-variable">size</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>        <span class="hljs-variable">elementData</span>[<span class="hljs-variable">size</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>] <span class="hljs-operator">=</span> <span class="hljs-variable">e</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 在此列表中的指定位置插入指定的元素。</span><br><span class="hljs-comment">     * 先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；</span><br><span class="hljs-comment">     * 再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>, <span class="hljs-params">E</span> <span class="hljs-params">element</span>) &#123;<br>        <span class="hljs-title function_">rangeCheckForAdd</span>(index);<br><br>        <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-variable">size</span> <span class="hljs-operator">+</span> <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!</span><br>        <span class="hljs-comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, index, <span class="hljs-variable">elementData</span>, index <span class="hljs-operator">+</span> <span class="hljs-number">1</span>,<br>                <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> index);<br>        <span class="hljs-variable">elementData</span>[index] <span class="hljs-operator">=</span> <span class="hljs-variable">element</span>;<br>        <span class="hljs-variable">size</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">E</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-title function_">rangeCheck</span>(index);<br><br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>        <span class="hljs-variable">E</span> <span class="hljs-variable">oldValue</span> <span class="hljs-operator">=</span> <span class="hljs-title function_">elementData</span>(index);<br><br>        int <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> index <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">numMoved</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, index <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, <span class="hljs-variable">elementData</span>, index,<br>                    <span class="hljs-variable">numMoved</span>);<br>        <span class="hljs-variable">elementData</span>[<span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-variable">size</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>        <span class="hljs-comment">//从列表中删除的元素</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">oldValue</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。</span><br><span class="hljs-comment">     * 返回true，如果此列表包含指定的元素</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">remove</span>(<span class="hljs-params">Object</span> <span class="hljs-params">o</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span> <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (int index <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; index<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">elementData</span>[index] <span class="hljs-operator">==</span> <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-title function_">fastRemove</span>(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (int index <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; index <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; index<span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>                <span class="hljs-keyword">if</span> (<span class="hljs-variable">o</span>.<span class="hljs-property">equals</span>(<span class="hljs-variable">elementData</span>[index])) &#123;<br>                    <span class="hljs-title function_">fastRemove</span>(index);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>                &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * Private remove method that skips bounds checking and does not</span><br><span class="hljs-comment">     * return the value removed.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">fastRemove</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>        int <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> index <span class="hljs-operator">-</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">numMoved</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, index <span class="hljs-operator">+</span> <span class="hljs-number">1</span>, <span class="hljs-variable">elementData</span>, index,<br>                    <span class="hljs-variable">numMoved</span>);<br>        <span class="hljs-variable">elementData</span>[<span class="hljs-operator">-</span><span class="hljs-operator">-</span><span class="hljs-variable">size</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; <span class="hljs-comment">// clear to let GC do its work</span><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中删除所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">clear</span>() &#123;<br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br><br>        <span class="hljs-comment">// 把数组中所有的元素的值设为null</span><br>        <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>)<br>            <span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">Collection</span>&lt;? <span class="hljs-params">extends</span> <span class="hljs-params">E</span>&gt; <span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-title class_">Object</span>[] <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-variable">c</span>.<span class="hljs-property">toArray</span>();<br>        int <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> <span class="hljs-variable">a</span>.<span class="hljs-property">length</span>;<br>        <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-variable">size</span> <span class="hljs-operator">+</span> <span class="hljs-variable">numNew</span>);  <span class="hljs-comment">// Increments modCount</span><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">a</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">elementData</span>, <span class="hljs-variable">size</span>, <span class="hljs-variable">numNew</span>);<br>        <span class="hljs-variable">size</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">numNew</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">addAll</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>, <span class="hljs-params">Collection</span>&lt;? <span class="hljs-params">extends</span> <span class="hljs-params">E</span>&gt; <span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-title function_">rangeCheckForAdd</span>(index);<br><br>        <span class="hljs-title class_">Object</span>[] <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-variable">c</span>.<span class="hljs-property">toArray</span>();<br>        int <span class="hljs-variable">numNew</span> <span class="hljs-operator">=</span> <span class="hljs-variable">a</span>.<span class="hljs-property">length</span>;<br>        <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-variable">size</span> <span class="hljs-operator">+</span> <span class="hljs-variable">numNew</span>);  <span class="hljs-comment">// Increments modCount</span><br><br>        int <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> index;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">numMoved</span> <span class="hljs-operator">&gt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, index, <span class="hljs-variable">elementData</span>, index <span class="hljs-operator">+</span> <span class="hljs-variable">numNew</span>,<br>                    <span class="hljs-variable">numMoved</span>);<br><br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">a</span>, <span class="hljs-number">0</span>, <span class="hljs-variable">elementData</span>, index, <span class="hljs-variable">numNew</span>);<br>        <span class="hljs-variable">size</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">numNew</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">numNew</span> <span class="hljs-operator">!=</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。</span><br><span class="hljs-comment">     * 将任何后续元素移动到左侧（减少其索引）。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">protected</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">removeRange</span>(<span class="hljs-params">int</span> <span class="hljs-params">fromIndex</span>, <span class="hljs-params">int</span> <span class="hljs-params">toIndex</span>) &#123;<br>        <span class="hljs-variable">modCount</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>;<br>        int <span class="hljs-variable">numMoved</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> <span class="hljs-variable">toIndex</span>;<br>        <span class="hljs-title class_">System</span>.<span class="hljs-property">arraycopy</span>(<span class="hljs-variable">elementData</span>, <span class="hljs-variable">toIndex</span>, <span class="hljs-variable">elementData</span>, <span class="hljs-variable">fromIndex</span>,<br>                <span class="hljs-variable">numMoved</span>);<br><br>        <span class="hljs-comment">// clear to let GC do its work</span><br>        int <span class="hljs-variable">newSize</span> <span class="hljs-operator">=</span> <span class="hljs-variable">size</span> <span class="hljs-operator">-</span> (<span class="hljs-variable">toIndex</span> <span class="hljs-operator">-</span> <span class="hljs-variable">fromIndex</span>);<br>        <span class="hljs-keyword">for</span> (int <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-variable">newSize</span>; <span class="hljs-variable">i</span> <span class="hljs-operator">&lt;</span> <span class="hljs-variable">size</span>; <span class="hljs-variable">i</span><span class="hljs-operator">+</span><span class="hljs-operator">+</span>) &#123;<br>            <span class="hljs-variable">elementData</span>[<span class="hljs-variable">i</span>] <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-variable">newSize</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查给定的索引是否在范围内。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">rangeCheck</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (index <span class="hljs-operator">&gt;=</span> <span class="hljs-variable">size</span>)<br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-title function_">outOfBoundsMsg</span>(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * add和addAll使用的rangeCheck的一个版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-variable">void</span> <span class="hljs-title function_">rangeCheckForAdd</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (index <span class="hljs-operator">&gt;</span> <span class="hljs-variable">size</span> <span class="hljs-operator">||</span> index <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span>)<br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-title function_">outOfBoundsMsg</span>(index));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回IndexOutOfBoundsException细节信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">private</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">outOfBoundsMsg</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Index: &quot;</span> <span class="hljs-operator">+</span> index <span class="hljs-operator">+</span> <span class="hljs-string">&quot;, Size: &quot;</span> <span class="hljs-operator">+</span> <span class="hljs-variable">size</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从此列表中删除指定集合中包含的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">removeAll</span>(<span class="hljs-params">Collection</span>&lt;?&gt; <span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-title class_">Objects</span>.<span class="hljs-property">requireNonNull</span>(<span class="hljs-variable">c</span>);<br>        <span class="hljs-comment">//如果此列表被修改则返回true</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchRemove</span>(<span class="hljs-variable">c</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 仅保留此列表中包含在指定集合中的元素。</span><br><span class="hljs-comment">     * 换句话说，从此列表中删除其中不包含在指定集合中的所有元素。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-variable">boolean</span> <span class="hljs-title function_">retainAll</span>(<span class="hljs-params">Collection</span>&lt;?&gt; <span class="hljs-params">c</span>) &#123;<br>        <span class="hljs-title class_">Objects</span>.<span class="hljs-property">requireNonNull</span>(<span class="hljs-variable">c</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">batchRemove</span>(<span class="hljs-variable">c</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。</span><br><span class="hljs-comment">     * 指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">ListIterator</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span> <span class="hljs-title function_">listIterator</span>(<span class="hljs-params">int</span> <span class="hljs-params">index</span>) &#123;<br>        <span class="hljs-keyword">if</span> (index <span class="hljs-operator">&lt;</span> <span class="hljs-number">0</span> <span class="hljs-operator">||</span> index <span class="hljs-operator">&gt;</span> <span class="hljs-variable">size</span>)<br>            <span class="hljs-variable">throw</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">IndexOutOfBoundsException</span>(<span class="hljs-string">&quot;Index: &quot;</span> <span class="hljs-operator">+</span> index);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">ListItr</span>(index);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 返回列表中的列表迭代器（按适当的顺序）。</span><br><span class="hljs-comment">     * 返回的列表迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">ListIterator</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span> <span class="hljs-title function_">listIterator</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">ListItr</span>(<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以正确的顺序返回该列表中的元素的迭代器。</span><br><span class="hljs-comment">     * 返回的迭代器是fail-fast 。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Iterator</span><span class="hljs-operator">&lt;</span><span class="hljs-variable">E</span><span class="hljs-operator">&gt;</span> <span class="hljs-title function_">iterator</span>() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">Itr</span>();<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="二、ArrayList-扩容机制"><a href="#二、ArrayList-扩容机制" class="headerlink" title="二、ArrayList 扩容机制"></a>二、ArrayList 扩容机制</h3><p>先了解一下基础的 ArrayList 的扩容机制概念：<code>ArrayList</code> 的内部使用数组存储元素，当添加的元素超过当前数组容量时，<code>ArrayList</code> 会自动扩容（通常是扩大到原来的 1.5 倍），以容纳更多的元素。</p><p>这里以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="小结-★★"><a href="#小结-★★" class="headerlink" title="小结  ★★"></a>小结  ★★</h4><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><p>通过面试题的方式来回答这个问题：</p><blockquote><p>讲一下 ArrayList 的扩容机制。</p></blockquote><p>ArrayList 的默认初始容量是10，容量不足时，会扩容到原来的 1.5 倍。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240208120458.png" alt="image.png"></p><h3 id="记录-Records"><a href="#记录-Records" class="headerlink" title="记录 Records"></a>记录 Records</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>HashMap保证key的不重复性，对于重复的key，HashMap会根据参数onlyIfAbsent的设置和原value是否为空两个条件来<strong>判断是否替换新value</strong>，</p><p>但要注意的是，对于HashSet，这个value只是个空的Object类的对象，没有任何实际作用，HashSet中的元素实际上是存储在key上的。针对重复的key，<strong>HashMap只有对于value的处理，并不会替换key</strong>，因此在HashSet中加入相同元素不会覆盖。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><p><strong>总结</strong>：结果向HashSet中加入相同元素不会进行覆盖。因为HashSet底层使用HashMap实现，元素存在HashMap的key中。在HashMap中，多次put相同的key，只会覆盖value，而不存在key的情况。</p><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢"><a href="#4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢" class="headerlink" title="4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢"></a>4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢</h4><p>为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？</p><p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p><p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会<strong>显著提高效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h3><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍<br>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p><h3 id="常用的一些命令"><a href="#常用的一些命令" class="headerlink" title="常用的一些命令"></a>常用的一些命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看用户名 ：git config <span class="hljs-keyword">user</span>.name<br><br>查看密码： git config <span class="hljs-keyword">user</span>.<span class="hljs-keyword">password</span><br><br>查看邮箱：git config <span class="hljs-keyword">user</span>.email<br><br>查看配置信息： $ git config <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门_基本操作</title>
    <link href="/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>基本的一些 Git 入门操作记录</p><h3 id="1、将某个目录文件上传到-Github-某个仓库"><a href="#1、将某个目录文件上传到-Github-某个仓库" class="headerlink" title="1、将某个目录文件上传到 Github 某个仓库"></a>1、将某个目录文件上传到 Github 某个仓库</h3><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p><blockquote><p>Git的工作流程核心</p></blockquote><ul><li>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</li><li>1、<strong>搬砖</strong>：在工作目录中添加、修改代码。</li><li>2、<strong>暂存</strong>（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>3、<strong>提交</strong>（git commit）：将暂存区域的文件提交到Git仓库。</li><li>4、<strong>推送</strong>（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>5、<strong>获取更新</strong>（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250040140.png" alt="image.png"></p><ul><li><code>git commit -a</code>指令省略了<code>add</code>到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是<code>git pull</code>多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、 <code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code>是专门用来撤销修改、回退版本的指令，替代上面<code>checkout</code>的撤销功能。</li></ul><hr><p>参考</p><ul><li><a href="https://www.cnblogs.com/anding/p/16987769.html">https://www.cnblogs.com/anding/p/16987769.html</a></li><li><a href="https://git-scm.com/book/zh/v2/">https://git-scm.com/book/zh/v2/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
