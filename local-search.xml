<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>obsidian常用插件使用记录</title>
    <link href="/2024/01/12/obsidian%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2024/01/12/obsidian%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>插件功能</p><ul><li>导出 pdf 带上目录</li></ul><hr><h4 id="1、导出-pdf-带上目录"><a href="#1、导出-pdf-带上目录" class="headerlink" title="1、导出 pdf 带上目录"></a>1、导出 pdf 带上目录</h4><p>使用 better-export-pdf 导出 pdf 带上目录</p><p>这个插件需要下载使用，下载地址：  <a href="https://github.com/l1xnan/obsidian-better-export-pdf/releases">https://github.com/l1xnan/obsidian-better-export-pdf/releases</a></p><p>下载对应的 obsidian-better-export-pdf.zip 文件即可。</p><p>参考： <a href="https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/better-export-pdf/">https://pkmer.cn/Pkmer-Docs/10-obsidian/obsidian%E7%A4%BE%E5%8C%BA%E6%8F%92%E4%BB%B6/better-export-pdf/</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7系统_常用操作</title>
    <link href="/2024/01/12/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2024/01/12/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1、防火墙"><a href="#1、防火墙" class="headerlink" title="1、防火墙"></a>1、防火墙</h3><blockquote><p>查看防火墙状态</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">firewall-cmd <span class="hljs-comment">--state</span><br></code></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl stop firewalld   <span class="hljs-comment"># 关闭防火墙</span><br><span class="hljs-params">system</span>ctl start firewalld  <span class="hljs-comment"># 启动防火墙</span><br>firewall-cmd --reload      <span class="hljs-comment"># 重启防火墙</span><br><span class="hljs-params">system</span>ctl disable firewalld  <span class="hljs-comment"># 禁用防火墙</span><br></code></pre></td></tr></table></figure><blockquote><p>开放防火墙端口</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --query-port=80/tcp   <span class="hljs-comment">#端口开放情况</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --list-ports  <span class="hljs-comment">#查看开放的端口</span></span><br><br><span class="hljs-comment">#开放端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8080/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8083-8085/tcp</span><br><br><span class="hljs-comment">#关闭端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --remove-port=8083-8085/tcp</span><br></code></pre></td></tr></table></figure><p>端口开放后建议重启一下防火墙</p><h3 id="2、查看服务器状态"><a href="#2、查看服务器状态" class="headerlink" title="2、查看服务器状态"></a>2、查看服务器状态</h3><p>常用的Linux命令：</p><h4 id="CPU使用情况"><a href="#CPU使用情况" class="headerlink" title="CPU使用情况"></a>CPU使用情况</h4><ol><li><p><strong>top</strong>:</p><ul><li><code>top</code> 命令用于实时显示系统中各个进程的资源占用状况。</li><li>它显示的信息包括系统运行时间、当前登录用户数、系统负载、进程总数、CPU使用率、内存使用率等。</li></ul></li><li><p><strong>vmstat</strong>:</p><ul><li><code>vmstat</code>（Virtual Memory Statistics）命令用于展示虚拟内存、进程、CPU活动等信息。</li><li>例如：<code>vmstat 1 5</code> 每1秒刷新一次，共显示5次数据。</li></ul></li></ol><h4 id="内存使用情况"><a href="#内存使用情况" class="headerlink" title="内存使用情况"></a>内存使用情况</h4><ol><li><p><strong>free</strong>:</p><ul><li><code>free</code> 命令用于显示系统的空闲、使用中和交换内存的信息。</li><li>例如：<code>free -h</code> 显示易于阅读的格式。</li></ul></li><li><p><strong>htop</strong>:</p><ul><li><code>htop</code> 是 <code>top</code> 命令的一个增强版本，提供了更多信息，界面更友好。</li><li>它需要在某些Linux发行版上单独安装。</li></ul></li></ol><h4 id="磁盘使用情况"><a href="#磁盘使用情况" class="headerlink" title="磁盘使用情况"></a>磁盘使用情况</h4><ol><li><p><strong>df</strong>:</p><ul><li><code>df</code>（Disk Free）命令用于显示系统中每个文件系统的总空间、已用空间和可用空间。</li><li>例如：<code>df -h</code> 显示易于阅读的格式。</li></ul></li><li><p><strong>du</strong>:</p><ul><li><code>du</code>（Disk Usage）命令用于显示指定文件或目录占用的磁盘空间。</li><li>例如：<code>du -sh /path/to/directory</code> 显示指定目录的总空间占用。</li></ul></li></ol><h4 id="网络使用情况"><a href="#网络使用情况" class="headerlink" title="网络使用情况"></a>网络使用情况</h4><ol><li><p><strong>netstat</strong>:</p><ul><li><code>netstat</code> 命令用于显示网络连接、路由表、接口统计等网络信息。</li><li>例如：<code>netstat -tulnp</code> 显示所有监听端口。</li></ul></li><li><p><strong>ss</strong>:</p><ul><li><code>ss</code>（Socket Statistics）命令是 <code>netstat</code> 的一个现代替代品，用于显示套接字统计信息。</li><li>例如：<code>ss -tuln</code> 显示监听端口。</li></ul></li></ol><h4 id="系统活动和性能"><a href="#系统活动和性能" class="headerlink" title="系统活动和性能"></a>系统活动和性能</h4><ol><li><p><strong>sar</strong>:</p><ul><li><code>sar</code> 命令用于收集、报告或保存系统活动信息，它是sysstat包的一部分。</li><li>例如：<code>sar -u 1 5</code> 每秒报告一次CPU使用情况，共报告5次。</li></ul></li><li><p><strong>iostat</strong>:</p><ul><li><code>iostat</code> 命令用于显示CPU统计信息和所有分区的I&#x2F;O统计信息。</li><li>它有助于监控系统的输入&#x2F;输出设备负载。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门_Docker的基本使用</title>
    <link href="/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、安装-Docker操作-centos系列安装"><a href="#1、安装-Docker操作-centos系列安装" class="headerlink" title="1、安装 Docker操作 (centos系列安装)"></a>1、安装 Docker操作 (centos系列安装)</h3><p>安装操作</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum install -<span class="hljs-keyword">y</span> yum-utils<br><br>yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br><br><br>yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>启动docer并设置开机自启</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker<br><br><span class="hljs-params">system</span>ctl enable docker<br></code></pre></td></tr></table></figure><p>docker配置加速度</p><p>修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件并添加上 registry-mirrors 键值；注册阿里云，可获取自己的加速器</p><p>容器镜像服务 →  容器加速器</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;. <br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>docker安装验证</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h3 id="2、docker-compose安装"><a href="#2、docker-compose安装" class="headerlink" title="2、docker-compose安装"></a>2、docker-compose安装</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。</p><p>使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</p><blockquote><p>安装操作</p></blockquote><p>先需要下载一下二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v2.5.0/</span>docker-compose-linux-x86_64<br></code></pre></td></tr></table></figure><p>放入&#x2F;usr&#x2F;local&#x2F;bin&#x2F; 路径下并重新命名添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 docker-compose<br><span class="hljs-built_in">chmod</span> +x docker-compose<br></code></pre></td></tr></table></figure><p>这个也可以推荐看一下</p><p>将脚本下载，阿里云的下载速度较快，推荐适用</p><p><a href="https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/">https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/</a></p><p>把脚本放在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;下.名字为docker-compose ,加执行权限 ，docker-compose命令就有了</p><h3 id="3、docker-安装-redis-操作"><a href="#3、docker-安装-redis-操作" class="headerlink" title="3、docker 安装 redis 操作"></a>3、docker 安装 redis 操作</h3><p>安装 Redis 使用 Docker 是一个非常简单且快捷的过程。以下是通过 Docker 安装和运行 Redis 的基本步骤：</p><ol><li><p><strong>拉取 Redis 镜像</strong>： 首先，你需要从 Docker Hub 拉取最新的 Redis 镜像。打开命令行界面，然后输入以下命令：</p><p> <code>docker pull redis</code></p><p> 这个命令会从 Docker Hub 下载最新的 Redis 镜像。</p></li><li><p><strong>运行 Redis 容器</strong>： 接着，使用以下命令来启动一个 Redis 容器：</p><p> <code>docker run --name redis -d redis</code></p><p> 这里，<code>--name redis</code> 设置容器的名称为 <code>some-redis</code>。你可以根据需要更改这个名称。<code>-d</code> 参数表示容器将在后台运行。</p></li><li><p><strong>暴露和映射端口</strong>（可选）： 如果你打算从宿主机外部访问 Redis，你需要映射端口。Redis 默认端口是 <code>6379</code>，所以你可以这样映射端口：</p><p> <code>docker run --name redis -d -p 6379:6379 redis</code></p><p> <code>-p 6379:6379</code> 表示将容器的 6379 端口映射到宿主机的 6379 端口。</p></li><li><p><strong>访问 Redis</strong>： 一旦 Redis 容器在运行，你可以通过 Redis 客户端或任何支持 Redis 的程序访问它。如果你只是在本地机器上运行和访问 Redis，你可以通过 <code>localhost:6379</code> 来访问它。</p></li><li><p><strong>使用 Redis CLI 进行交互</strong>（可选）： 如果你想要通过 Redis 命令行界面与 Redis 容器交互，可以使用以下命令进入 Redis 容器：</p><p> <code>docker exec -it some-redis redis-cli</code></p></li></ol><p>小结：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker pull redis<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> --name redis -d -p 6379:6379 redis</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=6379/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><h3 id="4、docker-的一些常用命令-🦌"><a href="#4、docker-的一些常用命令-🦌" class="headerlink" title="4、docker 的一些常用命令   🦌"></a>4、docker 的一些常用命令   🦌</h3><p>常用的Docker命令：</p><h4 id="容器管理"><a href="#容器管理" class="headerlink" title="容器管理"></a>容器管理</h4><p>1、 <strong>启动容器</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker run <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[COMMAND]</span> <span class="hljs-selector-attr">[ARG...]</span><br></code></pre></td></tr></table></figure><p>例如：<code>docker run -d -p 80:80 nginx</code> 会以守护态运行一个nginx容器，并将本机的80端口映射到容器的80端口。</p><p>2、<strong>列出容器</strong>:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> ps<span class="hljs-meta"> [OPTIONS]</span><br></code></pre></td></tr></table></figure><ul><li>只显示运行中的容器：<code>docker ps</code></li><li>显示所有容器（包括未运行的）：<code>docker ps -a</code></li></ul><p>3、 <strong>停止容器</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker stop <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker stop my_container</code> 停止名为 <code>my_container</code> 的容器。</li></ul><p>4、<strong>删除容器</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker rm <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker rm my_container</code> 删除名为 <code>my_container</code> 的容器。</li></ul><p>5、<strong>查看容器日志</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker logs <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker logs my_container</code> 查看名为 <code>my_container</code> 的容器的日志。</li></ul><p>6、重启 docker 容器</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker restart <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-keyword">CONTAINER</span> <span class="hljs-comment">[CONTAINER...]</span><br></code></pre></td></tr></table></figure><p>如果你的容器名称是 <code>my_container</code>，那么重启这个容器的命令将是：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docker restart my_container</span><br></code></pre></td></tr></table></figure><h4 id="镜像管理"><a href="#镜像管理" class="headerlink" title="镜像管理"></a>镜像管理</h4><p>1、<strong>列出镜像</strong>:</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">docker images <span class="hljs-comment">[OPTIONS]</span> <span class="hljs-comment">[REPOSITORY<span class="hljs-comment">[:TAG]</span>]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker images</code> 列出所有本地镜像。</li></ul><p>2、<strong>拉取镜像</strong>:</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir">docker pull [<span class="hljs-title class_">OPTIONS</span>] <span class="hljs-title class_">NAME</span>[<span class="hljs-symbol">:TAG|</span><span class="hljs-variable">@DIGEST</span>]<br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker pull nginx</code> 拉取最新的nginx镜像。</li></ul><p>3、<strong>构建镜像</strong>:</p><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gherkin">docker build [OPTIONS] PATH |<span class="hljs-string"> URL </span>|<span class="hljs-string"> -</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker build -t my_image .</code> 会根据当前目录下的 <code>Dockerfile</code> 构建一个名为 <code>my_image</code> 的镜像。</li></ul><p>4、 <strong>删除镜像</strong>:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">docker rmi <span class="hljs-selector-attr">[OPTIONS]</span> IMAGE <span class="hljs-selector-attr">[IMAGE...]</span><br></code></pre></td></tr></table></figure><ul><li>例如：<code>docker rmi my_image</code> 删除名为 <code>my_image</code> 的镜像。</li></ul><h4 id="网络管理"><a href="#网络管理" class="headerlink" title="网络管理"></a>网络管理</h4><ol><li><p><strong>列出网络</strong>:</p><p> <code>docker network ls</code></p></li><li><p><strong>创建网络</strong>:</p><p> <code>docker network create [OPTIONS] NETWORK  </code></p><ul><li>例如：<code>docker network create my_network</code> 创建一个名为 <code>my_network</code> 的网络。</li></ul></li><li><p><strong>删除网络</strong>:</p><p> <code>docker network rm NETWORK</code></p><ul><li>例如：<code>docker network rm my_network</code> 删除名为 <code>my_network</code> 的网络。</li></ul></li></ol><h4 id="卷管理"><a href="#卷管理" class="headerlink" title="卷管理"></a>卷管理</h4><ol><li><p><strong>创建卷</strong>:</p><p> <code>docker volume create [OPTIONS] [VOLUME]</code></p><ul><li>例如：<code>docker volume create my_volume</code> 创建一个名为 <code>my_volume</code> 的卷。</li></ul></li><li><p><strong>列出卷</strong>:</p><p> <code>docker volume ls</code></p></li><li><p><strong>删除卷</strong>:</p><p> <code>docker volume rm VOLUME</code></p><ul><li>例如：<code>docker volume rm my_volume</code> 删除名为 <code>my_volume</code> 的卷。</li></ul></li></ol><h4 id="其他常用命令"><a href="#其他常用命令" class="headerlink" title="其他常用命令"></a>其他常用命令</h4><ol><li><p><strong>查看Docker版本</strong>:</p><p> <code>docker version</code></p></li><li><p><strong>查看Docker系统信息</strong>:</p><p> <code>docker info</code></p></li><li><p><strong>查看容器&#x2F;镜像&#x2F;卷等的详细信息</strong>:</p><p> <code>docker inspect NAME|ID</code></p></li></ol><h3 id="5、docker-安装-Mysql-操作"><a href="#5、docker-安装-Mysql-操作" class="headerlink" title="5、docker 安装 Mysql 操作"></a>5、docker 安装 Mysql 操作</h3><p>以下是使用Docker安装和运行MySQL 5.7和8.0版本的步骤：</p><blockquote><ol><li><strong>运行MySQL 5.7</strong></li></ol></blockquote><ol><li><p><strong>拉取MySQL 5.7镜像</strong>:</p><p> <code>docker pull mysql:5.7</code></p></li><li><p><strong>启动MySQL 5.7容器</strong>:</p></li></ol><p>以下命令启动一个名为 <code>mysql57</code> 的MySQL 5.7容器，设置root密码（在此示例中为<code>yourpassword</code>），并映射端口3306（或选择其他未使用的端口）到宿主机。<br>同时，你可以指定一个数据卷来持久化MySQL数据。</p><p><code>docker run --name mysql57 -e MYSQL_ROOT_PASSWORD=yourpassword -p 3306:3306 -d mysql:5.7</code></p><ul><li>如果需要持久化数据到特定路径，可以添加 <code>-v</code> 参数，如:</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql57 -e MYSQL_ROOT_PASSWORD=yourpassword -p <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -v /my/own/datadir:/var/lib/mysql -d mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><blockquote><ol start="2"><li><strong>运行MySQL 8.0</strong></li></ol></blockquote><ol><li><p><strong>拉取MySQL 8.0镜像</strong>:</p><p> <code>docker pull mysql:8.0</code></p></li><li><p><strong>启动MySQL 8.0容器</strong>:</p></li></ol><ul><li>由于MySQL 5.7已经使用了3306端口，所以对于MySQL 8.0，你需要映射到宿主机的另一个端口，例如3307。</li></ul><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run --name mysql8 -e MYSQL_ROOT_PASSWORD=yourpassword -p <span class="hljs-number">3307</span>:<span class="hljs-number">3306</span> -d mysql:<span class="hljs-number">8</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><ul><li>同样，你也可以指定数据卷来持久化MySQL 8.0的数据。</li><li><code>mysql:8.0</code> 指的是Docker镜像的名称和标签。在这里，<code>mysql</code> 是镜像的名称，<code>8.0</code> 是镜像的标签，它指定了MySQL的具体版本。</li></ul><ol start="3"><li><p><strong>验证和连接</strong></p></li><li><p><strong>验证容器运行状态</strong>:</p><p> <code>docker ps</code></p></li><li><p><strong>连接到MySQL容器</strong>:</p></li></ol><p>使用Docker内置的命令行或者使用任何MySQL客户端连接到数据库。例如，要连接到MySQL 5.7实例，可以使用：<br><code>docker exec -it mysql57 mysql -uroot -pyourpassword</code></p><ul><li>对于MySQL 8.0，连接命令类似，只是容器名称不同。</li></ul><blockquote><p>注意事项</p></blockquote><ul><li>替换上述命令中的 <code>yourpassword</code> 为你自己的强密码。</li><li>如果你使用了自定义数据卷路径（如 <code>/my/own/datadir</code>），确保该路径在宿主机上存在，并且Docker有权限访问。</li><li>MySQL 8.0 默认使用了更强的密码加密策略（caching_sha2_password），某些客户端可能需要更新或配置以支持新的加密方式。</li></ul><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_45868731/article/details/131743699">https://blog.csdn.net/qq_45868731/article/details/131743699</a></li><li><a href="https://blog.csdn.net/ninimino/article/details/113388745">https://blog.csdn.net/ninimino/article/details/113388745</a></li><li><a href="https://blog.csdn.net/weixin_45821811/article/details/116211724">https://blog.csdn.net/weixin_45821811/article/details/116211724</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_Java基础_String常见面试题</title>
    <link href="/2024/01/11/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%9F%BA%E7%A1%80_String%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2024/01/11/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%9F%BA%E7%A1%80_String%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这种奇怪的题目还不少，待记录和理解一下。</p><p>to be contined…</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot项目部署方案</title>
    <link href="/2024/01/11/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/"/>
    <url>/2024/01/11/SpringBoot%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>记录一些常用操作：</p><h3 id="1、profiles指定不同环境的配置"><a href="#1、profiles指定不同环境的配置" class="headerlink" title="1、profiles指定不同环境的配置"></a>1、profiles指定不同环境的配置</h3><p>一般用于区别不同的环境，常见的 开发、测试、正式</p><p>环境区分配置文件，可以通过两种方式：</p><ul><li><p>通过application.yml中编码指定 <code>profile.active=uat</code> 方式指定</p></li><li><p>通过mvn中profiles来区分不同环境对应的配置文件夹，人工可以手动在idea勾选生成不同环境的包(推荐)</p></li></ul><h4 id="application-yml-编码指定"><a href="#application-yml-编码指定" class="headerlink" title="application.yml 编码指定"></a>application.yml 编码指定</h4><p>略</p><h4 id="mvn-→-profiles-区分"><a href="#mvn-→-profiles-区分" class="headerlink" title="mvn → profiles 区分"></a>mvn → profiles 区分</h4><p>在mvn中配置如下内容</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-comment">&lt;!--传递给脚本的参数值--&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node1<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>node2<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>node2<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">package-name</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_packageName&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">package-name</span>&gt;</span>  </span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">boot-main</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;scripts_bootMain&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">boot-main</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p>看一下下面这个解释</p><p><strong>节点粗解：</strong></p><p><strong>id：</strong> 用来指定不同环境配置文件所在的目录:</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401110850243.png" alt="image.png"></p><p>而在上面的代码中，在给定的配置中，定义了三个 <code>profile</code>，分别是 <code>node</code>, <code>node1</code>, 和 <code>node2</code>。每个 <code>profile</code> 中定义了一些 <code>properties</code>，这些属性可以在构建过程中使用</p><p><strong>properties：</strong> </p><p>该节点中的节点是可作为参数传递给其他配置文件，上面代码中的package-name节点值可以在另外的assembly.xml或者shell脚本文件中通过<code>$&#123;package-name&#125;</code>获取到，如下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401110851350.png" alt="image.png"></p><p><strong>activeByDefault：</strong> 指定默认环境配置文件夹</p><p>↑ 看了一下大概的解释，这里的用法大概是在 pom 依赖配置文件中定义一下对应的 profile 的节点 id ；并配置对应文件夹（在 profiles 文件夹下）</p><p>通过不同的文件夹对应不同的 yml 配置文件</p><p>然后在打包或者运行的时候通过 类似这种命令来操作 <code>mvn clean install -Pnode1</code>  ；具体待实践一下。</p><h3 id="2、maven-assembly-plugin打-发布压缩包"><a href="#2、maven-assembly-plugin打-发布压缩包" class="headerlink" title="2、maven-assembly-plugin打  发布压缩包"></a>2、maven-assembly-plugin打  发布压缩包</h3><p>先记录一下，具体没用过，暂时不太清楚</p><p>具体内容看参考链接： <a href="https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ">https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ</a></p><p>to be contined….</p><p>后续内容待实际部署的时候使用一下，再进行记录</p><hr><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ">https://mp.weixin.qq.com/s/yGPnk-bTkcBUiVq2FZsrBQ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>springboot</tag>
      
      <tag>Build</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20240110</title>
    <link href="/2024/01/10/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%9220240110/"/>
    <url>/2024/01/10/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%9220240110/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><ul><li><input disabled="" type="checkbox"> 面试题学习，准备一下八股（主要根据面试指北和Java面试库学习），继续完善知识库内容</li><li><input disabled="" type="checkbox"> 蘑菇项目继续学习，实际练习，从需求分析到架构设计，到最后的实现，写一下主要过程。部分内容待学习。</li><li><input disabled="" type="checkbox"> 学习一下码农会锁知识星球里面的项目，并真正加强自己的实际代码能力和编程能力</li><li><input disabled="" type="checkbox"> 写一个自习室项目和酒店管理项目。（可选）</li><li><input disabled="" type="checkbox"> 有空可以模仿写一个Java面试库项目，包括小程序版本。（可选）</li><li><input disabled="" type="checkbox"> 项目优化（Excel 优化导入和 接口配置）</li><li><input disabled="" type="checkbox"> 简历准备和完善（持续优化），准备投递</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day05</title>
    <link href="/2024/01/08/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day05/"/>
    <url>/2024/01/08/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day05/</url>
    
    <content type="html"><![CDATA[<h4 id="1、防止重复提交"><a href="#1、防止重复提交" class="headerlink" title="1、防止重复提交"></a>1、防止重复提交</h4><p><code>AvoidRepeatableCommitAspect</code> 类是一个Spring AOP切面，用于防止接口的重复提交。</p><p>这个切面通过拦截被 <code>@AvoidRepeatableCommit</code> 注解标记的方法，并在Redis中记录请求的状态来实现。</p><p>下面是对这个切面类实现的详细解释和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AvoidRepeatableCommitAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知：拦截所有标记了<span class="hljs-doctag">@AvoidRepeatableCommit</span>的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 连接点，提供对拦截方法的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行的结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(com.moxi.mogublog.admin.annotion.AvoidRepeatableCommit.AvoidRepeatableCommit)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br>        <span class="hljs-comment">// 获取请求者的IP地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br><br>        <span class="hljs-comment">// 获取注解的方法</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br>        <span class="hljs-comment">// 获取目标类名和方法名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br><br>        <span class="hljs-comment">// 构建一个基于类名和方法名的唯一标识</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipKey</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s#%s&quot;</span>, className, methodName);<br><br>        <span class="hljs-comment">// 转换成HashCode，用于生成Redis key</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> Math.abs(ipKey.hashCode());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s:%s_%d&quot;</span>, RedisConf.AVOID_REPEATABLE_COMMIT, ip, hashCode);<br><br>        log.info(<span class="hljs-string">&quot;ipKey=&#123;&#125;, hashCode=&#123;&#125;, key=&#123;&#125;&quot;</span>, ipKey, hashCode, key);<br><br>        <span class="hljs-comment">// 获取注解实例，以及注解中的超时时间</span><br>        <span class="hljs-type">AvoidRepeatableCommit</span> <span class="hljs-variable">avoidRepeatableCommit</span> <span class="hljs-operator">=</span> method.getAnnotation(AvoidRepeatableCommit.class);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> avoidRepeatableCommit.timeout();<br><br>        <span class="hljs-comment">// 检查Redis中是否存在该key</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisUtil.get(key);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(value)) &#123;<br>            log.info(<span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>            <span class="hljs-keyword">return</span> ResultUtil.result(SysConf.ERROR, <span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置Redis key以防止短时间内的重复提交</span><br>        redisUtil.setEx(key, StringUtils.getUUID(), timeout, TimeUnit.MILLISECONDS);<br><br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中：</p><ol><li>使用 <code>@Aspect</code> 标记这个类为一个切面，并通过 <code>@Component</code> 注册到Spring容器。</li><li><code>@Around</code> 注解定义了一个环绕通知，拦截所有使用 <code>@AvoidRepeatableCommit</code> 注解的方法。</li><li>在通知方法内，首先获取请求者的IP地址和目标方法的信息，然后构建一个唯一的Redis key。</li><li>通过检查Redis中该key的存在与否来判断是否已经提交过相同的请求。如果已经提交过，返回错误信息，防止重复处理。</li><li>如果没有提交过，将该key存储到Redis中，并设置过期时间为注解中指定的超时时间。</li><li>最后，执行被拦截的方法。</li></ol><p>这种实现方式有效地利用了Redis来防止短时间内的重复提交，适用于表单提交等需要防止重复操作的场景。<br>通过这个切面，可以增强应用的健壮性，防止由于重复提交导致的数据问题或资源浪费。</p><h4 id="2、邮件功能"><a href="#2、邮件功能" class="headerlink" title="2、邮件功能"></a>2、邮件功能</h4><p>略，后续实际运行看一下并进行分析。</p><p>类： RabbitMqUtil、SendMailUtils、SmsUtil</p><p>通过这个工具类来进行发送邮件。</p><h4 id="3、切面：限制请求访问"><a href="#3、切面：限制请求访问" class="headerlink" title="3、切面：限制请求访问"></a>3、切面：限制请求访问</h4><p><code>RequestLimitAspect</code> 类是一个Spring AOP切面，用于限制接口请求的频率。这个切面通过Redis实现请求的计数和时间限制。</p><p>下面是对这个切面类实现的详细解释和注释：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RequestLimitAspect</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">POINT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;execution(* com.moxi.mogublog.web.restapi..*.*(..))&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RequestLimitConfig requestLimitConfig;<br><br>    <span class="hljs-meta">@Pointcut(POINT)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">()</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知：用于在方法执行前后进行请求限制的检查。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 连接点，提供对拦截方法的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-keyword">if</span> (requestLimitConfig.getStart()) &#123;<br>            <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>            <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attribute.getRequest();<br><br>            <span class="hljs-comment">// 获取IP和请求路径</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURL().toString();<br><br>            <span class="hljs-comment">// 获取方法名称</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> point.getSignature().getName();<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> RedisConf.REQUEST_LIMIT + RedisConf.SEGMENTATION + ip + RedisConf.SEGMENTATION + methodName;<br><br>            <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.getMethod(point);<br><br>            <span class="hljs-comment">// 检查方法是否有RequestLimit注解</span><br>            <span class="hljs-keyword">if</span> (currentMethod.isAnnotationPresent(RequestLimit.class)) &#123;<br>                <span class="hljs-type">RequestLimit</span> <span class="hljs-variable">requestLimit</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(RequestLimit.class);<br>                <span class="hljs-type">boolean</span> <span class="hljs-variable">checkResult</span> <span class="hljs-operator">=</span> checkWithRedis(requestLimit.amount(), requestLimit.time(), key);<br>                <span class="hljs-keyword">if</span> (checkResult) &#123;<br>                    log.info(<span class="hljs-string">&quot;requestLimited, [用户ip:&#123;&#125;], [访问地址:&#123;&#125;]超过了限定的次数[&#123;&#125;]次&quot;</span>, ip, url, requestLimit.amount());<br>                    <span class="hljs-keyword">return</span> ResultUtil.result(ECode.REQUEST_OVER_LIMIT, <span class="hljs-string">&quot;接口请求过于频繁&quot;</span>);<br>                &#125;<br>                <span class="hljs-keyword">return</span> point.proceed();<br>            &#125;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">checkResult</span> <span class="hljs-operator">=</span> checkWithRedis(requestLimitConfig.getAmount(), requestLimitConfig.getTime(), key);<br>            <span class="hljs-keyword">if</span> (checkResult) &#123;<br>                log.info(<span class="hljs-string">&quot;requestLimited, [用户ip:&#123;&#125;], [访问地址:&#123;&#125;]超过了限定的次数[&#123;&#125;]次&quot;</span>, ip, url, requestLimitConfig.getAmount());<br>                <span class="hljs-keyword">return</span> ResultUtil.result(ECode.REQUEST_OVER_LIMIT, <span class="hljs-string">&quot;接口请求过于频繁&quot;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过Redis记录和检查请求次数，实现请求限制。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> amount 允许的最大请求次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> time   时间限制（毫秒）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key    Redis键</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否超过请求限制</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkWithRedis</span><span class="hljs-params">(<span class="hljs-type">int</span> amount, <span class="hljs-type">long</span> time, String key)</span> &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> redisUtil.incrBy(key, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (count == <span class="hljs-number">1</span>) &#123;<br>            redisUtil.expire(key, time, TimeUnit.MILLISECONDS);<br>        &#125;<br>        <span class="hljs-keyword">return</span> count &gt; amount;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中：</p><ol><li><strong>定义切点</strong>：通过 <code>@Pointcut</code> 定义了一个切点，拦截特定包下的所有方法。</li><li><strong>环绕通知</strong>：<code>@Around(&quot;pointcut()&quot;)</code> 表明 <code>around</code> 方法会在切点匹配的方法执行前后进行。</li><li><strong>请求限制逻辑</strong>：<ul><li>获取请求的IP地址和URL。</li><li>构造一个Redis键，基于IP地址和方法名称。</li><li>检查当前方法是否有 <code>@RequestLimit</code> 注解，如果有，使用注解中的参数进行请求限制检查。</li><li>如果没有该注解，使用配置文件中定义的参数进行检查。</li><li>使用 <code>checkWithRedis</code> 方法检查是否超过请求限制。如果超过，返回错误信息。</li></ul></li><li><strong>Redis计数和过期时间</strong>：<ul><li><code>checkWithRedis</code> 方法使用Redis来计数每个请求的频率</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础_基础内容02</title>
    <link href="/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/"/>
    <url>/2024/01/08/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/</url>
    
    <content type="html"><![CDATA[<p>面向对象基础</p><ul><li>面向对象 vs 面向过程</li><li>创建对象；对象实体与对象引用的区别</li><li>对象的相等和引用相等的区别</li><li>当类没有声明构造方法</li><li>构造方法的特点</li><li>面向对象三大特征</li><li>接口与抽象类</li><li>深拷贝与浅拷贝；引用拷贝</li></ul><p>Object</p><ul><li>Obect 类的常用方法</li><li>&#x3D; &#x3D; 和 equals() 的区别</li><li>hashCode()  的作用</li></ul><p>String</p><ul><li>String、StringBuffer、StringBuilder 的区别</li><li>不可变的 String</li><li>字符串拼接： 使用“+” 还是使用 StringBuilder</li><li>String#equals() 和 Object#equals() 有何区别？</li><li>字符串常量池</li><li>String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象？</li><li>String#intern 方法</li><li>String 类型的变量和常量做“+”运算时发生了什么？</li></ul><p>异常</p><ul><li>Exception 和 Error 有什么区别？</li><li>Checked Exception 和 Unchecked Exception</li><li>Throwable 类常用方法</li><li>try-catch-finally 如何使用？</li><li>finally 中的代码一定会执行吗？</li><li>如何使用 try-with-resources 代替try-catch-finally？</li><li>异常使用有哪些需要注意的地方？</li></ul><h3 id="一、面向对象基础"><a href="#一、面向对象基础" class="headerlink" title="一、面向对象基础"></a>一、面向对象基础</h3><h4 id="1-1、面向对象和面向过程的区别"><a href="#1-1、面向对象和面向过程的区别" class="headerlink" title="1.1、面向对象和面向过程的区别"></a>1.1、面向对象和面向过程的区别</h4><p>两者的主要区别在于解决问题的方式不同：</p><ul><li>面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><h4 id="1-2、创建对象"><a href="#1-2、创建对象" class="headerlink" title="1.2、创建对象"></a>1.2、创建对象</h4><p>new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。</p><ul><li>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；</li><li>一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</li></ul><blockquote><p>对象的相等和引用相等的区别</p></blockquote><ul><li>对象的相等一般比较的是内存中存放的内容是否相等。</li><li>引用相等一般比较的是他们指向的内存地址是否相等。</li></ul><p>对象是什么？</p><p>对象是类的一个实例，类定义了对象的状态（属性）和行为（方法）</p><p>创建对象的步骤：</p><ol><li><strong>定义类</strong>: 首先，需要定义一个类，作为对象的蓝图。类定义了对象的属性和方法。</li><li><strong>声明对象</strong>: 接下来，声明一个类的变量。这个变量将引用新创建的对象。</li><li><strong>实例化对象</strong>: 使用 <code>new</code> 关键字创建类的一个实例。</li><li><strong>初始化对象</strong>: 通过调用类的构造器来初始化新创建的对象</li></ol><p>创建对象示例：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-comment">// 定义Person类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> &#123;<br>    <span class="hljs-type">String</span> name;<br>    <span class="hljs-type">int</span> age;<br><br>    <span class="hljs-built_in">Person</span>(<span class="hljs-type">String</span> name, <span class="hljs-type">int</span> age) &#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 在另一个类中创建Person的对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 创建Person对象</span><br>        Person person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Person</span>(<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-number">30</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>new Person(&quot;Alice&quot;, 30);</code> 创建了一个 <code>Person</code> 类的实例，并且用 <code>Alice</code> 和 <code>30</code> 初始化这个对象的 <code>name</code> 和 <code>age</code> 属性。</p><h4 id="1-3、构造方法"><a href="#1-3、构造方法" class="headerlink" title="1.3、构造方法"></a>1.3、构造方法</h4><p>构造方法的作用：构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。</p><p>如果没有声明构造方法，类会有一个默认的不带参数的改造方法。</p><p>构造方法的特点：</p><ul><li>名字与类名相同。</li><li>没有返回值，但不能用 void 声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ul><p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况</p><h4 id="1-4、面向对象特征"><a href="#1-4、面向对象特征" class="headerlink" title="1.4、面向对象特征"></a>1.4、面向对象特征</h4><p>面向对象的三大特征：</p><ul><li>封装</li><li>继承</li><li>多态</li></ul><p>面向对象编程（OOP）的三大特征是封装、继承和多态。这些特征共同为创建模块化、可重用和易于维护的代码提供了基础。</p><table><thead><tr><th>特征</th><th>描述</th><th>优点</th></tr></thead><tbody><tr><td>封装</td><td>封装是把数据（属性）和行为（方法）组合成一个单元（类），并对数据的访问进行限制和保护。在Java中，可以通过使用访问修饰符（如<code>private</code>, <code>public</code>）来实现。</td><td>- 提高了数据安全性<br>- 减少了代码间的耦合<br>- 增强了代码的可读性和可维护性</td></tr><tr><td>继承</td><td>继承是一种使得一个类（子类）能够继承另一个类（父类）的属性和方法的机制。子类可以扩展或修改继承自父类的行为。</td><td>- 促进了代码的重用<br>- 建立了类之间的层次关系<br>- 提高了代码的可维护性</td></tr><tr><td>多态</td><td>多态是指允许不同类的对象对同一消息作出响应的能力，即同一操作作用于不同的对象时可以有不同的解释和行为。</td><td>- 增强了程序的灵活性和扩展性<br>- 允许不同类的对象被统一处理</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ol><li><strong>封装</strong>: 就像一个咖啡机，它隐藏了内部的复杂机械过程，只暴露出简单的接口（按钮）给用户使用。</li><li><strong>继承</strong>: 类似于父母与孩子的关系。孩子会继承父母的一些特征（如眼睛的颜色），同时也可以发展自己独特的特性（如不同的职业技能）。</li><li><strong>多态</strong>: 可以比作一个通用的电源插座。不同的电器（即使是不同类型的电器）都可以插入同一个插座，但插入后的行为（如充电、运转）依赖于接入的具体电器。</li></ol><h4 id="1-5、接口与抽象类"><a href="#1-5、接口与抽象类" class="headerlink" title="1.5、接口与抽象类"></a>1.5、接口与抽象类</h4><p>接口（Interfaces）和抽象类（Abstract Classes）是用于实现抽象层次的两种主要方式。</p><p>它们都不能被实例化，但在用法和目的上存在一些关键区别。</p><blockquote><p>对比</p></blockquote><table><thead><tr><th>特征</th><th>接口（Interfaces）</th><th>抽象类（Abstract Classes）</th></tr></thead><tbody><tr><td>实例化</td><td>不能直接实例化。</td><td>也不能直接实例化。</td></tr><tr><td>方法定义</td><td>可以有默认方法和静态方法。所有方法默认为public。不需要使用<code>abstract</code>关键字。</td><td>可以包含抽象方法（没有实现体的方法）和非抽象方法。抽象方法使用<code>abstract</code>关键字。</td></tr><tr><td>属性定义</td><td>只能定义常量（默认为public static final）。</td><td>可以包含非常量字段，且这些字段可以有各种访问控制。</td></tr><tr><td>实现&#x2F;扩展</td><td>一个类可以实现多个接口。</td><td>一个类只能继承一个抽象类。</td></tr><tr><td>构造器</td><td>不能有构造器。</td><td>可以有构造器。</td></tr><tr><td>多重继承的支持</td><td>支持（一个类可以实现多个接口）。</td><td>不支持（一个类只能继承一个类，但可以实现多个接口）。</td></tr><tr><td>默认方法</td><td>Java 8之后，接口可以有默认方法（有方法体）。</td><td>抽象类可以有具有实现的方法。</td></tr><tr><td>访问修饰符限制</td><td>接口中的方法默认是public的，属性默认是public static final的。</td><td>抽象类中的方法和属性可以有多种访问修饰符。</td></tr><tr><td>使用场景</td><td>当各个实现之间没有共享的代码，但需要共同遵守某些规则（方法）时使用。</td><td>当各个实现之间有大量共享的代码或属性时使用。</td></tr></tbody></table><p>类比</p><ol><li><strong>接口</strong>: 就像一个标准或协议，它定义了规范，但不提供完整的实现。就像电器的插头和插座的标准，制造商需要按照这个标准制造产品。</li><li><strong>抽象类</strong>: 可以看作是半成品，它定义了一些基本功能和结构，但留下了一些空白（抽象方法）供继承它的子类完成。</li></ol><h4 id="1-6、深拷贝与浅拷贝，引用拷贝"><a href="#1-6、深拷贝与浅拷贝，引用拷贝" class="headerlink" title="1.6、深拷贝与浅拷贝，引用拷贝"></a>1.6、深拷贝与浅拷贝，引用拷贝</h4><p>区别：</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象</li></ul><p>对比</p><table><thead><tr><th>类型</th><th>描述</th><th>结果</th></tr></thead><tbody><tr><td>浅拷贝</td><td>只复制对象的基本类型字段和引用类型字段的引用，不复制引用对象本身。</td><td>两个对象共享引用类型的成员。</td></tr><tr><td>深拷贝</td><td>复制对象的所有字段，包括基本类型和引用类型字段，引用类型的对象也会被复制。</td><td>两个对象完全独立，不共享任何成员。</td></tr><tr><td>引用拷贝</td><td>只复制对象的引用，不复制对象本身。</td><td>两个引用指向同一个对象，任何一个对象的改变都会影响到另一个。</td></tr></tbody></table><p> 类比</p><ul><li><strong>浅拷贝</strong>: 就像拍摄一张画作的照片，你得到的是画作的表面复制品，但它仍然连接着原来的画。</li><li><strong>深拷贝</strong>: 就像复制一个画作的每一笔细节来创建一个全新的画作，完全独立于原作。</li><li><strong>引用拷贝</strong>: 就像给别人画作的一个指向地址，两人看的是同一幅画。</li></ul><p>图描述：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240109211507.png" alt="image.png"></p><h3 id="二、Object"><a href="#二、Object" class="headerlink" title="二、Object"></a>二、Object</h3><h4 id="2-1-Object-类的常用方法"><a href="#2-1-Object-类的常用方法" class="headerlink" title="2.1 Object 类的常用方法"></a>2.1 Object 类的常用方法</h4><p>Object 类是一个特殊的类，是所有类的父类。它主要提供了以下 11 个方法：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> Class&lt;?&gt; <span class="hljs-title function_">getClass</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hashCode</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-built_in">Object</span> obj)<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，用于创建并返回当前对象的一份拷贝。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">native</span> <span class="hljs-built_in">Object</span> <span class="hljs-title function_">clone</span>() <span class="hljs-keyword">throws</span> CloneNotSupportedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">String</span> <span class="hljs-title function_">toString</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notify</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">notifyAll</span>()<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>(<span class="hljs-type">long</span> timeout) <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 多了 nanos 参数，这个参数表示额外时间（以纳秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 纳秒。。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>(<span class="hljs-type">long</span> timeout, <span class="hljs-type">int</span> nanos) <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">wait</span>() <span class="hljs-keyword">throws</span> InterruptedException<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实例被垃圾回收器回收的时候触发的操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">finalize</span>() <span class="hljs-keyword">throws</span> Throwable &#123; &#125;<br></code></pre></td></tr></table></figure><p>以下是Java中 <code>Object</code> 类的常用方法的总结，包括每个方法的功能和特性：</p><table><thead><tr><th>方法签名</th><th>返回类型</th><th>描述</th><th>特性</th></tr></thead><tbody><tr><td><code>public final native Class&lt;?&gt; getClass()</code></td><td><code>Class&lt;?&gt;</code></td><td>返回当前运行时对象的Class对象。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写</td></tr><tr><td><code>public native int hashCode()</code></td><td>int</td><td>返回对象的哈希码，主要用于哈希表。</td><td><code>native</code> 方法，通常与 <code>equals()</code> 方法一起使用。</td></tr><tr><td><code>public boolean equals(Object obj)</code></td><td>boolean</td><td>比较两个对象的内存地址是否相等。String类重写了此方法来比较字符串值。</td><td>可被子类重写以提供相等性逻辑。</td></tr><tr><td><code>protected native Object clone()</code></td><td>Object</td><td>创建并返回当前对象的一份拷贝。</td><td><code>native</code> 方法，类必须实现 <code>Cloneable</code> 接口才能使用此方法。</td></tr><tr><td><code>public String toString()</code></td><td>String</td><td>返回对象的字符串表示，通常包括类名和哈希码的16进制字符串。</td><td>建议所有子类重写此方法。</td></tr><tr><td><code>public final native void notify()</code></td><td>void</td><td>唤醒在此对象监视器上等待的单个线程。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。</td></tr><tr><td><code>public final native void notifyAll()</code></td><td>void</td><td>唤醒在此对象监视器上等待的所有线程。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。</td></tr><tr><td><code>public final native void wait(long timeout)</code></td><td>void</td><td>使当前线程等待直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>，或超时。</td><td>使用 <code>final</code> 和 <code>native</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>public final void wait(long timeout, int nanos)</code></td><td>void</td><td>使当前线程等待直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>，或超时加额外纳秒。</td><td>使用 <code>final</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>public final void wait()</code></td><td>void</td><td>使当前线程无限期等待，直到另一个线程调用 <code>notify()</code> 或 <code>notifyAll()</code>。</td><td>使用 <code>final</code> 关键字，不能被子类重写。释放对象的锁。</td></tr><tr><td><code>protected void finalize()</code></td><td>void</td><td>在对象被垃圾回收器回收时触发的操作。</td><td>在Java 9中被弃用，但子类可以重写以进行清理操作。</td></tr></tbody></table><p>这些方法提供了对象行为的基本框架，从对象的生命周期管理到线程间的通信。</p><h4 id="2-2-和-equals-的区别"><a href="#2-2-和-equals-的区别" class="headerlink" title="2.2 &#x3D;&#x3D; 和 equals() 的区别"></a>2.2 &#x3D;&#x3D; 和 equals() 的区别</h4><p>&#x3D;&#x3D; 对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，&#x3D;&#x3D; 比较的是值。</li><li>对于引用数据类型来说，&#x3D;&#x3D; 比较的是对象的内存地址。</li></ul><p>在Java中，&#x3D;&#x3D; 运算符和<code>equals()</code>方法用于比较两个对象，但它们在比较方式上有本质的不同。</p><blockquote><p>&#x3D;&#x3D; 运算符</p></blockquote><ol><li><p><strong>用途</strong>: 主要用于比较基本数据类型的值和引用类型的地址。</p></li><li><p><strong>对基本类型</strong>: 比较两个基本类型的值是否相同（例如，<code>int</code>, <code>char</code>, <code>double</code>等）。</p></li><li><p><strong>对引用类型</strong>: 比较两个对象引用是否指向内存中的同一位置。</p></li></ol><blockquote><p><code>equals()</code> 方法</p></blockquote><ol><li><p><strong>用途</strong>: 主要用于比较两个对象的内容或状态是否相等。</p></li><li><p><strong>默认行为</strong>: 在 <code>Object</code> 类中定义的 <code>equals()</code> 方法默认行为与  &#x3D;&#x3D; 相同，即比较对象的内存地址。</p></li><li><p><strong>重写</strong>: 多数类，如 <code>String</code>, <code>Date</code> 等，都重写了 <code>equals()</code> 方法来进行逻辑比较，即比较对象的内容而不是内存地址。</p></li></ol><blockquote><p>表格比较</p></blockquote><table><thead><tr><th>特性</th><th>&#x3D;&#x3D; 运算符</th><th><code>equals()</code> 方法</th></tr></thead><tbody><tr><td>比较类型</td><td>基本数据类型的值 &#x2F; 引用类型的内存地址</td><td>对象内容（可重写）</td></tr><tr><td>默认行为</td><td>比较内存地址（对于引用类型）</td><td>在 <code>Object</code> 类中也是比较内存地址</td></tr><tr><td>可重写性</td><td>不可重写</td><td>可以重写以提供自定义比较逻辑</td></tr><tr><td>使用场景</td><td>当需要检查两个变量是否指向相同的对象时使用</td><td>当需要检查两个对象是否在逻辑上相等时使用</td></tr><tr><td>例子</td><td><code>a == b</code>（对于基本类型或检查两个引用是否指向同一对象）</td><td><code>a.equals(b)</code>（对于检查两个对象的内容是否相等）</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ul><li><p><strong>&#x3D;&#x3D; 运算符</strong>: 就像检查两张名片上的地址是否一样，即使两张名片属于同一人，但如果地址不同，结果就是不相等。</p></li><li><p><strong><code>equals()</code> 方法</strong>: 就像比较两个人的面貌，即使他们住在不同的地方（不同的内存地址），只要面貌相同（内容相同），就认为他们相等。</p></li></ul><p>扩展的一些问题：</p><p>to be conteind…</p><h4 id="2-3-hashCode-有什么用"><a href="#2-3-hashCode-有什么用" class="headerlink" title="2.3 hashCode 有什么用"></a>2.3 hashCode 有什么用</h4><p><code>hashCode()</code> 的作用是获取哈希码（<code>int</code> 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code> 定义在 JDK 的 <code>Object</code> 类中，这就意味着 Java 中的任何类都包含有 <code>hashCode()</code> 函数。另外需要注意的是：<code>Object</code> 的 <code>hashCode()</code> 方法是本地方法，也就是用 C 语言或 C++ 实现的。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>散列表存储的是键值对(key-value)，它的特点是：<strong>能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</strong></p><p>hashCode() 和  equals() 方法</p><ul><li>如果两个对象的<code>hashCode</code> 值相等，那这两个对象不一定相等（哈希碰撞）。</li><li>如果两个对象的<code>hashCode</code> 值相等并且<code>equals()</code>方法也返回 <code>true</code>，我们才认为这两个对象相等。</li><li>如果两个对象的<code>hashCode</code> 值不相等，我们就可以直接认为这两个对象不相等。</li></ul><blockquote><p>为什么重写 equals() 时必须重写 hashCode() 方法？</p></blockquote><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p><strong>思考</strong>：重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话，使用 <code>HashMap</code> 可能会出现什么问题。</p><p>如果没有重写哈希函数的话，两个键获取哈希表位置索引可能会不对，造成一些现象，比如：在集合中查找对象时可能会失败，即使该对象已经存在；即使使用一个逻辑上相等的键去查找，也可能无法找到对应的值，导致数据访问上的问题等。</p><blockquote><p>散列表</p></blockquote><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在存储器存储位置的数据结构。也就是说，它通过计算出一个键值的函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。</p><p>这个映射函数称做散列函数，存放记录的数组称做散列表。</p><p>一个通俗的例子是，</p><p>为了查找电话簿中某人的号码，可以创建一个按照人名首字母顺序排列的表（即建立人名 x 到首字母 F(x) 的一个函数关系），在首字母为W的表中查找“王”姓的电话号码，显然比直接查找就要快得多。这里使用人名作为关键字，“取首字母”是这个例子中散列函数的函数法则 F( )，存放首字母的表对应散列表。关键字和函数法则理论上可以任意确定。</p><blockquote><p>哈希表</p></blockquote><p>哈希表（Hash Table）其实也叫散列表，是一个数据结构。</p><p>哈希表本质上就是一个数组，只不过数组存放的是单一的数据，而哈希表中存放的是键值对（key - value pair）</p><p>key 通过哈希函数（hash function）得到数组的索引，进而存取索引位置的值。</p><p>不同的 key 通过哈希函数可能得到相同的索引值，此时，产生了哈希碰撞。</p><p>通过在数组中插入链表或者二叉树，可以解决哈希碰撞问题。</p><h3 id="三、String"><a href="#三、String" class="headerlink" title="三、String"></a>三、String</h3><h4 id="3-1-String、StringBuffer、StringBuilder-的区别？"><a href="#3-1-String、StringBuffer、StringBuilder-的区别？" class="headerlink" title="3.1  String、StringBuffer、StringBuilder 的区别？"></a>3.1  String、StringBuffer、StringBuilder 的区别？</h4><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>是</td><td>是</td><td>否</td></tr><tr><td>性能</td><td>较低（对于频繁修改）</td><td>高（线程安全）</td><td>高（非线程安全）</td></tr><tr><td>用途</td><td>文本不频繁改变时</td><td>多线程中文本频繁改变</td><td>单线程中文本频繁改变</td></tr></tbody></table><h4 id="3-2-String-为什么是不可变的"><a href="#3-2-String-为什么是不可变的" class="headerlink" title="3.2 String 为什么是不可变的"></a>3.2 String 为什么是不可变的</h4><p><code>String</code> 真正不可变有下面几点原因：</p><ol><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供&#x2F;暴露修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变</li></ol><h4 id="3-3-字符串拼接用“-”-还是-StringBuilder"><a href="#3-3-字符串拼接用“-”-还是-StringBuilder" class="headerlink" title="3.3  字符串拼接用“+” 还是 StringBuilder?"></a>3.3  字符串拼接用“+” 还是 StringBuilder?</h4><p>Java 语言本身并不支持运算符重载，“+”和“+&#x3D;”是专门为 String 类重载过的运算符，也是 Java 中仅有的两个重载过的运算符。</p><p>在JDK8中，字符串对象通过“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p><p>不过，在循环内使用“+”进行字符串的拼接的话，存在比较明显的缺陷：<strong>编译器不会创建单个 <code>StringBuilder</code> 以复用，会导致创建过多的 <code>StringBuilder</code> 对象</strong>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span> str1 = <span class="hljs-string">&quot;he&quot;</span>;<br><span class="hljs-type">String</span> str2 = <span class="hljs-string">&quot;llo&quot;</span>;<br><span class="hljs-type">String</span> str3 = <span class="hljs-string">&quot;world&quot;</span>;<br><span class="hljs-type">String</span> str4 = str1 + str2 + str3;<br></code></pre></td></tr></table></figure><p>对应字节码</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101412356.png" alt="image.png"></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-type">String</span>[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br><span class="hljs-type">String</span> s = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++) &#123;<br>    s += arr[i];<br>&#125;<br>System.out.<span class="hljs-built_in">println</span>(s);<br></code></pre></td></tr></table></figure><p><code>StringBuilder</code> 对象是在循环内部被创建的，这意味着每循环一次就会创建一个 <code>StringBuilder</code> 对象</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101412821.png" alt="image.png"></p><p>如果直接使用 <code>StringBuilder</code> 对象进行字符串拼接的话，就不会存在这个问题。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">String</span>[] arr = &#123;<span class="hljs-string">&quot;he&quot;</span>, <span class="hljs-string">&quot;llo&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;;<br>StringBuilder s = <span class="hljs-keyword">new</span> <span class="hljs-type">StringBuilder</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> value : <span class="hljs-type">arr</span>) &#123;<br>    s.append(value);<br>&#125;<br>System.out.println(s);<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401101413874.png" alt="image.png"></p><p>而在 JDK9中，字符串相加 “+” 改为了用动态方法 <code>makeConcatWithConstants()</code> 来实现，而不是大量的 <code>StringBuilder</code>；这也意味着 JDK 9 之后，我们可以放心使用“+” 进行字符串拼接。</p><h4 id="3-4-String-equals-和-Object-equals-有何区别"><a href="#3-4-String-equals-和-Object-equals-有何区别" class="headerlink" title="3.4  String#equals() 和 Object#equals() 有何区别"></a>3.4  String#equals() 和 Object#equals() 有何区别</h4><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h4 id="3-5-字符串常量池-🐎"><a href="#3-5-字符串常量池-🐎" class="headerlink" title="3.5 字符串常量池   🐎"></a>3.5 字符串常量池   🐎</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><p>to be contined….</p><h4 id="3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象-🐕"><a href="#3-6-String-s1-new-String-“abc”-这句话创建了几个字符串对象-🐕" class="headerlink" title="3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象  🐕"></a>3.6 String s1 &#x3D; new String(“abc”);这句话创建了几个字符串对象  🐕</h4><p>会创建 1 或 2 个字符串对象。</p><p>to be contined…</p><h4 id="3-7-intern-方法"><a href="#3-7-intern-方法" class="headerlink" title="3.7 intern 方法"></a>3.7 intern 方法</h4><p><code>String.intern()</code> 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中</p><p>to be contined…</p><h4 id="3-8-String-类型的变量和常量做“-”运算时发生了什么"><a href="#3-8-String-类型的变量和常量做“-”运算时发生了什么" class="headerlink" title="3.8 String 类型的变量和常量做“+”运算时发生了什么"></a>3.8 String 类型的变量和常量做“+”运算时发生了什么</h4><p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-02.html">https://javaguide.cn/java/basis/java-basic-questions-02.html</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8</a></li><li><a href="https://www.cnblogs.com/Steven-HU/p/14505316.html">https://www.cnblogs.com/Steven-HU/p/14505316.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java基础_基础内容01</title>
    <link href="/2024/01/07/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/"/>
    <url>/2024/01/07/Java%E5%9F%BA%E7%A1%80_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/</url>
    
    <content type="html"><![CDATA[<h3 id="一、基础概念和常识"><a href="#一、基础概念和常识" class="headerlink" title="一、基础概念和常识"></a>一、基础概念和常识</h3><h4 id="1-1、Java语言的特点"><a href="#1-1、Java语言的特点" class="headerlink" title="1.1、Java语言的特点"></a>1.1、Java语言的特点</h4><p>比较多的特点，目前 Java 中在实际项目开发中真正强大的是Java 的生态；</p><p>且技术是服务于业务的，就业率和使用率在国内占比较大。</p><p>特点：</p><ul><li>平台无关性</li><li>面向对象（封装、继承、多态）</li><li>支持多线程</li><li>可靠性</li><li>安全性</li><li>……</li></ul><h4 id="1-2、Java-SE-vs-Java-EE"><a href="#1-2、Java-SE-vs-Java-EE" class="headerlink" title="1.2、Java SE  vs Java EE"></a>1.2、Java SE  vs Java EE</h4><p>Java SE （Java Platform，Standard Edition） 是 Java 的基础版本，Java EE  （Java Platform, Enterprise Edition ）是 Java 的高级版本。</p><blockquote><p>基本介绍：</p></blockquote><p>Java SE是Java编程语言的标准版，它提供了Java语言的核心功能，包括：</p><ul><li><strong>基本语言特性</strong>：如变量、数组、循环、条件语句等。</li><li><strong>核心类库</strong>：提供了基础的类库，包括数据类型、数学函数、文件处理、网络编程、并发编程等。</li><li><strong>图形用户界面（GUI）</strong>: 如AWT（Abstract Window Toolkit）和Swing。</li><li><strong>Java虚拟机（JVM）</strong>: Java程序的运行环境。</li><li><strong>工具</strong>: 如编译器（javac），解释器（java），打包工具（jar）等。</li></ul><p>Java EE是Java的企业版，它在Java SE的基础上增加了用于构建大型企业级应用的功能。Java EE包括：</p><ul><li><strong>扩展的类库</strong>: 在Java SE的基础上提供了额外的类库和API，用于企业级应用开发。</li><li><strong>服务器端技术</strong>: 如Servlets、JavaServer Pages（JSP）、Enterprise JavaBeans（EJB）等。</li><li><strong>Web服务</strong>: 支持创建和消费Web服务。</li><li><strong>持久化API</strong>: 如Java Persistence API（JPA）。</li><li><strong>分布式计算</strong>: 支持构建大型、分布式的多层应用。</li><li><strong>集成技术</strong>: 如JMS（Java Message Service）和JavaMail。</li></ul><blockquote><p>总结</p></blockquote><ul><li><strong>Java SE</strong> 提供了Java语言的基础，更适合开发桌面应用程序或简单的服务器应用程序</li><li><strong>Java EE</strong> 在Java SE的基础上增加了企业级特性，更适合开发复杂的企业级应用程序或 Web 应用程序</li></ul><h4 id="1-3、JVM-vs-JDK-vs-JRE"><a href="#1-3、JVM-vs-JDK-vs-JRE" class="headerlink" title="1.3、JVM vs JDK  vs  JRE"></a>1.3、JVM vs JDK  vs  JRE</h4><ul><li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机</li><li>JDK （Java Development Kit）是完整的Java软件开发工具包</li><li>JRE（Java Runtime Environment） 是 Java 运行时环境</li></ul><p>JDK &gt;  JRE  &gt;  JVM</p><p>关系可以看这张图：<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401081433625.png" alt="image.png"></p><hr><p><strong>JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。</strong> </p><p>我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现。</p><p>除了我们平时最常用的 HotSpot VM 外，还有 J9 VM、Zing VM、JRockit VM 等 JVM 。</p><p>JDK（Java Development Kit），它是功能齐全的 Java SDK，是提供给开发者使用，能够创建和编译 Java 程序的开发套件。它包含了 JRE，同时还包含了编译 java 源码的编译器 javac 以及一些其他工具比如 javadoc（文档注释工具）、jdb（调试器）、jconsole（基于 JMX 的可视化监控⼯具）、javap（反编译工具）等等。</p><p>JRE（Java Runtime Environment） 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，主要包括 Java 虚拟机（JVM）、Java 基础类库（Class Library）。</p><h4 id="1-4、JIT"><a href="#1-4、JIT" class="headerlink" title="1.4、JIT"></a>1.4、JIT</h4><p>略</p><h4 id="1-5、编译与解释"><a href="#1-5、编译与解释" class="headerlink" title="1.5、编译与解释"></a>1.5、编译与解释</h4><p>高级编程语言按照程序的执行方式分为两种：</p><ul><li>编译型：编译型语言open in new window 会通过编译器open in new window将源代码一次性翻译成可被该平台执行的机器码。<ul><li>一般情况下，编译语言的执行速度比较快，开发效率比较低。常见的编译性语言有 C、C++、Go、Rust 等等。</li></ul></li><li>解释型：解释型语言open in new window会通过解释器open in new window一句一句的将代码解释（interpret）为机器代码后再执行。<ul><li>解释型语言开发效率比较快，执行速度比较慢。常见的解释性语言有 Python、JavaScript、PHP 等等</li></ul></li></ul><blockquote><p>为什么说 Java 语言“编译与解释并存”？  →   先编译 后解释</p></blockquote><p>这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。</p><p>因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（.class 文件），这种字节码必须由 Java 解释器来解释执行。</p><h4 id="1-6、AOT"><a href="#1-6、AOT" class="headerlink" title="1.6、AOT"></a>1.6、AOT</h4><p>略</p><h4 id="1-7、Oracle-JDK-vs-OpenJDK"><a href="#1-7、Oracle-JDK-vs-OpenJDK" class="headerlink" title="1.7、Oracle JDK vs OpenJDK"></a>1.7、Oracle JDK vs OpenJDK</h4><p>JDK 原来是 SUN 公司开发的，后来 SUN 公司又卖给了 Oracle 公司;  原来的 SUN 公司把 JDK 给开源了； Oracle 公司就类似开了一个分支，做了一个闭源版本。</p><blockquote><p>区别：</p></blockquote><p> OpenJDK</p><ol><li><strong>开源</strong>：OpenJDK是一个开放源代码的Java SE平台实现，它是自由软件并且公开发布。它是Oracle JDK的基础。</li><li><strong>社区驱动</strong>：由开源社区维护和更新。它通常是最先获得最新语言特性和修复的版本。</li><li><strong>许可证</strong>：使用GPL（通用公共许可证）v2许可证，带有Classpath例外，允许不受GPL限制地使用类库。</li><li><strong>更新</strong>：通常更加频繁地获得更新和补丁。</li><li><strong>广泛使用</strong>：由于其开源性质，被广泛用于各种环境，包括商业应用。</li></ol><p>Oracle JDK</p><ol><li><strong>Oracle官方版本</strong>：Oracle JDK是由Oracle公司提供的Java SE平台的官方实现。它基于OpenJDK，并包含了一些附加组件。</li><li><strong>商业用途许可费</strong>：Oracle JDK的早期版本免费用于个人和开发用途，但从JDK 11开始，Oracle更改了许可策略，对于商业用途或生产环境中的使用需要付费。</li><li><strong>性能优化和附加特性</strong>：Oracle JDK可能包括一些专有的性能增强和其他特性，如JRockit或Mission Control。</li><li><strong>支持</strong>：Oracle提供专业的长期支持服务，适合企业用户。</li><li><strong>更新频率</strong>：Oracle JDK的更新可能不如OpenJDK频繁，但更稳定，经过了更严格的测试。</li></ol><blockquote><p>总结</p></blockquote><ul><li><strong>OpenJDK</strong> 是一个完全开源的JDK版本，适用于需要免费、开源解决方案的场景。</li><li><strong>Oracle JDK</strong> 提供了一些附加特性和专业支持，适用于需要稳定支持和企业级特性的商业应用。</li></ul><h4 id="1-8、Java-和-C-的区别"><a href="#1-8、Java-和-C-的区别" class="headerlink" title="1.8、Java 和 C++ 的区别?"></a>1.8、Java 和 C++ 的区别?</h4><p>稍微记一下。</p><p>虽然，Java 和 C++ 都是面向对象的语言，都支持封装、继承和多态，但是，它们还是有挺多不相同的地方：</p><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）</li><li>…….</li></ul><h3 id="二、基本语法"><a href="#二、基本语法" class="headerlink" title="二、基本语法"></a>二、基本语法</h3><h4 id="2-1-注释"><a href="#2-1-注释" class="headerlink" title="2.1 注释"></a>2.1 注释</h4><ol><li><p><strong>单行注释</strong>：通常用于解释方法内某单行代码的作用。</p></li><li><p><strong>多行注释</strong>：通常用于解释一段代码的作用。</p></li><li><p><strong>文档注释</strong>：通常用于生成 Java 开发文档。</p></li></ol><h4 id="2-2-标识符和关键字"><a href="#2-2-标识符和关键字" class="headerlink" title="2.2 标识符和关键字"></a>2.2 标识符和关键字</h4><p>在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 <strong>标识符</strong> 。简单来说， <strong>标识符就是一个名字</strong> 。</p><p>有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 <strong>关键字</strong> 。简单来说，<strong>关键字是被赋予特殊含义的标识符</strong> 。</p><blockquote><p>关键字</p></blockquote><table><thead><tr><th>分类</th><th>关键字</th><th></th><th></th><th></th><th></th><th></th><th></th></tr></thead><tbody><tr><td>访问控制</td><td>private</td><td>protected</td><td>public</td><td></td><td></td><td></td><td></td></tr><tr><td>类，方法和变量修饰符</td><td>abstract</td><td>class</td><td>extends</td><td>final</td><td>implements</td><td>interface</td><td>native</td></tr><tr><td></td><td>new</td><td>static</td><td>strictfp</td><td>synchronized</td><td>transient</td><td>volatile</td><td>enum</td></tr><tr><td>程序控制</td><td>break</td><td>continue</td><td>return</td><td>do</td><td>while</td><td>if</td><td>else</td></tr><tr><td></td><td>for</td><td>instanceof</td><td>switch</td><td>case</td><td>default</td><td>assert</td><td></td></tr><tr><td>错误处理</td><td>try</td><td>catch</td><td>throw</td><td>throws</td><td>finally</td><td></td><td></td></tr><tr><td>包相关</td><td>import</td><td>package</td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>基本类型</td><td>boolean</td><td>byte</td><td>char</td><td>double</td><td>float</td><td>int</td><td>long</td></tr><tr><td></td><td>short</td><td></td><td></td><td></td><td></td><td></td><td></td></tr><tr><td>变量引用</td><td>super</td><td>this</td><td>void</td><td></td><td></td><td></td><td></td></tr><tr><td>保留字</td><td>goto</td><td>const</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table><blockquote><p>Tips：所有的关键字都是小写的，在 IDE 中会以特殊颜色显示。</p><p><code>default</code> 这个关键字很特殊，既属于程序控制，也属于类，方法和变量修饰符，还属于访问控制。</p></blockquote><ul><li>在程序控制中，当在 <code>switch</code> 中匹配不到任何情况时，可以使用 <code>default</code> 来编写默认匹配的情况。</li><li>在类，方法和变量修饰符中，从 JDK8 开始引入了默认方法，可以使用 <code>default</code> 关键字来定义一个方法的默认实现。</li><li>在访问控制中，如果一个方法前没有任何修饰符，则默认会有一个修饰符 <code>default</code>，但是这个修饰符加上了就会报错。</li></ul><p>⚠️ 注意：虽然 <code>true</code>, <code>false</code>, 和 <code>null</code> 看起来像关键字但实际上他们是字面值，同时你也不可以作为标识符来使用。</p><h4 id="2-3-自增自减运算符"><a href="#2-3-自增自减运算符" class="headerlink" title="2.3 自增自减运算符"></a>2.3 自增自减运算符</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>符号在前就先加/减，符号在后就后加/减</strong></div><p>Java中的自增（<code>++</code>）和自减（<code>--</code>）运算符是常用的一元运算符，用于增加或减少变量的值。</p><blockquote><p>自增运算符（<code>++</code>）</p></blockquote><p>自增运算符<code>++</code>用于将变量的值增加1。它有两种形式：</p><ol><li><p><strong>前缀自增</strong>：<code>++var</code>。在表达式求值之前增加变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = ++a; // 先将a增加1，变成6，然后将a的值赋给b，b也是6</code></li></ul></li><li><p><strong>后缀自增</strong>：<code>var++</code>。在表达式求值之后增加变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = a++; // 先将a的值赋给b，b是5，然后a增加1，变成6</code></li></ul></li></ol><blockquote><p>自减运算符（<code>--</code>）</p></blockquote><p>自减运算符<code>--</code>用于将变量的值减少1。它同样有两种形式：</p><ol><li><p><strong>前缀自减</strong>：<code>--var</code>。在表达式求值之前减少变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = --a; // 先将a减少1，变成4，然后将a的值赋给b，b也是4</code></li></ul></li><li><p><strong>后缀自减</strong>：<code>var--</code>。在表达式求值之后减少变量的值。</p><ul><li>例如：</li><li><code>int a = 5; int b = a--; // 先将a的值赋给b，b是5，然后a减少1，变成4</code></li></ul></li></ol><blockquote><p>使用场景和注意事项</p></blockquote><ul><li>这些运算符通常用在循环和简单的数值操作中。</li><li>选择前缀还是后缀形式取决于你希望在表达式其他部分使用变量的哪个值（增加或减少前的值，还是增加或减少后的值）。</li><li>在单独使用时（不作为更大表达式的一部分），前缀和后缀形式的效果是相同的。</li></ul><blockquote><p>进阶问题</p></blockquote><p>考虑以下代码片段：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span> = 1; <br><span class="hljs-attribute">int j</span> = i++ + ++i;<br></code></pre></td></tr></table></figure><p>此时 j 的值是多少？</p><p><strong>分析：</strong></p><p>给定代码分析</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">int i</span> = 1; <br><span class="hljs-attribute">int j</span> = i++ + ++i;<br></code></pre></td></tr></table></figure><ol><li><strong>第一个操作 - <code>i++</code></strong> (后缀自增): 这个操作首先返回<code>i</code>的当前值，然后<code>i</code>的值增加1。所以，在这个表达式的这一部分，<code>i</code>的值被视为1，但之后<code>i</code>变成了2。</li><li><strong>第二个操作 - <code>++i</code></strong> (前缀自增): 在执行这个操作时，<code>i</code>已经是2了。现在，由于是前缀自增，<code>i</code>首先被增加1，变成3，然后这个值被用于表达式。所以，这一部分的值是3。</li><li><strong>结果</strong>: 结合这两部分，<code>j = 1 + 3</code>，所以<code>j</code>的最终值是4。</li></ol><p>关键点</p><ul><li>后缀自增(<code>i++</code>)先返回当前值，然后增加。</li><li>前缀自增(<code>++i</code>)先增加，然后返回增加后的值。</li><li>在包含多个自增&#x2F;自减操作的复合表达式中，理解求值的顺序非常重要。</li></ul><h4 id="2-4-移位运算符"><a href="#2-4-移位运算符" class="headerlink" title="2.4 移位运算符"></a>2.4 移位运算符</h4><ul><li><code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。<code>x &lt;&lt; 1</code>,相当于 x 乘以 2(不溢出的情况下)。</li><li><code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。<code>x &gt;&gt; 1</code>,相当于 x 除以 2。</li><li><code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li></ul><h4 id="2-5-continue、break-和-return-的区别"><a href="#2-5-continue、break-和-return-的区别" class="headerlink" title="2.5 continue、break 和 return 的区别"></a>2.5 continue、break 和 return 的区别</h4><p>关键词：</p><ol><li><code>continue</code>：指跳出当前的这一次循环，继续下一次循环。</li><li><code>break</code>：指跳出整个循环体，继续执行循环下面的语句。</li></ol><p><code>return</code> 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：</p><ol><li><code>return;</code>：直接使用 return 结束方法执行，用于没有返回值函数的方法</li><li><code>return value;</code>：return 一个特定值，用于有返回值函数的方法</li></ol><h3 id="三、基本数据类型"><a href="#三、基本数据类型" class="headerlink" title="三、基本数据类型"></a>三、基本数据类型</h3><h4 id="3-1、Java-中的基本数据类型"><a href="#3-1、Java-中的基本数据类型" class="headerlink" title="3.1、Java 中的基本数据类型"></a>3.1、Java 中的基本数据类型</h4><table><thead><tr><th>类型</th><th>基础类型</th><th>默认值</th><th>占用空间大小</th><th>位数</th><th>取值范围</th><th>对应包装类型</th></tr></thead><tbody><tr><td>数字类型</td><td>byte</td><td>0</td><td>1字节</td><td>8</td><td>-128 ~ 127</td><td>Byte</td></tr><tr><td>数字类型</td><td>short</td><td>0</td><td>2字节</td><td>16</td><td>-32768（-2^15） ~ 32767（2^15 - 1）</td><td>Short</td></tr><tr><td>数字类型</td><td>int</td><td>0</td><td>4字节</td><td>16</td><td>-2147483648 ~ 2147483647</td><td>Integer</td></tr><tr><td>数字类型</td><td>long</td><td>0L</td><td>8字节</td><td>32</td><td>-9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1）</td><td>Long</td></tr><tr><td>数字类型</td><td>float</td><td>0.0f</td><td>4字节</td><td>23</td><td>1.4E-45 ~ 3.4028235E38</td><td>Float</td></tr><tr><td>数字类型</td><td>double</td><td>0.0d</td><td>8字节</td><td>64</td><td>4.9E-324 ~ 1.7976931348623157E308</td><td>Double</td></tr><tr><td>字符类型</td><td>char</td><td>‘\u0000’（即空字符）</td><td>2字节（使用Unicode编码）</td><td>16</td><td>0 ~ 65535（2^16 - 1）</td><td>Character</td></tr><tr><td>布尔类型</td><td>boolean</td><td>false</td><td>1字节</td><td>1</td><td>true、false</td><td>Boolean</td></tr></tbody></table><h4 id="3-2-基本类型和包装类型"><a href="#3-2-基本类型和包装类型" class="headerlink" title="3.2 基本类型和包装类型"></a>3.2 基本类型和包装类型</h4><blockquote><p>区别</p></blockquote><ul><li><strong>用途</strong>：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。</li><li><strong>占用空间</strong>：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：</li></ul><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">比较方式<br><br>对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。<br></code></pre></td></tr></table></figure><blockquote><p>特点</p></blockquote><ol><li><strong>对象特性</strong>：包装类型是对象，可以调用各种方法，例如<code>Integer.parseInt()</code>。</li><li><strong>可用于泛型</strong>：在集合类等使用泛型的场合，只能使用对象，因此必须使用包装类型。</li><li><strong>可表示空值</strong>：可以表示为<code>null</code>，而基本类型不能。</li><li><strong>堆内存</strong>：对象通常存储在堆上，这可能导致处理稍慢于基本类型。</li><li><strong>自动装箱和拆箱</strong>：Java提供自动将基本类型转换为包装类型（装箱）和将包装类型转换为基本类型（拆箱）的功能。</li></ol><blockquote><p>比较和选择</p></blockquote><ul><li>使用基本数据类型时，如果关注性能和内存，并且不需要对象的特性，比如在大量数值计算中。</li><li>使用包装类型时，如果需要对象的特性，比如在使用集合类、需要表示空值或使用泛型时。</li></ul><h4 id="3-3-包装类型的缓存机制"><a href="#3-3-包装类型的缓存机制" class="headerlink" title="3.3 包装类型的缓存机制"></a>3.3 包装类型的缓存机制</h4><p>Java中的某些包装类实现了一个称为“缓存机制”的特性，主要是为了提高性能和减少内存使用。这一机制最常见于<code>Integer</code>和其他几种数字类型的包装类中。我们来详细探讨这一点。</p><blockquote><p>包装类型缓存机制的概述</p></blockquote><ol><li><strong>Integer缓存</strong>: Java的<code>Integer</code>类缓存了从<code>-128</code>到<code>127</code>之间的整数。这意味着在这个范围内的整数会被预先创建并缓存。当代码需要这些值的包装实例时，会重用已经创建的对象，而不是每次都创建新对象。</li><li><strong>其他类型</strong>: 类似的缓存机制也适用于<code>Byte</code>, <code>Short</code>, <code>Long</code>, <code>Character</code>等包装类。但具体的缓存范围可能不同。例如，<code>Byte</code>缓存了所有可能的值（从<code>-128</code>到<code>127</code>），而<code>Character</code>缓存了从<code>\u0000</code>到<code>\u007F</code>的字符。</li></ol><blockquote><p>缓存机制的工作原理</p></blockquote><p>当你通过<code>valueOf</code>方法（这是自动装箱背后使用的方法）或者直接使用自动装箱来创建一个包装对象时，Java会首先检查其值是否在缓存范围内。如果是，它会从缓存中返回相应的对象实例；如果不是，它会创建一个新的对象实例。</p><p>例如：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer a <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;  // 使用缓存</span><br>Integer b <span class="hljs-operator">=</span> <span class="hljs-number">100</span><span class="hljs-comment">;  // 重用相同的对象</span><br>Integer c <span class="hljs-operator">=</span> <span class="hljs-number">200</span><span class="hljs-comment">;  // 创建新的对象实例，因为200不在缓存范围内</span><br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>a</code>和<code>b</code>引用的是内存中相同的<code>Integer</code>对象，因为100在缓存范围内。</p><blockquote><p>缓存机制的好处</p></blockquote><ul><li><strong>性能提升</strong>：通过减少不必要的对象创建，提高了性能。</li><li><strong>内存优化</strong>：减少了内存的占用，因为共享了相同的对象。</li></ul><blockquote><p>使用时的注意事项</p></blockquote><ul><li>当比较包装类型的值时，应该使用<code>equals</code>方法而不是&#x3D;&#x3D; 运算符，因为 &#x3D;&#x3D; 比较的是引用，而不是值。但在缓存范围内，使用 &#x3D;&#x3D; 可能会误导你认为比较的是值。</li><li>在处理大量的整数运算时，要意识到自动装箱和拆箱可能会引入额外的性能开销</li></ul><hr><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，</p><p><code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，</p><p><code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>下面我们来看一个问题：下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Integer i1 <span class="hljs-operator">=</span> <span class="hljs-number">40</span><span class="hljs-comment">;</span><br>Integer i2 <span class="hljs-operator">=</span> new Integer(<span class="hljs-number">40</span>)<span class="hljs-comment">;</span><br>System.out.println(i1<span class="hljs-operator">=</span><span class="hljs-operator">=</span>i2)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p><code>Integer i1=40</code> 这一行代码会发生装箱，也就是说这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。</p><p>因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><p>因此，答案是 <code>false</code> 。</p><p>记住：<strong>所有整型包装类对象之间值的比较，全部使用 equals 方法比较</strong>。</p><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>记住：</strong> 所有整型包装类对象之间值的比较，全部使用 equals 方法比较</div><p> <img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20240108224809.png" alt="image.png"></p><h4 id="3-4-自动装箱与拆箱"><a href="#3-4-自动装箱与拆箱" class="headerlink" title="3.4 自动装箱与拆箱"></a>3.4 自动装箱与拆箱</h4><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h4 id="3-5-浮点数运算精度丢失"><a href="#3-5-浮点数运算精度丢失" class="headerlink" title="3.5 浮点数运算精度丢失"></a>3.5 浮点数运算精度丢失</h4><p>看一下下面这个代码示例：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">float</span> a = <span class="hljs-number">2</span>.<span class="hljs-number">0</span>f - <span class="hljs-number">1</span>.<span class="hljs-number">9</span>f;<br><span class="hljs-attribute">float</span> b = <span class="hljs-number">1</span>.<span class="hljs-number">8</span>f - <span class="hljs-number">1</span>.<span class="hljs-number">7</span>f;<br><span class="hljs-attribute">System</span>.out.println(a);// <span class="hljs-number">0</span>.<span class="hljs-number">100000024</span><br><span class="hljs-attribute">System</span>.out.println(b);// <span class="hljs-number">0</span>.<span class="hljs-number">099999905</span><br><span class="hljs-attribute">System</span>.out.println(a == b);// false<br></code></pre></td></tr></table></figure><p>原因分析：</p><p>浮点数运算中的精度丢失是一个在计算机科学中广泛存在的问题，尤其是在使用单精度（<code>float</code>）和双精度（<code>double</code>）类型时。这个问题的根源在于浮点数在计算机中的表示方式。</p><blockquote><p>浮点数表示</p></blockquote><p>浮点数在计算机中通常使用IEEE 754标准表示。这种表示方法有两个主要部分：</p><ol><li><strong>尾数（Mantissa）</strong>：代表数字的有效数字。</li><li><strong>指数（Exponent）</strong>：决定小数点的位置。</li></ol><p>由于这两个部分都有固定的位数，所以只能精确表示一定范围和精度的数。一些数，如分数<code>1/3</code>或特定的小数，无法被精确地表示为浮点数。</p><blockquote><p>精度丢失的原因</p></blockquote><ol><li><strong>有限的位数</strong>：由于尾数和指数的位数是有限的，因此浮点数不能精确表示所有的数值。在转换和运算过程中，会进行四舍五入以适应这些位数，从而导致精度丢失。</li><li><strong>二进制表示</strong>：某些十进制小数在二进制下是无限循环小数，无法精确表示，例如0.1。</li></ol><p>实际影响</p><p>在进行浮点数运算时，如加法、减法、乘法和除法，这种精度的丢失可能会累积，导致最终结果与预期有较大偏差。这在金融计算等需要高精度的场合尤为重要。</p><blockquote><p>解决方法</p></blockquote><ol><li><strong>使用<code>BigDecimal</code></strong>: 在Java中，<code>BigDecimal</code>类可以用于精确的小数运算。它允许控制舍入模式，可以用于金融和科学计算中。</li><li><strong>避免不必要的运算</strong>：减少浮点数运算的数量可以减少累积误差。</li><li><strong>理解和接受一定的误差</strong>：在某些场合，完全精确的结果可能并不是必需的，此时理解并接受浮点运算的限制是合理的。</li></ol><h3 id="四、变量"><a href="#四、变量" class="headerlink" title="四、变量"></a>四、变量</h3><h4 id="4-1-成员变量与局部变量"><a href="#4-1-成员变量与局部变量" class="headerlink" title="4.1 成员变量与局部变量"></a>4.1 成员变量与局部变量</h4><p>成员变量（字段、属性），局部变量在声明位置、作用域、初始化行为等方面有显著的不同</p><blockquote><p>成员变量（Member Variables）</p></blockquote><p>成员变量是定义在类中的变量，它们描述了类的属性或状态。根据是否使用<code>static</code>关键字，成员变量可以进一步分为实例变量和类变量。</p><ol><li><strong>实例变量</strong>：没有用<code>static</code>修饰的成员变量。每个类的实例都有自己的一套实例变量的副本。</li><li><strong>类变量（静态变量）</strong>：用<code>static</code>修饰的成员变量。它们属于类本身，所有实例共享同一个静态变量的副本。</li></ol><p>特点</p><ul><li><strong>作用域</strong>：整个类内部。</li><li><strong>生命周期</strong>：与对象的生命周期（实例变量）或类的生命周期（静态变量）相同。</li><li><strong>默认值</strong>：自动初始化为默认值（如<code>int</code>为0，对象引用为<code>null</code>）。</li><li><strong>访问方式</strong>：可以通过对象（实例变量）或类名（静态变量）访问。</li></ul><blockquote><p>局部变量（Local Variables）</p></blockquote><p>局部变量是在方法内、构造器内或代码块内定义的变量。</p><p><strong>特点</strong></p><ul><li><strong>作用域</strong>：仅限于它们被声明的方法、构造器或代码块内。</li><li><strong>生命周期</strong>：从声明开始到方法、构造器或代码块执行完毕时结束。</li><li><strong>初始化</strong>：不会自动初始化，必须在使用前显式初始化。</li><li><strong>内存位置</strong>：通常存储在栈上。</li></ul><blockquote><p>比较</p></blockquote><table><thead><tr><th>特性</th><th>成员变量</th><th>局部变量</th></tr></thead><tbody><tr><td>声明位置</td><td>类体内部</td><td>方法、构造器或代码块内</td></tr><tr><td>作用域</td><td>整个类内部</td><td>仅限于声明它们的块内</td></tr><tr><td>生命周期</td><td>实例变量：随对象存在；静态变量：随类存在</td><td>随方法、构造器或代码块执行完毕而结束</td></tr><tr><td>初始化</td><td>自动初始化为默认值</td><td>必须显式初始化</td></tr><tr><td>内存位置</td><td>堆（实例变量）或方法区（静态变量）</td><td>栈</td></tr></tbody></table><h4 id="4-2-静态变量"><a href="#4-2-静态变量" class="headerlink" title="4.2 静态变量"></a>4.2 静态变量</h4><p>略</p><h4 id="4-3-字符型常量和字符串常量"><a href="#4-3-字符型常量和字符串常量" class="headerlink" title="4.3 字符型常量和字符串常量"></a>4.3 字符型常量和字符串常量</h4><p>字符型常量（Character Constants）和字符串常量（String Constants）之间的主要区别：</p><table><thead><tr><th>特性</th><th>字符型常量（Character Constants）</th><th>字符串常量（String Constants）</th></tr></thead><tbody><tr><td>引号类型</td><td>单引号（’）</td><td>双引号（”）</td></tr><tr><td>内容</td><td>仅包含单个字符</td><td>可包含零个、一个或多个字符</td></tr><tr><td>类型</td><td>基本数据类型（<code>char</code>）</td><td>类（<code>String</code>）</td></tr><tr><td>存储大小</td><td>16位（2字节）Unicode字符</td><td>取决于字符串长度</td></tr><tr><td>可变性</td><td>不适用</td><td>不可变（一旦创建，内容不可更改）</td></tr><tr><td>示例</td><td><code>&#39;A&#39;</code>, <code>&#39;1&#39;</code>, <code>&#39;\n&#39;</code></td><td><code>&quot;Hello&quot;</code>, <code>&quot;123&quot;</code>, <code>&quot;&quot;</code></td></tr></tbody></table><h3 id="五、方法"><a href="#五、方法" class="headerlink" title="五、方法"></a>五、方法</h3><h4 id="5-1-什么是方法"><a href="#5-1-什么是方法" class="headerlink" title="5.1  什么是方法"></a>5.1  什么是方法</h4><p>略</p><h4 id="5-2-方法的返回值"><a href="#5-2-方法的返回值" class="headerlink" title="5.2 方法的返回值"></a>5.2 方法的返回值</h4><p>根据方法的返回值类型和参数类型，方法可以分为几种不同的类别。</p><p>区别：</p><table><thead><tr><th>类别</th><th>返回值类型</th><th>参数类型</th><th>描述</th></tr></thead><tbody><tr><td>无返回值无参数</td><td><code>void</code></td><td>无参数</td><td>这类方法不返回任何值，也不接受任何参数。</td></tr><tr><td>无返回值有参数</td><td><code>void</code></td><td>有参数</td><td>这类方法不返回值，但接受一个或多个参数。</td></tr><tr><td>有返回值无参数</td><td>非<code>void</code></td><td>无参数</td><td>这类方法返回一个值，但不接受任何参数。</td></tr><tr><td>有返回值有参数</td><td>非<code>void</code></td><td>有参数</td><td>这类方法既返回一个值，又接受一个或多个参数。</td></tr></tbody></table><blockquote><p>例子</p></blockquote><ol><li><strong>无返回值无参数</strong></li></ol><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f1</span>()</span> &#123;<br>    <span class="hljs-comment">//......</span><br>&#125;<br><span class="hljs-comment">// 下面这个方法也没有返回值，虽然用到了 return</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">f</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> a</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (...) &#123;<br>        <span class="hljs-comment">// 表示结束方法的执行,下方的输出语句不会执行</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    System.<span class="hljs-keyword">out</span>.println(a);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li><p><strong>无返回值有参数</strong></p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-function"><span class="hljs-title">public</span></span> void f2(<span class="hljs-keyword">Parameter</span> 1, ..., <span class="hljs-keyword">Parameter</span> <span class="hljs-comment">n) &#123;</span><br>    <span class="hljs-comment">//......</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>有返回值无参数</strong></p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">f3</span>()</span> &#123;<br>    <span class="hljs-comment">//......</span><br>    <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>有返回值有参数</strong></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">f4</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> a * b;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="5-3-静态方法与实例方法"><a href="#5-3-静态方法与实例方法" class="headerlink" title="5.3 静态方法与实例方法"></a>5.3 静态方法与实例方法</h4><blockquote><p>区别</p></blockquote><p>静态方法（Static Methods）</p><ol><li><strong>定义</strong>: 使用<code>static</code>关键字定义。</li><li><strong>调用方式</strong>: 可以通过类名直接调用，不需要创建类的对象。</li><li><strong>访问</strong>: 只能直接访问类的静态成员（变量和方法）。不能直接访问实例成员。</li><li><strong>用途</strong>: 常用于不依赖于对象状态的工具或帮助方法。</li></ol><p>实例方法（Instance Methods）</p><ol><li><strong>定义</strong>: 没有<code>static</code>关键字，属于类的实例。</li><li><strong>调用方式</strong>: 需要创建类的对象，通过对象调用。</li><li><strong>访问</strong>: 可以访问类的实例成员（变量和方法）以及静态成员。</li><li><strong>用途</strong>: 通常用于操作或访问对象的实例数据。</li></ol><blockquote><p>比较</p></blockquote><table><thead><tr><th>特性</th><th>静态方法</th><th>实例方法</th></tr></thead><tbody><tr><td>定义</td><td>使用 <code>static</code> 关键字</td><td>没有 <code>static</code> 关键字</td></tr><tr><td>调用方式</td><td>通过类名调用（例如 <code>ClassName.method()</code>）</td><td>通过对象实例调用（例如 <code>object.method()</code>）</td></tr><tr><td>访问类的成员</td><td>只能访问静态成员</td><td>可访问实例成员和静态成员</td></tr><tr><td>对象状态依赖</td><td>不依赖对象状态</td><td>依赖或可访问对象状态</td></tr><tr><td>典型用途</td><td>工具方法、计算方法、无需对象状态的操作</td><td>操作或访问对象的实例数据</td></tr></tbody></table><blockquote><p>类比</p></blockquote><ul><li><strong>静态方法</strong>: 就像是大学的公共图书馆，所有学生（类的实例）都可以使用，但它不属于任何一个学生。</li><li><strong>实例方法</strong>: 就像学生的个人笔记本，每个学生都有自己的笔记本，可以在其中写下自己的笔记（实例数据），并且每个笔记本都是独一无二的。</li></ul><hr><blockquote><p>静态方法不能调用非静态成员</p></blockquote><p>主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作</li></ol><h4 id="5-4-重载和重写"><a href="#5-4-重载和重写" class="headerlink" title="5.4 重载和重写"></a>5.4 重载和重写</h4><p>重载：（同一个类中的操作）</p><p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p>重写：（子类对父类的操作）</p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><table><thead><tr><th>特性</th><th>重载 (Overloading)</th><th>重写 (Overriding)</th></tr></thead><tbody><tr><td>所在位置</td><td>同一个类中</td><td>子类中</td></tr><tr><td>方法名</td><td>必须相同</td><td>必须相同</td></tr><tr><td>参数列表</td><td>必须不同（数量、类型或顺序）</td><td>必须相同</td></tr><tr><td>返回类型</td><td>可以不同</td><td>必须与被重写的方法兼容</td></tr><tr><td>访问修饰符</td><td>可以不同</td><td>不能比父类方法更严格</td></tr><tr><td>抛出的异常</td><td>可以不同</td><td>不能抛出新的检查异常或更广泛的检查异常</td></tr><tr><td>实现目的</td><td>增加同一操作的灵活性</td><td>实现运行时多态，提供特定的实现</td></tr></tbody></table><h4 id="5-5-可变长参数"><a href="#5-5-可变长参数" class="headerlink" title="5.5 可变长参数"></a>5.5 可变长参数</h4><p>略</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html">https://javaguide.cn/java/basis/java-basic-questions-01.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/gre6gr">https://www.yuque.com/snailclimb/mf2z3k/gre6gr</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_背诵版</title>
    <link href="/2024/01/07/%E9%9D%A2%E8%AF%95%E9%A2%98_%E8%83%8C%E8%AF%B5%E7%89%88/"/>
    <url>/2024/01/07/%E9%9D%A2%E8%AF%95%E9%A2%98_%E8%83%8C%E8%AF%B5%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_Redis</title>
    <link href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Redis/"/>
    <url>/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Redis/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Redis 有什么作用，为什么要用缓存，为什么选择Redis</li><li>在使用Redis作为缓存时，如果遇到缓存穿透（即请求的数据不在缓存中也不在数据库中）的问题，你会如何解决？</li></ul><h4 id="1、Redis-有什么作用，为什么要用缓存，为什么选择Redis"><a href="#1、Redis-有什么作用，为什么要用缓存，为什么选择Redis" class="headerlink" title="1、Redis 有什么作用，为什么要用缓存，为什么选择Redis"></a>1、Redis 有什么作用，为什么要用缓存，为什么选择Redis</h4><blockquote><p>LQ</p></blockquote><p>在项目中为什么要使用缓存，按照我个人理解，首先是引入缓存后对我系统性能是有提升的， 基于此我考虑引入缓存；或者有其他需求，比如：高并发（减少数据库压力），快速读写（基于内存，读数据快）；</p><p>为什么选择Redis，Redis 是非常流行的一套技术解决方案，采用它可以解决很多不必要的开发存在的问题（前人已经解决过了，而且我能使用前人的一套方案） 去使用Redis 去做一些东西，比如高可用，搭建集群，同时Redis 它本身自己也有很多优点，支持持久化，数据类型丰富等。</p><blockquote><p>GPT</p></blockquote><p>项目中使用缓存的原因</p><ol><li><p><strong>性能提升</strong>: 正如你所提到的，缓存主要是为了提升系统性能。通过存储经常访问的数据在内存中，可以避免每次都从数据库中读取，从而减少响应时间。</p></li><li><p><strong>减少数据库压力</strong>: 在高并发情况下，数据库可能成为性能瓶颈。缓存可以吸收大量的读操作，减轻数据库的负担。</p></li><li><p><strong>快速读写</strong>: 内存的读写速度远快于硬盘。使用内存作为缓存介质，可以实现迅速的数据访问。</p></li></ol><p>选择Redis的原因</p><ol><li><p><strong>流行性和社区支持</strong>: Redis作为一个广泛使用的技术，拥有强大的社区支持和丰富的文档资源。这意味着在使用过程中遇到问题时，更容易找到解决方案。</p></li><li><p><strong>高可用和集群支持</strong>: Redis的高可用性和集群功能使其在处理大规模、高可用性需求的场景中表现卓越。</p></li><li><p><strong>持久化能力</strong>: Redis提供多种持久化选项，如RDB（快照）和AOF（日志），这使得即使在断电等情况下数据也不会丢失。</p></li><li><p><strong>数据类型丰富</strong>: Redis支持的数据结构不仅限于简单的键值对，还包括列表、集合、哈希表等，这使得开发者可以为各种不同的应用场景选择合适的数据结构。</p></li><li><p><strong>易于搭建和维护</strong>: 相较于一些其他的解决方案，Redis的搭建和维护相对简单，这降低了技术门槛和维护成本。</p></li></ol><h4 id="2、在使用Redis作为缓存时，如果遇到缓存穿透（即请求的数据不在缓存中也不在数据库中）的问题，你会如何解决？"><a href="#2、在使用Redis作为缓存时，如果遇到缓存穿透（即请求的数据不在缓存中也不在数据库中）的问题，你会如何解决？" class="headerlink" title="2、在使用Redis作为缓存时，如果遇到缓存穿透（即请求的数据不在缓存中也不在数据库中）的问题，你会如何解决？"></a>2、在使用Redis作为缓存时，如果遇到缓存穿透（即请求的数据不在缓存中也不在数据库中）的问题，你会如何解决？</h4><p>解决缓存穿透问题的两种常见方法：使用布隆过滤器和设置空对象缓存。</p><blockquote><p>GPT</p></blockquote><p>布隆过滤器（Bloom Filter）</p><p>布隆过滤器是一种空间效率很高的数据结构，用于检测一个元素是否在一个集合中。它的特点是可能会误判（即错误地认为某个元素存在于集合中），但不会漏判（即如果它说某个元素不在集合中，那么这个元素一定不在集合中）。</p><ul><li><strong>应用于缓存穿透</strong>: 在查询缓存之前，先使用布隆过滤器检查数据是否可能存在。如果布隆过滤器表示数据不存在，那么就可以避免对数据库的查询，从而防止缓存穿透。</li><li><strong>优点</strong>: 能够大量减少对数据库的无效查询，提高系统的整体性能。</li><li><strong>注意点</strong>: 需要合理设置布隆过滤器的大小和哈希函数的数量，以平衡误判率和空间效率。</li></ul><p>设置空对象缓存</p><p>当查询不到数据时，可以在缓存中设置一个特殊的空对象或标记，表示这个数据在数据库中是不存在的。</p><ul><li><strong>应用于缓存穿透</strong>: 这样当再次查询相同的非存在数据时，可以直接从缓存中获取到这个空对象，从而避免再次查询数据库。</li><li><strong>优点</strong>: 简单易行，可以快速实现。</li><li><strong>注意点</strong>: 需要设置合理的过期时间，以避免长时间占用缓存空间。同时，要防止这种方法被恶意利用，导致缓存被填满无效数据。</li></ul><h4 id="3、“缓存雪崩”的现象，这是指什么？又该如何防止它发生？"><a href="#3、“缓存雪崩”的现象，这是指什么？又该如何防止它发生？" class="headerlink" title="3、“缓存雪崩”的现象，这是指什么？又该如何防止它发生？"></a>3、“缓存雪崩”的现象，这是指什么？又该如何防止它发生？</h4><p>缓存雪崩是由于大量缓存同时失效所引起的，这可能会导致突然的数据库请求激增，进而可能导致数据库服务崩溃</p><p>解决缓存雪崩的策略</p><ol><li><p><strong>不同的过期时间</strong>: 正如你所说，给不同的缓存项设置不同的过期时间可以避免它们同时过期。这样可以将缓存失效的请求分散到不同的时间点，减少对数据库的压力。</p></li><li><p><strong>缓存数据预热</strong>: 系统启动时，预先加载一些关键数据到缓存中。这意味着即使缓存过期，已经预热的数据仍然可以支撑一段时间的读取需求，减轻数据库负担。</p></li></ol><p>补充解决方案</p><ol start="3"><li><p><strong>设置缓存过期时间随机化</strong>: 为缓存项设置的过期时间加上一个随机值，这样即使多个缓存项原本有相同的过期时间，它们实际失效的时间也会有所不同。</p></li><li><p><strong>使用持久化</strong>: 在Redis等缓存系统中使用持久化，即使缓存服务重启，数据也可以从磁盘中恢复，减少了对数据库的直接压力。</p></li><li><p><strong>限流和降级机制</strong>: 在系统设计时引入限流和降级策略，当检测到数据库请求量激增时，通过限流来控制请求量，或者暂时降级服务（如返回简化数据或错误信息），以保护数据库不被压垮。</p></li></ol><h4 id="4、“缓存击穿”，它是什么意思，以及如何解决？"><a href="#4、“缓存击穿”，它是什么意思，以及如何解决？" class="headerlink" title="4、“缓存击穿”，它是什么意思，以及如何解决？"></a>4、“缓存击穿”，它是什么意思，以及如何解决？</h4><p>缓存击穿是指一个热点的缓存项（即高频访问的数据）突然失效（比如过期了），此时突然有大量的并发请求直接打到数据库上，可能会对数据库造成很大压力。</p><p>解决缓存击穿的策略</p><ol><li><p><strong>设置长时间或不过期</strong>: 对于那些查询量非常大的热点数据，可以设置较长的过期时间甚至不设置过期时间，这样可以保证这些数据大部分时间都在缓存中。</p></li><li><p><strong>限流和降级处理</strong>: 当系统检测到某个键突然请求量激增时，可以临时对这些请求进行限流，或者在数据不可用时提供降级服务。</p></li></ol><p>补充解决方案</p><ol start="3"><li><p><strong>使用互斥锁</strong>: 当缓存失效时，不是所有请求都去加载数据库数据，而是使用互斥锁（或其他同步机制）控制只有一个请求去数据库中加载数据并重新填充到缓存中。其他请求等待缓存重建后再访问缓存。</p></li><li><p><strong>逻辑过期</strong>: 对于热点数据，可以设置两层过期时间，一个是真实的过期时间，另一个是逻辑上的过期时间。在逻辑过期后，启动一个异步线程去更新这个数据，但在真实过期前，仍然可以返回旧的缓存数据，避免直接打到数据库。</p></li></ol><h4 id="5、缓存一致性：当数据同时存储在数据库和缓存中时，如何保证缓存和数据库之间的数据一致性？"><a href="#5、缓存一致性：当数据同时存储在数据库和缓存中时，如何保证缓存和数据库之间的数据一致性？" class="headerlink" title="5、缓存一致性：当数据同时存储在数据库和缓存中时，如何保证缓存和数据库之间的数据一致性？"></a>5、<strong>缓存一致性</strong>：当数据同时存储在数据库和缓存中时，如何保证缓存和数据库之间的数据一致性？</h4><p>缓存存一致性的挑战</p><p>在旁路缓存模式中，在更新数据库后、删除缓存前的这个短暂时间窗口内，其他读取操作可能会读到旧的缓存数据。</p><p>解决方案</p><ol><li><strong>更新数据库后立即删除缓存</strong>: 这是最常用的方法。先更新数据库，再删除缓存，保证下一次读取时能够从数据库中加载最新数据。但正如你提到的，这种方法存在一个窗口期，可能会读到旧数据。</li><li><strong>使用事务或锁</strong>: 对更新操作加锁可以保证在更新数据库和删除缓存的过程中，不会有读取操作介入，从而避免读取到旧数据。但这可能会降低系统的并发性能。</li></ol><p>补充策略</p><ol start="3"><li><strong>延迟双删</strong>: 更新数据库后，先删除缓存，稍作延时，然后再次删除缓存。这种方法的目的是为了覆盖那些在第一次删除缓存和数据库更新之间由于其他读操作引入的旧数据。</li><li><strong>Write-Through&#x2F;Read-Through缓存</strong>: 在Write-Through策略中，应用程序先写缓存，缓存再同步到数据库；在Read-Through策略中，如果缓存未命中，缓存系统会从数据库加载数据并返回，同时更新缓存。这些策略可以由缓存框架自动管理，减少了手动处理缓存一致性的负担。</li></ol><h4 id="6、在分布式缓存环境中，如何处理多个节点之间的缓存一致性问题？"><a href="#6、在分布式缓存环境中，如何处理多个节点之间的缓存一致性问题？" class="headerlink" title="6、在分布式缓存环境中，如何处理多个节点之间的缓存一致性问题？"></a>6、在分布式缓存环境中，如何处理多个节点之间的缓存一致性问题？</h4><hr><p>参考</p><ul><li><a href="https://mp.weixin.qq.com/s/7hfkBOrbdVUNkepuQ0PX6Q">https://mp.weixin.qq.com/s/7hfkBOrbdVUNkepuQ0PX6Q</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/fg8lgc">https://www.yuque.com/snailclimb/mf2z3k/fg8lgc</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/es0afc">https://www.yuque.com/snailclimb/mf2z3k/es0afc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_JVM</title>
    <link href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_JVM/"/>
    <url>/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_JVM/</url>
    
    <content type="html"><![CDATA[<p>下面的面试题主要针对的是 HotSpot VM。</p><p><strong>自测题</strong></p><p>to be contined…</p><hr>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_Java并发</title>
    <link href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%B9%B6%E5%8F%91/"/>
    <url>/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<p><strong>自测题</strong></p><ul><li>什么是线程，线程和进程的区别是什么。</li><li>为什么要使用多线程。</li><li>线程的生命周期和状态讲一下。</li><li>什么是线程死锁，如何预防和避免线程死锁。</li><li>讲一下线程中的乐观锁和悲观锁，并讲一下其对应的一种实现方案。（如何实现乐观锁和悲观锁）</li><li>synchronized 关键字有什么作用，你平时怎么使用 synchronized 的。</li><li>synchronized 关键字的底层原理讲一下。</li><li>synchronized 和 ReentrantLock 有什么区别。</li><li>synchronized 和 volatile 的区别讲一下。</li><li>乐观锁会存在什么问题。</li><li>讲一下 CAS ，其实现原理懂吗。</li><li>如果遇到ABA问题，怎么解决？</li><li>AQS 是什么，他的原理了解吗。</li><li>并发编程的三个重要特性是哪三个？</li><li>你怎么理解 JMM 的，JMM 是什么？</li><li>ThreadLocal 的底层原理讲一下，你在平时的项目中是如何使用 ThreadLocal 关键字的。</li><li>线程池有哪几种，线程池的重要参数有哪些？</li><li>Semaphore 有什么用，他的原理是什么？</li><li>CountDownLatc，CyclicBarrier 了解吗。</li></ul><hr><p>参考</p><ul><li><a href="https://www.yuque.com/snailclimb/mf2z3k/cm70wa">https://www.yuque.com/snailclimb/mf2z3k/cm70wa</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_Java集合</title>
    <link href="/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E9%9B%86%E5%90%88/"/>
    <url>/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E9%9B%86%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p><strong>自测题</strong></p><ul><li>讲一下 List、Map、Set 的区别</li><li>常见的集合实现类说一下，怎么用的大致说一下。</li><li>哪些集合是线程不安全的，在并发情况下，如何保证集合线程安全呢。</li><li>讲一下List 的实现类，其中：ArrayList 和 Vector、ArrayList 和 ArrayLinked 的区别讲一下。</li><li>ArrayList 的扩容机制了解吗，讲述一下怎么扩容的。</li><li>说一下 HashSet、LinkedHashSet 和 TreeSet 三者的区别。</li><li>Queue 了解吗，讲一下他的实现类特点。</li><li>讲一下HashMap 的底层实现。</li><li>HashMap 的查询、删除的时间复杂度是多少？</li><li>讲一下 HashMap 和 ConcurrentHashMap 的区别。</li><li>ConcurrentHashMap 线程安全的底层实现原理讲一下。</li></ul><hr><p>自测题相关问题回答</p><hr><p>参考</p><ul><li><a href="https://www.yuque.com/snailclimb/mf2z3k/vlf8gd">https://www.yuque.com/snailclimb/mf2z3k/vlf8gd</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>面试题_Java基础</title>
    <link href="/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<p><strong>自测题</strong></p><ul><li>讲一下Java 中的基本数据类型，有几种，他们默认的占用空间和默认值，对应的包装类型是什么。</li><li>包装类型和基础数据类型的区别，为什么要有包装类型</li><li>自动拆装箱的原理</li><li>String、StringBuffer、StringBuilder 的区别</li><li>重载和重写的区别</li><li>讲一下内部类，匿名内部类怎么使用的</li><li>讲一下深拷贝、浅拷贝和引用拷贝</li><li>接口和抽象类的区别</li><li>Java反射你怎么理解的，框架为什么需要使用反射，你是怎么理解反射的</li><li>谈一下你对 Java 注解的理解，平时你怎么用的，讲一个你使用 Java 注解解决的问题</li><li>讲一下 Java 泛型，泛型是什么，他怎么使用的，类型擦除讲一下，常用的通配符有哪些。</li><li>什么是I&#x2F;O; 常见的 IO 模型有哪些（BIO&#x2F;NIO&#x2F;AIO 的区别讲一下）</li><li>I&#x2F;O流为什么要分字节流和字符流</li></ul><hr><p>关于 String 有一些常见的面试题，放在另外一篇文章： <strong>面试题_Java基础_String常见面试题</strong></p><p>自测题相关内容：</p><h4 id="1、Java-中的基本数据类型"><a href="#1、Java-中的基本数据类型" class="headerlink" title="1、Java 中的基本数据类型"></a>1、Java 中的基本数据类型</h4><table><thead><tr><th>类型</th><th>基础类型</th><th>默认值</th><th>占用空间大小</th><th>对应包装类型</th></tr></thead><tbody><tr><td>数字类型</td><td>byte</td><td>0</td><td>1字节</td><td>Byte</td></tr><tr><td>数字类型</td><td>short</td><td>0</td><td>2字节</td><td>Short</td></tr><tr><td>数字类型</td><td>int</td><td>0</td><td>4字节</td><td>Integer</td></tr><tr><td>数字类型</td><td>long</td><td>0L</td><td>8字节</td><td>Long</td></tr><tr><td>数字类型</td><td>float</td><td>0.0f</td><td>4字节</td><td>Float</td></tr><tr><td>数字类型</td><td>double</td><td>0.0d</td><td>8字节</td><td>Double</td></tr><tr><td>字符类型</td><td>char</td><td>‘\u0000’（即空字符）</td><td>2字节（使用Unicode编码）</td><td>Character</td></tr><tr><td>布尔类型</td><td>boolean</td><td>false</td><td>1字节</td><td>Boolean</td></tr></tbody></table><h4 id="2、包装类型和基础类型的区别"><a href="#2、包装类型和基础类型的区别" class="headerlink" title="2、包装类型和基础类型的区别"></a>2、包装类型和基础类型的区别</h4><p>包装类型能够通过对象的方式进行操作，在使用泛型的时候会用到。</p><p>同时我们运算的时候也会有自动拆箱和自动装箱子</p><h4 id="3、String、StringBuffer、StringBuilder-的区别"><a href="#3、String、StringBuffer、StringBuilder-的区别" class="headerlink" title="3、String、StringBuffer、StringBuilder 的区别"></a>3、String、StringBuffer、StringBuilder 的区别</h4><table><thead><tr><th>特性</th><th><code>String</code></th><th><code>StringBuffer</code></th><th><code>StringBuilder</code></th></tr></thead><tbody><tr><td>可变性</td><td>不可变</td><td>可变</td><td>可变</td></tr><tr><td>线程安全</td><td>是</td><td>是</td><td>否</td></tr><tr><td>性能</td><td>较低（对于频繁修改）</td><td>高（线程安全）</td><td>高（非线程安全）</td></tr><tr><td>用途</td><td>文本不频繁改变时</td><td>多线程中文本频繁改变</td><td>单线程中文本频繁改变</td></tr></tbody></table><h4 id="4、重载和重写的区别"><a href="#4、重载和重写的区别" class="headerlink" title="4、重载和重写的区别"></a>4、重载和重写的区别</h4><hr><p>参考</p><ul><li><a href="https://www.yuque.com/snailclimb/mf2z3k/gre6gr">https://www.yuque.com/snailclimb/mf2z3k/gre6gr</a></li><li><a href="https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86">https://javaguide.cn/java/basis/java-basic-questions-01.html#%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%B8%B8%E8%AF%86</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>面试题</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_Kafka_基础使用</title>
    <link href="/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Kafka 是什么</li><li>Kafka 的核心概念</li></ul><h3 id="1、Kafka-是什么"><a href="#1、Kafka-是什么" class="headerlink" title="1、Kafka 是什么"></a>1、Kafka 是什么</h3><p>略</p><h3 id="2、Kafka-的核心概念"><a href="#2、Kafka-的核心概念" class="headerlink" title="2、Kafka 的核心概念"></a>2、Kafka 的核心概念</h3><p>核心概念主要是： Producer、Consumer、Broker、Topic、Partition</p><p>有点类似 RocketMQ，毕竟RocketMQ 的设计之处是参考了部分 Kafka 的设计，其中 Kafka 是没有 Queue 这个概念的，主题 Topic 下面的实际存储数据采用的是 Partion 分区。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231230105605.png" alt="image.png"></p><hr><blockquote><p>kafka 和 Zookeeper 的关系</p></blockquote><p>在 Kafka 2.8 之前，Kafka 其重度依赖于 Zookeeper。</p><p>在 Kafka 2.8 之后，引入了基于 Raft 协议的 KRaft 模式，不再依赖 Zookeeper，简化了 Kafka 的架构。</p><p>Zookeeper 的作用就是注册中心，作为节点的 Broker 的路由管理 和集群负载等功能</p><blockquote><p>kafka 和 RocketMQ 的区别</p></blockquote><p>可以看一下下面这个解释,  具体更深层次的理解建议从实际的代码程序方面入手去理解。</p><p>Kafka 和 RocketMQ 都是高性能的消息中间件，广泛用于处理大规模数据流和实现分布式系统中的消息传递。</p><p>尽管它们有许多相似之处，但也存在一些关键的区别。以下是 Kafka 和 RocketMQ 主要区别的概述：</p><blockquote><ol><li>设计架构</li></ol></blockquote><ul><li><strong>Kafka</strong>：最初由LinkedIn开发，重点放在高吞吐量和可扩展性上。Kafka 使用分区（Partition）和复制（Replication）的概念来保证消息的可靠性和可伸缩性。</li><li><strong>RocketMQ</strong>：最初由阿里巴巴开发，设计重点是提供更丰富的消息模型和服务质量。它采用了更复杂的存储和消息路由机制。</li></ul><blockquote><ol start="2"><li>存储机制</li></ol></blockquote><ul><li><strong>Kafka</strong>：采用分布式、可伸缩的日志存储机制。每个主题（Topic）分为多个分区，每个分区在物理上对应一个日志文件。</li><li><strong>RocketMQ</strong>：使用单一的 <code>CommitLog</code> 文件来存储所有主题的消息，然后通过 <code>ConsumeQueue</code> 和 <code>IndexFile</code> 来为消息提供索引和快速访问。</li></ul><blockquote><ol start="3"><li>消息消费模型</li></ol></blockquote><ul><li><strong>Kafka</strong>：主要支持发布-订阅模型，但也可以通过分区分配实现类似队列的消费模式。Kafka 强调消费者的概念，每个消费者负责跟踪自己的偏移量。</li><li><strong>RocketMQ</strong>：提供更多样的消息模型，包括发布-订阅、点对点消息、顺序消息和延时消息等。</li></ul><blockquote><ol start="4"><li>事务消息</li></ol></blockquote><ul><li><strong>Kafka</strong>：在较新版本中增加了对事务消息的支持，但实现相对简单。</li><li><strong>RocketMQ</strong>：提供了更为复杂和强大的事务消息支持。</li></ul><blockquote><ol start="5"><li>性能和可靠性</li></ol></blockquote><ul><li><strong>Kafka</strong>：以其高性能和高吞吐量而著称，特别是在处理大量数据时。</li><li><strong>RocketMQ</strong>：虽然也提供高性能处理，但在某些场景下可能不如Kafka高效，尤其是在单一CommitLog设计下。</li></ul><blockquote><ol start="6"><li>社区和生态</li></ol></blockquote><ul><li><strong>Kafka</strong>：有着广泛的社区支持和成熟的生态系统，是流数据处理和实时分析的首选。</li><li><strong>RocketMQ</strong>：在中国有较强的社区支持，特别是在阿里巴巴及其生态系统中得到广泛应用。</li></ul><p>选择Kafka还是RocketMQ，取决于具体的应用场景和需求。</p><p>如果需要处理大规模的数据流，特别是在数据分析和流处理方面，Kafka可能是更好的选择。而如果需要更复杂的消息类型和服务质量，或者对事务消息有更高的要求，RocketMQ可能更适合。在实际选择时，还需要考虑团队的技术栈兼容性和具体的业务需求。</p><h3 id="3、Kafka-消费顺序、消息丢失和重复消费"><a href="#3、Kafka-消费顺序、消息丢失和重复消费" class="headerlink" title="3、Kafka 消费顺序、消息丢失和重复消费"></a>3、Kafka 消费顺序、消息丢失和重复消费</h3><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html">https://javaguide.cn/high-performance/message-queue/kafka-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RabbitMQ_基础使用</title>
    <link href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>RabbitMQ是什么</li><li>RabbitMQ的组成部分</li><li>RabbitMQ 的工作流程</li><li>RabbitMQ广播和直接模式示例</li></ul><p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。</p><p>MQ 的核心作用：削峰、解耦、异步</p><h3 id="1、RabbitMQ是什么"><a href="#1、RabbitMQ是什么" class="headerlink" title="1、RabbitMQ是什么"></a>1、RabbitMQ是什么</h3><p>建议直接去官网看一下相关概念： <a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></p><blockquote><p>RabbitMQ的特点</p></blockquote><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。</p><p>特点</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><blockquote><p>安装和使用</p></blockquote><ul><li><ol><li>安装 erlang 环境</li></ol></li><li><ol start="2"><li>安装RabbitMQ服务端</li></ol></li></ul><h3 id="2、RabbitMQ的组成部分"><a href="#2、RabbitMQ的组成部分" class="headerlink" title="2、RabbitMQ的组成部分"></a>2、RabbitMQ的组成部分</h3><p>核心概念</p><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。<ul><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li></ul></li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>大概流程：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121056722.png" alt="image.png"></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和 routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">生产者</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消息</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">交换机</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">路由</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">队列</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消费</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">消费者</span><br>    <span class="hljs-comment">\                                         /</span><br>     <span class="hljs-comment">\</span><span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">通道 Channel</span><span class="hljs-title">]</span><span class="hljs-literal">-----------------------</span><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><p>通道的概念：</p><ul><li><strong>定义</strong>：通道是建立在实际的 TCP 连接内的一个轻量级连接。它是执行大多数操作（如消息发布或消息接收）的路径。</li><li><strong>作用</strong>：通道是多路复用连接中的一个独立路径，允许多个通道共享一个 TCP 连接，而不必为每个通道建立物理连接。这提高了资源利用率和通信效率</li><li>生产者使用通道来发送消息到交换机，而消费者使用通道从队列中接收消息。通道作为消息传输的通道，连接了生产者、交换机和消费者。</li></ul><p>通道是作为消息传递的载体贯穿整个过程。</p><p>to be contined….</p><h3 id="3、RabbitMQ-的工作流程"><a href="#3、RabbitMQ-的工作流程" class="headerlink" title="3、RabbitMQ 的工作流程"></a>3、RabbitMQ 的工作流程</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>建立连接</li><li>生产者<ul><li>声明交换机类型、名称、是否持久化等</li><li>发送消息</li></ul></li><li>交换机<ul><li>交换机接收消息，进行消息路由</li></ul></li><li>消费者<ul><li>订阅消息（监听队列）</li><li>接收消息，业务处理</li></ul></li></ul><blockquote><ol><li>消息生产者与 RabbitMQ Broker 建立连接</li></ol></blockquote><ul><li><strong>建立连接（Connection）</strong>：消息生产者（Producer）首先与 RabbitMQ Broker 建立连接。这个连接是一个比较重的操作，通常是长连接，并在多个消息发送过程中复用。</li><li><strong>开启通道（Channel）</strong>：一旦连接建立，生产者开启一个或多个通道（Channel）。通道是轻量级的，用于执行实际的消息发送和接收操作。在 RabbitMQ 中，所有的消息传输都是通过通道完成的。</li></ul><blockquote><ol start="2"><li>生产者声明交换机</li></ol></blockquote><ul><li><strong>声明交换机（Exchange）</strong>：生产者需要声明一个交换机，并指定它的类型（如 direct, topic, fanout, headers）和名称。生产者还可以设置交换机的其他属性，如是否持久化。持久化的交换机可以在 Broker 重启后依然存在。</li></ul><blockquote><ol start="3"><li>生产者发送消息</li></ol></blockquote><ul><li><strong>发送消息</strong>：生产者向指定的交换机发送消息。发送时，生产者还可以指定消息的各种属性，如是否持久化消息体，设置消息优先级等。</li><li><strong>指定 Routing Key</strong>：发送消息时，生产者需要指定一个 <code>routing key</code>。这个 <code>routing key</code> 用于决定消息如何路由到队列。</li></ul><blockquote><ol start="4"><li>交换机处理消息</li></ol></blockquote><ul><li><strong>接收消息</strong>：交换机接收到生产者发送的消息后，开始根据交换机类型和 <code>routing key</code> 进行消息路由。</li><li><strong>路由到队列</strong>：交换机根据 <code>routing key</code> 和交换机类型将消息路由到一个或多个绑定的队列中。例如，在 direct 类型的交换机中，消息会路由到 <code>routing key</code> 完全匹配的队列。</li></ul><blockquote><ol start="5"><li>消费者处理消息</li></ol></blockquote><ul><li><strong>监听队列</strong>：消费者（Consumer）监听一个或多个队列，等待消息的到来。</li><li><strong>接收消息</strong>：一旦有消息到达队列，消费者就会接收到这个消息。</li><li><strong>业务处理</strong>：消费者获取消息后，开始进行相应的业务处理。</li></ul><p>在整个过程中，RabbitMQ 通过交换机和队列的机制提供了强大的消息路由能力。</p><p>交换机决定了消息如何根据 <code>routing key</code> 被路由到不同的队列，而消费者从队列中获取消息进行处理。这种机制支持了高度的解耦和灵活的消息处理策略，适用于各种复杂的消息处理场景。</p><h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><p>RabbitMQ 中最常用的几种交换机类型及其区别：</p><blockquote><ol><li>Direct Exchange（直接交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到那些 <code>binding key</code> 与消息的 <code>routing key</code> 完全匹配的队列。</li><li><strong>用途</strong>：非常适合单播（unicast）或多播（multicast）路由场景，即一对一或一对多发送。</li></ul><blockquote><ol start="2"><li>Fanout Exchange（扇出交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到所有与该交换机绑定的队列，忽略 <code>routing key</code>。</li><li><strong>用途</strong>：非常适合广播消息，如日志系统，其中消息需要被发送到多个目的地。</li></ul><blockquote><ol start="3"><li>Topic Exchange（主题交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：可以根据模式匹配 <code>routing keys</code> 和 <code>binding keys</code>（模式中可以包含通配符）。<code>routing key</code> 为点分隔的一系列单词，<code>binding key</code> 中可以包含特殊字符 <code>*</code> 和 <code>#</code> 来进行模式匹配，其中 <code>*</code> 匹配一个单词，<code>#</code> 匹配零个或多个单词。</li><li><strong>用途</strong>：适用于同时需要单播和多播路由逻辑的复杂路由配置。</li></ul><blockquote><ol start="4"><li>Headers Exchange（头部交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：基于消息头部（headers）中的属性进行匹配。不依赖 <code>routing key</code>。匹配规则可以是“所有”（<code>x-match=all</code>，即所有头部属性必须匹配）或“任何”（<code>x-match=any</code>，即任意头部属性匹配）。</li><li><strong>用途</strong>：适用于需要根据多个属性进行路由决策的高级路由策略。</li></ul><blockquote><p>总结</p></blockquote><p>选择哪种交换机类型主要取决于你的具体应用场景和消息路由需求。</p><p>直接交换机适合简单的单播路由，扇出交换机适合广播，主题交换机适合复杂的路由场景，而头部交换机适合基于多属性的路由决策。了解这些交换机的特点可以帮助你更好地设计消息路由策略，并充分利用 RabbitMQ 的强大功能。</p><p>RabbitMQ 的处理流程是围绕着连接、交换机、消息发送和消息接收这几个核心环节展开的。</p><h4 id="路由键（Routing-Key）的作用"><a href="#路由键（Routing-Key）的作用" class="headerlink" title="路由键（Routing Key）的作用"></a>路由键（Routing Key）的作用</h4><p>路由键是消息发布到 RabbitMQ 时<strong>附带的一个字符串标识</strong>，它的作用是帮助交换机决定如何路由消息。</p><p>这里的“路由”指的是决定消息应该被发送到哪一个或哪些队列。路由键的具体作用取决于交换机的类型：</p><ol><li><strong>Direct Exchange</strong>：交换机会将消息路由到那些 <code>binding key</code> 与 <code>routing key</code> 完全匹配的队列。</li><li><strong>Topic Exchange</strong>：可以进行模式匹配，交换机会根据 <code>routing key</code> 和队列的 <code>binding key</code>（可以包含通配符）进行匹配。</li><li><strong>Fanout Exchange</strong>：忽略路由键，消息会被发送到所有绑定到该交换机的队列。</li><li><strong>Headers Exchange</strong>：不依赖路由键，而是根据发送的消息头部中的键值对进行匹配。</li></ol><h4 id="交换机与消费者之间的协同"><a href="#交换机与消费者之间的协同" class="headerlink" title="交换机与消费者之间的协同"></a>交换机与消费者之间的协同</h4><p>交换机不直接与消费者通信来决定向哪个消费者发送消息。</p><p>相反，它依赖于队列和队列与消费者之间的关系来实现消息的分发。下面是它们是如何协同工作的：</p><ol><li><p><strong>队列绑定到交换机</strong>：队列通过 <code>binding key</code>（在 fanout 和 headers 交换机中，这个 <code>binding key</code> 不一定被使用）绑定到交换机。这个过程决定了哪些消息会被路由到特定的队列。</p></li><li><p><strong>消费者监听队列</strong>：消费者通过打开一个通道并订阅（或监听）一个或多个队列来接收消息。这意味着消费者告诉 RabbitMQ：“我对这个队列中的消息感兴趣，请将它们发送给我。”</p></li><li><p><strong>消息分发</strong>：当消息通过交换机被路由到队列后，RabbitMQ 会将队列中的消息发送给订阅该队列的消费者。这个分发过程可能是基于不同的策略，如轮询或公平调度等。</p></li></ol><h4 id="消费者的监听"><a href="#消费者的监听" class="headerlink" title="消费者的监听"></a>消费者的监听</h4><p>当我们说消费者“监听”一个队列时，实际上是指消费者开启了一个持续的、异步的过程，这个过程会等待、接收并处理来自队列的消息。</p><p>消费者通过通道向 RabbitMQ 注册其对特定队列的兴趣。一旦队列中有消息，RabbitMQ 就会将消息推送给消费者。消费者接收到消息后，会根据自己的逻辑进行处理。</p><p>消费者通过监听队列来接收消息，交换机本身并不决定消息发送给哪个消费者，这是由队列中的消息与消费者之间的关系决定的。<strong>消费者监听意味着它们准备好接收和处理从队列中来的消息。</strong></p><h3 id="4、RabbitMQ广播和直接模式示例"><a href="#4、RabbitMQ广播和直接模式示例" class="headerlink" title="4、RabbitMQ广播和直接模式示例"></a>4、RabbitMQ广播和直接模式示例</h3><p>项目参考： <a href="https://gitee.com/yidao620/springboot-bucket">https://gitee.com/yidao620/springboot-bucket</a></p><p>这个项目的最后更新时间是五年前， 这里建议单独打开一下 springboot-rabbitmq</p><p>本地的 maven 版本是 3.5.2 , springboot-rabbitmq 依赖中的 maven-compiler-plugin 改为了 3.6.1 后没有报错</p><p>在 SpringBoot 中，使用消息队列需要引入 amqp 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yml 配置内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>  <br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>  <br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>在这个项目中，定义了一个配置类 RabbitConfig</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package com.xncoding.pos.config;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RabbitConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @version 1.0</span><br><span class="hljs-comment"> * @since 2018/3/1</span><br><span class="hljs-comment"> */</span><br>@Configuration<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br>    @Resource<br>    private RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定制化 AMQP 模版。</span><br><span class="hljs-comment">     * 设置消息转换器、编码、消息确认和返回回调。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return the amqp template</span><br><span class="hljs-comment">     */</span><br>    @Bean<br>    public AmqpTemplate amqpTemplate() &#123;<br>        Logger log = LoggerFactory.getLogger(RabbitTemplate.<span class="hljs-keyword">class</span>);<br><br>        <span class="hljs-regexp">// 使用 Jackson 作为消息转换器，自动将消息转换为 JSON 格式</span><br><span class="hljs-regexp">        rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 设置字符编码为 UTF-<span class="hljs-number">8</span><br>        rabbitTemplate.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>        <span class="hljs-regexp">// 消息发送失败时返回到队列，需要在配置文件中设置 publisher-returns: true</span><br><span class="hljs-regexp">        rabbitTemplate.setMandatory(true);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 定义消息发送失败的回调<br>        rabbitTemplate.setReturnCallback<span class="hljs-function"><span class="hljs-params">((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">String</span> correlationId = message.getMessageProperties().getCorrelationIdString();</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;消息：&#123;&#125; 发送失败, 应答码：&#123;&#125; 原因：&#123;&#125; 交换机: &#123;&#125;  路由键: &#123;&#125;&quot;</span>, correlationId, replyCode, replyText, exchange, routingKey);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        // 定义消息发送到交换机确认回调，需要在配置文件中设置 <span class="hljs-title">publisher-confirms</span>: <span class="hljs-title">true</span></span><br><span class="hljs-function">        <span class="hljs-title">rabbitTemplate</span>.<span class="hljs-title">setConfirmCallback</span><span class="hljs-params">((correlationData, ack, cause) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span> (ack) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange成功,id: &#123;&#125;&quot;</span>, correlationData.getId());</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange失败,原因: &#123;&#125;&quot;</span>, cause);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">rabbitTemplate</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Direct</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Direct</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Exchange</span> <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Direct</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">directExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directQueue&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">directQueue</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_QUEUE&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列绑定到交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>    <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">exchange</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">directBinding</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;directQueue&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 @Qualifier(<span class="hljs-string">&quot;directExchange&quot;</span>) Exchange exchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列绑定到交换机，使用路由键 &quot;<span class="hljs-title">DIRECT_ROUTING_KEY</span>&quot;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(exchange)</span>.<span class="hljs-title">with</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>)</span>.<span class="hljs-title">noargs</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Fanout</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">FanoutExchange</span> <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(FanoutExchange)</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">fanoutExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">A</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueA</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">A</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_A&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">B</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueB</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">B</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_B&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingA</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingB</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这个 <code>RabbitConfig</code> 配置类通过 <code>@Bean</code> 注解声明了多个 Spring Bean，用于设置 RabbitMQ 的不同组件。</p><p>它涵盖了消息模板的定制、交换机和队列的声明，以及队列与交换机的绑定。</p><p>这样的配置提供了灵活的方式来定义消息传递的行为，包括消息格式、路由策略和队列管理，适用于不同的消息处理需求。</p><p>通过这种方式，可以在 Spring 应用中轻松地使用 RabbitMQ 进行高效的消息通信。</p><hr><p>通过广播方式发送消息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送广播模式的消息。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> p</span>) &#123;<br>    <span class="hljs-comment">// 创建 CorrelationData 对象，带有一个唯一的标识符。</span><br>    <span class="hljs-comment">// 这个标识符用于消息确认过程中识别消息。</span><br>    <span class="hljs-title class_">CorrelationData</span> correlationData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>().<span class="hljs-title function_">toString</span>());<br><br>    <span class="hljs-comment">// 使用 RabbitTemplate 将消息发送到指定的交换机。</span><br>    <span class="hljs-comment">// 参数1: 交换机名称 - 这里是 &quot;FANOUT_EXCHANGE&quot;。</span><br>    <span class="hljs-comment">// 参数2: 路由键 - 在 Fanout 交换机中，路由键会被忽略，所以这里传递一个空字符串。</span><br>    <span class="hljs-comment">// 参数3: 消息内容 - 这里是传入的参数 p。</span><br>    <span class="hljs-comment">// 参数4: CorrelationData - 包含消息的唯一标识符，用于消息跟踪和确认。</span><br>    rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的配置类中，是声明了 Fanout 交换机， 并且绑定两个队列在这个交换机上。</p><h4 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.service;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.support.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-built_in">this</span>.getClass());<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试广播模式.</span><br><span class="hljs-comment">     * 在广播模式下，消息会被发送到所有绑定到交换机的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcast</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 FANOUT_EXCHANGE 交换机，路由键为空字符串</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试Direct模式.</span><br><span class="hljs-comment">     * 在Direct模式下，消息会被路由到具有指定路由键的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">direct</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 DIRECT_EXCHANGE 交换机，并指定路由键</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>, p, correlationData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.mq;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息监听器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Receiver.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听一.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_A 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_A&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_A &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听二.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_B 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_B&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_B &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * DIRECT模式.</span><br><span class="hljs-comment">     * 在 DIRECT_QUEUE 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;DIRECT_QUEUE&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;DIRECT &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在生产者类（<code>SenderService</code>）中，两个方法分别演示了如何在广播（Fanout）和直接（Direct）模式下发送消息。</li><li>在消费者类（<code>Receiver</code>）中，每个方法都使用了 <code>@RabbitListener</code> 注解来监听特定的队列，并在接收到消息后执行相应的处理逻辑。</li></ul><p>这里由于你配置了接收的监听，因此当你发送的时候你就收到了这条消息，并且通过日志的方式打印了出来，如果需要比较明显一点的观察现象，可以加一个等待时间确保被消费。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 等待一段时间以确保消息被消费 </span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="主题交换机（Topic-Exchange）的使用示例"><a href="#主题交换机（Topic-Exchange）的使用示例" class="headerlink" title="主题交换机（Topic Exchange）的使用示例"></a>主题交换机（Topic Exchange）的使用示例</h4><p>Topic Exchange 直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。</p><p>这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”* “ 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。<br><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121409207.png" alt="image.png"></p><blockquote><p>使用示例</p></blockquote><p>在前文的基础上，新增一些内容</p><p>配置类(更新配置类以包含一个主题交换机和两个队列，以及它们的绑定)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他配置 ...</span><br><br>    <span class="hljs-comment">// Topic Exchange 配置</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TopicExchange</span> <span class="hljs-title function_">topicExchange</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicExchange</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueOneWord</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueMultipleWords</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.*&quot; 只匹配一个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicOneWord</span>(<span class="hljs-params">Queue topicQueueOneWord, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueOneWord).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.#&quot; 匹配零个或多个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicMultipleWords</span>(<span class="hljs-params">Queue topicQueueMultipleWords, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueMultipleWords).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.#&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RabbitTemplate</span> rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到主题交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendToTopic</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> routingKey, <span class="hljs-built_in">String</span> message</span>) &#123;<br>        rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>, routingKey, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Logger</span> log = <span class="hljs-title class_">LoggerFactory</span>.<span class="hljs-title function_">getLogger</span>(<span class="hljs-title class_">Receiver</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicOneWord</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_ONE_WORD: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicMultipleWords</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_MULTIPLE_WORDS: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类(发送消息并验证它们被正确路由到对应的队列：)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// ... 其他测试 ...</span><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SenderService senderService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testTopicExchange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.*&quot;，应该只被 TOPIC_QUEUE_ONE_WORD 接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one&quot;</span>, <span class="hljs-string">&quot;Message for topic.one&quot;</span>);<br><br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.#&quot;，应该被两个队列接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one.two&quot;</span>, <span class="hljs-string">&quot;Message for topic.one.two&quot;</span>);<br><br>        <span class="hljs-comment">// 等待一段时间以确保消息被消费</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个测试消息使用路由键 “topic.one”，它符合 <code>*</code> 的匹配规则（匹配一个单词），因此只有 “TOPIC_QUEUE_ONE_WORD” 队列接收到这个消息。</li><li>第二个测试消息使用路由键 “topic.one.two”，它符合 <code>#</code> 的匹配规则（匹配多个单词），因此两个队列都接收到这个消息。</li></ul><p>运行测试后，通过日志输出可以验证这些匹配规则是否按预期工作。</p><blockquote><p>小结</p></blockquote><p>在 RabbitMQ中比较常用的三种模式是：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。</p><p>熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>通配符(TopicExchange)这种模式也可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一些。</p><hr><p>参考</p><ul><li><a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li><a href="https://developer.aliyun.com/article/769883">https://developer.aliyun.com/article/769883</a></li><li><a href="https://blog.csdn.net/CherryChenieth/article/details/124767155">https://blog.csdn.net/CherryChenieth/article/details/124767155</a></li><li><a href="https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html">https://javaguide.cn/high-performance/message-queue/rabbitmq-questions.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RocketMQ_基础使用</title>
    <link href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>RocketMQ是什么</li><li>队列模型和主题模型</li><li>RocketMQ架构设计</li><li>RocketMQ 的功能特性</li><li>如何解决顺序消费和重复消费</li><li>RocketMQ 如何实现分布式事务</li><li>如何解决消息堆积问题？</li><li>回溯消费</li><li>RocketMQ 如何保证高性能读写</li><li>RocketMQ 的刷盘机制</li><li>RocketMQ 如何保证不丢失消息</li></ul><h4 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h4><p>消息队列能用来干什么</p><ul><li>异步</li><li>解耦</li><li>削峰</li></ul><p>在引入消息队列时，同时意味着会给系统带来一系列的副作用和挑战，这些问题需要在设计和实施过程中予以特别考虑。</p><p>关键点和风险：</p><ul><li><ol><li>降低系统的可用性</li></ol></li><li><ol start="2"><li>增加系统的复杂度</li></ol></li><li><ol start="3"><li>如何解决重复消费消息的问题</li></ol></li><li><ol start="4"><li>如何解决消息的顺序消费问题</li></ol></li><li><ol start="5"><li>解决分布式事务问题</li></ol></li><li><ol start="6"><li>解决消息堆积的问题</li></ol></li></ul><h3 id="1、RocketMQ是什么"><a href="#1、RocketMQ是什么" class="headerlink" title="1、RocketMQ是什么"></a>1、RocketMQ是什么</h3><p>RocketMQ 是一款开源的分布式消息和流处理平台，由阿里巴巴集团开发并贡献给 Apache 软件基金会。它被设计用于处理大规模、高吞吐量的消息传递，并在阿里巴巴集团内部及众多企业中广泛使用。</p><p>特点：高性能，高可靠，高实时，分布式</p><h3 id="2、队列模型和主题模型"><a href="#2、队列模型和主题模型" class="headerlink" title="2、队列模型和主题模型"></a>2、队列模型和主题模型</h3><p>了解 RocketMQ 前，我们先了解下面两个名词概念：队列模型和主题模型</p><h4 id="队列模型和主题模型"><a href="#队列模型和主题模型" class="headerlink" title="队列模型和主题模型"></a>队列模型和主题模型</h4><ul><li>队列模型<ul><li>队列方式，生产者消费者</li></ul></li><li>主题模型&#x2F;发布订阅<ul><li>发布者将消息发送到指定主题中，订阅者需要 <strong>提前订阅主题</strong> 才能接受特定主题的消息。<img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231220201308.png" alt="image.png|500"></li></ul></li></ul><h4 id="RocketMQ中的消息模型"><a href="#RocketMQ中的消息模型" class="headerlink" title="RocketMQ中的消息模型"></a>RocketMQ中的消息模型</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>`RocketMQ` 中的消息模型是按照 主题模型 所实现的</strong></div><p>RocketMQ 实现的消息传递模型遵循了主题模型（也称为发布&#x2F;订阅模型）这一标准。</p><p>主题模型是消息中间件中的一种设计模式，它定义了如何进行消息的发布和订阅。在这种模型中，消息生产者（发布者）发送消息到一个主题（Topic），而消息消费者（订阅者）订阅这个主题并接收相应的消息。</p><blockquote><p>核心概念理解：</p></blockquote><ul><li><strong>主题模型（Topic Model）</strong>：<ul><li>它是一种发布&#x2F;订阅消息传递的架构模式。</li><li>消息生产者发布消息到主题，而不是直接发送给特定的消费者。</li><li>消息消费者订阅主题来接收消息，而不是从特定生产者接收。</li></ul></li><li><strong>发布&#x2F;订阅模型（Pub&#x2F;Sub Model）</strong>：<ul><li>这是主题模型的另一种叫法，强调的是消息的发布和订阅机制。</li><li>任何订阅了主题的消费者都能接收到主题中的消息，实现了生产者和消费者的解耦。</li></ul></li></ul><h4 id="RocketMQ-的主题模型如何实现"><a href="#RocketMQ-的主题模型如何实现" class="headerlink" title="RocketMQ 的主题模型如何实现"></a>RocketMQ 的主题模型如何实现</h4><p>在 RocketMQ 中，这种模型是通过多个队列（Queue）来实现的，每个队列相当于 Kafka 中的分区或 RabbitMQ 中的 Exchange。</p><p>具体实现看下一章的架构设计。</p><h3 id="3、RocketMQ架构设计"><a href="#3、RocketMQ架构设计" class="headerlink" title="3、RocketMQ架构设计"></a>3、RocketMQ架构设计</h3><p>先了解一下，在 RocketMQ 中，他的一些基础角色。</p><h4 id="基础角色"><a href="#基础角色" class="headerlink" title="基础角色"></a>基础角色</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231226214425.png" alt="image.png"></p><p><code>RocketMQ</code> 技术架构中有四大角色 <code>NameServer</code>、<code>Broker</code>、<code>Producer</code>、<code>Consumer</code></p><ul><li><code>NameServer</code><ul><li>注册中心，提供 <code>Broker</code>管理和路由信息管理</li><li>操作步骤<ul><li><ol><li><code>Broker</code> 会将自己的信息注册到 <code>NameServer</code> 中（此时，<code>NameServer</code> 会存放很多 <code>Broker</code> 的信息  ←  Broker 的路由表信息）</li></ol></li><li><ol start="2"><li>消费者和生产者从 <code>NameServer</code> 获取路由表信息和对应的  <code>Broker</code> 进行通信(生产者和消费者定期会向 <code>NameServer</code> 去查询相关的 <code>Broker</code> 的信息)</li></ol></li></ul></li><li>多个 NameServer 形成集群，但它们之间不同步信息。客户端（Producer 和 Consumer）可以连接任意一个 NameServer</li></ul></li><li><code>Broker</code><ul><li>消息队列服务器，生产者生产消息到 <code>Broker</code> ，消费者从 <code>Broker</code> 拉取消息并消费。</li><li>Broker 可以是 Master 也可以是 Slave。<ul><li>每个 Master 可以有多个 Slave。Master 负责读写消息，Slave 可以进行消息的同步，保证数据的高可用性。</li></ul></li><li>Broker 是消息存储和转发的核心。生产者将消息发送到 Broker，Broker 负责将消息保存在相应的队列中。</li><li>Broker 处理所有与消息相关的操作，包括消息的存储、检索、删除以及向消费者分发消息。</li><li>Broker 负责维护每个队列的状态，如消息偏移量（Offset），确保消息能够被正确地消费。</li></ul></li><li><code>Producer</code><ul><li>生产者</li></ul></li><li><code>Consumer</code><ul><li>消费者</li><li>消费者向 Broker 订阅特定的 Topic。这个过程会涉及 NameServer 来找到托管该 Topic 的 Broker。</li><li>一旦 Broker 中的 Topic 收到消息，符合条件的消费者（那些订阅了该 Topic 的消费者）就可以接收到这些消息。</li><li><strong>消费模式</strong>：<ul><li>在集群消费模式下，每条消息只会被消费者组中的一个消费者处理。</li><li>在广播消费模式下，每条消息会被发送到消费者组中的所有消费者。</li></ul></li></ul></li></ul><h4 id="消息处理-😀"><a href="#消息处理-😀" class="headerlink" title="消息处理 😀"></a>消息处理 😀</h4><p>生产消息和消费消息操作：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312271701523.png" alt="image.png"></p><p>讲述一下在 RocketMQ 中，生产者组发送消息以及消费者组是如何接受消息的。</p><p>在RocketMQ 中，NameServer 负责服务发现和路由管理，当生产者组发送某一个主题的消息时候，Producer Groups 会先从 NameServer 获取到 Topic 主题消息 所在的 Broker 信息，根据这些信息，生产者组会发送消息到正确的 Broker 和 对应的队列中。</p><p>里面的一个核心观点是 Topic ，个人理解主题Topic 是 将Queue进行分类，类似分组、标签（逻辑上）</p><p>而 Queue 的实际作用是 物理实际分区，消息的实际存储地方；消息发送到正确的 Broker 后，Broker 会负责将消息<strong>保存在</strong>相应的队列中。</p><p>Consumer Groups 会从NameServer 查询 Broker 的信息（从 NameServer 来找到托管该 Topic 的 Broker），订阅对应主题的消息，当 一旦 Broker 中的 Topic 收到消息，就可以接收到对应消息。</p><hr><p>一些常用的操作和概念也需要理解下。</p><p>当某个 <code>Topic</code> 消息量很大，应该给它多配置几个队列，并且 <strong>尽量多分布在不同 <code>Broker</code> 上，以减轻某个 <code>Broker</code> 的压力</strong> 。</p><p><code>Topic</code> 消息量都比较均匀的情况下，如果某个 <code>broker</code> 上的队列越多，则该 <code>broker</code> 压力越大。</p><blockquote><p>通常建议消费者组中的消费者数量与主题中的队列数量保持一致</p></blockquote><ul><li>这样做的目的是为了最大化并行处理的效率。</li><li><strong>原因</strong>：如果消费者的数量多于队列的数量，那么会有一些消费者实际上没有分配到队列，从而闲置。相反，如果消费者的数量少于队列的数量，某些队列可能不会被及时消费，导致消息积压。</li></ul><blockquote><p><strong>每个消费组在每个队列上维护一个消费位置</strong> </p></blockquote><ul><li><strong>Offset 的作用</strong>：消费位移是指消费者在队列中消费到的位置。它用于跟踪消费者已经消费到哪里，以便在消费者重启或故障后能够从上次的位置继续消费。</li><li><strong>谁来维护</strong>：这个位移是由 Broker 维护的。消费者在处理完消息后，会向 Broker 报告自己的消费位移。</li><li><strong>消息的保留</strong>：队列中的消息通常会在所有消费者组消费之后才会被删除。这意味着，只要有一个消费者组还没有消费某条消息，这条消息就会被保留在队列中。</li></ul><blockquote><p>消息的存储和删除</p></blockquote><ul><li><strong>数据的持久化</strong>：Broker 负责消息的存储。只要消息还没有被所有订阅的消费者组消费，它就会一直存储在 Broker 中。</li><li><strong>消息的删除</strong>：消息通常在满足一定条件后才会被删除，例如，当所有消费者组都消费了该消息，或者消息达到了其存储的最大时间（如设置了消息的存储时长）。</li></ul><blockquote><p>为什么一个主题中需要维护多个队列？</p></blockquote><ol><li><strong>提高并发能力</strong>：在一个主题下配置多个队列的目的是为了提高消息处理的并发能力。这允许多个生产者同时向不同的队列发送消息，同时也允许多个消费者并行地从不同队列中拉取和处理消息。</li><li><strong>负载均衡和效率</strong>：如果一个主题只有一个队列，那么所有的消息都会被顺序地放入这个单一的队列中，这限制了并行处理的可能性。在这种情况下，即使有多个消费者，也只能有一个消费者在任何给定时间处理队列中的消息，从而降低了整体的处理效率。</li></ol><h4 id="RocketMQ-的高可用"><a href="#RocketMQ-的高可用" class="headerlink" title="RocketMQ 的高可用"></a>RocketMQ 的高可用</h4><p>高可用情景下，会构建 <code>broker</code>  集群并且进行主从部署，同时<code>NameServer</code> 也进行集群部署。</p><p>官网架构图</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312211545167.png" alt="image.png"></p><p>第一，构建 <code>broker</code>  集群并且进行主从部署，此时，消息会分布在多个  <code>broker</code> </p><p>当某个 <code>Broker</code> 宕机，在<code>Rocketmq</code> 的 <code>master/slave</code> 结构下，<code>salve</code> 定时从 <code>master</code> 同步数据(同步刷盘或者异步刷盘)，如果 <code>master</code> 宕机，则 <code>slave</code> 提供消费服务，但是不能写入消息</p><p>第二， <code>NameServer</code> 进行了集群部署（ <strong>去中心化</strong> 的，没有主节点）；</p><p><code>Broker 会和所有 NameServer 保持长连接 ，并且在每隔 30 秒 </code>Broker<code>会向所有</code>Nameserver<code>发送心跳，心跳包含了自身的</code>Topic<code>配置信息，这个步骤就对应图中的</code>Routing Info&#96;</p><p>第三，在生产者需要向 <code>Broker</code> 发送消息的时候，<strong>需要先从 <code>NameServer</code> 获取关于 <code>Broker</code> 的路由信息</strong>，然后通过 <strong>轮询</strong> 的方法去向每个队列中生产数据以达到 <strong>负载均衡</strong> 的效果。</p><p>第四、消费者通过 <code>NameServer</code> 获取所有 <code>Broker</code> 的路由信息后，向 <code>Broker</code> 发送 <code>Pull</code> 请求来获取消息数据。</p><p><code>Consumer</code> 可以以两种模式启动—— <strong>广播（Broadcast）和集群（Cluster）</strong>。广播模式下，一条消息会发送给 <strong>同一个消费组中的所有消费者</strong> ，集群模式下消息只会发送给一个消费者。</p><h3 id="4、RocketMQ-的功能特性"><a href="#4、RocketMQ-的功能特性" class="headerlink" title="4、RocketMQ 的功能特性"></a>4、RocketMQ 的功能特性</h3><h4 id="消息"><a href="#消息" class="headerlink" title="消息"></a>消息</h4><p>在 RocketMQ 中，一般使用的是普通消息，还有定时消息、顺序消息、事务消息；下面我们分别来了解一下具体的一些使用。</p><blockquote><p>普通消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于大多数标准的消息传递需求，如异步处理、系统解耦、数据分发等。</li><li><strong>使用</strong>：生产者发送消息到指定的主题（Topic），消费者从主题订阅并处理这些消息。消息按照到达 Broker 的顺序存储。</li></ul><p><strong>普通消息生命周期</strong></p><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><blockquote><p>定时消息</p></blockquote><ul><li><strong>业务场景</strong>：用于那些需要在指定时间点执行的任务，如延迟通知、定时任务等。</li><li><strong>使用</strong>：生产者发送消息时指定一个延时级别，消息将在指定的延时后才被投递。RocketMQ 不支持任意的延时时间，而是提供了几个预设的延时级别（如1分钟、5分钟、10分钟等）。</li></ul><p><strong>定时消息生命周期</strong></p><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>定时中：消息被发送到服务端，和普通消息不同的是，服务端不会直接构建消息索引，而是会将定时消息<strong>单独存储在定时存储系统中</strong>，等待定时时刻到达。</li><li>待消费：定时时刻到达后，服务端将消息重新写入普通存储引擎，对下游消费者可见，等待消费者消费的状态。</li><li>消费中：消息被消费者获取，并按照消费者本地的业务逻辑进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ 会对消息进行重试处理。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。RocketMQ 默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：Apache RocketMQ 按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li></ul><p>定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延迟，影响定时精度。</p><blockquote><p>顺序消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于严格要求消息顺序的场景，如股票价格更新、订单状态变更等，这些场景中消息的处理顺序会影响到业务逻辑的正确性。</li><li><strong>使用</strong>：生产者在发送消息时，将消息分配到特定的队列。消费者从队列中按顺序消费消息。RocketMQ 通过固定的映射关系（如订单号的散列值）来保证相同类型的消息被路由到同一队列。</li></ul><p>顺序消息仅支持使用 MessageType 为 FIFO 的主题，即顺序消息只能发送至类型为顺序消息的主题中，发送的消息的类型必须和主题的类型一致。</p><p>和普通消息发送相比，顺序消息发送必须要设置消息组。（推荐实现 MessageQueueSelector 的方式）。要保证消息的顺序性需要单一生产者串行发送。</p><p>单线程使用 MessageListenerConcurrently 可以顺序消费，多线程环境下使用 MessageListenerOrderly 才能顺序消费。</p><blockquote><p>事务消息</p></blockquote><ul><li><strong>业务场景</strong>：适用于需要保证消息发送和本地事务同时成功或失败的场景，如支付和订单服务间的交互。</li><li><strong>使用</strong>：<ul><li>生产者发送半消息（预备消息）。</li><li>执行本地事务（比如数据库操作）。</li><li>根据本地事务执行结果，提交或回滚消息。提交的消息将被消费者消费，回滚的消息将被删除。</li></ul></li></ul><h4 id="发送消息"><a href="#发送消息" class="headerlink" title="发送消息"></a>发送消息</h4><ul><li>不建议单一进程创建大量生产者<ul><li>对于生产者的创建和初始化，建议遵循够用即可、最大化复用原则</li></ul></li><li>不建议频繁创建和销毁生产者</li></ul><blockquote><p>创建和销毁生产者</p></blockquote><p>正确示例：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs abnf">Producer p <span class="hljs-operator">=</span> ProducerBuilder.build()<span class="hljs-comment">;</span><br>for (int i <span class="hljs-operator">=</span><span class="hljs-number">0</span><span class="hljs-comment">;i&lt;n;i++)&#123;</span><br>    Message m<span class="hljs-operator">=</span> MessageBuilder.build()<span class="hljs-comment">;</span><br>    p.send(m)<span class="hljs-comment">;</span><br> &#125;<br>p.shutdown()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="消费者分组-🦌"><a href="#消费者分组-🦌" class="headerlink" title="消费者分组  🦌"></a>消费者分组  🦌</h4><ul><li>PushConsumer</li><li>SimpleConsumer</li><li>PullConsumer</li></ul><h4 id="生产者分组和消费者分组"><a href="#生产者分组和消费者分组" class="headerlink" title="生产者分组和消费者分组"></a>生产者分组和消费者分组</h4><blockquote><p>生产者分组</p></blockquote><ol><li><strong>RocketMQ 5.x 版本及以后</strong>：<ul><li>生产者现在是“匿名”的，即不再强调生产者分组（ProducerGroup）的概念。</li><li>在服务端，生产者不需要显式地配置为特定的分组，这简化了生产者的管理。</li></ul></li><li><strong>RocketMQ 3.x 和 4.x 版本</strong>：<ul><li>在这些历史版本中，生产者分组是一个重要的概念，用于标识和管理一组有着相同行为的生产者。</li><li>如果你是从这些旧版本升级到 5.x，那么之前使用的生产者分组可以废弃，不再需要设置，且不会影响当前业务。</li></ul></li></ol><blockquote><p>消费者分组</p></blockquote><ol><li><strong>概念</strong>：<ul><li>消费者分组是多个消费者的一个逻辑分组，这些消费者有着一致的消费行为。</li><li>通过消费者分组，可以实现消费行为的负载均衡和高可用性。</li></ul></li><li><strong>功能</strong>：<ul><li><strong>订阅关系管理</strong>：RocketMQ 以消费者分组的粒度来管理和追溯订阅关系。</li><li><strong>投递顺序性</strong>：服务端支持顺序投递和并发投递，这些投递方式在消费者分组中统一配置。</li><li><strong>消费重试策略</strong>：包括重试次数和死信队列的设置，用于处理消费失败的情况。</li></ul></li><li><strong>版本差异</strong>：<ul><li><strong>5.x 版本</strong>：消费者的消费行为统一由关联的消费者分组在服务端配置和管理，确保同一分组内所有消费者的行为一致。</li><li><strong>3.x&#x2F;4.x 历史版本</strong>：消费行为由消费者客户端接口定义，需要在消费者客户端设置时确保同一分组下的消费者行为一致。</li></ul></li></ol><p>RocketMQ 5.x 版本中对生产者分组的概念进行了简化，使其成为匿名的，而消费者分组则仍然是一个关键概念，用于管理消费者的行为和策略。</p><h3 id="5、如何解决顺序消费和重复消费"><a href="#5、如何解决顺序消费和重复消费" class="headerlink" title="5、如何解决顺序消费和重复消费"></a>5、如何解决顺序消费和重复消费</h3><h4 id="顺序消费"><a href="#顺序消费" class="headerlink" title="顺序消费"></a>顺序消费</h4><p>根据上文的架构设计中，我们可以知道<code>RocketMQ</code> 在主题上是无序的、它只有在队列层面才是保证有序的。</p><p>讲述顺序消费一般会设计两个概念——<strong>普通顺序</strong> 和 <strong>严格顺序</strong> 。</p><ul><li>普通顺序<ul><li>所谓普通顺序是指 消费者通过 <strong>同一个消费队列收到的消息是有顺序的</strong> ，不同消息队列收到的消息则可能是无顺序的。普通顺序消息在 <code>Broker</code> <strong>重启情况下不会保证消息顺序性</strong> (短暂时间) 。</li></ul></li><li>严格顺序<ul><li>所谓严格顺序是指 消费者收到的 <strong>所有消息</strong> 均是有顺序的。严格顺序消息 <strong>即使在异常情况下也会保证消息的顺序性</strong> 。</li></ul></li></ul><p>在严格顺序这种模式下，实现的成本较高，同时风险比较大，如果你使用严格顺序模式，<code>Broker</code> 集群中只要有一台机器不可用，则整个集群都不可用。现在主要场景是在 <code>binlog</code> 同步。</p><p>一般而言，我们的 <code>MQ</code> 都是能容忍短暂的乱序，所以推荐使用普通顺序模式。</p><hr><p>下面围绕普通顺序讲述一下消息的顺序保证实现。</p><p> <code>Producer</code> 生产消息的时候会进行轮询(取决负载均衡策略)来向同一主题的不同消息队列发送消息。</p><p>在这种情况下， RocketMQ 中实现普通顺序模式主要涉及到如何确保相关的消息（例如同一个订单的不同操作）被发送到同一个队列中，以保持消息的顺序性。</p><p>这里的关键在于正确地选择队列来发送消息。以下是详细的解释和实现方法：</p><blockquote><p>普通顺序模式的基本原理</p></blockquote><ul><li><strong>问题</strong>：在默认情况下，生产者在发送消息时可能会轮询地选择不同的队列，这可能导致同一个业务流程（如一个订单的不同操作）的相关消息被发送到不同的队列，从而打乱消息的顺序。</li><li><strong>解决方案</strong>：为了保证同一业务流程的消息被发送到同一个队列，需要在发送消息时采用一致的队列选择策略。</li></ul><blockquote><p>实现普通顺序模式</p></blockquote><ol><li><strong>使用哈希取模法</strong>：<ul><li>这是实现消息顺序的一种常用方法。生产者在发送每条消息时，可以根据业务标识符（例如订单ID）进行哈希计算。</li><li>然后，使用这个哈希值对队列数量进行取模运算，以此决定将消息发送到哪个队列。</li><li>这样做的结果是，相同订单ID的所有消息都会被发送到同一个队列，保持了顺序。</li></ul></li><li><strong>RocketMQ 的队列选择算法</strong>：<ul><li>RocketMQ 提供了内置的队列选择算法，其中之一是基于消息键的哈希值来选择队列。</li><li>当生产者发送消息时，可以指定一个消息键（例如订单ID），RocketMQ 会根据这个键的哈希值来选择队列。</li></ul></li><li><strong>发送顺序消息的实践</strong>：<ul><li>在实际应用中，确保每次发送消息时都使用相同的业务标识符（如订单ID）作为消息键。</li><li>这样，无论是使用 RocketMQ 的内置队列选择算法还是自定义的哈希取模法，都能确保同一订单的不同操作（创建、支付、发货）的消息被发送到同一个队列。</li></ul></li></ol><p><strong>消费顺序消息</strong></p><ul><li>在消费端，消费者会按照消息在队列中的顺序来处理消息。</li><li>由于相关的消息都在同一队列中，这保证了消费者能够按照发送顺序来处理这些消息。</li></ul><blockquote><p>队列选择算法</p></blockquote><p>RocketMQ 实现了两种队列选择算法，也可以自己实现</p><ul><li>轮询算法<ul><li>轮询算法就是向消息指定的 topic 所在队列中依次发送消息，保证消息均匀分布</li><li>是 RocketMQ 默认队列选择算法</li></ul></li><li>最小投递延迟算法<ul><li>每次消息投递的时候统计消息投递的延迟，选择队列时优先选择消息延时小的队列，导致消息分布不均匀,按照如下设置即可。</li><li>&#96;producer.setSendLatencyFaultEnable(true);</li></ul></li><li>继承 MessageQueueSelector 实现</li></ul><p>继承 MessageQueueSelector 实现</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-title class_">SendResult</span> sendResult = producer.<span class="hljs-title function_">send</span>(msg, <span class="hljs-keyword">new</span> <span class="hljs-title class_">MessageQueueSelector</span>() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">MessageQueue</span> <span class="hljs-title function_">select</span>(<span class="hljs-params">List&lt;MessageQueue&gt; mqs, Message msg, <span class="hljs-built_in">Object</span> arg</span>) &#123;<br>        <span class="hljs-comment">//从mqs中选择一个队列,可以根据msg特点选择</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>());<br></code></pre></td></tr></table></figure><h4 id="重复消费"><a href="#重复消费" class="headerlink" title="重复消费"></a>重复消费</h4><blockquote><p>重复消费问题</p></blockquote><ul><li>在消息队列系统中，由于各种原因（如网络波动、Broker 重启等），消息可能会被重复发送给消费者。</li><li>如果消费者对同一消息的重复处理会导致不同的结果（如多次增加用户积分），就会产生问题。</li></ul><blockquote><p>幂等性解决策略</p></blockquote><ul><li><strong>幂等性定义</strong>：幂等操作指的是无论执行多少次，都产生相同的效果。在消息队列的上下文中，这意味着对同一消息的重复处理应该保证最终结果不变。</li><li><strong>实例说明</strong>：例如，一个处理订单积分的系统，即使接收到同一订单消息多次，也应该只给用户增加一次相应的积分。</li></ul><blockquote><p>实现幂等性的方法</p></blockquote><ol><li><strong>使用 Redis</strong>：<ul><li>利用 Redis 的 key-value 特性实现幂等性。例如，使用订单ID作为 key，确保对同一订单的处理是幂等的。</li></ul></li><li><strong>数据库插入法</strong>：<ul><li>依赖数据库的唯一键约束来防止重复数据的插入，如使用唯一索引来确保每条消息只被处理一次。</li></ul></li><li><strong>场景特定解决方案</strong>：<ul><li>根据业务场景的不同，选择合适的幂等性实现方法。考虑消息消费的特性，决定是采用强校验还是弱校验的幂等性策略。</li></ul></li></ol><p>幂等性的概念不限于消息队列，它同样适用于其他场景，如避免 HTTP 服务的重复请求处理或解决 RPC 框架在自动重试时的重复调用问题。</p><p>重要的是根据具体的业务需求和场景来设计和实现幂等性策略。</p><h4 id="特殊情况处理"><a href="#特殊情况处理" class="headerlink" title="特殊情况处理"></a>特殊情况处理</h4><h5 id="发送异常"><a href="#发送异常" class="headerlink" title="发送异常"></a>发送异常</h5><p>选择队列后会与 Broker 建立连接，通过网络请求将消息发送到 Broker 上，如果 Broker 挂了或者网络波动发送消息超时此时 RocketMQ 会进行重试。</p><p>重新选择其他 Broker 中的消息队列进行发送，默认重试两次，可以手动设置。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">producer.setRetryTimesWhenSendFailed(<span class="hljs-number">5</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h5 id="消息过大"><a href="#消息过大" class="headerlink" title="消息过大"></a>消息过大</h5><p>消息超过 4k 时 RocketMQ 会将消息压缩后在发送到 Broker 上，减少网络资源的占用。</p><h3 id="6、RocketMQ-如何实现分布式事务"><a href="#6、RocketMQ-如何实现分布式事务" class="headerlink" title="6、RocketMQ 如何实现分布式事务"></a>6、RocketMQ 如何实现分布式事务</h3><p>这里建议用实际例子去补充一下具体如何完成的，目前我们讲述一下 RocketMQ 是如何实现分布式事务的。</p><blockquote><p>分布式事务的常见实现方式（每种方法都有其适用场景和局限性）</p></blockquote><ul><li>2PC（两阶段提交）</li><li>TCC（Try-Confirm-Cancel）</li><li>事务消息（half 半消息机制）</li></ul><blockquote><p>RocketMQ 的分布式事务实现</p></blockquote><p>在 RocketMQ 中，其采用的实现机制是：事务消息加上事务反查机制。</p><p>参考一下这篇博客中关于订单关于的一个流程使用： <a href="https://juejin.cn/post/6844904099993878536">https://juejin.cn/post/6844904099993878536</a></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281351790.png" alt="image.png"></p><p>上述内容提及到自己认为需要注意的点：</p><ul><li>本地事务进行下一步操作后，服务方才会提交或者回滚半消息到 RocketMQ 的节点 Broker</li></ul><blockquote><p>图：RocketMQ 实现分布式事务</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281358695.png" alt="image.png"></p><p>关于 Half Message，半消息  和 事务状态回查  的一个基本表述：</p><ol><li><strong>事务消息（Half 消息）</strong>：<ul><li><strong>第一步：发送 Half 消息</strong>：所谓的 Half 消息是指一种特殊状态的消息，它在事务完成之前对消费者是不可见的。</li><li><strong>实现机制</strong>：当发送一个事务消息时，RocketMQ 首先存储这个消息，但将其标记为不可见状态（Half 状态）。这是通过改变消息的主题为 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 实现的，因为消费者通常不订阅这个特殊主题，所以不会消费这些 Half 消息。</li></ul></li><li><strong>事务反查机制</strong>：<ul><li><strong>定时任务</strong>：RocketMQ 会启动一个定时任务，定期检查 <code>RMQ_SYS_TRANS_HALF_TOPIC</code> 中的消息。</li><li><strong>反查请求</strong>：对于每条 Half 消息，RocketMQ 会根据其生产者组向相应的服务发送事务状态回查请求。</li><li><strong>事务状态决定</strong>：根据回查结果，RocketMQ 会决定是提交还是回滚这条消息。如果事务成功，消息将变为正常状态并可被消费；如果事务失败，消息将被回滚或删除。</li></ul></li><li><strong>网络波动和事务反查的重要性</strong>：<ul><li><strong>问题场景</strong>：如果在确认事务成功（即第四步）时出现网络问题，RocketMQ 无法知道该消息是否应该对消费者可见。</li><li><strong>反查机制的作用</strong>：事务反查确保即使在网络波动或其他问题的情况下，事务消息的最终状态也能得到正确处理。</li></ul></li></ol><p>其他的表述也是大同小异，具体更多的细节可以看一下具体实现，以及相关联的其他分布式事务是如何实现的，比较差异。</p><h3 id="7、如何解决消息堆积问题？"><a href="#7、如何解决消息堆积问题？" class="headerlink" title="7、如何解决消息堆积问题？"></a>7、如何解决消息堆积问题？</h3><p>解决消息队列中的堆积问题通常需要从两个主要方面考虑：</p><ul><li>生产者生产消息减少</li><li>消费者处理消息速率加快</li></ul><blockquote><p>生产者生产消息减少</p></blockquote><p>处理策略一般是限流和降级：</p><ul><li><strong>生产者限流</strong>：在高峰期，如果生产者生产消息的速度过快，可以采取限流措施。这意味着暂时减少消息的生产速率，或者在非高峰时段再进行消息的发送。</li><li><strong>服务降级</strong>：在系统负载过高时，可以临时关闭一些非核心业务功能，减少消息的产生。</li></ul><blockquote><p>消费者处理消息速率加快</p></blockquote><p>处理策略可以是 增加消费者实例 以及 增加队列数量</p><ul><li>增加消费者实例（集群消费模式下增长同一个消费者组下的实例数对堆积消息消费处理帮助不大）<ul><li>当现有队列中有消息堆积，并且现有的消费者处理能力不足以及时处理这些消息时。</li><li>增加消费者实例可以帮助更快地处理现有队列中已经堆积的消息。</li><li>在一个队列只被一个消费者消费的场景中（如 RocketMQ 的集群消费模式），增加同一消费者组的实例数对于加快处理一个单独队列中的堆积消息是无效的。</li></ul></li><li>增加队列数量（增加队列数量后，新来的一些消息能够被策略分配到新的队列，从而减少堆积压力）<ul><li>当预期未来将有高负载，或者想要提高系统处理新消息的能力时。</li><li>增加队列数量可以为新生产的消息提供更多的存储空间，并允许更多的消费者并行处理这些新消息。</li><li>仅仅增加队列数量而不增加消费者实例可能导致新队列中的消息未被及时消费，特别是在集群消费模式下。</li></ul></li></ul><div style="background: linear-gradient(to right, #74ebd5, #ACB6E5); color: #333; padding: 15px; border-radius: 10px; border: 1px solid #ddd; box-shadow: 0 2px 5px rgba(0,0,0,0.2);">  <strong> </strong>最快速解决消息堆积问题的方法还是增加消费者实例，不过 同时你还需要增加每个主题的队列数量 。</div><hr><p>在消息堆积后，我们一般的处理是先排查消费端故障，让处理消费正常起来；</p><p>但此时消息队列中已经堆积了大量的一个消息待处理，我们除了优化消费者端的消息处理逻辑和实施快速失败机制之外，还有其他几种方法可以考虑：</p><ul><li><ol><li>调整队列和消费者的映射关系</li></ol></li><li><ol start="2"><li>临时增加特定队列的消费者</li></ol><ul><li>尽管在集群模式下，一个队列在同一时间只能由一个消费者消费，但您可以尝试临时创建一个新的消费者组，专门用来处理那个堆积的队列。</li></ul></li><li><ol start="3"><li>使用消息过滤</li></ol><ul><li><strong>消息选择性消费</strong>：如果适用，可以在消费者端使用消息过滤，专注于处理最紧急或最重要的消息。</li></ul></li><li><ol start="4"><li>短期策略</li></ol><ul><li><strong>临时措施</strong>：作为一种短期策略，可以暂时将一些不太重要的业务处理延后，优先处理堆积的消息。</li></ul></li><li><ol start="5"><li>系统资源优化，监控和动态调整</li></ol></li></ul><h3 id="8、回溯消费"><a href="#8、回溯消费" class="headerlink" title="8、回溯消费"></a>8、回溯消费</h3><blockquote><p>官方文档解释</p></blockquote><p>回溯消费是指 <code>Consumer</code> 已经消费成功的消息，由于业务上需求需要重新消费，</p><p>在<code>RocketMQ</code> 中， <code>Broker</code> 在向<code>Consumer</code> 投递成功消息后，<strong>消息仍然需要保留</strong> 。并且重新消费一般是按照时间维度，例如由于 <code>Consumer</code> 系统故障，恢复后需要重新消费 1 小时前的数据，那么 <code>Broker</code> 要提供一种机制，可以按照时间维度来回退消费进度。<code>RocketMQ</code> 支持按照时间回溯消费，时间维度精确到毫秒。</p><h3 id="9、RocketMQ-如何保证高性能读写"><a href="#9、RocketMQ-如何保证高性能读写" class="headerlink" title="9、RocketMQ 如何保证高性能读写"></a>9、RocketMQ 如何保证高性能读写</h3><p>RocketMQ 内部主要是使用基于 mmap 实现的零拷贝，用来读写文件</p><p>to be contined….</p><h3 id="10、RocketMQ-的刷盘机制-🦅"><a href="#10、RocketMQ-的刷盘机制-🦅" class="headerlink" title="10、RocketMQ 的刷盘机制   🦅"></a>10、RocketMQ 的刷盘机制   🦅</h3><h4 id="同步刷盘和异步刷盘"><a href="#同步刷盘和异步刷盘" class="headerlink" title="同步刷盘和异步刷盘"></a>同步刷盘和异步刷盘</h4><p>在 RocketMQ 中，同步刷盘和异步刷盘是两种不同的消息持久化策略，它们各有优劣，并适用于不同的业务场景。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312281520496.png" alt="image.png"></p><p>以下是对这两种策略的详细说明和比较：</p><blockquote><p>同步刷盘（SYNC_FLUSH）</p></blockquote><ul><li><strong>工作原理</strong>：在同步刷盘模式下，每当生产者发送一条消息，Broker 需要将消息写入磁盘并完成刷盘操作后，才会向生产者返回确认（ACK）。只有收到这个确认，生产者才知道消息已经安全存储。</li><li><strong>优点</strong>：提供了更高的消息可靠性。即使在Broker意外宕机的情况下，也不会丢失已确认的消息。</li><li><strong>缺点</strong>：影响性能。由于每条消息都需要等待磁盘写入完成，这会增加消息的延迟时间，降低吞吐量。</li><li><strong>适用场景</strong>：适用于对消息可靠性有极高要求的场景，如金融交易、重要业务数据处理等。</li></ul><blockquote><p>异步刷盘（ASYNC_FLUSH）</p></blockquote><ul><li><strong>工作原理</strong>：在异步刷盘模式下，Broker 将消息写入内存后，就立即向生产者返回确认。实际的刷盘操作是由后台线程异步完成的，不会阻塞消息的发送。</li><li><strong>优点</strong>：提高了性能和吞吐量。由于消息发送不需要等待磁盘操作完成，因此减少了延迟。</li><li><strong>缺点</strong>：消息可靠性降低。如果Broker在消息还未刷入磁盘前发生宕机，那么这部分消息可能会丢失。</li><li><strong>适用场景</strong>：适用于对性能要求较高，但对消息可靠性要求不是特别严格的场景，如日志收集、一些非关键的业务通知等。</li></ul><p><strong>刷盘策略的设置</strong></p><ul><li><strong>配置参数</strong>：在 RocketMQ 中，可以通过设置Broker的<code>FlushDiskType</code>参数来调整刷盘策略。</li><li>可以选择<code>ASYNC_FLUSH</code>（异步刷盘）或<code>SYNC_FLUSH</code>（同步刷盘）。</li></ul><p>同步刷盘和异步刷盘在消息可靠性和性能之间提供了不同的平衡点。</p><p>在实际应用中，应根据业务需求的不同，选择最合适的刷盘策略。对于那些要求高可靠性的场景，同步刷盘是更好的选择；而对于那些更看重性能和吞吐量的应用，异步刷盘则更为适合</p><h4 id="同步复制和异步复制"><a href="#同步复制和异步复制" class="headerlink" title="同步复制和异步复制"></a>同步复制和异步复制</h4><p>同步复制和异步复制在 RocketMQ 中指的是主从Broker之间的数据复制方式，这直接影响消息的可靠性和系统的可用性。这两种复制策略在保证数据一致性和提高系统性能之间提供了不同的平衡点。以下是对这两种策略的详细说明和比较：</p><blockquote><p>同步复制（同步双写）</p></blockquote><ul><li><strong>工作原理</strong>：在同步复制模式下，当消息被写入主Broker后，它必须同时被复制到从Broker上。只有当消息在主从Broker上都成功写入后，才向生产者返回写入成功的确认。</li><li><strong>优点</strong>：提高了数据的可靠性。即使主Broker宕机，从Broker上仍然有消息的完整副本。</li><li><strong>缺点</strong>：影响性能。由于消息写入操作需要在主从Broker上都完成，这可能导致较高的延迟和降低吞吐量。</li><li><strong>适用场景</strong>：适用于对数据可靠性要求极高的场景，如金融交易。</li></ul><blockquote><p>异步复制</p></blockquote><ul><li><strong>工作原理</strong>：在异步复制模式下，当消息写入主Broker之后，系统就直接返回写入成功。消息的复制到从Broker是异步进行的。</li><li><strong>优点</strong>：提高了性能。由于不需要等待从Broker确认，消息的写入和确认速度更快。</li><li><strong>缺点</strong>：可能存在数据不一致的风险。如果主Broker在数据复制完成前宕机，从Broker可能缺少最新的数据。</li><li><strong>适用场景</strong>：适用于对性能要求较高，但数据可靠性要求不是极端严格的场景。</li></ul><blockquote><p>可用性与顺序性的考虑</p></blockquote><ul><li><strong>可用性问题</strong>：由于RocketMQ不支持自动主从切换，如果主Broker宕机，整个系统将无法继续生产消息。虽然消费者可以从从Broker消费消息，但在主Broker宕机期间会存在短暂的主从数据不一致情况。</li><li><strong>解决方案</strong>：通过部署多个主从集群（多Broker架构）来提高可用性。每个Topic分布在不同的Broker中，可以在一定程度上解决单个Broker宕机问题。</li><li><strong>顺序性问题</strong>：在多Broker架构下，如果某个主Broker负责特定顺序消息宕机，其他Broker无法替代它处理这些消息，可能影响消息的顺序性。</li><li><strong>Dledger</strong>：RocketMQ通过引入Dledger技术，支持半数以上节点的消息复制后才确认写入成功，并支持主节点的动态选举，解决了严格顺序性和高可用性的问题。</li></ul><p>同步复制和异步复制在RocketMQ中提供了不同的数据一致性和性能平衡。在设计系统时，需要根据业务需求的具体情况选择合适的复制策略。</p><p>Dledger作为一种解决方案，虽然提高了可用性和顺序性保证，但在选举过程中可能会暂时无法提供服务，并且对节点的数量有一定要求。在实际应用中，需综合考虑业务场景的特性和对数据可靠性、系统性能的具体需求来决定使用哪种复制策略。</p><h4 id="存储机制"><a href="#存储机制" class="headerlink" title="存储机制"></a>存储机制</h4><p>RocketMQ 的存储机制采用混合型结构，优化了数据的写入效率和读取效率。这种设计涉及到三个关键组件：CommitLog、ConsumeQueue 和 IndexFile。</p><p>以下是这些组件的功能和它们在整个存储结构中的作用：</p><blockquote><p>CommitLog   核心文件</p></blockquote><ul><li><strong>功能</strong>：CommitLog 是消息存储的核心文件，它存储了生产者写入的消息主体内容及其元数据。</li><li><strong>存储结构</strong>：CommitLog 文件的大小默认为1GB，文件命名基于起始偏移量，例如 <code>00000000001073741824</code>。</li><li><strong>写入方式</strong>：消息主要是顺序写入CommitLog文件，提高了写入效率。当一个文件写满后，写入会继续在下一个文件。</li></ul><blockquote><p>ConsumeQueue   索引文件</p></blockquote><ul><li><strong>功能</strong>：ConsumeQueue 作为消费消息的索引，提升读取效率。</li><li><strong>结构</strong>：ConsumeQueue 保存了特定Topic下队列消息在CommitLog中的起始物理偏移量、消息大小和消息Tag的HashCode值。</li><li><strong>存储路径</strong>：采用 <code>topic/queue/file</code> 的三层组织结构，文件路径为 <code>$HOME/store/consumequeue/&#123;topic&#125;/&#123;queueId&#125;/&#123;fileName&#125;</code>。</li><li><strong>条目组织</strong>：每个条目固定20字节，包括commitlog的物理偏移量、消息长度和tag hashcode，允许像数组一样随机访问每个条目。</li></ul><blockquote><p>IndexFile</p></blockquote><ul><li><strong>功能</strong>：提供了通过key或时间区间查询消息的能力，但不涉及消息的主体内容。</li></ul><p>存储机制的特点</p><ul><li><strong>高效写入</strong>：不分Topic地顺序写入CommitLog，增加了写入效率。</li><li><strong>索引优化</strong>：使用ConsumeQueue作为索引文件，加快了基于Topic的消息检索和消费。</li><li><strong>文件大小</strong>：CommitLog文件设计成固定大小主要是为了支持内存映射机制，提高文件操作的效率。</li></ul><p>读取流程</p><ul><li>生产者发送消息时指定Topic和QueueId，消息被顺序存储到CommitLog。</li><li>相应的索引信息（偏移量、大小、tag hash）被存入对应Topic和QueueId的ConsumeQueue文件。</li><li>消费者根据消费偏移量（ConsumeOffset）在ConsumeQueue中检索下一条消息的位置，然后根据CommitLog中的位置找到实际消息。</li></ul><p>RocketMQ的存储架构通过将所有消息顺序存储在一个共享的CommitLog文件并使用ConsumeQueue和IndexFile作为索引文件来实现高效的消息读写。</p><p>这种设计在提高写入效率的同时，通过索引机制加快了消息的检索和消费速度。<br>与Kafka的每个Topic独立存储文件相比，RocketMQ的这种混合型存储结构更注重写入效率和灵活的读取操作。</p><blockquote><p><code>IndexFile</code> 和 <code>ConsumeQueue</code> 的区别</p></blockquote><p>在 RocketMQ 中，<code>IndexFile</code> 和 <code>ConsumeQueue</code> 都是消息存储结构的重要部分，但它们的用途和工作方式有所不同。</p><p>理解这两者之间的区别有助于更好地把握 RocketMQ 的消息存储和检索机制。</p><p>以下是对 <code>IndexFile</code> 和 <code>ConsumeQueue</code> 的主要区别的概述：</p><blockquote><p>ConsumeQueue</p></blockquote><ul><li><strong>目的</strong>：<code>ConsumeQueue</code> 作为消费消息的索引，其主要目的是加快消息消费的效率。</li><li><strong>内容</strong>：它保存了特定 Topic 下的队列消息在 <code>CommitLog</code> 中的起始物理偏移量、消息大小和消息 Tag 的 HashCode 值。</li><li><strong>结构</strong>：<code>ConsumeQueue</code> 文件是定长设计，每个条目包含了消息在 <code>CommitLog</code> 的偏移量、长度和 Tag HashCode，使得消费者能够快速定位消息。</li><li><strong>使用</strong>：消费者使用 <code>ConsumeQueue</code> 来快速查找待消费的消息，有效提升了消息消费的速度和效率。</li></ul><blockquote><p>IndexFile</p></blockquote><ul><li><strong>目的</strong>：<code>IndexFile</code> 的主要作用是提供一种基于 key 或时间区间来快速查询消息的方法。</li><li><strong>内容</strong>：它创建了消息属性（如消息的唯一标识符或业务键）的索引，以及消息在 <code>CommitLog</code> 中的物理偏移量。</li><li><strong>结构</strong>：<code>IndexFile</code> 不是针对特定 Topic 或队列的，而是为了提供跨所有消息的快速查找功能。</li><li><strong>使用</strong>：当需要根据特定关键字或者时间区间查询消息时，<code>IndexFile</code> 能够快速定位这些消息。</li></ul><p>区别：</p><ul><li><strong>使用场景</strong>：<code>ConsumeQueue</code> 是为了优化消息消费过程而设计的，而 <code>IndexFile</code> 则是为了提供一种灵活的消息查询机制。</li><li><strong>数据内容</strong>：<code>ConsumeQueue</code> 侧重于消息消费的快速定位，而 <code>IndexFile</code> 侧重于提供基于关键字和时间的快速检索。</li><li><strong>结构设计</strong>：<code>ConsumeQueue</code> 是基于 Topic 的逻辑消费队列，每个条目指向 <code>CommitLog</code> 中的特定消息；而 <code>IndexFile</code> 是一个全局索引，允许根据不同的查询条件找到消息。</li></ul><hr><h3 id="11、RocketMQ-如何保证不丢失消息"><a href="#11、RocketMQ-如何保证不丢失消息" class="headerlink" title="11、RocketMQ 如何保证不丢失消息"></a>11、RocketMQ 如何保证不丢失消息</h3><p>RocketMQ 采用了多种机制来确保消息的可靠性，防止消息丢失。</p><p>以下是 RocketMQ 实现消息不丢失的主要方法：</p><ul><li><ol><li>消息持久化</li></ol></li><li><ol start="2"><li>高可用性设计</li></ol></li><li><ol start="3"><li>消息重试机制</li></ol></li><li><ol start="5"><li>事务消息</li></ol></li><li><ol start="6"><li>同步复制</li></ol></li><li><ol start="7"><li>消息确认机制</li></ol></li></ul><blockquote><ol><li>消息持久化</li></ol></blockquote><ul><li><strong>磁盘存储</strong>：默认情况下，所有消息在被消费之前都会被持久化到磁盘，确保即使在发生系统崩溃的情况下也不会丢失消息。</li><li><strong>同步和异步刷盘</strong>：提供了同步刷盘和异步刷盘两种模式。同步刷盘提供更高的消息可靠性，而异步刷盘则提供更高的性能。</li></ul><blockquote><ol start="2"><li>高可用性设计</li></ol></blockquote><ul><li><strong>主从架构</strong>：通过部署多个Broker实例（包括主Broker和从Broker），并使用数据复制机制来确保数据的一致性和可靠性。</li><li><strong>故障自动转移</strong>：如果主Broker宕机，从Broker可以自动接管，保证服务的持续可用性。</li></ul><blockquote><ol start="3"><li>消息重试机制</li></ol></blockquote><ul><li><strong>消费者重试</strong>：如果消费者处理消息失败，RocketMQ 提供了消息重试机制，允许消费者在一定时间后重新尝试处理消息。</li></ul><blockquote><ol start="4"><li>死信队列</li></ol></blockquote><ul><li><strong>死信处理</strong>：对于多次重试仍然失败的消息，可以被发送到死信队列。这样做可以避免一直重试无法处理的消息，同时保留这些消息以便后续分析和处理。</li></ul><blockquote><ol start="5"><li>事务消息</li></ol></blockquote><ul><li><strong>半消息和事务回查</strong>：对于需要事务支持的场景，RocketMQ 提供了事务消息功能。这包括发送半消息和在必要时进行事务状态的回查，以保证事务的一致性。</li></ul><blockquote><ol start="6"><li>同步复制</li></ol></blockquote><ul><li><strong>数据复制</strong>：在主从架构中，可以配置数据同步复制，确保从Broker实时复制主Broker的数据。</li></ul><blockquote><ol start="7"><li>消息确认机制</li></ol></blockquote><ul><li><strong>生产者确认</strong>：生产者可以等待Broker的确认回应，以确保消息已经成功存储在Broker上。</li><li><strong>消费者确认</strong>：消费者在处理完消息后发送确认，确保消息不会被重复投递。</li></ul><hr><p>参考</p><ul><li><a href="https://rocketmq.apache.org/docs/quickStart/01quickstart">https://rocketmq.apache.org/docs/quickStart/01quickstart</a></li><li><a href="https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/">https://rocketmq.apache.org/zh/docs/quickStart/01quickstart/</a></li><li><a href="https://developer.aliyun.com/article/788183">https://developer.aliyun.com/article/788183</a></li><li><a href="https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html">https://javaguide.cn/high-performance/message-queue/rocketmq-questions.html</a></li><li><a href="https://juejin.cn/post/7134227366481494046">https://juejin.cn/post/7134227366481494046</a></li><li><a href="https://b23.tv/GneHu8S">https://b23.tv/GneHu8S</a></li><li><a href="https://juejin.cn/post/6844904099993878536">https://juejin.cn/post/6844904099993878536</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues">https://doocs.github.io/advanced-java/#/docs/high-concurrency/how-to-ensure-high-availability-of-message-queues</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白板擦</title>
    <link href="/2023/12/26/%E7%99%BD%E6%9D%BF%E6%93%A6/"/>
    <url>/2023/12/26/%E7%99%BD%E6%9D%BF%E6%93%A6/</url>
    
    <content type="html"><![CDATA[<p>今日计划</p><ul><li><input disabled="" type="checkbox"> 过一下面试题，准备一下八股（主要根据面试指北和Java面试库学习）</li><li><input disabled="" type="checkbox"> 完善知识库内容</li><li><input disabled="" type="checkbox"> 通过输出倒逼输入</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Fluid主题</title>
    <link href="/2023/12/26/Fluid%E4%B8%BB%E9%A2%98/"/>
    <url>/2023/12/26/Fluid%E4%B8%BB%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://hexo.fluid-dev.com/docs/start/">https://hexo.fluid-dev.com/docs/start/</a></li><li><a href="https://hexo.fluid-dev.com/">https://hexo.fluid-dev.com/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>框架学习_MyBatis-Plus使用</title>
    <link href="/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://caochenlei.blog.csdn.net/article/details/108809902">https://caochenlei.blog.csdn.net/article/details/108809902</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/108281646?spm=1001.2014.3001.5502&ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkwNDU3Lz90eXBlPWJsb2c=">https://caochenlei.blog.csdn.net/article/details/108281646?spm=1001.2014.3001.5502&amp;ydreferer=aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM4NDkwNDU3Lz90eXBlPWJsb2c%3D</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>MyBatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_Redis实战篇</title>
    <link href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/"/>
    <url>/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h2 id="Redis-实战篇"><a href="#Redis-实战篇" class="headerlink" title="Redis 实战篇"></a>Redis 实战篇</h2><h3 id="1、Redis-分布式锁"><a href="#1、Redis-分布式锁" class="headerlink" title="1、Redis 分布式锁"></a>1、Redis 分布式锁</h3><p>分布式锁的实现常见的有：</p><ul><li>基于数据库的锁（乐观锁和悲观锁）</li><li>基于缓存的锁</li><li>基于Zookeeper 的锁（强一致性）</li><li>基于消息队列的锁（少见）</li><li>基于其他分布式协调服务</li></ul><p>这里主要介绍一下 Redis 分布式锁的实现方式，以及它是如何使用的。</p><p>Redis 分布式锁通过是<strong>利用<code>SETNX</code>这个方法</strong>，如果插入Key成功，则表示获得到了锁，如果有人插入成功，那么其他人就回插入失败，无法获取到锁，利用这套逻辑完成<code>互斥</code>，从而实现分布式锁</p><p>在使用 <code>SETNX</code>这个方法的时候，一般还会使用 EXPIRE 命令为锁设置一个过期时间防止死锁。</p><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://cyborg2077.github.io/2022/10/22/RedisPractice/">https://cyborg2077.github.io/2022/10/22/RedisPractice/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_常见面试题</title>
    <link href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/12/25/Redis%E5%85%A5%E9%97%A8_%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<blockquote><p>常见面试题</p></blockquote><ul><li>为什么要用分布式缓存</li><li>常见的缓存更新策略有哪几种?</li><li>Redis主从复制：主从节点之间如何同步数据？</li><li>Redis Sentinel：如何实现自动化地故障转移？</li><li>Redis Cluster：缓存的数据量太大怎么办？</li></ul><blockquote><p>Redis 基础面试题</p></blockquote><hr><p>参考</p><ul><li><a href="https://www.yuque.com/snailclimb/mf2z3k/fg8lgc">https://www.yuque.com/snailclimb/mf2z3k/fg8lgc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容03</title>
    <link href="/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/"/>
    <url>/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><h3 id="1、分库分表"><a href="#1、分库分表" class="headerlink" title="1、分库分表"></a>1、分库分表</h3><p>MySQL的分表分库是一种数据库架构设计方法，用于处理大规模数据和高并发访问。</p><p>随着数据量的增长和访问量的提升，单一数据库或表可能难以承受压力，这时通过分表分库可以有效地提高性能和可扩展性。</p><blockquote><p>分表（Sharding）</p></blockquote><p>分表是指将一个大表拆分成多个小表的过程。</p><p>这些小表可以分布在同一个数据库或多个数据库中。分表通常基于某些关键字段进行，比如时间、用户ID等。</p><ul><li><strong>垂直分表</strong>：将表中不同的列分到不同的表中。例如，一个用户表可以被分成用户基础信息表和用户详细信息表。</li><li><strong>水平分表</strong>：根据行数据将表分成多个表，每个表包含相同的列，但只包含部分行。例如，基于用户ID范围或创建时间进行切分。</li></ul><blockquote><p>分库（Database Sharding）</p></blockquote><p>分库涉及将数据分布到多个数据库实例上。每个数据库实例可以托管在不同的服务器上，从而分散负载和提高容错能力。</p><ul><li><strong>分布式数据库</strong>：数据被分散存储在多个物理位置，每个数据库实例可以独立处理查询和事务。</li><li><strong>读写分离</strong>：常与分库结合使用，读操作和写操作分别在不同的数据库实例上进行。</li></ul><p>在实现MySQL的分表分库时，可能需要使用一些工具和中间件，如MyCAT、Shard-Query等，它们帮助管理复杂的分片逻辑，并对应用层透明。</p><h3 id="2、主从复制和读写分离"><a href="#2、主从复制和读写分离" class="headerlink" title="2、主从复制和读写分离"></a>2、主从复制和读写分离</h3><p>在MySQL中，主从复制和读写分离是两种常用的架构策略，用于提高数据库的可用性、扩展性和性能。</p><h4 id="主从复制（Master-Slave-Replication）"><a href="#主从复制（Master-Slave-Replication）" class="headerlink" title="主从复制（Master-Slave Replication）"></a>主从复制（Master-Slave Replication）</h4><p>主从复制是一种数据复制的方法，其中数据从一个主服务器（Master）自动复制到一个或多个从服务器（Slave）。</p><p>工作原理</p><ol><li><strong>日志复制</strong>：主服务器的更改（如INSERT、UPDATE、DELETE操作）被记录到二进制日志中。</li><li><strong>日志传输</strong>：这些更改（日志条目）被传输到从服务器。</li><li><strong>应用更改</strong>：从服务器读取这些日志条目，并在自己的数据副本上应用这些更改。</li></ol><p>目的和优势：</p><ul><li><strong>数据备份</strong>：提供了数据备份，有助于灾难恢复。</li><li><strong>读取负载分散</strong>：从服务器可以用于读取操作，减轻主服务器的负载。</li><li><strong>高可用性</strong>：如果主服务器出现故障，从服务器可以被提升为新的主服务器。</li></ul><p>主从辅助操作主要涉及三个线程: binlog 线程、I&#x2F;O 线程和 SQL 线程。</p><ul><li><strong>binlog 线程</strong> : 负责将主服务器上的数据更改写入二进制日志中。</li><li><strong>I&#x2F;O 线程</strong> : 负责从主服务器上读取二进制日志，并写入从服务器的中继日志中。</li><li><strong>SQL 线程</strong> : 负责读取中继日志并重放其中的 SQL 语句。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401041611217.png" alt="image.png"></p><h4 id="读写分离（Read-Write-Splitting）"><a href="#读写分离（Read-Write-Splitting）" class="headerlink" title="读写分离（Read-Write Splitting）"></a>读写分离（Read-Write Splitting）</h4><p>读写分离涉及将数据库的读取操作（SELECT查询）和写入操作（INSERT、UPDATE、DELETE）分离到不同的服务器上。</p><p>实现方法</p><ul><li><strong>主服务器处理写操作</strong>：所有更改数据的操作都在主服务器上执行。</li><li><strong>从服务器处理读操作</strong>：所有的读取请求都被重定向到从服务器。</li></ul><p>读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202401041612689.png" alt="image.png"></p><blockquote><p>小结</p></blockquote><p>读写分离和主从复制可以通过MySQL的内置功能实现，也可以使用第三方工具如ProxySQL、MaxScale等来帮助管理。</p><p>主从复制和读写分离是提高MySQL数据库性能和可靠性的重要策略。</p><p>它们在处理大量数据和高并发访问的情况下尤其有用，但也需要考虑其带来的额外管理和配置复杂性。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-devide.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-devide.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库_SQL常见面试题</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/sql/sql-questions-01.html">https://javaguide.cn/database/sql/sql-questions-01.html</a></li><li><a href="https://javaguide.cn/database/sql/sql-questions-02.html">https://javaguide.cn/database/sql/sql-questions-02.html</a></li><li><a href="https://javaguide.cn/database/sql/sql-questions-03.html">https://javaguide.cn/database/sql/sql-questions-03.html</a></li><li><a href="https://javaguide.cn/database/sql/sql-questions-04.html">https://javaguide.cn/database/sql/sql-questions-04.html</a></li><li><a href="https://javaguide.cn/database/sql/sql-questions-05.html">https://javaguide.cn/database/sql/sql-questions-05.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库_SQL语法基础知识</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>看一下这个： <a href="https://javaguide.cn/database/sql/sql-syntax-summary.html">https://javaguide.cn/database/sql/sql-syntax-summary.html</a></p><p>to be contined…</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库_基础知识</title>
    <link href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <url>/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    
    <content type="html"><![CDATA[<p>数据库基础知识包含了数据库设计、管理和操作的核心概念。</p><p>常见的一些概念👇</p><p>有兴趣百度了解下，或者通过参考链接扩展一下相关内容</p><ul><li>数据库和数据库管理系统（DBMS）</li><li>数据模型（关系模型与非关系模型）</li><li>数据库设计<ul><li>ER图</li><li>数据库范式</li></ul></li><li>元组, 码, 候选码, 主码, 外码, 主属性, 非主属性</li><li>主键和外键</li><li>为什么不推荐使用外键与级联</li><li>存储过程</li><li>数据库设计</li><li>字符集</li></ul><h4 id="SQL（结构化查询语言）"><a href="#SQL（结构化查询语言）" class="headerlink" title="SQL（结构化查询语言）"></a>SQL（结构化查询语言）</h4><ul><li><strong>数据定义语言（DDL）</strong>：定义数据库结构，包括CREATE、ALTER、DROP等命令。</li><li><strong>数据操纵语言（DML）</strong>：用于数据访问和处理，包括INSERT、UPDATE、DELETE、SELECT等命令。</li><li><strong>数据控制语言（DCL）</strong>：用于权限和事务控制，包括GRANT、REVOKE、BEGIN TRANSACTION等。</li></ul><h4 id="drop、delete-与-truncate-区别"><a href="#drop、delete-与-truncate-区别" class="headerlink" title="drop、delete 与 truncate 区别?"></a>drop、delete 与 truncate 区别?</h4><ul><li>drop           移除整个表结构，包括其数据和表定义     不能回滚（DDL)</li><li>delete         删除表中的一行或多行记录      能回滚(DML)</li><li>truncate      删除表中的所有记录    不能回滚（DDL)</li></ul><p>执行速度：一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code></p><p>在MySQL中，<code>DROP</code>、<code>DELETE</code>和<code>TRUNCATE</code>都是用于移除数据的命令，但它们在用法和影响上有明显的区别：</p><blockquote><ol><li>DELETE</li></ol></blockquote><ul><li><strong>用途</strong>：<code>DELETE</code>用于删除表中的一行或多行记录。</li><li><strong>特点</strong>：<ul><li>可以带有<code>WHERE</code>子句，提供了条件删除的功能。</li><li>影响的行数会记录在事务日志中，因此可以回滚。</li><li>触发器（如果有的话）会被激活。</li><li>较慢，特别是在删除大量数据时，因为它逐行删除。</li></ul></li><li><strong>示例</strong>：<code>DELETE FROM table_name WHERE condition;</code></li></ul><blockquote><ol start="2"><li>TRUNCATE</li></ol></blockquote><ul><li><strong>用途</strong>：<code>TRUNCATE</code>用于删除表中的所有记录。</li><li><strong>特点</strong>：<ul><li>不能带有<code>WHERE</code>子句，它总是删除表中的所有记录。</li><li>执行速度比<code>DELETE</code>快，因为它不逐行删除数据，而是直接移除数据页。</li><li>不记录详细的事务日志，只记录重建空表的操作，因此无法回滚（在某些数据库系统中，<code>TRUNCATE</code>是事务安全的，并且可以回滚）。</li><li>重置表的自增计数器（如果有的话）。</li><li>不触发触发器。</li></ul></li><li><strong>示例</strong>：<code>TRUNCATE TABLE table_name;</code></li></ul><blockquote><ol start="3"><li>DROP</li></ol></blockquote><ul><li><strong>用途</strong>：<code>DROP</code>用于移除整个表结构，包括其数据和表定义。</li><li><strong>特点</strong>：<ul><li>删除表的结构及其数据，释放存储空间。</li><li>不能回滚（一旦执行，表就完全消失了）。</li><li>不触发触发器。</li><li>在删除大量数据且不再需要该表时使用。</li></ul></li><li><strong>示例</strong>：<code>DROP TABLE table_name;</code></li></ul><blockquote><p>总结</p></blockquote><ul><li><strong>删除数据行</strong>：如果需要删除部分数据行，使用<code>DELETE</code>。若需删除所有数据行且表结构仍需保留，使用<code>TRUNCATE</code>。</li><li><strong>删除表</strong>：如果要删除整个表及其数据，使用<code>DROP</code>。</li><li><strong>性能考虑</strong>：当处理大量数据时，<code>TRUNCATE</code>比<code>DELETE</code>更高效。</li><li><strong>事务和回滚</strong>：<code>DELETE</code>操作可以回滚，而<code>TRUNCATE</code>和<code>DROP</code>在大多数情况下不能。</li></ul><p>选择使用哪个命令取决于具体的需求，如是否需要保留表结构、是否需要条件删除或是否关注性能优化。</p><h4 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步?"></a>数据库设计通常分为哪几步?</h4><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li><strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行。</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护</li></ol><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/basis.html">https://javaguide.cn/database/basis.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容02</title>
    <link href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/"/>
    <url>/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/</url>
    
    <content type="html"><![CDATA[<h3 id="3、事务隔离"><a href="#3、事务隔离" class="headerlink" title="3、事务隔离"></a>3、事务隔离</h3><p>事务就是要保证一组数据库操作，要么全部成功，要么全部失败。</p><p>在 <strong>MySQL</strong> 中，事务支持是在引擎层实现的，MyISAM 引擎不支持事务，InnoDB 支持；下述内容也是围绕 InnoDB 引擎来讲述的。</p><h4 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h4><p>在MySQL中，事务隔离级别定义了一个事务可能受其他并发事务影响的程度。</p><p>这个概念对于理解并发操作时可能出现的问题（如脏读、不可重复读、幻读）至关重要。</p><p>MySQL支持以下四种标准的事务隔离级别：</p><ul><li>读未提交</li><li>读已提交</li><li>可重复读</li><li>串行化</li></ul><blockquote><ol><li>READ UNCOMMITTED（读未提交）</li></ol></blockquote><p>这是最低的隔离级别，在这个级别，事务可以读取到其他事务还未提交的更改。</p><p>想象一个图书馆，所有书籍即使正在被编辑（数据被修改）也可以被任何人阅读。</p><p>这可能导致“脏读”，即一个事务可能读取到另一个事务修改但尚未提交的数据，如果那个事务回滚，读取到的数据就是无效的。</p><blockquote><ol start="2"><li>READ COMMITTED（读已提交）</li></ol></blockquote><p>在这个级别，一个事务只能读取到其他事务已经提交的更改。</p><p>回到图书馆的例子，这就相当于只有当一本书完成编辑并返回到书架上时，其他人才能阅读它。</p><p>这解决了脏读的问题，但仍然可能出现“不可重复读”，因为在同一个事务中，同样的查询可能会返回不同的结果，如果其他事务在两次查询之间提交了更改。</p><blockquote><ol start="3"><li>REPEATABLE READ（可重复读）</li></ol></blockquote><p>MySQL的默认隔离级别。</p><p>在这个级别，事务在开始时创建一个数据快照，<strong>确保在整个事务期间可以重复读取相同的数据</strong>，即使其他事务提交了更改。</p><p>在图书馆中，即使书籍被编辑，你也会一直读到你最初找到的版本。虽然解决了不可重复读的问题，但它仍然面临“幻读”的问题，当一个事务中的两个相同的查询可能<strong>因为另一个事务的插入操作</strong>而返回不同的行数。</p><blockquote><ol start="4"><li>SERIALIZABLE（串行化）</li></ol></blockquote><p>这是最高的隔离级别，它通过<strong>强制事务顺序执行</strong>，避免了幻读的问题。在图书馆中，这相当于当你阅读一本书时，<strong>其他任何人都不能编辑或检查这本书</strong>。这会导致明显的性能下降，因为它阻止了可能的并发事务执行。</p><p>不同隔离级别对性能和并发性的影响是一个权衡：</p><ul><li>更低的隔离级别（如READ UNCOMMITTED和READ COMMITTED）提高了并发性，但牺牲了数据的准确性。</li><li>更高的隔离级别（如REPEATABLE READ和SERIALIZABLE）提供了更准确的数据和事务一致性，但可能会降低并发性。</li></ul><p>选择哪个隔离级别取决于应用程序的特定需求和它可以容忍的数据不一致程度。</p><p>例如，银行系统可能会倾向于使用更高的隔离级别以保证事务的准确性，而一个只显示近似数据的报告系统可能会选择一个更低的隔离级别以获得更好的性能。</p><h4 id="隔离级别REPEATABLE-READ（可重复读）的实现"><a href="#隔离级别REPEATABLE-READ（可重复读）的实现" class="headerlink" title="隔离级别REPEATABLE READ（可重复读）的实现"></a>隔离级别REPEATABLE READ（可重复读）的实现</h4><p>在MySQL中，REPEATABLE READ（可重复读）隔离级别的实现是通过结合使用多版本并发控制（MVCC）和回滚日志来完成的。</p><p>这两种机制共同工作，以确保事务可以在其执行期间多次读取同一数据的一致状态，同时避免由其他并发事务引起的数据不一致。</p><blockquote><p>多版本并发控制（MVCC）</p></blockquote><p>MVCC是可重复读隔离级别的核心，它允许在不加锁的情况下进行读操作，同时仍然保持事务间的隔离。</p><ul><li><strong>数据版本化</strong>：在MVCC中，每当数据被更新时，原始数据不会立即被覆盖。相反，会创建一个新的数据版本。这样，不同的事务可以看到同一数据的不同版本。</li><li><strong>读视图（Read-View）</strong>：当事务开始时，它创建一个读视图，这个视图代表数据库在那一时刻的状态。在整个事务期间，即使数据在其他事务中被更改，该事务也能看到其读视图中的数据版本。</li></ul><blockquote><p>回滚日志</p></blockquote><p>回滚日志是实现MVCC的关键组成部分，它用于记录每个数据版本的历史信息。</p><ul><li><strong>版本链</strong>：每当数据项被更新，回滚日志就会记录一个操作，这些操作形成了一条版本链。例如，一个值从1改为2，再改为3，最后变为4，回滚日志会记录这一系列变化。</li><li><strong>保留历史数据</strong>：这些回滚操作允许数据库“回滚”到早期的状态。因此，即使当前数据值是4，不同的事务依据它们的读视图可能看到的值是1、2或4。</li></ul><p>回滚日志什么时候删除？</p><ul><li>在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。</li><li>什么时候才不需要了呢？就是当系统里没有比这个回滚日志更早的 read-view 的时候。</li></ul><blockquote><p>实现原理</p></blockquote><p>结合MVCC和回滚日志，可重复读隔离级别在MySQL中的实现可以这样理解：</p><ol><li><strong>事务开始时创建读视图</strong>：事务开始时捕捉数据库的瞬时快照，这个快照定义了事务能看到的数据版本。</li><li><strong>读取操作时使用回滚日志</strong>：当事务中的操作需要读取数据时，系统会利用回滚日志找到该事务读视图对应的数据版本。</li><li><strong>隔离性的保证</strong>：即使在事务执行过程中，其他事务已经提交了对相同数据的更改，该事务仍然只能看到其开始时的数据版本。</li><li><strong>回滚日志的维护</strong>：回滚日志会一直保留，直到没有事务需要早期的数据版本为止。这确保了即使在有长事务存在的情况下，数据的早期版本仍然可用。</li></ol><blockquote><p>长事务的影响</p></blockquote><p>由于长事务可能会访问旧版本的数据，MySQL必须保留长事务开始之前的所有回滚信息。这不仅占用了大量存储空间，而且可能影响系统性能。</p><p>例如，在MySQL 5.5及以前的版本中，大量的回滚日志可能导致ibdata文件过大，即使长事务最终提交，这些空间也不会自动释放，有时需要重建整个数据库来清理这些空间。</p><p>因此，虽然REPEATABLE READ提供了较强的隔离性，但也需要合理管理事务的生命周期，避免长事务对系统性能和存储空间的负面影响。</p><h4 id="事务的启动方式"><a href="#事务的启动方式" class="headerlink" title="事务的启动方式"></a>事务的启动方式</h4><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>事务的启动方式：</strong>显示启动事务；自动提交模式</div><p>在MySQL中，事务的启动方式对于事务管理和性能优化至关重要。理解和正确使用不同的事务启动方式可以避免长事务带来的风险。下面是MySQL中常见的几种事务启动方式：</p><blockquote><ol><li>显式启动事务</li></ol></blockquote><ul><li><strong>使用语句启动</strong>：最直接的启动事务的方式是使用<code>BEGIN</code>或<code>START TRANSACTION</code>语句。这种方式下，事务会持续到执行<code>COMMIT</code>或<code>ROLLBACK</code>语句为止。<code>COMMIT</code>用于提交事务中的所有更改，而<code>ROLLBACK</code>用于撤销所有更改。</li><li><strong>显式控制</strong>：这种方法的优点是开发者对事务的开始和结束有明确的控制，这有助于避免不必要的长事务。</li></ul><blockquote><ol start="2"><li>自动提交模式</li></ol></blockquote><ul><li><strong>设置自动提交</strong>：通过执行<code>SET autocommit=0</code>，可以关闭当前线程的自动提交。这意味着即使执行了一个简单的<code>SELECT</code>查询，也会启动一个事务，并且事务不会自动提交。</li><li><strong>潜在风险</strong>：这种模式下，如果开发者忘记了手动提交或回滚事务，或者在长连接中使用此模式，可能会无意中创建长事务，这会占用大量资源并影响数据库性能。</li></ul><blockquote><ol start="3"><li>推荐的实践</li></ol></blockquote><ul><li><strong>默认自动提交</strong>：建议总是使用<code>SET autocommit=1</code>。通过显式的<code>BEGIN</code>、<code>COMMIT</code>和<code>ROLLBACK</code>语句来控制事务，这样可以清晰地管理事务的生命周期。</li><li><strong>减少交互</strong>：对于需要频繁启动事务的场景，可以使用<code>COMMIT WORK AND CHAIN</code>语法。在<code>autocommit=1</code>的情况下，这个命令不仅提交当前事务，还会自动开始一个新事务。这减少了每个事务开始时执行<code>BEGIN</code>的需求，同时保持了事务的显式控制。</li></ul><blockquote><ol start="4"><li>监控长事务</li></ol></blockquote><ul><li><strong>检测长事务</strong>：可以通过查询<code>information_schema.innodb_trx</code>表来监控长时间运行的事务。例如，要查找运行时间超过60秒的事务，可以使用类似以下的查询语句：<figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> information_schema.innodb_trx <br><span class="hljs-keyword">WHERE</span> TIME_TO_SEC(TIMEDIFF(NOW(), trx_started)) &gt; <span class="hljs-number">60</span>;<br></code></pre></td></tr></table></figure>  这对于识别可能影响数据库性能的长事务非常有用。</li></ul><p>通过以上方法，开发者可以更有效地管理MySQL事务，避免因误用或不当的事务管理导致的性能问题。</p><p>明确的事务界定，结合对长事务的监控，有助于维持数据库的健康状态和高效性能。</p><hr><blockquote><p>问题：作为业务开发负责人兼数据库负责人，如何避免长事务的出现并妥善处理这种情况。</p></blockquote><p>长事务可能导致多种性能问题，如锁争用、事务日志膨胀、主从延迟等。</p><p>以下是一些有效的策略和最佳实践：</p><ul><li><ol><li>教育和培训</li></ol></li><li><ol start="2"><li>代码审查</li></ol></li><li><ol start="3"><li>监控和报警</li></ol></li><li><ol start="4"><li>性能分析</li></ol></li><li><ol start="5"><li>优化事务管理</li></ol></li><li><ol start="6"><li>应用架构设计</li></ol></li><li><ol start="7"><li>测试和仿真</li></ol></li><li><ol start="8"><li>环境管理</li></ol></li></ul><blockquote><ol start="3"><li>监控和报警</li></ol></blockquote><ul><li><strong>事务持续时间监控</strong>：监控事务的持续时间，使用如<code>information_schema.innodb_trx</code>的查询来识别长事务。</li><li><strong>实时报警系统</strong>：实现实时报警系统，当事务超过预设阈值时发出警告。</li></ul><blockquote><ol start="4"><li>性能分析</li></ol></blockquote><ul><li><strong>分析慢查询日志</strong>：定期检查慢查询日志，找出可能导致长事务的慢SQL语句。</li><li><strong>使用性能分析工具</strong>：使用如MySQL Workbench等工具分析数据库性能，寻找优化点。</li></ul><blockquote><ol start="5"><li>优化事务管理</li></ol></blockquote><ul><li><strong>短事务原则</strong>：鼓励使用短事务原则，尽量减少事务的作用范围和持续时间。</li><li><strong>避免不必要的事务</strong>：有些读取操作可能不需要事务，特别是在只读操作中。</li></ul><h3 id="4、数据库索引-🐱"><a href="#4、数据库索引-🐱" class="headerlink" title="4、数据库索引   🐱"></a>4、数据库索引   🐱</h3><p>在MySQL中，数据库索引是一种特殊的数据结构，它们帮助数据库快速高效地定位和检索数据。</p><p>你可以将索引类比为图书的目录：就像目录使你能够快速找到你想要阅读的章节，数据库索引允许数据库快速找到存储在数据表中的特定数据，而不必扫描整个表。</p><blockquote><p>索引的类型</p></blockquote><p>按数据结构分类可分为：B+tree索引、Hash索引、Full-text索引。<br>按物理存储分类可分为：聚簇索引、二级索引（辅助索引）。<br>按字段特性分类可分为：主键索引、普通索引、前缀索引。<br>按字段个数分类可分为：单列索引、联合索引（复合索引、组合索引）。</p><h4 id="索引-B-树"><a href="#索引-B-树" class="headerlink" title="索引(B+树)"></a>索引(B+树)</h4><blockquote><p>B+ Tree 原理</p></blockquote><p>参考： </p><ul><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-b-tree.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/wghadf">https://www.yuque.com/snailclimb/mf2z3k/wghadf</a></li></ul><p>索引为什么使用 B+ 树</p><p>引入各种树解决的问题以及面临的新问题</p><ul><li>二叉查找树（BST)<ul><li>不平衡</li><li>二叉查找树的平均时间复杂度是 O(lgn)；但是在极端情况下，BST会退化为链表，此时时间复杂度为 O(n)</li></ul></li><li>平衡二叉树（AVL)<ul><li>旋转耗时</li><li>删除的一个耗时效率较低，比起使用的好处而言，综合使用并不广泛</li></ul></li><li>红黑树<ul><li>树太高</li><li>红黑树在内存的表现优异；但是在真正存储在磁盘的时候，考虑的偏重是需要减少IO次数</li></ul></li><li>B树<ul><li>为磁盘而生</li><li>将二叉树改为了多路平衡查找树</li></ul></li><li>B+ 树<ul><li>在 B 树的基础上，进一步降低了树的高度，部分改造，使得范围查询更加高效。</li></ul></li></ul><h3 id="5、锁机制"><a href="#5、锁机制" class="headerlink" title="5、锁机制"></a>5、锁机制</h3><p>MySQL的锁机制是一种用来管理多个事务对同一数据进行访问的机制，旨在保持数据的一致性和完整性。</p><p>锁机制允许多个事务同时读写数据库，同时防止数据冲突和不一致。</p><p>MySQL中的锁主要可以分为以下几种类型：</p><ul><li>表级锁（Table-level Locks）</li><li>行级锁（Row-level Locks）</li><li>页面锁（Page-level Locks）</li><li>共享锁和排他锁</li><li>意向锁（Intention Locks）</li><li>死锁（Deadlocks）</li></ul><blockquote><ol><li>表级锁（Table-level Locks）</li></ol></blockquote><ul><li><strong>简单但开销小</strong>：锁定整个表，是最简单的锁策略，开销最小。</li><li><strong>并发性低</strong>：不适合高并发操作，因为它阻止了对同一表的其他访问。</li><li><strong>应用</strong>：MyISAM存储引擎主要使用表级锁。</li></ul><blockquote><ol start="2"><li>行级锁（Row-level Locks）</li></ol></blockquote><ul><li><strong>高并发处理</strong>：只锁定需要访问的数据行。是最细粒度的锁，允许高度的并发。</li><li><strong>开销大</strong>：比表级锁更多的内存和CPU资源。</li><li><strong>死锁</strong>：可能会引起死锁，需要额外的逻辑来处理。</li><li><strong>应用</strong>：InnoDB存储引擎使用行级锁。</li></ul><blockquote><ol start="3"><li>页面锁（Page-level Locks）</li></ol></blockquote><ul><li><strong>中间粒度</strong>：锁定内存中的页面，介于表级锁和行级锁之间。</li><li><strong>并发和资源</strong>：平衡了并发性和资源开销。</li><li><strong>应用</strong>：一些存储引擎如BerkeleyDB使用页面锁。</li></ul><blockquote><ol start="4"><li>共享锁和排他锁</li></ol></blockquote><ul><li><strong>共享锁（Shared Locks）</strong>：又称读锁，允许事务读一行数据。</li><li><strong>排他锁（Exclusive Locks）</strong>：又称写锁，允许事务排他地写一行数据。</li></ul><blockquote><ol start="5"><li>意向锁（Intention Locks）</li></ol></blockquote><ul><li><strong>层级锁系统</strong>：用于支持表级锁和行级锁的兼容。</li><li><strong>类型</strong>：包括意向共享锁和意向排他锁。</li></ul><blockquote><ol start="6"><li>死锁（Deadlocks）</li></ol></blockquote><ul><li><strong>问题</strong>：当多个事务相互等待对方释放锁时发生。</li><li><strong>解决</strong>：MySQL会自动检测并解决死锁，通常是通过回滚一个事务来解锁。</li></ul><p><strong>锁策略的选择</strong></p><ul><li>不同的存储引擎支持不同的锁策略。例如，InnoDB支持行级锁和表级锁，而MyISAM主要使用表级锁。</li><li>锁的选择取决于多种因素，包括事务的类型、并发级别、数据表的大小等。</li></ul><p>锁机制的实际应用</p><ul><li>在高并发的数据库系统中，适当的锁策略对于维护数据的完整性和提高系统性能至关重要。</li><li>理解不同锁的行为和影响可以帮助数据库管理员和开发人员优化查询，减少死锁，并提高数据库的整体性能。</li></ul><h3 id="DEBUYG"><a href="#DEBUYG" class="headerlink" title="DEBUYG"></a>DEBUYG</h3><p>待完善，参考 <a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E9%94%81</a></p><h3 id="6、explain的使用"><a href="#6、explain的使用" class="headerlink" title="6、explain的使用"></a>6、explain的使用</h3><p>在MySQL中，<code>EXPLAIN</code>是一个非常有用的工具，它用于分析MySQL如何执行SQL查询，特别是用于优化查询性能。</p><p>使用<code>EXPLAIN</code>可以帮助你理解MySQL如何处理你的SQL语句，包括选择哪些索引，如何连接表，以及估计的行数等。</p><blockquote><p>如何使用EXPLAIN</p></blockquote><p>要使用<code>EXPLAIN</code>，只需在你的SELECT语句之前加上关键字<code>EXPLAIN</code>。例如：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">EXPLAIN</span> <span class="hljs-keyword">SELECT</span> * <span class="hljs-keyword">FROM</span> your_table <span class="hljs-keyword">WHERE</span> your_column = <span class="hljs-string">&#x27;some_value&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这条命令会返回一个结果集，展示了MySQL执行该查询的计划。</p><blockquote><p>EXPLAIN输出的关键列</p></blockquote><p><code>EXPLAIN</code>的输出包含了许多列，以下是一些最重要的列：</p><ol><li><strong>id</strong>：表示SELECT的序列号，用于区分查询中不同部分的执行顺序。</li><li><strong>select_type</strong>：查询的类型，如SIMPLE（简单表，即不使用表连接或子查询），PRIMARY（主查询），SUBQUERY（子查询）等。</li><li><strong>table</strong>：显示这一行的数据是关于哪个表的。</li><li><strong>type</strong>：表示连接类型，是优化中非常重要的一个指标，从最好到最差依次是：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL。</li><li><strong>possible_keys</strong>：显示可能应用在这张表上的索引。</li><li><strong>key</strong>：实际使用的索引。如果为NULL，则没有使用索引。</li><li><strong>key_len</strong>：使用的索引的长度。在不损失精确性的情况下，长度越短越好。</li><li><strong>ref</strong>：显示索引的哪一列被使用了。</li><li><strong>rows</strong>：MySQL认为必须检查的用来返回请求数据的行数。</li><li><strong>Extra</strong>：包含MySQL解决查询的详细信息。比如，“Using index”表示相应的SELECT操作使用了覆盖索引，避免了访问表的数据行。</li></ol><blockquote><p>使用EXPLAIN进行性能优化</p></blockquote><p>通过分析<code>EXPLAIN</code>的输出，你可以获得如何优化查询的线索：</p><ul><li><strong>确保适当的索引被使用</strong>：如果<code>key</code>列是NULL，或者<code>type</code>列显示为ALL或index，可能需要优化索引。</li><li><strong>检查连接顺序</strong>：在<code>id</code>列中，较大的值表示优先级较高的表，你可以通过调整查询结构来改变连接顺序。</li><li><strong>优化查询结构</strong>：根据<code>Extra</code>列的信息，你可能需要调整查询结构，如更改JOIN类型或重新编写子查询。</li></ul><blockquote><p>注意事项</p></blockquote><ul><li><strong>EXPLAIN不执行查询</strong>：它只显示MySQL如何执行查询，实际上并不执行该查询。</li><li><strong>估计的行数可能不准确</strong>：<code>rows</code>列显示的是估计的行数，这个估计可能基于表统计数据，而不是实际的行数。</li></ul><p>平时用这个进行分析语句的时候，看的最多的三个字段是：select_type、key、rows</p><ul><li>select_type : 查询类型，有简单查询、联合查询、子查询等</li><li>key : 使用的索引</li><li>rows : 扫描的行数</li></ul><p>性能优化注意的点比较多，建议看一下这个： </p><ul><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-performance.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-performance.html</a></li></ul><p>性能优化策略</p><ul><li>优化数据访问<ul><li><ol><li>减少请求的数据量</li></ol></li><li><ol start="2"><li>减少服务器端扫描的行数</li></ol></li></ul></li><li>重构查询方式<ul><li>1.切分大查询</li><li>2.分解大连接查询</li></ul></li></ul><p>参考</p><ul><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2">https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2</a></li><li><a href="https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236">https://developer.huawei.com/consumer/cn/forum/topic/0204405591412170236</a></li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html">https://www.pdai.tech/md/db/sql-mysql/sql-mysql-overview.html</a></li><li><a href="https://www.yuque.com/snailclimb/mf2z3k/wghadf">https://www.yuque.com/snailclimb/mf2z3k/wghadf</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容01</title>
    <link href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/"/>
    <url>/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>基础架构</li><li>日志系统</li><li>事务隔离</li><li>MySQL索引</li><li>锁机制</li><li>explain</li></ul><h3 id="1、基础架构"><a href="#1、基础架构" class="headerlink" title="1、基础架构"></a>1、基础架构</h3><p>MySQL的逻辑架构可以从上到下分为几个主要层次：</p><ul><li>客户端层<ul><li>包括了用户的接口，如命令行客户端和图形用户界面（GUI）</li></ul></li><li>服务层<ul><li>连接处理：管理客户端和服务器之间的连接，包括身份认证。</li><li>SQL接口：接收SQL命令，并且返回查询结果。</li><li>解析器：将SQL语句分解成可以理解和执行的部分。</li><li>优化器：决定最佳的查询路径。</li><li>缓存&#x2F;缓冲：存储数据，以便更快地访问。</li></ul></li><li>存储引擎层<ul><li>负责MySQL中数据的存储和提取。</li><li>MySQL的存储引擎是可插拔的，最常见的如InnoDB（支持事务和行级锁定）和MyISAM（支持全文搜索但不支持事务）。</li></ul></li><li>存储层<ul><li>实际存储数据的地方</li><li>包括数据文件、索引文件等</li></ul></li></ul><p>每一层在MySQL的运行中扮演着关键角色，并且它们共同工作以处理和存储数据。<br>客户端层接收用户输入的SQL查询，服务层对这些查询进行处理和优化，存储引擎层执行这些查询并通过存储层对数据进行物理存储和修改。</p><blockquote><p>餐厅与数据库</p></blockquote><p>现在，让我们用一个类比来帮助理解。想象MySQL是一家餐厅：</p><p>客户端层像是餐厅的顾客，他们点菜（发送SQL查询）。</p><p>服务层是服务员，他们接收订单，解释顾客的需求（解析SQL），并决定如何最有效地准备食物（优化查询）。<br>存储引擎层像是厨师，根据服务员给出的订单来准备食物（执行SQL查询）。</p><p>存储层则是冰箱和储藏室，存储着所有食材（数据）。</p><p>在这个过程中，每个员工和每个存储区都必须协调一致，以确保食物（数据）的质量和服务的效率。</p><blockquote><p>默认存储引擎</p></blockquote><p>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始成为了默认存储引擎。</p><blockquote><p>Server层和存储引擎层</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312221022103.png" alt="image.png|600"></p><p>将这个描述与上面的类比结合起来，可以这样理解：</p><ol><li><strong>Server层</strong>：<ul><li>这一层可以被视为餐厅的前台和服务区域。</li><li><strong>连接器</strong>：餐厅的接待台，负责迎接顾客（建立客户端连接）。</li><li><strong>查询缓存</strong>：已经准备好的菜肴，可以立即提供给顾客，无需再次等待厨师准备（缓存之前的查询结果）。</li><li><strong>分析器</strong>：服务员听顾客点菜并确认菜单上有这道菜（解析SQL查询，检查语法）。</li><li><strong>优化器</strong>：服务员决定为顾客服务的顺序，以确保效率（决定查询的最优执行计划）。</li><li><strong>执行器</strong>：服务员将顾客的订单传达给厨师并确保菜肴能够按要求出品（执行查询）。</li><li>此层包含所有的内置函数，就像餐厅有各种调味品和烹饪方法可供选择。</li><li>跨存储引擎的功能，如存储过程、触发器、视图，都像是餐厅提供的特殊服务，无论使用哪个厨房（存储引擎），都可以提供。</li></ul></li><li><strong>存储引擎层</strong>：<ul><li>这一层相当于餐厅的厨房。</li><li>每个存储引擎都像是一个专门的烹饪区域，有着不同的烹饪技术和设备（如InnoDB支持事务，MyISAM提供全文搜索功能）。</li><li>存储引擎负责数据的物理存储和检索，就像厨师们管理食材并将其制作成菜肴一样。</li></ul></li></ol><blockquote><p>对于SQL的解析和优化</p></blockquote><ul><li><strong>SQL解析</strong>：当服务层接收到客户端层发送的SQL语句后，它首先进行语法检查和解析，将SQL分解为解析树。</li><li><strong>SQL优化</strong>：然后，优化器会评估多个可能的查询执行计划，并选择一个成本最低（通常是执行时间最短）的计划</li></ul><blockquote><p>连接器</p></blockquote><p>建议在使用中要尽量减少建立连接的动作，也就是尽量使用长连接。</p><p>但如果使用长连接，服务器需要一直分配资源给这些连接（在执行过程中临时使用的内存是管理在连接对象里面），随着时间的推移，如果有很多大的操作，它占用的内存就会越来越大，最终可能会耗尽内存，导致数据库服务崩溃。</p><p>解决这个问题，有两个方法：</p><ol><li><strong>定期断开连接</strong>：就像定期清理手机后台运行的应用，以释放内存，保持手机运行流畅。你可以在数据库中，用完连接后或者执行了一些大查询操作之后，断开连接，下次需要时再重新连接。</li><li><strong>使用mysql_reset_connection</strong>：如果你用的是MySQL 5.7或更高版本，这就像给手机做个快速重启，清除所有运行的程序但不完全关机，这样可以迅速释放内存。<code>mysql_reset_connection</code>命令可以重置连接的状态，但不需要像完全断开连接那样再次进行繁琐的握手和权限验证。</li></ol><blockquote><p>查询缓存</p></blockquote><p>作用：作为查询缓存</p><ol><li>当你执行一个<code>SELECT</code>语句时，MySQL会检查查询缓存。</li><li>如果之前执行过相同的查询（这里的“相同”意味着字节到字节的完全匹配），并且结果已经缓存，MySQL就会立即返回结果，不用再次执行查询。</li><li>查询的文本是缓存的“key”，查询的结果是“value”。</li></ol><p>缺点：</p><ul><li>查询缓存每当表更新时就会失效。如果表经常更新，那么缓存的命中率就会非常低。</li><li>每次表更新，所有相关的缓存都会被清空。这意味着，即使你的查询结果被存入缓存，但如果表一更新，这些结果就会消失。</li></ul><p>因为这些限制，对于那些数据更新频繁的系统，启用查询缓存可能会带来更多的性能开销而不是好处。只有在数据很少变动的情况下，比如某些配置表，查询缓存才可能提高性能。</p><p>如果你还是想要利用查询缓存，可以将<code>query_cache_type</code>设置为<code>DEMAND</code>。这样，只有那些你显式指定为<code>SQL_CACHE</code>的查询才会使用查询缓存，就像这样：</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> SQL_CACHE * <span class="hljs-keyword">FROM</span> T <span class="hljs-keyword">WHERE</span> ID=<span class="hljs-number">10</span>;<br></code></pre></td></tr></table></figure><p>但是，值得注意的是，从MySQL 8.0版本开始，查询缓存功能被完全移除了。这是因为在实践中，维护查询缓存通常会导致更多的性能问题，而现代的数据库系统有更高效的方式来提高查询性能，比如更好的索引和优化器策略。</p><p>所以，在最新的MySQL版本中，不需要也不能使用查询缓存了。</p><blockquote><p>分析器</p></blockquote><ul><li>词法分析</li><li>语法分析</li></ul><blockquote><p>优化器:  决定查询的最优执行计划</p></blockquote><blockquote><p>执行器：执行查询（操作存储引擎，返回结果）</p></blockquote><h3 id="2、日志系统"><a href="#2、日志系统" class="headerlink" title="2、日志系统"></a>2、日志系统</h3><p>MySQL的日志系统是其核心功能之一，就像黑匣子一样，记录了发生在数据库中的所有关键活动。它包括多种类型的日志，每种日志记录不同类型的信息，对于数据库的恢复、优化和故障排除都至关重要。</p><p>下面是MySQL日志系统中最重要的几种日志类型：</p><ul><li>错误日志</li><li>查询日志（通用查询日志）</li><li>二进制日志（binlog）</li><li>慢查询日志</li><li>中继日志（Relay Log）</li><li>InnoDB重做日志（Redo Log）</li><li>InnoDB回滚日志（Undo Log）</li></ul><blockquote><p>错误日志</p></blockquote><p>错误日志就像是医生的诊断记录，它记录MySQL服务器启动、运行或停止时遇到的问题。如果数据库出现问题，这是第一个要查看的地方。这里会有关于任何错误的详细信息，包括服务启动失败的原因。</p><blockquote><p>查询日志（通用查询日志）</p></blockquote><p>查询日志记录了所有对MySQL服务器的请求，无论这些请求是否得到了执行。可以把它看作是商店的客流记录器，记录每一个进门的顾客及其请求的商品。</p><p>由于记录了所有活动，包括每条SQL语句的文字记录，这个日志很容易变得非常大，因此在高负载系统中通常不推荐开启。</p><blockquote><p>二进制日志（binlog）</p></blockquote><p>二进制日志是数据库活动的详细记录，包括所有修改数据或可能修改数据的语句（如<code>INSERT</code>、<code>UPDATE</code>、<code>DELETE</code>）。可以将二进制日志视为飞机的黑匣子，记录飞行过程中的所有重要事件。</p><p>它对于复制和数据恢复是必不可少的，因为它可以用来在另一台服务器上重放数据更改，或者在数据丢失后恢复数据。</p><blockquote><p>慢查询日志</p></blockquote><p>慢查询日志记录执行时间超过特定时长的查询。</p><p>将其想象为监控摄像头，特别关注那些在商店里逗留时间过长的顾客。这对于发现那些需要优化的查询非常有帮助。</p><blockquote><p>中继日志（Relay Log）</p></blockquote><p>在MySQL复制设置中，从服务器上的中继日志记录了从主服务器接收到的所有二进制日志事件。</p><p>从服务器上的复制子系统会读取这些日志，并应用到从服务器的数据库中。这类似于接力赛中，接力棒在运动员之间传递的过程。</p><blockquote><p>InnoDB重做日志（Redo Log）</p></blockquote><p>InnoDB存储引擎专用的日志，它记录了导致数据库状态改变的所有操作，确保在系统崩溃后能够恢复数据。</p><p>可以把它看作是飞机上的飞行记录仪，记录了飞行中所有的操作，以便在事故后重建发生了什么。</p><blockquote><p>InnoDB回滚日志（Undo Log）</p></blockquote><p>回滚日志是InnoDB用来处理事务的，它记录了数据的旧版本，使得数据库能够“回滚”到以前的状态。</p><p>可以把它比作是时光机，能够把事情恢复到过去某个时间点的状态。</p><h4 id="RedoLog-And-binlog"><a href="#RedoLog-And-binlog" class="headerlink" title="RedoLog And  binlog"></a>RedoLog And  binlog</h4><p><strong>InnoDB重做日志（Redo Log）与 二进制日志（binlog）</strong></p><p>我们来看一下InnoDB的重做日志（Redo Log）和二进制日志（binlog）的作用和它们在MySQL中的应用。</p><blockquote><p>InnoDB重做日志（Redo Log）</p></blockquote><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>Redo Log：</strong>重做日志文件大小是固定的，并组成一个循环写入的序列。（有一个擦除点和写入点，文件满的时候需要先擦除再写入）</div><p>在InnoDB存储引擎中，重做日志用于记录对数据库所做的每个写操作，确保在系统崩溃后可以恢复这些操作。</p><p>这个过程类似于传统账本与便笺的使用。想象一下，当店主在便笺上快速记下客户的购买记录，之后在每天结束时，他会将这些记录详细地转移到正式的账本中。便笺上的记录对应于重做日志，而正式账本就像是数据库文件。</p><p>重做日志是循环使用的，有一个固定的大小。当数据库进行写操作时，InnoDB会将操作详情写入重做日志，并标记为准备（prepare）状态。</p><p>随后，在合适的时机，这些操作会被实际应用到磁盘上的数据文件中。</p><p>这种策略允许InnoDB引擎快速响应写操作，因为它不需要每次都同步写入磁盘。</p><hr><p>InnoDB的重做日志（Redo Log）包括两部分：内存中的重做日志缓冲（redo log buffer）和磁盘上的重做日志文件。</p><ol><li><p><strong>重做日志缓冲（Redo Log Buffer）</strong>：这是内存中的一部分，用于暂时存放那些还没有被写入到磁盘重做日志文件的数据。当事务被提交时，事务的重做日志信息首先被写入到这个缓冲区中。</p></li><li><p><strong>重做日志文件（Redo Log Files）</strong>：这些是存放在磁盘上的物理文件，用于持久保存重做日志数据。即使在系统崩溃的情况下，由于这些信息被存储在磁盘上，InnoDB也可以在重启后使用这些日志来恢复数据。</p></li></ol><p>关于重做日志文件的大小，它们是固定的，并且可以通过MySQL的配置文件进行设置。通常，重做日志文件组成一个循环写入的序列，这意味着当最后一个日志文件写满后，系统会回到第一个日志文件开始覆盖旧的日志（这取决于日志的写入位置和检查点的位置）。</p><p>在配置文件（通常是<code>my.cnf</code>或<code>my.ini</code>）中，可以通过以下参数来定义重做日志文件的大小和数量：</p><ul><li><code>innodb_log_file_size</code>：定义单个重做日志文件的大小。</li><li><code>innodb_log_files_in_group</code>：定义重做日志文件组中文件的数量。</li></ul><p>例如，如果你设置<code>innodb_log_file_size</code>为512MB，并且设置<code>innodb_log_files_in_group</code>为4，那么总共会有2GB的重做日志空间可用（512MB * 4 &#x3D; 2048MB或2GB）。</p><p>选择适当的重做日志文件大小是很重要的，因为它会影响数据库的性能和恢复能力。如果重做日志太小，可能会导致频繁的I&#x2F;O操作，因为日志空间会迅速填满并需要频繁地进行日志切换操作。如果太大，恢复过程可能会更慢，因为InnoDB可能需要处理大量的日志数据来恢复状态。通常，这个值应该根据系统的负载和I&#x2F;O能力来调整。</p><blockquote><p>二进制日志（binlog）</p></blockquote><p>二进制日志记录了所有对数据库进行更改的SQL语句。它不是特定于InnoDB的，而是MySQL服务器层面的日志。你可以把它看作是一部摄像机，记录下了发生的所有事件，无论是好是坏。</p><p>在数据库需要恢复或者进行复制设置时，二进制日志是不可或缺的。</p><p>与重做日志不同，二进制日志是逻辑日志，记录的是发生了什么（例如“给ID&#x3D;2的这一行的c字段加1”），而重做日志是物理日志，记录的是在哪个数据页上做了修改。二进制日志是按顺序追加的，并且不会覆盖旧的日志。</p><blockquote><p>两者的协同工作与两阶段提交</p></blockquote><div style="background-color: #ced6e0; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>两阶段提交：</strong>只有在重做日志和二进制日志都被成功写入后，事务才会提交。</div><p>当执行一个更新操作时，InnoDB会先写入重做日志，这个操作会标记为prepare状态。一旦这个操作被写入，即使系统崩溃，这个操作也不会丢失，确保了数据库的crash-safe特性。<strong>只有在重做日志和二进制日志都被成功写入后，事务才会提交</strong>。</p><p>这就引入了所谓的“两阶段提交”：</p><ol><li><strong>准备阶段</strong>：事务的修改先被写入重做日志，并将事务标记为prepare状态。</li><li><strong>提交阶段</strong>：事务的修改被写入二进制日志，然后InnoDB事务会提交，重做日志的状态会变为commit。</li></ol><p>这种机制保证了即使在事务提交过程中发生故障，重做日志和二进制日志的状态也能保持一致。这对于恢复到精确的某一点以及主从复制是必要的，确保了数据的一致性。</p><blockquote><p>应用场景</p></blockquote><p>在应用中，你可以利用重做日志来确保事务的持久性和原子性。</p><p>例如，如果你的系统突然断电或者崩溃，重做日志可以用来恢复未提交的事务，以及确保已提交的事务不会丢失。</p><p>二进制日志主要用于：</p><ul><li><strong>数据复制</strong>：将binlog内容复制到从服务器，从服务器重放这些操作，保持和主服务器的数据一致。</li><li><strong>数据恢复</strong>：当需要将数据库恢复到过去的某个状态时，可以使用全量备份加上二进制日志来达到这个目的。</li></ul><p>两阶段提交保证了在使用重做日志和二进制日志时，系统的状态是一致的，这对于确保数据的准确性和可恢复性非常重要。</p><blockquote><p>思考题： 在什么场景下，一天一备会比一周一备更有优势呢？</p></blockquote><p>日常全量备份相比周备份的优势在于减少了数据丢失的风险。如果发生灾难，你只会丢失一天的数据，而不是一周的。这直接影响了数据库系统的恢复点目标（Recovery Point Objective，RPO），即在数据丢失事件后数据恢复的能力。</p><p>每天备份的RPO明显小于每周备份，因此一天一备的策略更适合对数据准确性要求较高的系统。</p><hr><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1ve411F794">https://www.bilibili.com/video/BV1ve411F794</a></li><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2">https://gitee.com/moxi159753/LearningNotes/tree/master/MySQL/MySQL45%E8%AE%B2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析</title>
    <link href="/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E4%BB%8EJava%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <url>/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E4%BB%8EJava%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Java 构建线程的方式</li><li>线程池的7个参数</li><li>线程池的执行流程</li><li>线程池属性标识</li><li>线程池的 execute 方法执行</li><li>Worker 的封装</li></ul><blockquote><p>从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析</p></blockquote><h3 id="一、Java-构建线程的方式（常识）"><a href="#一、Java-构建线程的方式（常识）" class="headerlink" title="一、Java 构建线程的方式（常识）"></a>一、Java 构建线程的方式（常识）</h3><ul><li>继承 Thread</li><li>实现 Runnable</li><li>实现 Callable</li><li>线程池方式（Java提供了构建线程池的方式）<ul><li>Java提供了 Executors 可以去创建（规范中不允许使用这种方式创建线程池，这种方式对线程的控制粒度比较低）</li><li>推荐手动创建线程池</li></ul></li></ul><h3 id="二、线程池的7个参数（常识）"><a href="#二、线程池的7个参数（常识）" class="headerlink" title="二、线程池的7个参数（常识）"></a>二、线程池的7个参数（常识）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,   <span class="hljs-comment">//核心线程池</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">//最大线程数</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">//最大空闲时间</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,         <span class="hljs-comment">//时间单位</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//阻塞队列</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,        <span class="hljs-comment">//线程工厂</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;   <span class="hljs-comment">//拒绝策略</span><br></code></pre></td></tr></table></figure><h3 id="三、线程池的执行流程（常识）"><a href="#三、线程池的执行流程（常识）" class="headerlink" title="三、线程池的执行流程（常识）"></a>三、线程池的执行流程（常识）</h3><blockquote><p>线程池执行流程</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231221203519.png" alt="image.png"></p><p>为什么要先进阻塞再去尝试创建非核心线程：</p><p>饭店（线程池） - 厨子（线程） - 人多先排队（阻塞队列）- 招厨子（创建最大线程数） - 今日客满（拒绝策略）</p><h3 id="四、线程池属性标识"><a href="#四、线程池属性标识" class="headerlink" title="四、线程池属性标识"></a>四、线程池属性标识</h3><h4 id="4-1-线程池属性"><a href="#4-1-线程池属性" class="headerlink" title="4.1 线程池属性"></a>4.1 线程池属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//ctl 是一个int 类型的数值，表达了两个意思，1：声明当前线程池的状态, 2: 声明线程池中的线程数</span><br><span class="hljs-comment">//高3位是：线程池状态</span><br><span class="hljs-comment">//低29位是： 线程池中的线程个数</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">ctl</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>(ctlOf(RUNNING, <span class="hljs-number">0</span>));  <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COUNT_BITS</span> <span class="hljs-operator">=</span> Integer.SIZE - <span class="hljs-number">3</span>;  <span class="hljs-comment">//29，方便后面做位运算</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CAPACITY</span>   <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;   <span class="hljs-comment">//通过位运算得出最大容量</span><br>  <br><span class="hljs-comment">// runState is stored in the high-order bits  </span><br><span class="hljs-comment">//线程池状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">RUNNING</span>    <span class="hljs-operator">=</span> -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//111 代表线程池为RUNNING，代表正常接收任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">SHUTDOWN</span>   <span class="hljs-operator">=</span>  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//000 代表线程池为`SHUTDOWN`状态，不接收新任务，但是内部还会处理阻塞队列中的任务，正在进行的任务也正常处理</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">STOP</span>       <span class="hljs-operator">=</span>  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//001  代表线程池为`STOP`状态，不接收新任务，也不去处理阻塞队列中的任务，同时会中断正在执行的任务</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TIDYING</span>    <span class="hljs-operator">=</span>  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//010 代表线程池为`TIDYING`状态，过渡的状态，代表当前线程池即将Game Over</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">TERMINATED</span> <span class="hljs-operator">=</span>  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;  <span class="hljs-comment">//011 代表线程池为`TERMINATED`，要执行terminated(),真的凉凉了</span><br>  <br><span class="hljs-comment">// Packing and unpacking ctl  </span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">runStateOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>     &#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125;  <span class="hljs-comment">//得到线程池的状态</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">workerCountOf</span><span class="hljs-params">(<span class="hljs-type">int</span> c)</span>  &#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125;   <span class="hljs-comment">//得到当前线程池的线程数量</span><br></code></pre></td></tr></table></figure><p><code>ThreadPoolExecutor</code>类使用了一些高级的位操作来高效地管理线程池的状态和工作线程的数量。</p><blockquote><p>核心变量解释</p></blockquote><ul><li><code>AtomicInteger ctl</code><ul><li>实际它是使用了 <code>AtomicInteger ctl</code> 这个变量来进行存储线程池的状态和线程数。原子操作保证了线程安全，即在多线程环境下，对这个变量的修改是原子性的，避免了竞态条件。</li><li>高3位是：线程池状态</li><li>低29位是： 线程池中的线程个数</li></ul></li><li><code>COUNT_BITS</code><ul><li>用于计算和存储线程数量的位数。它是<code>Integer.SIZE</code>（Java中整数的位数，通常是32位）减去3。</li><li>29，方便后面做位运算;3位用于表示线程池状态</li></ul></li><li><code>CAPACITY</code><ul><li>表示的最大线程数。它通过将1左移<code>COUNT_BITS</code>位然后减1来计算。</li><li>类似 100000000 - 1 &#x3D; 011111111111 这种，是常见的位运算的一种表示方式</li></ul></li></ul><blockquote><p>线程池状态</p></blockquote><p>线程池的状态被存储在<code>ctl</code>的高位。这些状态包括：</p><ul><li><strong><code>RUNNING</code></strong><ul><li>111</li><li>线程池可以接受新任务，并且也可以处理排队的任务。</li></ul></li><li><strong><code>SHUTDOWN</code></strong><ul><li>000</li><li>不接受新任务，但是可以处理排队的任务。</li></ul></li><li><strong><code>STOP</code></strong><ul><li>001</li><li>不接受新任务，不处理排队的任务，并且中断正在进行的任务。</li></ul></li><li><strong><code>TIDYING</code></strong><ul><li>010</li><li>所有任务都已终止，workerCount（活动线程数）为零，线程池正在转换到状态<code>TERMINATED</code>。</li></ul></li><li><strong><code>TERMINATED</code></strong><ul><li>011</li><li><code>terminated()</code>方法已经完成</li></ul></li></ul><blockquote><p>位操作方法</p></blockquote><ul><li><strong><code>runStateOf(int c)</code></strong>: 提取<code>ctl</code>中的状态部分。</li><li><strong><code>workerCountOf(int c)</code></strong>: 提取<code>ctl</code>中的工作线程数部分。</li><li><strong><code>ctlOf(int rs, int wc)</code></strong>: 将运行状态和工作线程数组合成一个<code>ctl</code>值</li></ul><h4 id="4-2-线程池状态变化"><a href="#4-2-线程池状态变化" class="headerlink" title="4.2 线程池状态变化"></a>4.2 线程池状态变化</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231222005453.png" alt="image.png"></p><h3 id="五、线程池的-execute-方法执行"><a href="#五、线程池的-execute-方法执行" class="headerlink" title="五、线程池的 execute 方法执行"></a>五、线程池的 execute 方法执行</h3><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>execute</code>方法是用于提交任务的关键方法。</p><p>它决定如何将一个新的<code>Runnable</code>任务添加到线程池中。</p><h4 id="execute-方法"><a href="#execute-方法" class="headerlink" title="execute 方法"></a>execute 方法</h4><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span>(<span class="hljs-params">Runnable command</span>)</span> &#123;<br>    <span class="hljs-comment">// 检查提交的任务不是null</span><br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br><br>    <span class="hljs-comment">// 获取当前线程池状态和工作线程数</span><br>    <span class="hljs-built_in">int</span> c = ctl.<span class="hljs-keyword">get</span>();<br><br>    <span class="hljs-comment">// 如果当前工作线程数小于核心线程数</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-comment">// 尝试添加一个新工作线程来执行这个任务</span><br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-literal">true</span>))<br>            <span class="hljs-keyword">return</span>; <span class="hljs-comment">// 如果成功，直接返回</span><br>        <span class="hljs-comment">// 如果添加工作线程失败，重新获取线程池状态</span><br>        c = ctl.<span class="hljs-keyword">get</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 如果线程池处于运行状态，且任务能被添加到队列中</span><br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-comment">// 重新检查线程池状态</span><br>        <span class="hljs-built_in">int</span> recheck = ctl.<span class="hljs-keyword">get</span>();<br>        <span class="hljs-comment">// 如果线程池不再运行，并且能从队列中移除任务，则拒绝任务</span><br>        <span class="hljs-keyword">if</span> (!isRunning(recheck) &amp;&amp; <span class="hljs-keyword">remove</span>(command))<br>            reject(command);<br>        <span class="hljs-comment">// 如果没有活动的工作线程，则添加一个新的工作线程</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            addWorker(<span class="hljs-literal">null</span>, <span class="hljs-literal">false</span>);<br>    &#125;<br>    <span class="hljs-comment">// 如果任务不能被添加到队列，尝试创建一个新工作线程来执行这个任务</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-literal">false</span>))<br>        reject(command); <span class="hljs-comment">// 如果创建失败，则拒绝任务</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现步骤：</p><ol><li><strong>参数检查</strong>: 首先检查传入的<code>Runnable</code>对象不是<code>null</code>。</li><li><strong>工作线程数量检查</strong>: 如果当前工作线程的数量小于核心线程数<code>corePoolSize</code>，尝试直接创建一个新的工作线程来执行任务。</li><li><strong>任务队列处理</strong>: 如果当前线程数已经达到或超过核心线程数，或者新工作线程的创建失败，则尝试将任务加入到等待队列中。</li><li><strong>状态重新检查</strong>: 在成功将任务加入队列后，需要再次检查线程池的状态，确保线程池仍在运行。如果线程池状态改变（例如，被关闭了），则尝试移除刚加入的任务，并执行拒绝策略。</li><li><strong>无活动线程处理</strong>: 如果任务被成功加入队列，但没有活动的工作线程可以处理队列中的任务，这时会尝试创建一个新的工作线程。</li><li><strong>拒绝策略</strong>: 如果无法将任务加入队列，且无法创建新的工作线程，最后的选项是拒绝任务。</li></ol><h4 id="addWorker-方法"><a href="#addWorker-方法" class="headerlink" title="addWorker 方法"></a>addWorker 方法</h4><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>addWorker</code>方法是用于向线程池中添加新的工作线程的关键方法。</p><p>它在处理新任务或者需要增加线程池中的线程数量时被调用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-type">boolean</span> core)</span> &#123;<br>    retry:<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-comment">// 获取当前线程池的控制状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">c</span> <span class="hljs-operator">=</span> ctl.get();<br>        <span class="hljs-comment">// 获取运行状态</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(c);<br><br>        <span class="hljs-comment">// 检查线程池的状态是否允许添加新的工作线程</span><br>        <span class="hljs-comment">// 仅在以下情况返回false：</span><br>        <span class="hljs-comment">// 1. 线程池状态为SHUTDOWN以上（不包括SHUTDOWN）且不满足以下所有条件：</span><br>        <span class="hljs-comment">//    - 状态为SHUTDOWN</span><br>        <span class="hljs-comment">//    - firstTask为null</span><br>        <span class="hljs-comment">//    - 工作队列不为空</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>            !(rs == SHUTDOWN &amp;&amp;<br>              firstTask == <span class="hljs-literal">null</span> &amp;&amp;<br>              !workQueue.isEmpty()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// 无限循环，尝试增加工作线程的数量</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">wc</span> <span class="hljs-operator">=</span> workerCountOf(c);<br>            <span class="hljs-comment">// 检查当前工作线程数是否超过了最大容量或设置的阈值</span><br>            <span class="hljs-comment">// 如果超过容量或者超过corePoolSize/maximumPoolSize，则返回false</span><br>            <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-comment">// 使用CAS操作增加工作线程计数</span><br>            <span class="hljs-comment">// 如果CAS成功，跳出retry标签，继续向下执行</span><br>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                <span class="hljs-keyword">break</span> retry;<br>            <span class="hljs-comment">// 如果CAS失败，重新读取ctl</span><br>            c = ctl.get(); <br>            <span class="hljs-comment">// 如果运行状态发生变化，重新开始外层循环</span><br>            <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                <span class="hljs-keyword">continue</span> retry;<br>            <span class="hljs-comment">// 如果CAS失败但运行状态没有变化，继续尝试内层循环的CAS操作</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 添加工作线程的过程</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerStarted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">workerAdded</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-type">Worker</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 创建新的工作线程</span><br>        w = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Worker</span>(firstTask);<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.thread;<br>        <span class="hljs-comment">// 如果成功创建线程</span><br>        <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReentrantLock</span> <span class="hljs-variable">mainLock</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 在持有锁的情况下再次检查线程池状态</span><br>                <span class="hljs-type">int</span> <span class="hljs-variable">rs</span> <span class="hljs-operator">=</span> runStateOf(ctl.get());<br><br>                <span class="hljs-comment">// 如果线程池状态允许添加工作线程，则将其添加到工作集合中</span><br>                <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-literal">null</span>)) &#123;<br>                    <span class="hljs-comment">// 检查线程是否已经启动（预防异常情况）</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalThreadStateException</span>();<br>                    workers.add(w);<br>                    <span class="hljs-type">int</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> workers.size();<br>                    <span class="hljs-comment">// 更新记录的最大池大小</span><br>                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                        largestPoolSize = s;<br>                    workerAdded = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-comment">// 如果成功添加工作线程，则启动该线程</span><br>            <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                t.start();<br>                workerStarted = <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 如果工作线程未能成功启动，处理失败情况</span><br>        <span class="hljs-keyword">if</span> (!workerStarted)<br>            addWorkerFailed(w);<br>    &#125;<br>    <span class="hljs-comment">// 返回工作线程是否成功启动</span><br>    <span class="hljs-keyword">return</span> workerStarted;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现步骤：</p><ol><li><strong>状态检查</strong>: 首先检查线程池的状态，确定是否可以添加新的工作线程。如果线程池正在关闭，并且条件不允许添加工作线程（例如，任务队列为空），则直接返回<code>false</code>。</li><li><strong>增加工作线程数</strong>: 使用一个无限循环，通过CAS（Compare-And-Swap）操作尝试增加工作线程计数。如果CAS操作成功，跳出循环；如果失败，重新尝试。</li><li><strong>创建和启动工作线程</strong>: 创建一个新的<code>Worker</code>对象，并尝试启动其线程。这个过程涉及获取一个全局锁以保证线程安全。</li><li><strong>线程池状态再次检查</strong>: 在锁内部再次检查线程池的状态，以确保在获取锁的过程中状态没有改变。</li><li><strong>添加到工作集合</strong>: 如果一切正常，将新的<code>Worker</code>添加到工作线程集合中，并更新记录的最大池大小。</li><li><strong>启动线程</strong>: 尝试启动线程。如果启动成功，返回<code>true</code>；否则，在<code>finally</code>块中处理启动失败的情况。</li></ol><p><code>addWorker</code>方法的实现体现了线程池如何有效地管理线程的创建和添加。</p><p>使用CAS操作保证了线程安全，而双重检查（在方法开始和持有锁时）确保了即使在高并发的情况下也能正确地管理线程池的状态。</p><h3 id="六、Worker-的封装"><a href="#六、Worker-的封装" class="headerlink" title="六、Worker 的封装"></a>六、Worker 的封装</h3><p>在Java的<code>ThreadPoolExecutor</code>类中，<code>Worker</code>是一个关键的内部类，它封装了线程池中的工作线程的行为和属性。</p><p><code>Worker</code>类继承自<code>AbstractQueuedSynchronizer</code>，是一个用于构建锁和其他同步组件的框架</p><h4 id="ThreadPoolExecutor内部类Worker的构造函数"><a href="#ThreadPoolExecutor内部类Worker的构造函数" class="headerlink" title="ThreadPoolExecutor内部类Worker的构造函数"></a><code>ThreadPoolExecutor</code>内部类<code>Worker</code>的构造函数</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">Worker(Runnable firstTask) &#123;<br>    <span class="hljs-comment">// 设置Worker的状态为-1，暂时阻止线程中断</span><br>    <span class="hljs-comment">// 这是为了防止在Worker真正开始运行前被中断</span><br>    setState(-<span class="hljs-number">1</span>);<br><br>    <span class="hljs-comment">// 将传入的任务（可能为null）设置为Worker的第一个任务</span><br>    <span class="hljs-comment">// 这个任务将是Worker创建后执行的第一个任务</span><br>    <span class="hljs-keyword">this</span>.firstTask = firstTask;<br><br>    <span class="hljs-comment">// 使用线程池的线程工厂创建一个新线程，并将当前Worker作为任务传递给这个新线程</span><br>    <span class="hljs-comment">// 这里，Worker自身实际上是一个Runnable，因为它实现了Runnable接口</span><br>    <span class="hljs-keyword">this</span>.thread = getThreadFactory().newThread(<span class="hljs-keyword">this</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>代码分析：</p><ol><li><strong>暂时禁用中断</strong>: <code>setState(-1)</code>设置Worker的状态，这个状态用于控制线程的中断。设置为-1意味着在<code>runWorker</code>方法真正开始执行之前，线程不应被中断。这是一个预防措施，以确保Worker在开始执行其任务前不会被意外中断。</li><li><strong>设置第一个任务</strong>: <code>this.firstTask = firstTask</code>将传入的任务赋值给Worker的<code>firstTask</code>属性。这个任务是Worker将要执行的第一个任务。如果这个值是<code>null</code>，Worker将从线程池的任务队列中获取任务。</li><li><strong>创建新线程</strong>: <code>this.thread = getThreadFactory().newThread(this)</code>调用线程工厂来创建一个新线程，并将当前Worker作为运行任务传递。由于Worker实现了<code>Runnable</code>接口，它可以被线程直接执行。线程工厂是线程池的一个组成部分，用于定制线程创建过程（例如设置线程名称、优先级等）。</li></ol><h4 id="runWorker-方法"><a href="#runWorker-方法" class="headerlink" title="runWorker 方法"></a>runWorker 方法</h4><p>定义了线程池中的工作线程（<code>Worker</code>）如何执行任务</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> runWorker(Worker w) &#123;<br>    <span class="hljs-comment">// 获取当前执行这个方法的线程</span><br>    Thread wt = Thread.currentThread();<br>    <span class="hljs-comment">// 从Worker获取第一个任务</span><br>    Runnable <span class="hljs-keyword">task</span> = w.firstTask;<br>    <span class="hljs-comment">// 设置Worker的第一个任务为null</span><br>    w.firstTask = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">// 释放Worker上的锁，允许中断</span><br>    w.unlock(); <br><br>    <span class="hljs-comment">// 标记是否异常完成任务</span><br>    <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 当有任务执行或者能从任务队列中获取到任务时，继续循环</span><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">task</span> != <span class="hljs-keyword">null</span> || (<span class="hljs-keyword">task</span> = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 锁定Worker，以开始执行任务</span><br>            w.lock();<br>            <span class="hljs-comment">// 如果线程池正在停止，确保线程被中断；</span><br>            <span class="hljs-comment">// 如果不是，则确保线程不被中断。这需要在第二种情况下重新检查以处理shutdownNow竞争状态</span><br>            <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                 (Thread.interrupted() &amp;&amp;<br>                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                !wt.isInterrupted())<br>                wt.interrupt();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 在执行任务前的钩子方法</span><br>                beforeExecute(wt, <span class="hljs-keyword">task</span>);<br>                Throwable thrown = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// 运行任务</span><br>                    <span class="hljs-keyword">task</span>.run();<br>                &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> x;<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                    thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-comment">// 在执行任务后的钩子方法</span><br>                    afterExecute(<span class="hljs-keyword">task</span>, thrown);<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">// 任务执行完毕，清理工作</span><br>                <span class="hljs-keyword">task</span> = <span class="hljs-keyword">null</span>;<br>                w.completedTasks++;<br>                w.unlock();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 如果正常退出循环，设置completedAbruptly为false</span><br>        completedAbruptly = <span class="hljs-keyword">false</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// 处理Worker退出</span><br>        processWorkerExit(w, completedAbruptly);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行步骤：</p><ol><li><strong>初始化</strong>: 首先获取当前线程和Worker中的第一个任务。解锁Worker以允许线程中断。</li><li><strong>任务执行循环</strong>: 方法进入一个循环，不断执行任务。如果Worker的第一个任务为空，则尝试从线程池的任务队列中获取新的任务。</li><li><strong>中断管理</strong>: 在每次任务执行前，检查线程池的状态，如果需要，根据线程池的状态来决定是否中断当前线程。</li><li><strong>任务执行</strong>: 实际执行任务，并处理任何可能抛出的异常。同时，执行钩子方法<code>beforeExecute</code>和<code>afterExecute</code>，这些方法可以用于在任务执行前后做一些准备和清理工作。</li><li><strong>任务完成后处理</strong>: 更新完成任务的计数，清理变量，解锁Worker。</li><li><strong>异常处理与退出</strong>: 如果任务执行过程中发生异常导致线程意外结束，<code>completedAbruptly</code>标记会保持为<code>true</code>。在最后的<code>finally</code>块中，调用<code>processWorkerExit</code>来处理Worker的退出，这可能包括替换这个Worker或者根据当前线程池状态进行其他处理。</li></ol><hr><p>参考</p><ul><li><a href="https://www.bilibili.com/video/BV1244y1n7bz">https://www.bilibili.com/video/BV1244y1n7bz</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_线程池最佳实践</title>
    <link href="/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <url>/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html">https://javaguide.cn/java/concurrent/java-thread-pool-best-practices.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_进阶内容</title>
    <link href="/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>进阶内容学习</p></blockquote><ul><li>Redis事务</li><li>Redis性能优化</li><li>Redis生产问题</li><li>Redis集群</li><li>Redis使用规范</li></ul><h3 id="1、Redis-事务"><a href="#1、Redis-事务" class="headerlink" title="1、Redis 事务"></a>1、Redis 事务</h3><p>to be contined….</p><h3 id="2、Redis-性能优化"><a href="#2、Redis-性能优化" class="headerlink" title="2、Redis 性能优化"></a>2、Redis 性能优化</h3><h3 id="3、Redis-生产问题"><a href="#3、Redis-生产问题" class="headerlink" title="3、Redis 生产问题"></a>3、Redis 生产问题</h3><div style="background-color: #f2c867; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>Redis 生产问题：</strong>缓存穿透、缓存击穿、缓存雪崩、数据一致性、Redis 阻塞</div><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指查询不存在的数据。由于这些数据不在缓存中，每次查询都会穿过缓存，直接访问数据库。</p><p>如果有大量此类查询，<strong>数据库可能会因此承受过大的压力</strong>。</p><blockquote><p>成因</p></blockquote><ul><li>频繁查询不存在的数据（可能是由于错误的输入或恶意攻击）。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>空对象缓存</strong>：即使某个值在数据库中不存在，也可以在缓存中存储一个特殊的空对象或空值，并设置较短的过期时间。</li><li><strong>布隆过滤器</strong>：在查询之前使用布隆过滤器判断数据是否可能存在。布隆过滤器是一种空间效率高但可能有一定误判率的数据结构。</li></ul><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指某个热点数据（即被频繁访问的数据）在缓存中失效的瞬间，大量请求同时涌向数据库。</p><blockquote><p>成因</p></blockquote><ul><li>热点数据在缓存中突然过期，而此时正有大量并发请求这些数据。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>设置热点数据永不过期</strong>：对于一些极其热门的数据，可以设置为永不过期。</li><li><strong>互斥锁</strong>：在缓存失效的瞬间，使用互斥锁或分布式锁，确保只有一个请求去数据库查询数据并重新缓存。</li></ul><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩是指缓存中大量数据同时过期，导致所有的请求都直接访问数据库，可能会使数据库压力过大甚至崩溃。</p><blockquote><p>成因</p></blockquote><ul><li>缓存设置了相同的过期时间，导致大量数据同时过期。</li><li>缓存服务崩溃，所有数据丢失。</li></ul><blockquote><p>解决方案</p></blockquote><ul><li><strong>不同的过期时间</strong>：为缓存数据设置不同的过期时间，避免同时过期。</li><li><strong>缓存数据预热</strong>：系统启动时预先加载热点数据到缓存中。</li><li><strong>使用高可用的缓存架构</strong>：比如使用Redis集群，提高缓存系统的稳定性和容错能力。</li></ul><h4 id="如何保证缓存和数据库的数据一致性"><a href="#如何保证缓存和数据库的数据一致性" class="headerlink" title="如何保证缓存和数据库的数据一致性"></a>如何保证缓存和数据库的数据一致性</h4><h4 id="哪些情况可能导致-Redis-阻塞"><a href="#哪些情况可能导致-Redis-阻塞" class="headerlink" title="哪些情况可能导致 Redis 阻塞"></a>哪些情况可能导致 Redis 阻塞</h4><h3 id="4、Redis-集群"><a href="#4、Redis-集群" class="headerlink" title="4、Redis 集群"></a>4、Redis 集群</h3><p>看一下这篇文字： <a href="https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k">https://www.yuque.com/snailclimb/mf2z3k/ks9olb19hc9wse5k</a></p><p>里面讲述了从 主从节点复制 →  哨兵机制 Sentinel  → Redis 集群Cluster （自动配置了哨兵模式，且建议至少一主一从节点，三个主节点以上的单数节点集群模式）</p><h3 id="5、Reids-使用规范"><a href="#5、Reids-使用规范" class="headerlink" title="5、Reids 使用规范"></a>5、Reids 使用规范</h3><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/redis/redis-questions-02.html">https://javaguide.cn/database/redis/redis-questions-02.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RocketMQ_安装与使用</title>
    <link href="/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>下载地址： <a href="https://rocketmq.apache.org/download/">https://rocketmq.apache.org/download/</a></p><p>这里下载 4.8.0 版本：<a href="https://rocketmq.apache.org/release-notes/2020/12/21/4.8.0">Release Notes - Apache RocketMQ - Version 4.8.0 | RocketMQ</a></p><p>选择Binary 进行下载。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312211150403.png" alt="image.png"></p><blockquote><p>NameServer</p></blockquote><p>注册中心，用于管理 Broker</p><blockquote><p>Broker</p></blockquote><p>用来保持 Topic 主题的信息，接收生产者的消息。</p><h4 id="搭建可视化监控平台"><a href="#搭建可视化监控平台" class="headerlink" title="搭建可视化监控平台"></a>搭建可视化监控平台</h4><p>rocketmq-dashboard是RocketMQ的一个拓展开源项目，可以对MQ进行可视化监控。 </p><p>下载地址： <a href="https://github.com/apache/rocketmq-dashboard">https://github.com/apache/rocketmq-dashboard</a></p><h4 id="RocketMQ的基本使用"><a href="#RocketMQ的基本使用" class="headerlink" title="RocketMQ的基本使用"></a>RocketMQ的基本使用</h4><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/xianren95/article/details/121924194">https://blog.csdn.net/xianren95/article/details/121924194</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<ul><li>接口中默认方法与静态方法</li><li>函数式接口（Functional Interface）</li><li>Lambda表达式（Lambda Expressions）</li><li>流API（Streams API）</li><li>Optional 类</li><li>新的日期时间API（New Date-Time API）</li></ul><h3 id="1、接口中默认方法与静态方法"><a href="#1、接口中默认方法与静态方法" class="headerlink" title="1、接口中默认方法与静态方法"></a>1、接口中默认方法与静态方法</h3><p>在Java 8之前，接口只能有方法声明，而不能有方法实现。这意味着一旦接口被更改（比如添加新方法），所有实现了该接口的类都必须随之修改以实现新添加的方法。</p><p>Java 8引入的<code>default</code>和<code>static</code>方法正是为了解决这个问题。</p><blockquote><p><code>default</code> 方法</p></blockquote><ul><li><p><strong>作用</strong>: <code>default</code>方法允许我们在接口中添加有具体实现的非抽象方法。这意味着实现接口的类可以不用实现这些<code>default</code>方法。</p></li><li><p><strong>用途</strong>: 这对于向现有接口添加新功能非常有用，因为它不会破坏实现该接口的现有类的功能。</p></li><li><p><strong>类比</strong>: 想象一下，有一个标准的建筑蓝图（接口）。突然，需要在所有这样的建筑中添加一个新的功能（比如中央供暖）。<code>default</code>方法就像是一个标准的中央供暖系统设计，可以直接加入到现有的蓝图中，而不需要重新设计整个建筑。</p></li></ul><blockquote><p><code>static</code> 方法</p></blockquote><ul><li><p><strong>作用</strong>: <code>static</code>方法允许我们在接口中添加静态方法。这些方法可以直接通过接口来调用，而不需要一个接口的实例。</p></li><li><p><strong>用途</strong>: <code>static</code>方法通常用于提供一些与接口相关的工具方法。</p></li><li><p><strong>类比</strong>: 如果接口是一种服务的标准（比如邮寄服务），那么<code>static</code>方法就像是可以直接从服务标准本身获得的额外帮助或工具，如一个在线邮资计算器。</p></li></ul><p>具体使用示例</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyInterface</span> </span>&#123;<br>    <span class="hljs-comment">// 一个默认方法</span><br>    <span class="hljs-keyword">default</span> void <span class="hljs-keyword">new</span><span class="hljs-type">Method</span>() &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a default method&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 一个静态方法</span><br>    <span class="hljs-keyword">static</span> void anotherNewMethod() &#123;<br>        System.out.println(<span class="hljs-string">&quot;This is a static method&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实现接口的类</span><br><span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClass</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">MyInterface</span></span> </span>&#123;<br>    <span class="hljs-comment">// 不需要实现newMethod()</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">Main</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> void main(<span class="hljs-keyword">String</span>[] args) &#123;<br>        MyClass myClass = <span class="hljs-keyword">new</span> <span class="hljs-type">MyClass</span>();<br>        myClass.<span class="hljs-keyword">new</span><span class="hljs-type">Method</span>(); <span class="hljs-comment">// 调用默认方法</span><br><br>        MyInterface.anotherNewMethod(); <span class="hljs-comment">// 直接调用接口的静态方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyClass</code>实现了<code>MyInterface</code>但没有实现<code>newMethod()</code>方法，因为它是一个默认方法。</p><p>同时，可以直接通过<code>MyInterface</code>调用静态方法<code>anotherNewMethod()</code>。</p><hr><p>有一种情况需要重写 default 的接口方法，注意一下，示例如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceNew</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sm</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface提供的方式实现&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sm2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface提供的方式实现&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface default方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def2</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;interface default2方法&quot;</span>);<br>    &#125;<br>    <span class="hljs-comment">//须要实现类重写</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">f</span>()</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title">InterfaceNew1</span> &#123;<br>    <span class="hljs-function"><span class="hljs-literal">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">def</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;InterfaceNew1 default方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果有一个类既实现了 <code>InterfaceNew</code> 接口又实现了 <code>InterfaceNew1</code>接口，它们都有<code>def()</code>，并且 <code>InterfaceNew</code> 接口和 <code>InterfaceNew1</code>接口没有继承关系的话，这时就必须重写<code>def()</code>。</p><p>不然的话，编译的时候就会报错。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InterfaceNewImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">InterfaceNew</span> , <span class="hljs-title class_">InterfaceNew1</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">InterfaceNewImpl</span> interfaceNew = <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterfaceNewImpl</span>();<br>        interfaceNew.<span class="hljs-title function_">def</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">def</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">InterfaceNew1</span>.<span class="hljs-property">super</span>.<span class="hljs-title function_">def</span>();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><blockquote><p>Java8中，接口和抽象类的区别</p></blockquote><ul><li>interface 和 class 的区别，主要有：<ul><li>接口多实现，类单继承</li><li>接口的方法是 public abstract 修饰，变量是 public static final 修饰。 abstract class 可以用其他修饰符</li></ul></li><li>interface 的方法是<strong>更像是一个扩展插件</strong>。而 abstract class 的方法是要继承的。</li></ul><p>interface 新增<code>default</code>和<code>static</code>修饰的方法，为了解决接口的修改与现有的实现不兼容的问题，并不是为了要替代<code>abstract class</code>。</p><h3 id="2、函数式接口（Functional-Interface）"><a href="#2、函数式接口（Functional-Interface）" class="headerlink" title="2、函数式接口（Functional Interface）"></a>2、函数式接口（Functional Interface）</h3><p>函数式接口（Functional Interface）是Java 8引入的一个<strong>重要概念</strong>，它是Java对函数式编程支持的一部分。</p><blockquote><p>定义</p></blockquote><p>函数式接口<strong>是只有一个抽象方法的接口</strong>。尽管接口可以包含多个默认方法、静态方法，<strong>但只能有一个抽象方法</strong>。这种接口的主要目的是为了与Lambda表达式结合使用。</p><blockquote><p><code>@FunctionalInterface</code> 注解</p></blockquote><p>虽然不是强制性的，但通常会使用<code>@FunctionalInterface</code>注解来标记函数式接口。这个注解有助于编译器识别意图，并在接口不是有效的函数式接口时生成编译时错误。</p><blockquote><p>函数式接口示例：</p></blockquote><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">Greeting</span> </span>&#123;<br>    <span class="hljs-keyword">String</span> sayHello(<span class="hljs-keyword">String</span> name);<br>&#125;<br></code></pre></td></tr></table></figure><p>这个<code>Greeting</code>接口定义了一个接受一个字符串参数并返回一个字符串的方法。</p><p>由于它只有一个抽象方法，所以它是一个函数式接口。</p><blockquote><p>使用场景</p></blockquote><p>函数式接口在Java 8中引入Lambda表达式时变得非常重要。Lambda表达式提供了一种简洁的方式来实现函数式接口，从而使代码更简洁、更易读。</p><p>可以将函数式接口想象成一种特殊的工具套件。这个套件里只有一个工具槽（抽象方法），但你可以以多种方式（Lambda表达式、方法引用）填充这个槽。这就像是一个可定制的工具，你可以根据需要插入不同的功能。</p><p>函数式接口在Java中的很多地方都有使用，例如：</p><ul><li>在<code>java.util.function</code>包中，Java 8引入了一系列标准的函数式接口，如<code>Predicate&lt;T&gt;</code>、<code>Function&lt;T,R&gt;</code>、<code>Consumer&lt;T&gt;</code>等。</li><li>在集合框架中，它们被用于简化迭代、过滤和转换操作。</li><li>在并发编程中，例如使用<code>Runnable</code>或<code>Callable</code>接口。</li></ul><h3 id="3、Lambda-表达式"><a href="#3、Lambda-表达式" class="headerlink" title="3、Lambda 表达式"></a>3、Lambda 表达式</h3><p>Lambda表达式是Java 8中一个非常重要的新特性，它为Java带来了一种简洁的方式来表示函数式接口的实例。</p><p>Lambda表达式主要用于提供一种简洁、表达式风格的方法来表示可以传递的匿名函数。这种表达方式非常适合创建简短的、只使用一次的方法版本。</p><h4 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h4><blockquote><p>语法格式</p></blockquote><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span> expression 或<br><span class="hljs-function"><span class="hljs-params">(parameters)</span> -&gt;</span>&#123; statements; &#125;<br></code></pre></td></tr></table></figure><ul><li>parameters<ul><li>与方法定义中的参数列表类似。对于单个参数，可以省略括号</li></ul></li><li><code>-&gt;</code><ul><li>Lambda表达式的核心，用于分隔参数列表和Lambda体</li></ul></li><li><strong>Lambda体</strong><ul><li>可以是一个表达式或一个代码块。表达式体会返回一个值，而代码块可以包含零个或多个语句。</li></ul></li></ul><h4 id="简易示例"><a href="#简易示例" class="headerlink" title="简易示例"></a>简易示例</h4><blockquote><p>使用示例</p></blockquote><p>Lambda表达式通常与函数式接口一起使用。函数式接口是只有一个抽象方法的接口，这意味着Lambda表达式可以为该抽象方法提供实现。</p><p>假设我们有一个简单的函数式接口：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StringOperation</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(String s)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>不使用Lambda表达式，我们可能需要这样实现：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">StringOperation operation = <span class="hljs-keyword">new</span> StringOperation() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getLength</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">return</span> s.<span class="hljs-title">length</span><span class="hljs-params">()</span></span>;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>使用Lambda表达式，我们可以这样简化：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf">StringOperation operation <span class="hljs-operator">=</span> s -&gt; s.length()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="替代匿名内部类"><a href="#替代匿名内部类" class="headerlink" title="替代匿名内部类"></a>替代匿名内部类</h4><p>平时开发经常会用到 Runnable 接口、Comparator 接口、Listener 接口 这三个接口，下面分别就看一下他们的使用示例。</p><blockquote><p>Runnable 接口</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-built_in">new</span> Thread(<span class="hljs-built_in">new</span> Runnable() &#123;<br>            @Override<br>            <span class="hljs-built_in">public</span> <span class="hljs-type">void</span> run() &#123;<br>                <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;The runable now is using!&quot;);<br>            &#125;<br>&#125;).<span class="hljs-keyword">start</span>();<br>//用lambda<br><span class="hljs-built_in">new</span> Thread(() -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(&quot;It&#x27;s a lambda function!&quot;)).<span class="hljs-keyword">start</span>();<br></code></pre></td></tr></table></figure><blockquote><p>Comparator 接口</p></blockquote><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;<span class="hljs-type">Integer</span>&gt; strings = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br><br>Collections.sort(strings, <span class="hljs-built_in">new</span> Comparator&lt;<span class="hljs-type">Integer</span>&gt;() &#123;<br>@Override<br><span class="hljs-built_in">public</span> <span class="hljs-type">int</span> compare(<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) &#123;<br>    <span class="hljs-keyword">return</span> o1 - o2;&#125;<br>&#125;);<br><br>//Lambda<br>Collections.sort(strings, (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) -&gt; o1 - o2);<br>//分解开<br>Comparator&lt;<span class="hljs-type">Integer</span>&gt; comparator = (<span class="hljs-type">Integer</span> o1, <span class="hljs-type">Integer</span> o2) -&gt; o1 - o2;<br>Collections.sort(strings, comparator);<br></code></pre></td></tr></table></figure><blockquote><p>Listener 接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">JButton</span> <span class="hljs-variable">button</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">JButton</span>();<br>button.addItemListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ItemListener</span>() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">itemStateChanged</span><span class="hljs-params">(ItemEvent e)</span> &#123;<br>   e.getItem();<br>&#125;<br>&#125;);<br><span class="hljs-comment">//lambda</span><br>button.addItemListener(e -&gt; e.getItem());<br></code></pre></td></tr></table></figure><h4 id="集合上使用"><a href="#集合上使用" class="headerlink" title="集合上使用"></a>集合上使用</h4><blockquote><p>在集合上的应用</p></blockquote><p>Lambda表达式特别适合用在集合的操作上，比如<code>forEach</code>、<code>map</code>、<code>filter</code>等方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">List&lt;String&gt; list = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;C++&quot;);<br><br>// 使用Lambda表达式迭代<br>list.<span class="hljs-keyword">forEach</span>(element -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(element));<br><br>// 使用Lambda表达式和Stream API进行过滤<br>list.stream()<br>    .<span class="hljs-keyword">filter</span>(s -&gt; s.startsWith(&quot;J&quot;))<br>    .<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-type">void</span> lamndaFor() &#123;<br>        List&lt;String&gt; strings = Arrays.asList(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;);<br>        //传统<span class="hljs-keyword">foreach</span><br>        <span class="hljs-keyword">for</span> (String s : strings) &#123;<br>            <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s);<br>        &#125;<br>        //Lambda <span class="hljs-keyword">foreach</span><br>        strings.<span class="hljs-keyword">forEach</span>((s) -&gt; <span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(s));<br>        //<span class="hljs-keyword">or</span><br>        strings.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>::println);<br> //map<br>        Map&lt;<span class="hljs-type">Integer</span>, String&gt; map = <span class="hljs-built_in">new</span> HashMap&lt;&gt;();<br>        map.<span class="hljs-keyword">forEach</span>((k,v)-&gt;<span class="hljs-keyword">System</span>.<span class="hljs-keyword">out</span>.println(v));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="方法的引用"><a href="#方法的引用" class="headerlink" title="方法的引用"></a>方法的引用</h4><p>Java 8 允许使用 <code>::</code> 关键字来传递方法或者构造函数引用，无论如何，表达式返回的类型必须是 functional-interface。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClassSuper</span> &#123;<br>    LambdaInterface <span class="hljs-title function_">sf</span><span class="hljs-params">()</span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LambdaClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">LambdaClassSuper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LambdaInterface <span class="hljs-title function_">staticF</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> LambdaInterface <span class="hljs-title function_">f</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">show</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">//1.调用静态函数，返回类型必须是functional-interface</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> LambdaClass::staticF;<br><br>        <span class="hljs-comment">//2.实例方法调用</span><br>        <span class="hljs-type">LambdaClass</span> <span class="hljs-variable">lambdaClass</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaClass</span>();<br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">lambdaInterface</span> <span class="hljs-operator">=</span> lambdaClass::f;<br><br>        <span class="hljs-comment">//3.超类上的方法调用</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">superf</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">super</span>::sf;<br><br>        <span class="hljs-comment">//4. 构造方法调用</span><br>        <span class="hljs-type">LambdaInterface</span> <span class="hljs-variable">tt</span> <span class="hljs-operator">=</span> LambdaClassSuper::<span class="hljs-keyword">new</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问变量</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>;<br>Collections.sort(<span class="hljs-built_in">string</span>s, (Integer o1, Integer o2) -&gt; o1 - i);<br><span class="hljs-comment">//i =3;</span><br></code></pre></td></tr></table></figure><p>lambda 表达式可以引用外边变量，但是该变量默认拥有 final 属性，不能被修改，如果修改，编译时就报错。</p><p>to be contined……</p><h3 id="4、Stream"><a href="#4、Stream" class="headerlink" title="4、Stream"></a>4、Stream</h3><blockquote><p>Stream 是什么</p></blockquote><p>java 新增了 <code>java.util.stream</code> 包，它和之前的流大同小异。之前接触最多的是资源流，比如<code>java.io.FileInputStream</code>，通过流把文件从一个地方输入到另一个地方，它只是内容搬运工，对文件内容不做任何 CRUD。</p><p><code>Stream</code>依然不存储数据，不同的是它可以检索(Retrieve)和逻辑处理集合数据、包括筛选、排序、统计、计数等。可以想象成是 Sql 语句。</p><p>它的源数据可以是 <code>Collection</code>、<code>Array</code> 等。由于它的方法参数都是函数式接口类型，所以一般和 Lambda 配合使用。</p><blockquote><p>流类型</p></blockquote><ol><li>stream 串行流</li><li>parallelStream 并行流，可多线程执行</li></ol><h4 id="Stream-常用方法"><a href="#Stream-常用方法" class="headerlink" title="Stream 常用方法"></a>Stream 常用方法</h4><ul><li><code>stream()</code>, <code>parallelStream()</code></li><li><code>filter()</code></li><li><code>findAny()</code> <code>findFirst()</code></li><li><code>sort</code></li><li><code>forEach</code> void</li><li><code>map(), reduce()</code></li><li><code>flatMap()</code> - 将多个Stream连接成一个Stream</li><li><code>collect(Collectors.toList())</code></li><li><code>distinct</code>, <code>limit</code></li><li><code>count</code></li><li><code>min</code>, <code>max</code>, <code>summaryStatistics</code></li></ul><h3 id="5、Optional"><a href="#5、Optional" class="headerlink" title="5、Optional"></a>5、Optional</h3><h3 id="6、Date-Time-API"><a href="#6、Date-Time-API" class="headerlink" title="6、Date-Time API"></a>6、Date-Time API</h3><p>to be contined….</p><hr><p>参考</p><ul><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7">https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7</a></li><li><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">https://javaguide.cn/java/new-features/java8-common-new-features.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JDK8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_线程池</title>
    <link href="/2023/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>线程池介绍</li><li>Executor 框架</li><li>ThreadPoolExecutor 类</li><li>线程池原理分析</li><li>常见的内置线程池</li><li>实践使用篇</li></ul><h3 id="1、什么是线程池"><a href="#1、什么是线程池" class="headerlink" title="1、什么是线程池"></a>1、什么是线程池</h3><p>线程池是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。</p><p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行</strong></p><p>使用线程池的一些好处：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="2、Executor-框架介绍"><a href="#2、Executor-框架介绍" class="headerlink" title="2、Executor 框架介绍"></a>2、Executor 框架介绍</h3><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p> Executor 框架 三大部分组成</p><ul><li><strong>任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</strong></li><li><strong>任务的执行(<code>Executor</code>)</strong></li><li><strong>异步计算的结果(<code>Future</code>)</strong></li></ul><blockquote><p><strong>任务的执行(<code>Executor</code>)</strong></p></blockquote><p>看这个图，了解一下对应核心类的关系：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219213228.png" alt="image.png"></p><p>任务的执行(<code>Executor</code>) 包括任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。</p><p><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code>** 这两个关键类实现了 <code>ExecutorService</code> 接口。</p><h3 id="3、ThreadPoolExecutor-类使用-★"><a href="#3、ThreadPoolExecutor-类使用-★" class="headerlink" title="3、ThreadPoolExecutor 类使用 ★"></a>3、ThreadPoolExecutor 类使用 ★</h3><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ThreadPoolExecutor(int corePoolSize,     <span class="hljs-comment">//线程池的核心线程数量</span><br>                          int maximumPoolSize,  <span class="hljs-comment">//线程池的最大线程数</span><br>                          long keepAliveTime,   <span class="hljs-comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br>                          TimeUnit unit,        <span class="hljs-comment">//时间单位</span><br>                          BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">//任务队列，用来储存等待执行任务的队列</span><br>                          ThreadFactory threadFactory,       <span class="hljs-comment">//线程工厂，用来创建线程，一般默认即可</span><br>                          RejectedExecutionHandler handler  <span class="hljs-comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br>  )&#123;<br>    <span class="hljs-comment">// 参数检查：核心线程数不能小于0，最大线程数不能小于或等于0，最大线程数不能小于核心线程数，keepAliveTime不能小于0</span><br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException();<br><br>    <span class="hljs-comment">// 参数检查：工作队列、线程工厂和拒绝策略不能为null</span><br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> new NullPointerException();<br><br>    <span class="hljs-comment">// 获取安全管理器的上下文，这是Java安全模型的一部分</span><br>    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?<br>            <span class="hljs-literal">null</span> :<br>            AccessController.getContext();<br><br>    <span class="hljs-comment">// 设置线程池的核心线程数</span><br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br><br>    <span class="hljs-comment">// 设置线程池的最大线程数</span><br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br><br>    <span class="hljs-comment">// 设置工作队列</span><br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br><br>    <span class="hljs-comment">// 设置线程保持活动的时间，单位转换为纳秒</span><br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><br>    <span class="hljs-comment">// 设置线程工厂，用于创建新线程</span><br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br><br>    <span class="hljs-comment">// 设置拒绝策略，当线程池不能接受任务时使用</span><br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><h4 id="线程池创建的两种方式"><a href="#线程池创建的两种方式" class="headerlink" title="线程池创建的两种方式"></a>线程池创建的两种方式</h4><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>**<code>ScheduledThreadPool</code>**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><blockquote><p>不建议使用第二种，原因如下：</p></blockquote><p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code>Executors</code> 去创建，</p><p>而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h4 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h3 id="4、线程池原理分析"><a href="#4、线程池原理分析" class="headerlink" title="4、线程池原理分析"></a>4、线程池原理分析</h3><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></li><li><a href="https://www.bilibili.com/video/BV1eD4y1w7Rp">https://www.bilibili.com/video/BV1eD4y1w7Rp</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot学习_SpringBoot 自动装配原理</title>
    <link href="/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面试题：讲述一下Spring Boot 的自动装配原理。</p></blockquote><p>Spring Boot 的自动装配原理基于 Spring 框架的依赖注入和条件注册特性，通过一系列的“启动器”（starters）和自动配置（auto-configuration）类来简化配置过程。</p><p>以下是关键点：</p><ol><li><strong>启动器（Starters）</strong>:<ul><li>Spring Boot 提供了一系列的启动器，它们是预先打包好的依赖集合，旨在提供不同功能的快速集成，如 Web 应用、数据库访问等。</li></ul></li><li><strong>@EnableAutoConfiguration</strong>:<ul><li>这是自动装配的核心注解。通常，这个注解是通过 <code>@SpringBootApplication</code> 杂注引入的，它会触发 Spring Boot 的自动配置机制。</li><li>它利用了 Spring 的 <code>ImportSelector</code> 接口来加载 <code>META-INF/spring.factories</code> 中指定的配置类。</li></ul></li><li><strong>条件注解（Conditional Annotations）</strong>:<ul><li>自动配置类使用一系列的条件注解（如 <code>@ConditionalOnClass</code>，<code>@ConditionalOnBean</code>），确保只有在满足特定条件时才启用配置。这些条件通常包括类路径上的类存在、某个 Bean 不存在、某个属性有特定的值等。</li></ul></li><li><strong>spring.factories</strong>:<ul><li>这是一个位于每个自动配置库 <code>META-INF</code> 目录下的属性文件。它列出了所有可用的自动配置类，这些类由 <code>AutoConfigurationImportSelector</code> 读取和处理。</li></ul></li><li><strong>自动配置类（AutoConfiguration Classes）</strong>:<ul><li>这些类通常采用 <code>@Configuration</code> 形式，并且它们自身也可以包含 <code>@Bean</code>、<code>@Component</code> 和其他配置相关的注解。</li><li>自动配置类可以提供默认的 Bean 定义、属性绑定和其他自动化配置。</li></ul></li><li><strong>细粒度控制</strong>:<ul><li>开发者可以通过 <code>application.properties</code> 或 <code>application.yml</code> 文件来覆盖自动配置的默认值。</li><li>如果需要，可以通过 <code>@EnableAutoConfiguration</code> 的 <code>exclude</code> 属性排除特定的自动配置类。</li></ul></li><li><strong>事件监听与发布</strong>:<ul><li>在自动配置的过程中，Spring Boot 也会发布和监听各种事件，允许用户在应用生命周期的不同阶段进行交互。</li></ul></li></ol><p>总结来说，Spring Boot 的自动装配是一个智能且灵活的机制，它减轻了传统 Spring 应用配置的负担，通过一系列条件匹配和约定优于配置的原则，提供了一个即插即用的开发体验。</p><h3 id="1、什么是Spring-Boot-的自动装配"><a href="#1、什么是Spring-Boot-的自动装配" class="headerlink" title="1、什么是Spring Boot 的自动装配"></a>1、什么是Spring Boot 的自动装配</h3><p>先了解一下自动装配类主要用的注解和自动配置类，了解其概念，并继续往下进行学习。</p><p>Spring Boot 的自动装配原理是基于 Spring 框架的依赖注入和条件装配特性。</p><p>自动装配主要通过 <code>@EnableAutoConfiguration</code> 注解和一系列的自动配置类 (<code>*AutoConfiguration</code> 类) 来实现。</p><p>以下是从源码角度对其原理的解析：</p><blockquote><ol><li>@EnableAutoConfiguration</li></ol></blockquote><ul><li><code>@EnableAutoConfiguration</code> 注解是 Spring Boot 自动装配的入口。它通常与 <code>@SpringBootApplication</code> 注解一起使用，在应用启动时被激活。</li><li>该注解背后使用了 <code>@Import</code> 注解来导入 <code>EnableAutoConfigurationImportSelector</code> 类，这是启动自动装配的关键。</li></ul><blockquote><ol start="2"><li>EnableAutoConfigurationImportSelector</li></ol></blockquote><ul><li><code>EnableAutoConfigurationImportSelector</code> 实现了 <code>ImportSelector</code> 接口，负责选择需要导入的配置类。</li><li>它读取 <code>META-INF/spring.factories</code> 文件中的内容，这个文件列出了所有可用的自动配置类。</li><li>每个自动配置类都是以条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>）标注的，这些注解确保只有在特定条件满足时，相关配置才会被应用。</li></ul><blockquote><ol start="3"><li>条件注解</li></ol></blockquote><ul><li>条件注解是 Spring Framework 的核心特性之一，Spring Boot 在此基础上实现了自动装配。</li><li><code>@Conditional</code> 注解家族（比如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）允许在满足特定条件时，才执行某些操作（如实例化 Bean）。</li><li>这些注解确保了只有当相关的类存在于类路径上、或者某个 Bean 尚未定义时，对应的自动配置类才会被激活。</li></ul><blockquote><ol start="4"><li>自动配置类 (<code>*AutoConfiguration</code>)</li></ol></blockquote><ul><li>自动配置类通常命名为 <code>*AutoConfiguration</code>，它们包含了一系列的 Bean 定义和条件逻辑。</li><li>这些类利用 Spring 的依赖注入特性，定义了如何创建和配置 Bean，从而简化了许多常见场景的配置工作。</li><li>例如，<code>DataSourceAutoConfiguration</code> 可以在类路径上检测到数据库连接池实现时自动配置数据源（DataSource）。</li></ul><p>示例：DataSourceAutoConfiguration</p><p>以 <code>DataSourceAutoConfiguration</code> 为例，展示自动配置类的典型结构：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)<br>public class DataSourceAutoConfiguration &#123;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    <span class="hljs-variable">@Configuration</span><br>    <span class="hljs-variable">@Conditional</span>(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)<br>    public static class DataSourceConfiguration &#123;<br>        <span class="hljs-comment">// Bean 定义和配置</span><br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    static class DataSourceAvailableCondition extends SpringBootCondition &#123;<br>        <span class="hljs-comment">// 条件判断逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p>Spring Boot 的自动装配是通过一系列的自动配置类以及条件注解实现的。</p><p>这些自动配置类位于应用的类路径上，并在满足特定条件时被 <code>@EnableAutoConfiguration</code> 注解激活。</p><p>这种机制极大地简化了 Spring 应用的配置过程，允许开发者以最少的努力实现强大的功能。</p><h3 id="2、解读-SpringBootApplication-注解"><a href="#2、解读-SpringBootApplication-注解" class="headerlink" title="2、解读@SpringBootApplication 注解"></a>2、解读@SpringBootApplication 注解</h3><p>上述内容也谈论到 条件注解是 Spring Framework 的核心特性之一，Spring Boot 在其基础上，通过 SPI 的方式，做了进一步优化，并进而实现了自动装配。</p><blockquote><p>我们从启动类开始了解其自动装配原理</p></blockquote><p>本地的版本是：org.springframework.boot:spring-boot-autoconfigure:2.2.5.RELEASE</p><h4 id="2-1-SpringBootApplication"><a href="#2-1-SpringBootApplication" class="headerlink" title="2.1  SpringBootApplication"></a>2.1  SpringBootApplication</h4><p>@SpringBootApplication注解是放置在 Spring Boot 应用的主类上，注解的作用是启用组件扫描和自动配置。</p><p>我们找到一个启动类，进入其注解代码，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE) <span class="hljs-comment">// 注解作用于类型上（比如类、接口）</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME) <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-variable">@Documented</span> <span class="hljs-comment">// 将此注解包含在 Javadoc 中</span><br><span class="hljs-variable">@Inherited</span> <span class="hljs-comment">// 注解可以被继承</span><br><span class="hljs-variable">@SpringBootConfiguration</span> <span class="hljs-comment">// 特殊的@Configuration，表明这是一个 Spring Boot 配置类</span><br><span class="hljs-variable">@EnableAutoConfiguration</span> <span class="hljs-comment">// 启用 Spring Boot 的自动配置机制</span><br><span class="hljs-comment">//启用组件扫描，让 Spring 自动发现和注册应用中的 Beans。通常，它会扫描与主类相同的包以及子包中的组件。</span><br><span class="hljs-comment">//`excludeFilters` 属性用于排除某些类型的组件，这里特别排除了 `TypeExcludeFilter` 和 `AutoConfigurationExcludeFilter` 类型的组件</span><br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;TypeExcludeFilter.class&#125;<br>        ),<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>        )<br>    &#125;<br>) <br>public <span class="hljs-variable">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">// ... 其他属性定义 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 EnableAutoConfiguration"></a>2.2 EnableAutoConfiguration</h4><blockquote><p>作用</p></blockquote><p><code>@EnableAutoConfiguration</code> 是 Spring Boot 的核心注解之一，用于启动自动配置的机制。这个注解通过 <code>@Import</code> 注解导入 <code>AutoConfigurationImportSelector</code>，后者负责根据条件选择和应用自动配置类。</p><blockquote><p>代码</p></blockquote><p><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解继续往下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> <span class="hljs-comment">// 指定注解可以应用于类型级别（类、接口等）</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-meta">@Documented</span> <span class="hljs-comment">// 注解将被包含在javadoc中</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">// 注解可以被子类继承</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">// 自动配置包，将主配置类的包视为自动配置包</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">// 导入AutoConfigurationImportSelector</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <br>    <span class="hljs-comment">// 用于覆盖自动配置是否启用的属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    <span class="hljs-comment">// 排除特定的自动配置类</span><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 通过名称排除特定的自动配置类</span><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用示例</p></blockquote><p>通常，我们是不会显式地使用 <code>@EnableAutoConfiguration</code>，它已经包含在 <code>@SpringBootApplication</code> 注解中。</p><p>但如果需要单独使用，可以像下面这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableAutoConfiguration</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)<br>public class MyConfiguration &#123;<br>    <span class="hljs-comment">// 配置内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>@EnableAutoConfiguration</code> 注解用于启动自动配置，但排除了特定的自动配置类 <code>DataSourceAutoConfiguration</code>。</p><hr><h4 id="2-3-AutoConfigurationImportSelector"><a href="#2-3-AutoConfigurationImportSelector" class="headerlink" title="2.3 AutoConfigurationImportSelector"></a>2.3 AutoConfigurationImportSelector</h4><p><code>AutoConfigurationImportSelector</code> 是 Spring Boot 自动装配机制的关键组成部分。这个类实现了多个 Spring 框架的接口，使其能够在启动时选择和注册自动配置类。</p><p>先看一下这个类 <code>AutoConfigurationImportSelector</code>的继承体系：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AutoConfigurationImportSelector</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">DeferredImportSelector, <span class="hljs-symbol">BeanClassLoaderAware</span>, <span class="hljs-symbol">ResourceLoaderAware</span>, <span class="hljs-symbol">BeanFactoryAware</span>, <span class="hljs-symbol">EnvironmentAware</span>, <span class="hljs-symbol">Ordered</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">DeferredImportSelector</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br>    String[] selectImports(AnnotationMetadata var1);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的两层继承关系可以看出 <code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，这意味着它实现了这个接口中的 <code>selectImports</code>方法，</p><p><code>selectImports</code> 方法是 <code>AutoConfigurationImportSelector</code> 类的核心部分，用于根据当前的应用上下文环境选择合适的自动配置类。</p><p>以下是对这个方法的代码注释解释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-comment">// 检查是否启用自动配置</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-comment">// 如果自动配置没有启用，则不导入任何配置</span><br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 加载自动配置的元数据</span><br>        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br><br>        <span class="hljs-comment">// 获取自动配置条目（即自动配置类的列表）</span><br>        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <br>                <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br><br>        <span class="hljs-comment">// 将自动配置类转换为字符串数组并返回</span><br>        <span class="hljs-comment">// 这些类名将被 Spring 容器进一步处理，以实现自动配置</span><br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法解释</p></blockquote><ol><li><strong>isEnabled 方法</strong>:<ul><li>检查是否启用了自动配置。这通常是通过检查某个特定的属性或条件来决定的。如果自动配置被禁用，则此方法返回一个空的数组，意味着不进行任何自动配置。</li></ul></li><li><strong>加载自动配置元数据</strong>:<ul><li>使用 <code>AutoConfigurationMetadataLoader</code> 加载自动配置的元数据。这些元数据通常从 <code>META-INF/spring.factories</code> 文件中读取，其中列出了所有可用的自动配置类。</li></ul></li><li><strong>获取自动配置条目</strong>:<ul><li><code>getAutoConfigurationEntry</code> 方法根据当前的应用上下文环境和已加载的元数据确定哪些自动配置类应该被激活。这涉及到一系列条件匹配，例如检查类路径上是否存在特定的类。</li></ul></li><li><strong>返回自动配置类的名称</strong>:<ul><li>最后，该方法返回一个包含应该激活的自动配置类名称的字符串数组。Spring 容器随后将使用这些类名来实例化相应的 Bean 定义。</li></ul></li></ol><h4 id="2-4-getAutoConfigurationEntry"><a href="#2-4-getAutoConfigurationEntry" class="headerlink" title="2.4 getAutoConfigurationEntry"></a>2.4 getAutoConfigurationEntry</h4><p>重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法的主要职责是收集所有应该被激活的自动配置类，并根据给定的条件来筛选和排除某些配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(<br>    AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;<br>    <br>    <span class="hljs-comment">// 检查自动配置是否被启用，如果没有，则返回一个空的配置条目</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取注解的属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>        <br>        <span class="hljs-comment">// 获取所有候选的配置类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 移除重复的配置</span><br>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);<br>        <br>        <span class="hljs-comment">// 获取需要排除的配置类</span><br>        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 检查排除的类是否真的存在于候选配置中，并抛出异常如果有的话</span><br>        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 从候选配置中移除排除的配置</span><br>        configurations.removeAll(exclusions);<br>        <br>        <span class="hljs-comment">// 过滤配置，可能使用条件服务等进一步筛选配置</span><br>        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);<br>        <br>        <span class="hljs-comment">// 触发自动配置导入相关事件</span><br>        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 返回一个新的 AutoConfigurationEntry 对象，包含最终确定的配置类和排除的类</span><br>        <span class="hljs-keyword">return</span> new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法解释</p><ol><li><strong>isEnabled</strong>:<ul><li>检查是否在注解元数据中设置了启用自动配置的属性。</li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> boolean isEnabled(AnnotationMetadata metadata) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass() == AutoConfigurationImportSelector.<span class="hljs-keyword">class</span> ? (<span class="hljs-built_in">Boolean</span>)<span class="hljs-keyword">this</span>.getEnvironment().getProperty(<span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>, <span class="hljs-built_in">Boolean</span>.<span class="hljs-keyword">class</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>isEnabled</code> 方法会判断自动装配开关是否打开。</p><p>默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><ol start="2"><li><strong>getAttributes</strong>:<ul><li>提取注解元数据中的属性，这些属性可能会影响自动配置的选择。</li><li>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></li></ul></li><li><strong>getCandidateConfigurations</strong>:<ul><li>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></li></ul></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">spring-<span class="hljs-keyword">boot</span>/spring-<span class="hljs-keyword">boot</span>-project/spring-<span class="hljs-keyword">boot</span>-autoconfigure/src/main/resources/<span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/spring.factories<br></code></pre></td></tr></table></figure><p>不光是单个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>你可以看一下 druid 数据库连接池的 Spring Boot Starter ，在它里面就创建了<code>META-INF/spring.factories</code>文件。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219202949.png" alt="image.png"></p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><ol start="4"><li><strong>removeDuplicates</strong>:<ul><li>保证配置列表中没有重复的条目。</li></ul></li><li><strong>getExclusions</strong>:<ul><li>读取注解元数据，找出需要从自动配置中排除的类。</li></ul></li><li><strong>checkExcludedClasses</strong>:<ul><li>确保排除的类是候选配置列表中的成员，如果不是，则抛出异常。</li></ul></li><li><strong>configurations.removeAll(exclusions)</strong>:<ul><li>实际从候选配置列表中移除被排除的类。</li></ul></li><li><strong>filter</strong>:<ul><li>使用 <code>AutoConfigurationMetadata</code> 对候选配置进行进一步的条件筛选。</li></ul></li><li><strong>fireAutoConfigurationImportEvents</strong>:<ul><li>发布事件，这可能会影响后续处理过程，例如通过监听器来进一步修改配置列表。</li></ul></li><li><strong>返回 AutoConfigurationEntry</strong>:<ul><li>创建并返回一个 <code>AutoConfigurationEntry</code> 对象，该对象包含了最终确定要导入的自动配置类和已排除的类。</li></ul></li></ol><p>我们在具体使用的时候，<code>spring.factories</code>中会有很多配置，但每次启动并不是全部加载；</p><p>我们会在配置类上使用 ConditionalOnxxx 注解，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><p>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123; RabbitTemplate.class, Channel.class &#125;)<br><span class="hljs-variable">@EnableConfigurationProperties</span>(RabbitProperties.class)<br><span class="hljs-variable">@Import</span>(RabbitAnnotationDrivenConfiguration.class)<br>public class RabbitAutoConfiguration &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、新建一个-starter"><a href="#3、新建一个-starter" class="headerlink" title="3、新建一个 starter"></a>3、新建一个 starter</h3><p>创建过程：</p><blockquote><ol><li>创建项目结构</li></ol></blockquote><p>需要创建一个 Maven项目。</p><p>为了遵循 Spring Boot Starter 命名约定，项目的名称通常以 <code>spring-boot-starter-</code> 开头，例如 <code>spring-boot-starter-myfeature</code>。</p><blockquote><ol start="2"><li>添加必要的依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Boot 以及其他所需库的依赖。</p><p>示例 Maven <code>pom.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加其他自己 Starter 需要的依赖 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>创建自动配置类</li></ol></blockquote><p>在项目中创建一个或多个配置类，使用 <code>@Configuration</code> 注解，并根据需要使用 <code>@Conditional</code> 注解来条件化配置。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(MyFeature.class)<br><span class="hljs-variable">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>, name = <span class="hljs-string">&quot;enabled&quot;</span>, havingValue = <span class="hljs-string">&quot;true&quot;</span>, matchIfMissing = true)<br>public class MyFeatureAutoConfiguration &#123;<br><br>    <span class="hljs-variable">@Bean</span><br>    <span class="hljs-variable">@ConditionalOnMissingBean</span><br>    public MyFeature <span class="hljs-built_in">myFeature</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">MyFeature</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>创建 <code>spring.factories</code> 文件</li></ol></blockquote><p>在项目的资源目录中创建一个 <code>META-INF/spring.factories</code> 文件，并指定自动配置类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.example</span>.MyFeatureAutoConfiguration<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>配置属性类（可选）</li></ol></blockquote><p>如果你的 Starter 需要配置属性，创建一个属性类使用 <code>@ConfigurationProperties</code> 注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFeatureProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> boolean enabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// ... 其他属性和getter/setter</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>测试 Starter</li></ol></blockquote><p>创建一个简单的 Spring Boot 应用来验证 Starter 是否按预期工作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStarterTestApp</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">MyStarterTestApp</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="7"><li>打包和发布</li></ol></blockquote><p>使用 Maven 将 Starter 打包，并发布到 Maven 中央仓库或私有仓库，使得其他项目可以添加依赖使用。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`mvn clean install`</span><br></code></pre></td></tr></table></figure><p>同时最好编写清晰的文档，说明如何添加 Starter 的依赖，以及如何配置和使用提供的功能。</p><blockquote><p>总结</p></blockquote><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，</p><p>通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，</p><p>自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的生命周期</title>
    <link href="/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>本篇讲述一下关于Bean的生命周期。</p><p>bean的作用域有很多种，这里讨论一下完全被 IOC容器控制的单例 Bean。</p><h3 id="1、Spring-Bean-生命周期的四个阶段"><a href="#1、Spring-Bean-生命周期的四个阶段" class="headerlink" title="1、Spring Bean 生命周期的四个阶段"></a>1、Spring Bean 生命周期的四个阶段</h3><blockquote><p>普通的 Java 对象</p></blockquote><p>对于普通的 Java 对象来说，它们的生命周期是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><blockquote><p>Spring Bean</p></blockquote><p>而对于 Spring Bean 的生命周期来说，可以分为四个阶段：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>其中初始化完成之后，就代表这个 Bean 可以使用了</p><p>上述四个阶段的大概的一个逻辑</p><p>前面三个阶段的操作（先大概了解有这个印象，具体内容继续往下面看）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = (BeanWrapper)<span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 实例化阶段</span><br>        instanceWrapper = <span class="hljs-built_in">this</span>.createBeanInstance(beanName, mbd, args);<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 属性赋值阶段</span><br>        <span class="hljs-built_in">this</span>.populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化阶段</span><br>        exposedObject = <span class="hljs-built_in">this</span>.initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>销毁操作，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p><h3 id="2、Spring-Bean-的生命周期的扩展点"><a href="#2、Spring-Bean-的生命周期的扩展点" class="headerlink" title="2、Spring Bean 的生命周期的扩展点"></a>2、Spring Bean 的生命周期的扩展点</h3><p>上面讲述到Bean的生命周期有四个阶段，分别是：实例化  →  属性赋值  →  初始化  →  销毁；</p><p>在不同阶段中间，Spring 框架会进行一些功能的扩展点，下面分四个部分分别讲解这些扩展点。</p><ul><li>Bean 自身方法</li><li>容器级别方法</li><li>工厂后处理器方法</li><li>Bean 级生命周期方法</li></ul><h4 id="2-1-Bean-自身的方法"><a href="#2-1-Bean-自身的方法" class="headerlink" title="2.1  Bean 自身的方法"></a>2.1  Bean 自身的方法</h4><p>在Bean的生命周期中，Bean自身是有一些特定方法是能够被调用的，以便完成其生命周期过程。</p><p>比如构造函数、getter&#x2F;setter 以及 init-method 和 destory-method 所指定的方法等，而这些方法又分别对应着上文说的四个阶段：例化、属性赋值、初始化和销毁。</p><p>这些Bean自身的方法一般是我们在配置Bean的时候就已经定义好的，下面我们通过一个简单 Bean 的使用来看一下其用法。</p><blockquote><p>Bean 示例</p></blockquote><p>我们定义一个简单的 Bean，名为 <code>MyBean</code>，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-comment">// 构造函数 - 实例化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBean</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean Constructor: Bean is being instantiated.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Setter 方法 - 属性赋值阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">String <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean setValue: Setting property value.&quot;</span>);<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化方法 - 初始化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean init: Bean is being initialized.&quot;</span>);<br>        <span class="hljs-comment">// 执行初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 销毁方法 - 销毁阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean destroy: Bean is being destroyed.&quot;</span>);<br>        <span class="hljs-comment">// 执行清理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们通过注解或者xml 配置声明  init-method 和 destory-method  对应的方法。</p><blockquote><p>xml 配置</p></blockquote><p><strong>在 Spring 配置中定义 Bean</strong></p><p>在 Spring 的 XML 配置文件中，如下配置这个 Bean，并指定 <code>init-method</code> 和 <code>destroy-method</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.MyBean&quot;</span> init-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;init&quot;</span> destroy-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;destroy&quot;</span>&gt;<br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;value&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;Some value&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注解配置</p></blockquote><p>在基于 Java 的配置中，可以使用 <code>@Bean</code> 注解：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;init&quot;</span>, destroyMethod = <span class="hljs-string">&quot;destroy&quot;</span>)<br>    <span class="hljs-keyword">public</span> MyBean myBean() &#123;<br>        MyBean myBean = <span class="hljs-keyword">new</span> <span class="hljs-type">MyBean</span>();<br>        myBean.setValue(<span class="hljs-string">&quot;Some value&quot;</span>);<br>        <span class="hljs-keyword">return</span> myBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Bean</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;appContext.xml&quot;</span>);<br>        SimpleBean simpleBean = context.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;myBean&quot;</span>, MyBean.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 使用 simpleBean ...</span><br>        ((ClassPathXmlApplicationContext) context).<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭上下文以触发销毁方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>四个主要阶段以及代码解释</p></blockquote><p>通过注解或者xml配置的方式，我们指定了初始化和销毁方法，并在 <code>MyBean</code> 定义了 Setter 方法，具体在容器执行的时候，会进行以下的操作：</p><ol><li><strong>实例化阶段</strong>:<ul><li>当 Spring 容器创建 <code>MyBean</code> 的实例时，首先调用其构造函数。</li></ul></li><li><strong>属性赋值阶段</strong>:<ul><li>接着，Spring 容器通过调用 <code>setValue</code> 方法来注入属性值。</li></ul></li><li><strong>初始化阶段</strong>:<ul><li>在所有属性都设置之后，Spring 容器调用指定的 <code>init</code> 方法。</li></ul></li><li><strong>销毁阶段</strong>:<ul><li>当 Spring 容器关闭时，它会调用 <code>destroy</code> 方法。</li></ul></li></ol><h4 id="2-2-容器级别方法"><a href="#2-2-容器级别方法" class="headerlink" title="2.2  容器级别方法"></a>2.2  容器级别方法</h4><p>将这个容器级别方法理解为阶段中间容器会进行的一些操作，这些方法一般是 BeanPostProcessor 的一系列接口。</p><p>在上述讲到的Bean 四个阶段，在这四个阶段的执行过程中，进行一些前置或者后置的操作。</p><p>这些操作独立于 Bean 之外，并且会注册到 Spring 容器中，在Spring 容器创建Bean的时候，会进行一些处理。</p><p>具体的一个关系看下图（比较清晰）：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png" alt="image.png"></p><p>你可以理解  <code>InstantiationAwareBeanPostProcessor</code> 接口方法是 作为 实例化阶段的”产前产后护理”；<code>BeanPostProcessor</code> 是 初始化阶段的 “关键调整和增强”。</p><h5 id="源码内容分析（容器级别方法）"><a href="#源码内容分析（容器级别方法）" class="headerlink" title="源码内容分析（容器级别方法）"></a>源码内容分析（容器级别方法）</h5><p>需要去了解Bean的生命周期，这个源码对应的方法是必须去了解和看的。</p><h5 id="InstantiationAwareBeanPostProcessor-接口分析"><a href="#InstantiationAwareBeanPostProcessor-接口分析" class="headerlink" title="InstantiationAwareBeanPostProcessor 接口分析"></a>InstantiationAwareBeanPostProcessor 接口分析</h5><p>查看源码，可以看到 InstantiationAwareBeanPostProcessor 接口是继承  BeanPostProcessor</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">InstantiationAwareBeanPostProcessor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BeanPostProcessor</span><br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractAutowireCapableBeanFactory#createBean</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建Bean实例的方法，接收Bean的名称、RootBeanDefinition（Bean的定义信息）和参数数组</span><br>protected Object createBean(<span class="hljs-keyword">String</span> beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable Object[] args) throws BeanCreationException &#123;</span><br>    <span class="hljs-comment">// 如果启用了跟踪日志，输出创建Bean实例的跟踪信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析Bean的类信息，如果已经有解析过的类信息，使用之前解析得到的类信息</span><br>    RootBeanDefinition mbdToUse = mbd;<br>    Class&lt;?&gt; resolvedClass = <span class="hljs-built_in">this</span>.resolveBeanClass(mbd, beanName, <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 如果解析得到的类信息不为空，且当前Bean的定义信息没有指定类信息，则更新Bean的定义信息</span><br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-type">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 准备处理方法的覆盖，即准备解析方法注解</span><br>        mbdToUse.prepareMethodOverrides();<br>    &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException var9) &#123;<br>        <span class="hljs-comment">// 如果方法注解解析失败，抛出BeanDefinitionStoreException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, var9);<br>    &#125;<br><br>    Object beanInstance;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在实例化Bean之前，尝试调用BeanPostProcessor的beforeInstantiation方法</span><br>        beanInstance = <span class="hljs-built_in">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-comment">// 如果beforeInstantiation方法返回非空，表示已经创建了Bean实例，直接返回该实例</span><br>        <span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> beanInstance;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>        <span class="hljs-comment">// 如果beforeInstantiation方法抛出异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var10);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行真正的Bean创建逻辑，包括实例化、属性注入等过程</span><br>        beanInstance = <span class="hljs-built_in">this</span>.doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">// 如果启用了跟踪日志，输出Bean实例创建完成的跟踪信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 返回创建的Bean实例</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125; <span class="hljs-keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了异常，抛出异常</span><br>        <span class="hljs-keyword">throw</span> var7;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了未捕获的异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, var8);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-工厂后处理器方法"><a href="#2-3-工厂后处理器方法" class="headerlink" title="2.3 工厂后处理器方法"></a>2.3 <strong>工厂后处理器方法</strong></h4><p><strong>BeanFactoryProcessor 一系列接口</strong></p><p>包括 AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor 等。</p><p>这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能</p><blockquote><p>BeanFactoryProcessor 接口 vs  BeanPostProcessor接口</p></blockquote><p><code>BeanFactoryPostProcessor</code> 接口和 <code>BeanPostProcessor</code> 接口都是 Spring 框架中用于定制和扩展 Bean 的关键接口，但它们的作用和时机略有不同。</p><p>BeanFactoryPostProcessor 接口：</p><ol><li><p><strong>作用：</strong> <code>BeanFactoryPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 之前修改或定制 BeanFactory 的配置。</p></li><li><p><strong>时机：</strong> 在 Spring 容器读取了 Bean 的定义（配置元数据）但在实例化任何 Bean 之前，<code>BeanFactoryPostProcessor</code> 接口提供了机会来修改 Bean 的定义，例如修改属性值、添加属性等。</p></li><li><p><strong>实现方法：</strong> 实现 <code>postProcessBeanFactory</code> 方法，该方法传递了 BeanFactory 对象，可以在此方法中修改 BeanFactory 的配置。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">ConfigurableListableBeanFactory</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistryPostProcessor</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistry</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanFactory</span>(<span class="hljs-params">ConfigurableListableBeanFactory beanFactory</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以修改 BeanFactory 的配置</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span>(<span class="hljs-params">BeanDefinitionRegistry registry</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以注册新的 BeanDefinition</span><br>        <span class="hljs-title class_">BeanDefinitionBuilder</span> builder = <span class="hljs-title class_">BeanDefinitionBuilder</span>.<span class="hljs-title function_">genericBeanDefinition</span>(<span class="hljs-title class_">MyBean</span>.<span class="hljs-property">class</span>);<br>        registry.<span class="hljs-title function_">registerBeanDefinition</span>(<span class="hljs-string">&quot;myBean&quot;</span>, builder.<span class="hljs-title function_">getBeanDefinition</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor 接口</p></blockquote><ol><li><p><strong>作用：</strong> <code>BeanPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 后，在 Bean 的初始化前后执行一些自定义的逻辑。</p></li><li><p><strong>时机：</strong> 当 Bean 被实例化后，但在调用其初始化方法（如果有的话）之前，<code>BeanPostProcessor</code> 提供了 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code> 方法用于在初始化阶段进行定制操作。</p></li><li><p><strong>实现方法：</strong> 实现 <code>BeanPostProcessor</code> 接口的两个方法，可以在这两个方法中添加定制逻辑。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">BeanPostProcessor</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之前的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之后的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><code>BeanFactoryPostProcessor</code> 主要用于修改整个 BeanFactory 的配置，它在 Bean 实例化之前执行。</li><li><code>BeanPostProcessor</code> 主要用于在每个 Bean 的初始化阶段添加自定义逻辑，它在 Bean 实例化后，初始化方法调用前后执行。</li></ul><p>在实际应用中，可以同时使用这两个接口来完成更复杂的定制需求。</p><h4 id="2-4-Bean-级生命周期方法"><a href="#2-4-Bean-级生命周期方法" class="headerlink" title="2.4  Bean 级生命周期方法"></a>2.4  <strong>Bean 级生命周期方法</strong></h4><p>关于 Bean 级生命周期方法的理解：</p><ul><li>这些方法提供了针对 Bean 实例的<strong>个性化行为</strong>，允许 Bean 在其生命周期的关键点做出响应。</li></ul><p>通过这些方法，是可以对于某个Bean实例进行个性化操作的。</p><p>可以理解为 Bean 类直接实现接口的方法，比如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等方法，这些方法只对当前 Bean 生效。</p><p>Aware 类型的接口</p><p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。</p><p>基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。</p><h3 id="3、Spring-Bean-详细生命周期"><a href="#3、Spring-Bean-详细生命周期" class="headerlink" title="3、Spring Bean 详细生命周期"></a>3、Spring Bean 详细生命周期</h3><blockquote><p>Bean 的生命周期</p></blockquote><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 set() 方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName() 方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader() 方法，传入 ClassLoader 对象的实例。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory() 方法，传入 BeanFactory 对象的实例。</li><li>与上面的类似，如果实现了其他 * .Aware 接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessBeforeInitialization() 方法</li><li>如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><h3 id="4、Bean-创建流程入口-refresh"><a href="#4、Bean-创建流程入口-refresh" class="headerlink" title="4、Bean 创建流程入口 refresh()"></a>4、Bean 创建流程入口 refresh()</h3><h4 id="相关概念回顾"><a href="#相关概念回顾" class="headerlink" title="相关概念回顾"></a>相关概念回顾</h4><h5 id="Spring上下文"><a href="#Spring上下文" class="headerlink" title="Spring上下文"></a>Spring上下文</h5><p>从代码级别来说，就是指Spring Context</p><p>从源码级别，我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境。</p><h5 id="Spring-初始化操作"><a href="#Spring-初始化操作" class="headerlink" title="Spring 初始化操作"></a>Spring 初始化操作</h5><p>具体操作可以见下#ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用</p><p>使用前需要引入 spring-context 相关的依赖，初始化Bean可以通过注解的方式也可以通过xml的方式。</p><h5 id="BeanFactory-与-ApplicationContext"><a href="#BeanFactory-与-ApplicationContext" class="headerlink" title="BeanFactory  与  ApplicationContext"></a><code>BeanFactory</code>  与  <code>ApplicationContext</code></h5><p>先了解一下  <code>BeanFactory</code> 与  <code>ApplicationContext</code> 接口两个的作用与概念：</p><ul><li><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是Spring Framework的IoC容器的基础。 </li><li><code>BeanFactory</code> 提供了配置框架和基本功能，提供了一种高级配置机制，能够管理任何类型的对象。</li><li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子接口，相比于 <code>BeanFactory</code>  来说，增加了更多的企业特定功能, 是 <code>BeanFactory</code> 的一个完整的超集。</li><li><code>BeanFactory</code> 实现了<strong>延迟</strong>加载（懒加载），只有在请求获取Bean时（例如，通过<code>getBean()</code>方法），容器才会创建该Bean。这意味着如果应用中未使用某个Bean，它就不会被实例化。</li><li><code>ApplicationContext</code>其下管理的 Bean 是<strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li></ul><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。</p><h5 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a><code>AbstractApplicationContext</code></h5><p><code>AbstractApplicationContext</code> 实现了 <code>ApplicationContext</code> 接口，提供了这个接口的大部分通用功能。</p><p>它是实际应用上下文类（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>）的父类</p><p>通过继承和扩展 <code>AbstractApplicationContext</code>，Spring 允许开发者自定义应用上下文的行为，以满足特定的业务需求。</p><h5 id="ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？"><a href="#ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？" class="headerlink" title="ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？"></a>ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？</h5><p>以下是几个典型场景，其中可能会加载并使用 <code>ClassPathXmlApplicationContext</code> 的构造方法：</p><ol><li>Java 应用的主方法 (main)</li></ol><p>在一个标准的 Java 应用程序中，你可以在 <code>main</code> 方法中创建 <code>ClassPathXmlApplicationContext</code> 的实例来启动 Spring 容器。这是最常见的用法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">// 使用 context 获取 Bean 实例...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ClassPathXmlApplicationContext</code> 用于加载名为 “applicationContext.xml” 的配置文件。</p><ol start="2"><li>Web 应用程序</li></ol><p>在基于 Servlet 的传统 Web 应用程序中，可以在 Servlet 的 <code>init</code> 方法中创建 <code>ClassPathXmlApplicationContext</code>，或者使用 Spring 的 <code>ContextLoaderListener</code> 在 Web 应用启动时自动加载 Spring 上下文。</p><ol start="3"><li>单元测试</li></ol><p>在编写 Spring 应用的单元测试时，可以在测试类中创建 <code>ClassPathXmlApplicationContext</code> 来加载所需的 Spring 配置，并进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;testContext.xml&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        <span class="hljs-comment">// 执行测试...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，测试使用了单独的配置文件 “testContext.xml”。</p><ol start="4"><li>Spring Boot 应用</li></ol><p>使用 Spring Boot 时通常不直接使用 <code>ClassPathXmlApplicationContext</code></p><p> Spring Boot 提供了基于注解的配置和自动配置的能力，一般是使用注解配置的方式进行声明Bean操作 ，但在一些旧的或特殊的情况下，可能仍然需要手动加载 XML 配置的方式。</p><hr><h4 id="Bean-创建流程入口"><a href="#Bean-创建流程入口" class="headerlink" title="Bean 创建流程入口"></a>Bean 创建流程入口</h4><p>这里直接跟一下源码看一下相关内容</p><p>下面的代码是从 spring-context-5.2.4.RELEASE 版本中的 AbstractApplicationContext 抽象类下相关方法和内容说明。</p><p>在实际应用上下文类中（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>），他们的构造方法中会调用这个 refresh() 方法类进行初始化 Spring 容器。</p><p>因此可以判断出  Bean 创建流程入口 是定义在 AbstractApplicationContext 抽象类下 refresh() 方法。</p><h5 id="refressh方法"><a href="#refressh方法" class="headerlink" title="refressh方法"></a>refressh方法</h5><p>这里实际看一下相关代码 AbstractApplicationContext#refresh()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void refresh() throws BeansException, IllegalStateException &#123;<br>    <span class="hljs-comment">// 同步锁确保容器刷新时的线程安全</span><br>    synchronized (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br><br>        <span class="hljs-comment">// 准备刷新，设置启动日期和活跃状态等</span><br>        <span class="hljs-keyword">this</span>.prepareRefresh();<br><br>        <span class="hljs-comment">// 获取新的 BeanFactory，初始化 BeanFactory，并加载 Bean 定义</span><br>        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 配置 BeanFactory，设置类加载器、事件处理器等</span><br>        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 允许在 BeanFactory 标准初始化之后进行定制修改</span><br>            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// 调用在容器中注册的 BeanFactoryPostProcessor</span><br>            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 注册 BeanPostProcessor，这些处理器影响所有 Bean 的创建</span><br>            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 初始化 MessageSource 组件，用于国际化处理</span><br>            <span class="hljs-keyword">this</span>.initMessageSource();<br><br>            <span class="hljs-comment">// 初始化 ApplicationEventMulticaster，用于事件广播</span><br>            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 特定于 ApplicationContext 的刷新操作</span><br>            <span class="hljs-keyword">this</span>.onRefresh();<br><br>            <span class="hljs-comment">// 注册监听器到事件广播器</span><br>            <span class="hljs-keyword">this</span>.registerListeners();<br><br>            <span class="hljs-comment">// 初始化所有剩余的非懒加载单例</span><br>            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 完成刷新过程，通知生命周期处理器以及发布相应的事件</span><br>            <span class="hljs-keyword">this</span>.finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;<br>            <span class="hljs-comment">// 在上下文初始化过程中捕获并处理异常</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);<br>            &#125;<br><br>            <span class="hljs-comment">// 销毁已创建的 Bean，以防有些 Bean 已经初始化了，但后续的初始化过程失败了</span><br>            <span class="hljs-keyword">this</span>.destroyBeans();<br><br>            <span class="hljs-comment">// 取消刷新操作，重置上下文的同步标志</span><br>            <span class="hljs-keyword">this</span>.cancelRefresh(var9);<br><br>            <span class="hljs-comment">// 重新抛出异常，通知外部调用者</span><br>            <span class="hljs-keyword">throw</span> var9;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 重置公共缓存（例如 Reflection 缓存）</span><br>            <span class="hljs-keyword">this</span>.resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>可以看到初始化单例这步操作是在 this.finishBeanFactoryInitialization(beanFactory); 这里进行的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 BeanFactory 包含名为 &quot;conversionService&quot; 的 Bean，并且这个 Bean 适配于 ConversionService 类型</span><br>    <span class="hljs-keyword">if</span> (beanFactory.<span class="hljs-built_in">containsBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>) &amp;&amp; beanFactory.<span class="hljs-built_in">isTypeMatch</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>)) &#123;<br>        <span class="hljs-comment">// 将这个 Bean 设置为容器的 ConversionService</span><br>        beanFactory.<span class="hljs-built_in">setConversionService</span>((ConversionService)beanFactory.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 BeanFactory 还没有嵌入的值解析器</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.<span class="hljs-built_in">hasEmbeddedValueResolver</span>()) &#123;<br>        <span class="hljs-comment">// 添加一个嵌入的值解析器，用于解析占位符</span><br>        beanFactory.<span class="hljs-built_in">addEmbeddedValueResolver</span>(strVal -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getEnvironment</span>().<span class="hljs-built_in">resolvePlaceholders</span>(strVal);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有实现 LoadTimeWeaverAware 接口的 Bean 的名称</span><br>    <span class="hljs-type">String</span>[] weaverAwareNames = beanFactory.<span class="hljs-built_in">getBeanNamesForType</span>(LoadTimeWeaverAware.<span class="hljs-keyword">class</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 遍历这些 Bean 名称</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> weaverAwareName : weaverAwareNames) &#123;<br>        <span class="hljs-comment">// 初始化相应的 Bean，以确保它们能够执行加载时织入（Load Time Weaving）的相关逻辑</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getBean</span>(weaverAwareName);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 BeanFactory 的临时类加载器设置为 null</span><br>    beanFactory.<span class="hljs-built_in">setTempClassLoader</span>(null);<br><br>    <span class="hljs-comment">// 冻结所有的 Bean 定义，表示注册的 Bean 定义将不再被修改或任何进一步的处理</span><br>    beanFactory.<span class="hljs-built_in">freezeConfiguration</span>();<br><br>    <span class="hljs-comment">// 预实例化单例，确保所有非懒加载的单例都被实例化</span><br>    beanFactory.<span class="hljs-built_in">preInstantiateSingletons</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实例化 Instantiation</p></blockquote><p>其中第一阶段 —— 实例化 Instantiation，</p><p>Bean 实例化的时机分为两种，一种是 BeanFactory，还有一种是  ApplicationContext；</p><p>下面是两者差别：</p><ul><li>BeanFactory<ul><li>其下管理的Bean <strong>在使用到Bean的时候</strong> 才会进行实例化Bean操作（懒加载策略）</li></ul></li><li>ApplicationContext  <ul><li>其下管理的 Bean <strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li><li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，复杂程度更高一些。</li><li>如<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>等，提供了多种方便的方式来创建ApplicationContext实例</li></ul></li></ul><hr><p>视频地址：  <a href="https://www.bilibili.com/video/BV1584y1r7n6/">https://www.bilibili.com/video/BV1584y1r7n6/</a></p><h4 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231218215844.png" alt="image.png"></p><p>生产 →  使用  →  销毁</p><h5 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h5><p>启动，准备容器&#x2F;环境等</p><p>① 加载 Bean 定义（BeanDefinitions)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">加载Bean定义<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>通过 loadBeanDefinitions 扫描所有xml配置、注解将Bean记录在 Bean定义集合 beanDefinitionMap 中</p><p>②创建 Bean 对象（createBean)</p><p>遍历“Bean定义”集合</p><p>通过 createBean 遍历 beanDefinitionMap 创建bean</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">创建Bean<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">preInstantiateSingletioins</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">doGetBean</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">createBean</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><blockquote><p>2.1.构造对象</p></blockquote><p>通过 createBeanInstance 方法进行对象的构造</p><p>使用反射机制从“Bean定义”中的BeanClass拿到类的构造方法</p><p>准备参数：在单例池中，根据参数的Class类进行查找</p><p>构造对象：通过反射进行Bean的构造（如果是无参则无需准备参数直接构造）</p><hr><p>查找Class类<br>    当匹配到多个实例，<br>    会再根据参数名进行匹配</p><blockquote><p>2.2.填充属性</p></blockquote><p>通过 populateBean 方法对 Bean 内部所需属性进行属性填充, 通常是 @Autowired 注解的变量</p><p>三级缓存进行依赖注入</p><blockquote><p>2.3.初始化实例</p></blockquote><p>通过 initializeBean 方法对实例进行初始化</p><p>初始化操作：</p><ol><li>初始化容器相关信息<br>通过 invokeAwareMethods 方法为实现各种 Aware 接口的Bean设置诸如 beanName, beanFactory 等容器信息<br>Aware 接口指代：信息感知接口</li><li>通过 invokeInitMethods 方法执行 Bean 的初始化方法</li></ol><p>该 invokeInitMethods 方法是通过实现 InitializingBean 接口而实现的 afterPropertiesSet 方法<br>【Bean填充属性后执行】  ((InitializingBean)bean).afterPropertiesSet()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">afterPropertiesSet <br><br>↓ <br><br><span class="hljs-keyword">init</span>-Methods<br><br>↓<br><br>BeanPostProcessors<br></code></pre></td></tr></table></figure><hr><h5 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h5><p>销毁操作<br>销毁前<br>    销毁之前会执行 postProcessBeforeDestruction “销毁前处理器“，这步会执行 Bean 中 @PreDestroy 注解的方法<br>容器销毁<br>    后续通过 destoryBeans 方法逐一“销毁”容器中的Bean，销毁的时候会执行 destroy 方法（通过registerDisposableBean方法注册的Bean，该接口只有一个方法 destroy。在Bean销毁的时候，Spring容器会调用这个方法。）<br>Bean自定义销毁方法<br>    “客户销毁方法”invokeCustomDestroyMethod; →  执行Bean上自定义的 destoryMethod 方法</p><h3 id="5、Spring-Bean-生命周期流程图"><a href="#5、Spring-Bean-生命周期流程图" class="headerlink" title="5、Spring Bean 生命周期流程图"></a>5、<strong>Spring Bean 生命周期流程图</strong></h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312160247944.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html">https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html</a></li><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://www.bilibili.com/video/BV1584y1r7n6">https://www.bilibili.com/video/BV1584y1r7n6</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li><li><a href="https://blog.csdn.net/qq_20021569/article/details/109178816">https://blog.csdn.net/qq_20021569/article/details/109178816</a></li><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></li><li><a href="https://cloud.tencent.com/developer/article/2216932">https://cloud.tencent.com/developer/article/2216932</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_性能优化</title>
    <link href="/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <url>/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>性能优化参考： <a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a></p><p>规范</p><p>略</p><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html">https://javaguide.cn/database/mysql/mysql-high-performance-optimization-specification-recommendations.html</a></li><li><a href="https://mp.weixin.qq.com/s/NM-aHaW6TXrnO6la6Jfl5A">https://mp.weixin.qq.com/s/NM-aHaW6TXrnO6la6Jfl5A</a></li><li><a href="https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q">https://mp.weixin.qq.com/s/XC8e5iuQtfsrEOERffEZ-Q</a></li><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">https://javaguide.cn/database/mysql/mysql-questions-01.html#mysql-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的作用域</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>复习概念</p></blockquote><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些"></a>Spring 中的 bean 的作用域有哪些</h3><p>这个问题是面试题场景的一个问题，我们首先来看一下基本的一个回答。</p><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><blockquote><p>如何配置 bean 的作用域</p></blockquote><p>xml 方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public Person <span class="hljs-built_in">personPrototype</span>() &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>具体怎么配置的看你实际使用，这里大概讲一下使用场景，通过不同场景下的使用示例对 Spring 中 Bean 的作用域有一个基本认知。</p><h4 id="Singleton-Bean（默认作用域）"><a href="#Singleton-Bean（默认作用域）" class="headerlink" title="Singleton Bean（默认作用域）"></a>Singleton Bean（默认作用域）</h4><p><strong>场景</strong>: 在一个在线书店应用中，有一个库存管理服务负责跟踪所有书籍的库存。这个服务需要是单例的，因为它维护着整个应用中书籍库存的统一视图。</p><p>代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; bookInventory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(String isbn, <span class="hljs-type">int</span> quantity)</span> &#123;<br>        bookInventory.put(isbn, bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) + quantity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkStock</span><span class="hljs-params">(String isbn)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他与库存管理相关的方法 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>InventoryService</code> 是一个singleton作用域的Bean，它在应用的整个生命周期内只会有一个实例。</p><p>所有对书籍库存的操作都通过这个单一实例进行，确保了库存数据的一致性。</p><h4 id="Prototype作用域"><a href="#Prototype作用域" class="headerlink" title="Prototype作用域"></a>Prototype作用域</h4><p><strong>场景</strong>: 在同一在线书店应用中，当用户想要购买书籍时，每个购物车都应该是独立的。因此，每个用户的购物车应该有其自己的状态。</p><p>代码逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Scope</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Component</span>;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> isbn</span>) &#123;<br>        items.<span class="hljs-title function_">put</span>(isbn, items.<span class="hljs-title function_">getOrDefault</span>(isbn, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">getItems</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> items;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 购物车的其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApplicationContext</span> context;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ShoppingCart</span> <span class="hljs-title function_">createNewShoppingCart</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">ShoppingCart</span>.<span class="hljs-property">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ShoppingService</code> 使用Spring的应用上下文来为每个用户创建一个新的<code>ShoppingCart</code>实例。</p><p>每次调用<code>createNewShoppingCart</code>方法时，都会返回一个全新的购物车实例，保证了用户之间购物车的隔离。</p><h4 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h4><p><strong>场景</strong>: 在一个新闻网站应用中，你需要跟踪每个HTTP请求的访问信息，例如用户的地理位置和设备类型，以便为他们提供定制化的新闻内容。</p><p>代码逻辑</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.springframework.web.context.annotation.RequestScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequestScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> location;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> deviceType;<br><br>    <span class="hljs-keyword">public</span> UserContext(HttpServletRequest request) &#123;<br>        <span class="hljs-comment">// 通过请求获取用户的位置和设备类型</span><br>        <span class="hljs-built_in">this</span>.location = request.getHeader(<span class="hljs-string">&quot;Location&quot;</span>);<br>        <span class="hljs-built_in">this</span>.deviceType = request.getHeader(<span class="hljs-string">&quot;Device-Type&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation() &#123;<br>        <span class="hljs-keyword">return</span> location;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getDeviceType() &#123;<br>        <span class="hljs-keyword">return</span> deviceType;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserContext userContext;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/news&quot;</span>)<br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;NewsItem&gt;&gt; getNews() &#123;<br>        List&lt;NewsItem&gt; <span class="hljs-keyword">new</span><span class="hljs-type">s</span> = <span class="hljs-keyword">new</span><span class="hljs-type">sService</span>.getNewsForLocation(userContext.getLocation());<br>        <span class="hljs-comment">// 返回定制化的新闻内容</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>UserContext</code>是一个request作用域的Bean，它为每个HTTP请求提供了一个新实例，</p><p>包含了请求特定的用户上下文信息，如位置和设备类型。</p><h4 id="Session作用域"><a href="#Session作用域" class="headerlink" title="Session作用域"></a>Session作用域</h4><p><strong>场景</strong>: 在一个在线考试平台上，每个用户的考试过程需要被追踪。用户可能会在考试中断后返回继续考试，所以考试状态需要在会话中保持。</p><p>代码逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.web.context.<span class="hljs-keyword">annotation</span>.SessionScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@SessionScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamSession</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Exam currentExam;<br>    <span class="hljs-keyword">private</span> int currentQuestionIndex;<br><br>    <span class="hljs-comment">// 考试会话的方法，例如开始考试、回答问题等</span><br>&#125;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ExamSession examSession;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/start&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String startExam() &#123;<br>        examSession.startNewExam();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;exam_started&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/answer&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String answerQuestion(Answer answer) &#123;<br>        examSession.answerQuestion(answer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;answer_recorded&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ExamSession</code> 是一个session作用域的Bean，它记录了用户的当前考试状态。每个用户会话都有自己的<code>ExamSession</code>实例。</p><blockquote><p>Session vs Global-Session vs WebSocket</p></blockquote><ol><li><strong>Session</strong>:<ul><li><strong>作用域</strong>: 限定在一个用户的HTTP会话中。</li><li><strong>典型用例</strong>: 在用户登录到网站后，你可能需要跟踪该用户的特定状态（比如购物车、偏好设置等）。这种情况下，每个用户都有自己的会话，每个会话都有自己的Bean实例。</li></ul></li><li><strong>Global-Session</strong>:<ul><li><strong>作用域</strong>: 限定在Portlet环境的全局HTTP会话中。在Spring 5及之后的版本中已不再使用，因为Spring 5不再支持Portlet。</li><li><strong>典型用例</strong>: 在Portlet环境中，多个Portlet可能需要共享全局会话数据。例如，用户的语言偏好可能需要跨多个Portlet保持一致。</li></ul></li><li><strong>WebSocket</strong>:<ul><li><strong>作用域</strong>: 绑定到WebSocket的会话中。</li><li><strong>典型用例</strong>: 当用户通过WebSocket连接到你的服务器时，你可能需要为每个WebSocket会话保存状态，例如游戏中的玩家状态或聊天应用中的用户会话</li></ul></li></ol><h4 id="Singleton-vs-Prototype"><a href="#Singleton-vs-Prototype" class="headerlink" title="Singleton vs Prototype"></a>Singleton vs Prototype</h4><blockquote><p>Singleton vs Prototype</p></blockquote><ol><li><strong>Singleton</strong>:<ul><li><strong>描述</strong>: 在Spring IoC容器中只创建一个Bean实例。</li><li><strong>典型用例</strong>: 大多数服务层和数据访问层的组件都是无状态的，可以被应用中的所有其他Bean共享。例如，数据库连接池、业务服务等。</li></ul></li><li><strong>Prototype</strong>:<ul><li><strong>描述</strong>: 每次请求时，Spring IoC容器都会创建一个新的Bean实例。</li><li><strong>典型用例</strong>: 比如在一个应用中，你想要为每个文件上传创建一个新的处理器（FileUploadHandler）实例，以防不同用户上传的数据相互冲突。</li></ul></li></ol><p>两种作用域的使用主要取决于Bean的状态管理需求。</p><p>Singleton用于那些不需要维护状态信息的共享组件，而Prototype适用于每次使用都需要一个新状态的场景。</p><blockquote><p>Singleton vs Prototype   对比两者的生命周期区别</p></blockquote><p>单例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 只有一个Bean实例被创建。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 如果Bean实现了<code>InitializingBean</code>接口或定义了自定义的初始化方法（如使用<code>@PostConstruct</code>注解或在XML配置中指定<code>init-method</code>），将会执行。</li><li><strong>后处理</strong>: <code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean现在可以被应用中的其他Bean使用。</li><li><strong>销毁</strong>: 当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口或定义了自定义的销毁方法（如使用<code>@PreDestroy</code>注解或在XML配置中指定<code>destroy-method</code>），将会执行。</li></ol><p>多例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 每次请求时都创建一个新的Bean实例。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 与单例Bean相同，如果有指定的初始化方法，将会执行。</li><li><strong>后处理</strong>: 与单例Bean相同，<code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean被客户端获取并使用。</li><li><strong>销毁</strong>: 容器不会管理多例Bean的完整生命周期；销毁由客户端负责。</li></ol><p>区别：</p><ul><li><strong>实例化频率</strong>:<ul><li><strong>单例</strong>: 只在Spring IoC容器创建时实例化一次。</li><li><strong>多例</strong>: 每次请求时实例化。</li></ul></li><li><strong>依赖注入时机</strong>:<ul><li><strong>单例</strong>: 依赖项在容器创建单例Bean时注入。</li><li><strong>多例</strong>: 依赖项在每次创建新实例时注入。</li></ul></li><li><strong>生命周期管理</strong>:<ul><li><strong>单例</strong>: 容器负责整个生命周期，包括销毁。</li><li><strong>多例</strong>: 容器启动后，不再管理Bean的生命周期；Bean的销毁不由Spring容器管理，需要用户手动管理。</li></ul></li><li><strong>销毁回调</strong>:<ul><li><strong>单例</strong>: 容器关闭时，可以调用销毁方法。</li><li><strong>多例</strong>: 容器不自动调用销毁方法，必须由获取Bean的客户端代码来处理。</li></ul></li></ul><p>在实际应用中，单例Bean通常用于无状态的服务，例如业务逻辑组件和数据访问对象。</p><p>而多例Bean则用于有明确状态的操作，这些状态不能共享给其他实例或线程，例如用户的会话或独立的任务处理器。</p><p>多例Bean 的销毁操作有兴趣可以了解一下： <a href="https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype">https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype</a></p><blockquote><p>为了让Spring容器释放由 prototype scopeBean 持有的资源，可以尝试使用自定义 <a href="https://springdoc.cn/spring/core.html#beans-factory-extension-bpp">Bean后处理器</a>，它持有对需要清理的Bean的引用。</p></blockquote><hr><p>参考</p><ul><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B">Spring常见面试题总结 | JavaGuide(Java面试 + 学习指南)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_IOC</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、IOC是什么"><a href="#1、IOC是什么" class="headerlink" title="1、IOC是什么"></a>1、IOC是什么</h3><p>IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p><p>IOC （Inversion of Control ）指的是控制反转&#x2F;反转控制。</p><blockquote><p>IOC 理论说明</p></blockquote><p>例如：现有类 A 依赖于类 B</p><ul><li>在传统的开发方式中，往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li>使用IOC思想的开发方式：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面获取。</li></ul><p>控制反转主要指的是将对象的创建和对象之间的关系维护交给IOC容器去管理，而不是由程序员手动进行管理。在传统的应用中，对象的创建通常是由程序员通过<code>new</code>关键字来完成的，而对象之间的关系也需要由程序员进行硬编码。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312051438413.png" alt="image.png"></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li></ul><blockquote><p>IOC 和 DI  的关系</p></blockquote><p>其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p><div style="background-color: #3498db; color: white; padding: 10px;">    IoC是设计思想，DI是实现方式。</div><hr><blockquote><p>IOC 容器</p></blockquote><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="2、IOC-配置的三种方式"><a href="#2、IOC-配置的三种方式" class="headerlink" title="2、IOC 配置的三种方式"></a>2、IOC 配置的三种方式</h3><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    主流方式是 注解 + Java 配置.</div><p>Spring框架提供了三种主要的IoC配置方式：XML配置、注解配置和Java配置。开发者可以选择其中一种或混合使用这些方式，来声明对象的依赖关系和配置信息。</p><p>Spring容器会根据这些配置信息，自动扫描并加载所需的对象，实现对象的创建、装配和管理。</p><h4 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h4><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p><p>这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><ul><li><strong>优点</strong>： 可以使用于任何场景，结构清晰，通俗易懂</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><p><strong>举例</strong>：</p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。</p><p>其本质上就是把在XML上的配置声明转移到Java配置类中</p><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><p><strong>举例</strong>：</p><ol><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">pdai</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user dao</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userDao&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-title function_">userDao</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user service</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userService&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">UserServiceImpl</span> userService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.<span class="hljs-title function_">setUserDao</span>(<span class="hljs-title function_">userDao</span>());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><p><strong>举例</strong>：</p><ol><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author pdai</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user dao impl.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return user list</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; findUserList() &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3、依赖注入的三种方式"><a href="#3、依赖注入的三种方式" class="headerlink" title="3、依赖注入的三种方式"></a>3、依赖注入的三种方式</h3><p>参考看一下这个： <a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></p><p>依赖注入有三种主要的实现方式：属性注入、Setter注入和构造方法注入。</p><p>属性注入最简单，但通用性较差。Spring官方推荐使用构造方法注入，因为它支持注入不可变对象，通用性更强。对于可变对象，可以考虑使用Setter注入。</p><p><strong>代码示例</strong></p><blockquote><ol><li>属性注入（Field Injection）</li></ol></blockquote><p><strong>属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式</strong>(直接在类的字段上注入依赖)</p><p>这种方式在某些场景下很方便，但可能会导致难以测试和难以维护的代码，因为它隐藏了类的依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class MyService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private DependencyClass dependency;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-variable">@Component</span><br>public class DependencyClass &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优点是简单易用，缺点也随之而来</p><ol><li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li><li>通用性问题：只能适应于 IoC 容器；</li><li>设计原则问题：更容易违背单一设计原则。</li></ol><blockquote><ol start="2"><li>Setter注入（Setter Injection）</li></ol></blockquote><p>在Setter注入中，Spring通过调用类的setter方法来注入依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> void setDependency(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>setter 的方式可能会麻烦一点，不过他是完全符合单一职责的设计原则，每一个 Setter 只针对一个对象。</p><p>缺点：</p><ol><li>不能注入不可变对象（final 修饰的对象）；</li><li>注入的对象可被修改</li></ol><blockquote><ol start="3"><li>构造方法注入（Constructor Injection）</li></ol></blockquote><p>这种方式通过类的构造方法来注入依赖。这是最推荐的方式，因为它可以确保所需的依赖项在对象创建时即被提供，从而保证了对象的不变性和依赖的不可更改性。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyService</code> 类依赖于 <code>DependencyClass</code>。</p><p>当Spring创建 <code>MyService</code> 的实例时，它会查找 <code>DependencyClass</code> 的实例并通过构造方法注入它。</p><p>从Spring 4.3开始，当一个类只有一个构造函数时，<code>@Autowired</code> 注解是可选的(可以省略）。Spring会自动将这个唯一的构造函数用作依赖注入的入口。</p><p>上面的代码可以简化为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法符合“约定优于配置”的原则，减少了不必要的注解使用。</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html</a></li><li><a href="https://www.martinfowler.com/articles/injection.html">https://www.martinfowler.com/articles/injection.html</a></li><li><a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">https://www.iteye.com/blog/jinnianshilongnian-1413846</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F</a></li><li><a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day04</title>
    <link href="/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/"/>
    <url>/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/</url>
    
    <content type="html"><![CDATA[<p>继续讲述蘑菇博客里面一些写法的使用说明</p><p>解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AvoidRepeatableCommit</span>  <br><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@OperationLogger</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>)  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>, notes = <span class="hljs-string">&quot;增加博客&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/add&quot;</span>)  <br>public String <span class="hljs-built_in">add</span>(<span class="hljs-variable">@Validated</span>(&#123;Insert.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-comment">// 参数校验  </span><br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">blogService</span><span class="hljs-selector-class">.addBlog</span>(blogVO);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解AvoidRepeatableCommit的使用"><a href="#1、自定义注解AvoidRepeatableCommit的使用" class="headerlink" title="1、自定义注解AvoidRepeatableCommit的使用"></a>1、自定义注解<code>AvoidRepeatableCommit</code>的使用</h3><p><code>@AvoidRepeatableCommit</code> 注解用于防止用户在指定时间内重复提交表单或请求。</p><p>与Spring AOP（面向切面编程）一起使用，以便在方法执行之前执行某些预处理操作。</p><blockquote><p>自定义注解 AvoidRepeatableCommit</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-variable">@interface</span> AvoidRepeatableCommit &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定时间内不可重复提交,单位毫秒，默认1秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-selector-tag">long</span> <span class="hljs-selector-tag">timeout</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表明这个注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表明这个注解在运行时保留，可以通过反射读取。</li><li><code>timeout()</code>: 注解的属性，表示不允许重复提交的时间窗口，默认为1000毫秒（1秒）。</li></ul><p>使用场景：在Spring MVC的控制器方法上使用此注解，防止用户在短时间内重复提交相同的请求</p><blockquote><p>AvoidRepeatableCommitAspect 切面</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AvoidRepeatableCommitAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于处理带有 <span class="hljs-doctag">@AvoidRepeatableCommit</span> 注解的方法。</span><br><span class="hljs-comment">     * 防止同一个用户在指定时间内重复提交相同的请求。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点，提供对连接点的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行的返回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(com.moxi.mogublog.admin.annotion.AvoidRepeatableCommit.AvoidRepeatableCommit)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br>        <span class="hljs-comment">// 获取请求者的IP地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br><br>        <span class="hljs-comment">// 获取注解标记的方法</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br>        <span class="hljs-comment">// 获取类名和方法名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipKey</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s#%s&quot;</span>, className, methodName);<br><br>        <span class="hljs-comment">// 生成基于IP和方法的唯一标识</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> Math.abs(ipKey.hashCode());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s:%s_%d&quot;</span>, RedisConf.AVOID_REPEATABLE_COMMIT, ip, hashCode);<br>        log.info(<span class="hljs-string">&quot;ipKey=&#123;&#125;, hashCode=&#123;&#125;, key=&#123;&#125;&quot;</span>, ipKey, hashCode, key);<br><br>        <span class="hljs-type">AvoidRepeatableCommit</span> <span class="hljs-variable">avoidRepeatableCommit</span> <span class="hljs-operator">=</span> method.getAnnotation(AvoidRepeatableCommit.class);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> avoidRepeatableCommit.timeout();<br><br>        <span class="hljs-comment">// 检查Redis中是否已存在该请求的标记</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisUtil.get(key);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(value)) &#123;<br>            log.info(<span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>            <span class="hljs-keyword">return</span> ResultUtil.result(SysConf.ERROR, <span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置Redis标记以防止在timeout时间内重复提交</span><br>        redisUtil.setEx(key, StringUtils.getUUID(), timeout, TimeUnit.MILLISECONDS);<br><br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Around(&quot;@annotation(...AvoidRepeatableCommit)&quot;)</code>: 表明这个切面的方法会在所有标记有 <code>@AvoidRepeatableCommit</code> 注解的方法之前执行。</li><li>切面的实现逻辑是：首先检查Redis中是否已经存储了针对该请求的标记。如果存在，表示该请求在指定时间内已经提交过，因此拒绝重复提交。如果不存在，允许执行方法，并在Redis中设置一个标记，以防止在指定时间内的重复提交。</li></ul><p>在这个方法中：</p><ol><li>首先，它获取当前请求的 <code>HttpServletRequest</code> 对象，并从中提取请求者的IP地址。</li><li>然后，它获取了被 <code>@AvoidRepeatableCommit</code> 注解的方法的信息，包括类名和方法名，并生成一个基于这些信息和IP地址的唯一标识。</li><li>接着，它检查Redis缓存中是否已经存在这个请求的标记。如果存在，表示在指定的时间窗口内该请求已经提交过，因此返回一个错误信息，防止重复处理相同的请求。</li><li>如果不存在，则将该请求的标记存储到Redis中，并设置过期时间为注解中指定的 <code>timeout</code>。这样，如果在 <code>timeout</code> 时间内再次收到相同的请求，就会被拦截。</li><li>最后，它执行原来标记了 <code>@AvoidRepeatableCommit</code> 注解的方法。</li></ol><p>通过这种方式，<code>AvoidRepeatableCommitAspect</code> 切面有效地防止了在短时间内对同一方法的重复调用，特别是对于防止表单的重复提交非常有效。</p><h3 id="2、自定义注解-OperationLogger-的使用"><a href="#2、自定义注解-OperationLogger-的使用" class="headerlink" title="2、自定义注解 OperationLogger 的使用"></a>2、自定义注解 <code>OperationLogger</code> 的使用</h3><p><code>@OperationLogger</code> 是一个自定义注解，用于记录操作日志。结合Spring AOP，在方法执行前后添加日志记录的逻辑。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Target</span>(ElementType.METHOD)<br><span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-keyword">@interface</span> OperationLogger &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务名称。</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-built_in">value</span>() default &quot;&quot;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 平台</span><br><span class="hljs-comment">     */</span><br>    PlatformEnum <span class="hljs-built_in">platform</span>() default PlatformEnum<span class="hljs-selector-class">.ADMIN</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否将当前日志记录到数据库中。</span><br><span class="hljs-comment">     */</span><br>    boolean <span class="hljs-built_in">save</span>() default true;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表示该注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表示该注解在运行时有效，可以通过反射获取。</li><li><code>value()</code>: 提供业务名称，默认为空。</li><li><code>platform()</code>: 指定操作发生的平台，默认为 <code>ADMIN</code>。</li><li><code>save()</code>: 指示是否将日志记录保存到数据库，默认为 <code>true</code>。</li></ul><h4 id="LoggerAspect"><a href="#LoggerAspect" class="headerlink" title="LoggerAspect"></a>LoggerAspect</h4><p><code>LoggerAspect</code> 是一个切面类，用于处理带有 <code>@OperationLogger</code> 注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间，用于计算方法执行时长</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date startTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义切点，匹配带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(OperationLogger operationLogger)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于在方法执行前后添加日志记录逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, OperationLogger operationLogger)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 日志收集</span><br>            handle(joinPoint);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;日志记录出错!&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志处理逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.getMethod(point);<br>        <span class="hljs-type">OperationLogger</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(OperationLogger.class);<br><br>        <span class="hljs-comment">// 判断是否需要保存日志</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> annotation.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(point.getArgs(), annotation.value());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ua</span> <span class="hljs-operator">=</span> RequestUtil.getUa();<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; | &#123;&#125; - &#123;&#125; &#123;&#125; - &#123;&#125;&quot;</span>, bussinessName, IpUtils.getIpAddr(request), RequestUtil.getMethod(), RequestUtil.getRequestUrl(), ua);<br><br>        <span class="hljs-keyword">if</span> (!save) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取参数名称和值</span><br>        Map&lt;String, Object&gt; nameAndArgsMap = AopUtils.getFieldsName(point);<br>        <span class="hljs-type">SecurityUser</span> <span class="hljs-variable">securityUser</span> <span class="hljs-operator">=</span> (SecurityUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramsJson</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(nameAndArgsMap);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> request.getMethod();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 异步存储日志</span><br>        threadPoolTaskExecutor.execute(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLogHandle</span>(ip, type, url, securityUser, paramsJson, point.getTarget().getClass().getName(),<br>                        point.getSignature().getName(), bussinessName, startTime, redisUtil));<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在执行带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法时抛出异常后执行的通知。</span><br><span class="hljs-comment"> * 用于记录异常信息和相关操作日志。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> joinPoint 连接点，提供对目标方法的访问</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operationLogger 操作日志的自定义注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e 抛出的异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AfterThrowing(value = &quot;pointcut(operationLogger)&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, OperationLogger operationLogger, Throwable e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">// 创建一个异常日志对象</span><br><span class="hljs-type">ExceptionLog</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionLog</span>();<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br><span class="hljs-comment">// 获取请求IP地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>exception.setIp(ip);<br><br><span class="hljs-comment">// 解析操作名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">operationName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(joinPoint.getArgs(), operationLogger.value());<br><br><span class="hljs-comment">// 尝试从Redis中获取IP来源信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonResult</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip);<br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(jsonResult)) &#123;<br><span class="hljs-comment">// 如果Redis中没有IP来源信息，则查询并保存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">addresses</span> <span class="hljs-operator">=</span> IpUtils.getAddresses(SysConf.IP + SysConf.EQUAL_TO + ip, SysConf.UTF_8);<br><span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(addresses)) &#123;<br>exception.setIpSource(addresses);<br>redisUtil.setEx(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip, addresses, <span class="hljs-number">24</span>, TimeUnit.HOURS);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果Redis中已有IP来源信息，直接使用</span><br>exception.setIpSource(jsonResult);<br>&#125;<br><br><span class="hljs-comment">// 设置异常日志的其他信息</span><br>exception.setIp(ip);<br>exception.setMethod(joinPoint.getSignature().getName());<br>exception.setExceptionJson(JSON.toJSONString(e,<br>SerializerFeature.DisableCircularReferenceDetect,<br>SerializerFeature.WriteMapNullValue));<br>exception.setExceptionMessage(e.getMessage());<br>exception.setOperation(operationName);<br>exception.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>exception.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><span class="hljs-comment">// 将异常日志保存到数据库</span><br>exception.insert();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SysLogHandle-类"><a href="#SysLogHandle-类" class="headerlink" title="SysLogHandle 类"></a><code>SysLogHandle</code> 类</h4><p><code>SysLogHandle</code> 是一个Runnable实现，用于异步记录日志信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysLogHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractRequestAwareRunnable</span> &#123;<br><br>    <span class="hljs-comment">// Redis工具类，用于操作Redis</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RedisUtil</span> redisUtil;<br><br>    <span class="hljs-comment">// 请求的参数列表，以JSON字符串格式保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> paramsJson;<br><br>    <span class="hljs-comment">// 被调用的类的完整路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> classPath;<br><br>    <span class="hljs-comment">// 被调用的方法名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> methodName;<br><br>    <span class="hljs-comment">// 方法请求的开始时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Date</span> startTime;<br><br>    <span class="hljs-comment">// 操作名称，通常从注解中获取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> operationName;<br><br>    <span class="hljs-comment">// 请求的IP地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> ip;<br><br>    <span class="hljs-comment">// 请求类型（如GET、POST）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>;<br><br>    <span class="hljs-comment">// 请求的URL</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> requestUrl;<br><br>    <span class="hljs-comment">// 当前操作的安全用户信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">SecurityUser</span> securityUser;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，初始化日志处理所需的各种参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip           请求的IP地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type         请求类型（如GET、POST）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestUrl   请求的URL</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> securityUser 当前操作的安全用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> paramsJson   请求的参数列表（JSON格式）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> classPath    被调用的类的完整路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodName   被调用的方法名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationName 操作名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startTime    方法请求的开始时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisUtil    Redis工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">SysLogHandle</span>(<span class="hljs-title class_">String</span> ip, <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>, <span class="hljs-title class_">String</span> requestUrl, <span class="hljs-title class_">SecurityUser</span> securityUser,<br>                        <span class="hljs-title class_">String</span> paramsJson, <span class="hljs-title class_">String</span> classPath,<br>                        <span class="hljs-title class_">String</span> methodName, <span class="hljs-title class_">String</span> operationName,<br>                        <span class="hljs-title class_">Date</span> startTime, <span class="hljs-title class_">RedisUtil</span> redisUtil) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ip</span> = ip;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestUrl</span> = requestUrl;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">securityUser</span> = securityUser;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">paramsJson</span> = paramsJson;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">classPath</span> = classPath;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = methodName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">operationName</span> = operationName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = startTime;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisUtil</span> = redisUtil;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行日志记录的逻辑。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onRun</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">SysLog</span> sysLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLog</span>();<br><br>        <span class="hljs-comment">// 从Redis中获取IP来源信息</span><br>        <span class="hljs-title class_">String</span> jsonResult = redisUtil.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isEmpty</span>(jsonResult)) &#123;<br>            <span class="hljs-title class_">String</span> addresses = <span class="hljs-title class_">IpUtils</span>.<span class="hljs-title function_">getAddresses</span>(<span class="hljs-title class_">SysConf</span>.<span class="hljs-property">IP</span> + <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">EQUAL_TO</span> + ip, <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">UTF_8</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotEmpty</span>(addresses)) &#123;<br>                sysLog.<span class="hljs-title function_">setIpSource</span>(addresses);<br>                redisUtil.<span class="hljs-title function_">setEx</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip, addresses, <span class="hljs-number">24</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">HOURS</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sysLog.<span class="hljs-title function_">setIpSource</span>(jsonResult);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置日志的其他属性</span><br>        sysLog.<span class="hljs-title function_">setIp</span>(ip);<br>        sysLog.<span class="hljs-title function_">setClassPath</span>(classPath);<br>        sysLog.<span class="hljs-title function_">setMethod</span>(methodName);<br>        sysLog.<span class="hljs-title function_">setType</span>(<span class="hljs-keyword">type</span>);<br>        sysLog.<span class="hljs-title function_">setUrl</span>(requestUrl);<br>        sysLog.<span class="hljs-title function_">setOperation</span>(operationName);<br>        sysLog.<span class="hljs-title function_">setCreateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUserName</span>(securityUser.<span class="hljs-title function_">getUsername</span>());<br>        sysLog.<span class="hljs-title function_">setAdminUid</span>(securityUser.<span class="hljs-title function_">getUid</span>());<br>        sysLog.<span class="hljs-title function_">setParams</span>(paramsJson);<br><br>        <span class="hljs-comment">// 计算并设置请求耗时</span><br>        <span class="hljs-title class_">Date</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-title class_">Long</span> spendTime = <span class="hljs-title class_">DateUtil</span>.<span class="hljs-title function_">between</span>(startTime, endTime, <span class="hljs-title class_">DateUnit</span>.<span class="hljs-property">MS</span>);<br>        sysLog.<span class="hljs-title function_">setSpendTime</span>(spendTime);<br><br>        <span class="hljs-comment">// 将日志信息保存到数据库</span><br>        sysLog.<span class="hljs-title function_">insert</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SysLogHandle</code> 继承自 <code>AbstractRequestAwareRunnable</code>，它是一个Runnable实现，用于异步执行日志记录任务。</li><li>构造函数接收所有必要的参数，包括请求信息、用户信息和方法信息。</li><li><code>onRun</code> 方法是日志记录逻辑的实现。它首先从Redis中获取IP来源信息，然后创建一个 <code>SysLog</code> 对象并设置各种属性，包括请求信息、用户信息、操作名称、参数等。</li><li>最后，计算请求耗时并将日志信息保存到数据库。</li></ul><p>这个类的主要作用是异步记录每次请求的详细日志，包括请求参数、执行时间等，</p><p>通过异步处理，它还有助于减少日志记录对应用性能的影响。</p><h4 id="异步日志记录的功能"><a href="#异步日志记录的功能" class="headerlink" title="异步日志记录的功能"></a>异步日志记录的功能</h4><p>在切面的时候，handle 方法保存日志的操作是异步进行的，这里单独拿出来分析一下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 异步存储日志</span><br><span class="hljs-selector-tag">threadPoolTaskExecutor</span><span class="hljs-selector-class">.execute</span>(<br>        new <span class="hljs-built_in">SysLogHandle</span>(ip, type, url, securityUser,<br>                        paramsJson, point.<span class="hljs-built_in">getTarget</span>().<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getName</span>(),<br>                        point.<span class="hljs-built_in">getSignature</span>().<span class="hljs-built_in">getName</span>(), bussinessName,<br>                        startTime, redisUtil));<br><br></code></pre></td></tr></table></figure><ol><li><strong>使用线程池</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这部分代码利用Spring框架中的 <code>ThreadPoolTaskExecutor</code> 来执行一个任务。<code>ThreadPoolTaskExecutor</code> 是一个基于线程池的TaskExecutor实现，允许异步执行任务。</li></ul></li><li><strong>创建日志处理任务</strong>:<ul><li><code>new SysLogHandle(...)</code>: 这里创建了一个 <code>SysLogHandle</code> 对象，它是一个实现了 <code>Runnable</code> 接口的类，用于处理日志记录的具体逻辑。</li></ul></li><li><strong>传递参数给日志处理任务</strong>:<ul><li>向 <code>SysLogHandle</code> 构造器传递了多个参数，包括请求的IP地址 (<code>ip</code>)、请求类型 (<code>type</code>)、请求URL (<code>url</code>)、当前安全用户 (<code>securityUser</code>)、请求参数的JSON字符串 (<code>paramsJson</code>)、被调用的类名和方法名（通过 <code>point.getTarget().getClass().getName()</code> 和 <code>point.getSignature().getName()</code> 获取）、业务名称 (<code>bussinessName</code>)、方法开始执行的时间 (<code>startTime</code>)，以及Redis工具类 (<code>redisUtil</code>)。</li></ul></li><li><strong>执行任务</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这个方法将 <code>SysLogHandle</code> 的实例提交到线程池进行异步执行，不会阻塞当前线程的执行。这意味着原方法（被 <code>@OperationLogger</code> 注解的方法）的执行和日志的记录是并发进行的。</li></ul></li></ol><blockquote><p>实际应用</p></blockquote><p>在实际应用中，这种异步日志记录方法非常有用，尤其是在高流量的Web应用中。它允许应用快速响应用户请求，同时将耗时的日志记录操作放在后台线程中执行，从而不会显著影响用户体验和应用性能。</p><p>通过将日志记录逻辑从主执行路径中分离出来，可以减少对主业务逻辑的干扰，同时确保了重要的操作日志被正确记录和存储。</p><h4 id="工具类AspectUtil"><a href="#工具类AspectUtil" class="headerlink" title="工具类AspectUtil"></a>工具类AspectUtil</h4><p>对于上面使用到的工具类 AspectUtil 进行记录说明</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-variable">enum</span> <span class="hljs-title class_">AspectUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例实例，枚举类型保证全局唯一。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">INSTANCE</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取以类路径为前缀的键。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix 前缀字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 以类路径为前缀的键字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getKey</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>, <span class="hljs-params">String</span> <span class="hljs-params">prefix</span>) &#123;<br>        <span class="hljs-title class_">String</span> <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span><span class="hljs-title class_">StringUtils</span>.<span class="hljs-property">isEmpty</span>(<span class="hljs-variable">prefix</span>)) &#123;<br>            <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">prefix</span>;<br>        &#125;<br>        <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-variable">point</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">keyPrefix</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法所在的类的名称，替换所有的点为下划线。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 处理后的类名字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>().<span class="hljs-property">getClass</span>().<span class="hljs-property">getName</span>().<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法的Method对象。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前执行方法的Method对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NoSuchMethodException 如果无法找到相应的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Method</span> <span class="hljs-title function_">getMethod</span>(<span class="hljs-title class_">JoinPoint</span> <span class="hljs-variable">point</span>) <span class="hljs-variable">throws</span> <span class="hljs-title class_">NoSuchMethodException</span> &#123;<br>        <span class="hljs-title class_">Signature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getSignature</span>();<br>        <span class="hljs-title class_">MethodSignature</span> <span class="hljs-variable">msig</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">MethodSignature</span>) <span class="hljs-variable">sig</span>;<br>        <span class="hljs-title class_">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">target</span>.<span class="hljs-property">getClass</span>().<span class="hljs-property">getMethod</span>(<span class="hljs-variable">msig</span>.<span class="hljs-property">getName</span>(), <span class="hljs-variable">msig</span>.<span class="hljs-property">getParameterTypes</span>());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析业务名称中的占位符，并用方法参数替换。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 方法参数数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bussinessName 带占位符的业务名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 解析后的业务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">parseParams</span>(<span class="hljs-params">Object</span>[] <span class="hljs-params">params</span>, <span class="hljs-params">String</span> <span class="hljs-params">bussinessName</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)) &#123;<br>            <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">RegexUtils</span>.<span class="hljs-property">match</span>(<span class="hljs-variable">bussinessName</span>, <span class="hljs-string">&quot;(?&lt;=<span class="hljs-char escape_">\\</span>&#123;)(<span class="hljs-char escape_">\\</span>d+)&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-variable">s</span> : <span class="hljs-variable">result</span>) &#123;<br>                int index <span class="hljs-operator">=</span> <span class="hljs-title class_">Integer</span>.<span class="hljs-property">parseInt</span>(<span class="hljs-variable">s</span>);<br>                <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>&#123;&quot;</span> <span class="hljs-operator">+</span> index <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&#125;&quot;</span>, <span class="hljs-variable">JSON</span>.<span class="hljs-property">toJSONString</span>(<span class="hljs-variable">params</span>[index <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">bussinessName</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>AspectUtil</code> 是一个枚举类型，提供了一个全局唯一的实例 <code>INSTANCE</code>。</li><li><code>getKey</code> 方法根据连接点 (<code>JoinPoint</code>) 和给定的前缀生成一个字符串键。该键通常用于识别特定的方法或类。</li><li><code>getClassName</code> 方法获取连接点指向的目标类的名称，并将其中的点替换为下划线。这在需要基于类名生成唯一标识时很有用。</li><li><code>getMethod</code> 方法返回连接点指向的具体方法的 <code>Method</code> 对象，用于进一步的反射操作。</li><li><code>parseParams</code> 方法解析业务名称字符串中的占位符，并用方法的实际参数替换这些占位符。这对于生成动态的日志消息或错误消息非常有用，特别是当消息内容依赖于方法的输入参数时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day03</title>
    <link href="/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/"/>
    <url>/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/</url>
    
    <content type="html"><![CDATA[<p>这里讲述蘑菇博客里面一些写法的使用说明</p><p>下面的章节都是为了解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解-AuthorityVerify-的使用"><a href="#1、自定义注解-AuthorityVerify-的使用" class="headerlink" title="1、自定义注解 AuthorityVerify 的使用"></a>1、自定义注解 AuthorityVerify 的使用</h3><h4 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AuthorityVerify &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</code>：这表明这个注解可以应用于方法和类。如果放在类上，通常意味着类中的所有方法都应用这个注解；如果放在方法上，则只针对该方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：这指定了注解的保留策略是在运行时。这意味着这个注解不仅被保存在class文件中，还可以通过反射在运行时被读取。</li><li><code>String value() default &quot;&quot;</code>：这是一个可选的注解元素，允许在使用注解时设置一个字符串值。它的默认值是空字符串。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>这个注解可以应用于类或方法来实现权限验证。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span><br>public class SomeController &#123;<br><br>    <span class="hljs-variable">@AuthorityVerify</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/someSecureMethod&quot;</span>)<br>    public String <span class="hljs-built_in">someSecureMethod</span>() &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@AuthorityVerify</code> 应用于一个控制器方法。<br>你可以将其放在任何Spring Controller的方法上，表示该方法需要进行权限验证。<br>注解中的 <code>&quot;admin&quot;</code> 字符串可以用来指定需要哪种权限才能访问该方法。</p><p>要让这个注解真正起作用，还需要编写额外的代码来处理这个注解。通常是通过Spring的AOP（面向切面编程）功能来实现的，可以创建一个切面来拦截带有 <code>@AuthorityVerify</code> 注解的方法调用，然后执行权限验证逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityAspect</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取注解中的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> authorityVerify.value();<br><br>        <span class="hljs-comment">// 这里实现权限验证逻辑</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 继续执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里蘑菇博客项目也是这样使用的。</p><p>上面的示例是通过注解的值，然后在环绕通知里面的方法，根据获取值来进行下一步操作。</p><p>蘑菇博客的这个方法有所不同的是，他是通过判断添加该注解的方法，获取访问请求路径，获取用户，判定该用户下是否有该访问路径的权限。</p><p>getList 方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AuthorityVerifyAspect"><a href="#AuthorityVerifyAspect" class="headerlink" title="AuthorityVerifyAspect"></a><code>AuthorityVerifyAspect</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 权限校验 切面实现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-06-19:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityVerifyAspect</span> &#123;<br><br>    <span class="hljs-comment">// 自动注入所需的服务和工具类</span><br>    <span class="hljs-meta">@Autowired</span><br>    CategoryMenuService categoryMenuService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RoleService roleService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    AdminService adminService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisUtil redisUtil;<br><br>    <span class="hljs-comment">// 定义切点，指向使用AuthorityVerify注解的方法</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(AuthorityVerify authorityVerify)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，用于在方法执行前后添加额外的处理</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-comment">// 获取当前HTTP请求的属性</span><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attribute.getRequest();<br><br>        <span class="hljs-comment">// 获取请求路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 解析出请求者的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">adminUid</span> <span class="hljs-operator">=</span> request.getAttribute(SysConf.ADMIN_UID).toString();<br><br>        <span class="hljs-comment">// 尝试从Redis获取管理员能够访问的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">visitUrlStr</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.ADMIN_VISIT_MENU + RedisConf.SEGMENTATION + adminUid);<br>        LinkedTreeMap&lt;String, String&gt; visitMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedTreeMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 判断Redis中是否有数据</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(visitUrlStr)) &#123;<br>            <span class="hljs-comment">// 从Redis中获取</span><br>            visitMap = (LinkedTreeMap&lt;String, String&gt;) JsonUtils.jsonToMap(visitUrlStr, String.class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Redis中没有，则查询数据库</span><br>            <span class="hljs-type">Admin</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> adminService.getById(adminUid);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">roleUid</span> <span class="hljs-operator">=</span> admin.getRoleUid();<br>            <span class="hljs-type">Role</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> roleService.getById(roleUid);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">categoryMenuUids</span> <span class="hljs-operator">=</span> role.getCategoryMenuUids();<br>            String[] uids = categoryMenuUids.replace(<span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>            List&lt;String&gt; categoryMenuUids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(uids));<br><br>            <span class="hljs-comment">// 只查询访问的按钮</span><br>            QueryWrapper&lt;CategoryMenu&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>            queryWrapper.in(SQLConf.UID, categoryMenuUids);<br>            queryWrapper.eq(SQLConf.MENU_TYPE, EMenuType.BUTTON);<br>            queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br>            List&lt;CategoryMenu&gt; buttonList = categoryMenuService.list(queryWrapper);<br><br>            <span class="hljs-keyword">for</span> (CategoryMenu item : buttonList) &#123;<br>                <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(item.getUrl())) &#123;<br>                    visitMap.put(item.getUrl(), item.getUrl());<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将访问URL存储到Redis中</span><br>            redisUtil.setEx(RedisConf.ADMIN_VISIT_MENU + SysConf.REDIS_SEGMENTATION + adminUid, JsonUtils.objectToJson(visitMap), <span class="hljs-number">1</span>, TimeUnit.HOURS);<br>        &#125;<br><br>        <span class="hljs-comment">// 判断该角色是否能够访问该接口</span><br>        <span class="hljs-keyword">if</span> (visitMap.get(url) != <span class="hljs-literal">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;用户拥有操作权限，访问的路径: &#123;&#125;，拥有的权限接口：&#123;&#125;&quot;</span>, url, visitMap.get(url));<br>            <span class="hljs-comment">// 用户有权限，继续执行业务</span><br>            <span class="hljs-keyword">return</span> joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;用户不具有操作权限，访问的路径: &#123;&#125;&quot;</span>, url);<br>            <span class="hljs-comment">// 用户无权限，返回无权限的响应</span><br>            <span class="hljs-keyword">return</span> ResultUtil.result(ECode.NO_OPERATION_AUTHORITY, MessageConf.RESTAPI_NO_PRIVILEGE);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、-Validated-注解的使用"><a href="#2、-Validated-注解的使用" class="headerlink" title="2、@Validated 注解的使用"></a>2、@Validated 注解的使用</h3><h4 id="解释如何使用的"><a href="#解释如何使用的" class="headerlink" title="解释如何使用的"></a>解释如何使用的</h4><p>Spring框架中，<code>@Validated</code> 注解是用来启用方法参数级别的验证的。这个注解告诉Spring需要对被注解的参数执行验证。</p><blockquote><p>如何使用 <code>@Validated</code></p></blockquote><p>一般会结合 验证组、<code>@RequestBody</code>、<code>BindingResult</code> 结合使用</p><ol><li><strong>指定验证组</strong>:<ul><li><code>@Validated</code> 可以指定一个或多个验证组，例如 <code>@Validated(&#123;GetList.class&#125;)</code>。这意味着只有在 <code>GetList</code> 组中定义的验证规则会被应用于 <code>blogVO</code> 对象。如果没有指定组，将应用默认的验证规则。</li></ul></li><li><strong>与 <code>@RequestBody</code> 结合</strong>:<ul><li>在REST控制器中，<code>@Validated</code> 通常与 <code>@RequestBody</code> 结合使用，用于验证JSON请求体映射到的Java对象。</li></ul></li><li><strong>处理验证结果</strong>:<ul><li>通常与 <code>BindingResult</code> 结合使用，后者用于捕获验证过程中发现的错误。如果存在错误，可以通过检查 <code>BindingResult</code> 对象来响应相应的错误信息。</li></ul></li></ol><h4 id="基本使用用法"><a href="#基本使用用法" class="headerlink" title="基本使用用法"></a>基本使用用法</h4><blockquote><p>使用示例</p></blockquote><p>展示如何在Spring Boot应用中对一个REST API端点的请求体进行验证。</p><p><strong>场景描述</strong></p><p>假设我们正在编写一个博客应用程序，需要一个API来创建新的博客文章。</p><p>我们希望确保传入的数据满足某些条件，比如标题不为空，内容长度不低于一定字符数等。</p><p><strong>实体类定义</strong></p><p>首先，我们定义一个 <code>BlogPost</code> 类，它包含文章的标题和内容，这些字段都有特定的验证规则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">NotBlank</span>;<br><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">Size</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogPost</span> &#123;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Title is required&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Content is required&quot;</span>)<br>    <span class="hljs-meta">@Size</span>(min = <span class="hljs-number">100</span>, message = <span class="hljs-string">&quot;Content must be at least 100 characters long&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> content;<br><br>    <span class="hljs-comment">// Getters and setters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getTitle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTitle</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> title</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getContent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setContent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制器方法</strong></p><p>接下来，我们创建一个REST控制器方法来接收博客文章的数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.validation.BindingResult;<br><span class="hljs-keyword">import</span> org.springframework.validation.<span class="hljs-keyword">annotation</span>.Validated;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/createBlog&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String createBlog(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> BlogPost blogPost, BindingResult result) &#123;<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            <span class="hljs-comment">// 处理验证错误，例如返回错误信息</span><br>            <span class="hljs-keyword">return</span> result.getFieldError().getDefaultMessage();<br>        &#125;<br>        <span class="hljs-comment">// 如果数据有效，执行业务逻辑，例如保存博客文章</span><br>        <span class="hljs-comment">// saveBlogPost(blogPost);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blog post created successfully&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下上面的用法</p><ul><li><code>BlogPost</code> 类中的字段 <code>title</code> 和 <code>content</code> 使用了JSR 380（Hibernate Validator）注解来声明验证规则。<code>@NotBlank</code> 确保字段不为空，<code>@Size</code> 指定了 <code>content</code> 字段的最小长度。</li><li>在 <code>BlogController</code> 的 <code>createBlog</code> 方法中，<code>@Validated</code> 注解用于启用对 <code>@RequestBody</code> 注解的 <code>BlogPost</code> 对象的自动验证。</li><li><code>BindingResult</code> 参数用于捕获任何验证错误。如果存在错误，可以从 <code>BindingResult</code> 中获取错误信息并适当响应。</li></ul><p>在接口调用的时候，当客户端发送POST请求到 <code>/createBlog</code> 端点，并提供JSON格式的博客文章数据时，Spring将自动验证该数据是否符合 <code>BlogPost</code> 类中定义的规则。如果数据不符合规则，将返回相应的错误信息。</p><h4 id="如果需要使用验证组，是如何使用的"><a href="#如果需要使用验证组，是如何使用的" class="headerlink" title="如果需要使用验证组，是如何使用的"></a>如果需要使用验证组，是如何使用的</h4><blockquote><p>使用示例2</p></blockquote><p>这里主要说明一下验证组的使用</p><p>在Spring框架中，当 <code>@Validated</code> 注解被应用于一个方法参数，并且指定了一个或多个组类，进行验证时只会考虑那些属于指定组的验证约束。</p><p><strong>验证组的作用</strong></p><ol><li><strong>分组验证</strong>:<ul><li>验证组允许你将一个实体类（如 <code>BlogVO</code>）的验证规则分成不同的组。这样，你可以在不同的场景下应用不同的验证规则集合。</li><li>例如，一个实体在创建时可能需要一组验证规则，在更新时需要另一组规则。</li></ul></li><li><strong>定义验证组</strong>:<ul><li>验证组通常是空接口，用于标识验证规则属于哪个组。</li><li>例如，<code>public interface GetList &#123;&#125;</code> 可以作为一个验证组的声明。</li></ul></li></ol><p><strong>代码示例</strong></p><p>实体类中的验证规则</p><p>在 <code>BlogVO</code> 实体类中，验证注解可能像这样使用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span>VO &#123;<br><br>    <span class="hljs-variable">@NotBlank</span>(groups = <span class="hljs-title class_">GetList</span>.<span class="hljs-keyword">class</span>, message = <span class="hljs-string">&quot;Title cannot be empty when getting list&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-regexp">//</span> 其他字段和getter/setter<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中：</p><ul><li><code>@NotBlank</code> 注解只有在执行针对 <code>GetList</code> 组的验证时才会生效。</li><li>如果在一个方法中使用了 <code>@Validated(&#123;GetList.class&#125;)</code> 对 <code>BlogVO</code> 实例进行验证，那么只有那些指定为 <code>GetList</code> 组的验证规则（如上面的 <code>title</code> 字段）会被考虑。</li><li>这种方式提供了灵活性，允许在不同的操作（如获取列表、创建、更新等）中重复使用同一个实体类，同时应用不同的验证规则。</li></ul><p>控制器方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><p>GetList 接口定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * GetList Group  用于getList方法查询时  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2019年12月4日22:49:01  </span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetList</span> &#123;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Validated(&#123;GetList.class&#125;)</code> 表明只有标记为 <code>GetList</code> 组的验证约束会被应用于 <code>BlogVO</code> 对象。</li><li>这意味着 <code>BlogVO</code> 类中的某些验证注解可能被指定为仅在 <code>GetList</code> 组上下文中有效。</li></ul><hr><h3 id="3、抛出异常工具类ThrowableUtils"><a href="#3、抛出异常工具类ThrowableUtils" class="headerlink" title="3、抛出异常工具类ThrowableUtils"></a>3、抛出异常工具类ThrowableUtils</h3><p>这个类主要用法是处理验证结果，当传入接口数据时，映射对象  BlogVO 里面的参数校验，对应的验证结果  result ，对验证结果进行处理</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抛出异常工具类</span><br><span class="hljs-comment"> * 用于处理和格式化由Spring Validation框架抛出的验证错误。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @author 陌溪</span><br><span class="hljs-comment"> * @date 2019年12月4日22:47:18</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ThrowableUtils &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验参数正确性，如果发现验证错误，则拼装并抛出自定义异常。</span><br><span class="hljs-comment">     * 这个方法主要用于处理由Spring Validation框架产生的验证错误。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param result BindingResult对象，包含验证过程中产生的错误信息。</span><br><span class="hljs-comment">     */</span><br>    public static void checkParamArgument(BindingResult result) &#123;<br>        <span class="hljs-comment">// 检查是否存在验证错误</span><br>        <span class="hljs-keyword">if</span> (result != null &amp;&amp; result.hasErrors()) &#123;<br>            StringBuilder sb = new StringBuilder();<br><br>            <span class="hljs-comment">// 获取所有字段级别的错误</span><br>            <span class="hljs-keyword">List</span>&lt;FieldError&gt; errors = result.getFieldErrors();<br>            <span class="hljs-keyword">if</span> (CollectionUtil.isNotEmpty(errors)) &#123;<br>                <span class="hljs-comment">// 只处理第一个错误</span><br>                FieldError <span class="hljs-keyword">error</span> = errors.<span class="hljs-built_in">get</span>(0);<br>                <br>                <span class="hljs-comment">// 获取被拒绝的值（即不合法的输入值）</span><br>                String rejectedValue = Objects.<span class="hljs-keyword">toString</span>(<span class="hljs-keyword">error</span>.getRejectedValue(), <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-comment">// 获取默认错误信息</span><br>                String defMsg = <span class="hljs-keyword">error</span>.getDefaultMessage();<br><br>                <span class="hljs-comment">// 排除在类级别上的注解提示</span><br>                <span class="hljs-keyword">if</span> (rejectedValue.contains(Constants.DELIMITER_TO)) &#123;<br>                    <span class="hljs-comment">// 对于类级别的错误，直接使用错误信息</span><br>                    sb.<span class="hljs-keyword">append</span>(defMsg);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 对于字段级别的错误，拼接字段名和错误信息</span><br>                    <span class="hljs-keyword">if</span> (Constants.DELIMITER_COLON.contains(defMsg)) &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理非字段级别的错误（如类级别的错误）</span><br>                String msg = result.getAllErrors().<span class="hljs-built_in">get</span>(0).getDefaultMessage();<br>                sb.<span class="hljs-keyword">append</span>(msg);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 抛出自定义异常，包含处理过的错误信息</span><br>            throw new ApiInvalidParamException(sb.<span class="hljs-keyword">toString</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、自定义异常-ApiInvalidParamException-的使用"><a href="#4、自定义异常-ApiInvalidParamException-的使用" class="headerlink" title="4、自定义异常 ApiInvalidParamException 的使用"></a>4、自定义异常 ApiInvalidParamException 的使用</h3><p><code>ApiInvalidParamException</code> 类是一个自定义异常类，继承自 <code>RuntimeException</code>。其主要作用是封装和表示与API参数相关的错误或异常情况。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的运行时异常类，用于表示API操作中的参数无效或不符合预期的情况。</span><br><span class="hljs-comment"> * 这个类主要用于在API层抛出参数相关的异常，并能够被全局异常处理器捕获和处理，</span><br><span class="hljs-comment"> * 以便返回统一格式的错误响应给客户端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiInvalidParamException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无参构造函数。</span><br><span class="hljs-comment">     * 创建一个没有详细错误消息的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息和原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述和原因的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含原因的ApiInvalidParamException异常实例，但不提供详细信息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><p>类中定义了几个构造函数，允许在创建异常实例时提供不同类型的信息：</p><ol><li><p><strong>无参构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException()</code>: 创建一个没有详细错误消息的异常实例。</li></ul></li><li><p><strong>带消息的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message)</code>: 创建一个带有具体错误描述的异常实例。</li></ul></li><li><p><strong>带消息和原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message, Throwable cause)</code>: 创建一个异常实例，同时提供错误描述和一个原始异常（原始异常表示这个新异常的原因）。</li></ul></li><li><p><strong>带原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(Throwable cause)</code>: 创建一个异常实例，只包含一个原始异常。</li></ul></li></ol><blockquote><p>自定义异常类的使用</p></blockquote><p><strong>使用场景</strong></p><p>在API的各个层面（如控制器、服务或数据访问层）中，当遇到不符合要求的参数或其他与参数相关的问题时，可以抛出 <code>ApiInvalidParamException</code>。</p><p>然后，全局异常处理器可以捕获这些异常，并将它们转换为统一的、用户友好的响应格式，如JSON，包含错误代码和错误消息。</p><p><strong>作用和用途</strong></p><ol><li><strong>自定义异常处理</strong>:<ul><li>这个类用于表示在API中遇到的特定类型的参数错误。通过创建这样的自定义异常，可以更清晰地表达代码中可能出现的特定错误情况。</li></ul></li><li><strong>全局异常拦截</strong>:<ul><li>在一个基于Spring Boot的REST API项目中，通常会有一个全局异常处理器（如使用 <code>@ControllerAdvice</code> 注解的类）。</li><li><code>ApiInvalidParamException</code> 可以被这样的全局处理器捕获，并转换为统一的响应格式发送给API的调用者。这有助于维持API的响应格式的一致性。</li></ul></li><li><strong>错误消息定制</strong>:<ul><li>这个异常类允许在抛出异常时附带一个自定义的错误消息，这对于提供更详细的错误信息（例如，哪个参数错误以及为什么错误）非常有用。</li></ul></li></ol><h3 id="5、全局异常处理"><a href="#5、全局异常处理" class="headerlink" title="5、全局异常处理"></a>5、全局异常处理</h3><p><code>GlobalExceptionConfig</code> 类和 <code>HandlerExceptionResolver</code> 类是Spring框架中用于全局异常处理的配置和实现</p><p>针对蘑菇博客相关实现，进行说明</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration  </span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionConfig</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@Bean  </span><br>    <span class="hljs-keyword">public</span> HandlerExceptionResolver getHandlerExceptionResolver() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">HandlerExceptionResolver</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Configuration</code>: 表示这个类包含Spring容器的bean定义。</li><li><code>@Bean</code>: 表示该方法将返回一个对象，该对象应该被注册为Spring应用程序上下文中的bean。</li><li><code>getHandlerExceptionResolver()</code>: 这个方法创建并返回 <code>HandlerExceptionResolver</code> 的一个实例，用于全局异常处理</li></ul><blockquote><p>HandlerExceptionResolver 类解释</p></blockquote><p><code>HandlerExceptionResolver</code> 类实现了Spring的 <code>HandlerExceptionResolver</code> 接口，用于处理Spring MVC抛出的所有异常。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">HandlerExceptionResolver</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolveException</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, <span class="hljs-built_in">Object</span> handler, Exception exception</span>) &#123;<br>        <span class="hljs-comment">// 异常处理逻辑...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Slf4j</code>: Lombok库提供的注解，为类提供了一个日志对象 <code>log</code>。</li><li><code>resolveException(...)</code>: 这是异常处理的核心方法，它接收发生异常的HTTP请求和响应、处理器（handler）对象以及实际抛出的异常。</li><li>在这个方法内部，可以根据不同类型的异常进行处理，并生成适当的响应</li></ul><p>具体代码分析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理Spring MVC抛出的所有异常。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request   当前的HTTP请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response  当前的HTTP响应</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler   处理当前请求的处理器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exception 抛出的异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ModelAndView - Spring MVC的模型和视图对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>, Exception exception)</span> </span>&#123;<br>        log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;系统统一异常处理：&quot;</span>, exception);<br><br>        <span class="hljs-comment">// 检查响应是否已经提交</span><br>        <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化错误代码和信息</span><br>        String errorCode = ErrorCode.ERROR;<br>        String message = BaseMessageConf.OPERATION_FAIL;<br><br>        <span class="hljs-comment">// 根据异常类型设置不同的错误代码和消息</span><br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BusinessException) &#123;<br>            errorCode = ((BusinessException) exception).getCode();<br>            message = exception.getMessage();<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(exception <span class="hljs-keyword">instanceof</span> ApiInvalidParamException)</span> </span>&#123;<br>            errorCode = ErrorCode.PARAM_INCORRECT;<br>            message = exception.getMessage();<br>        &#125;<br>        <span class="hljs-comment">// ...处理其他自定义异常</span><br><br>        <span class="hljs-comment">// 设置响应类型为JSON</span><br>        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);<br><br>        <span class="hljs-comment">// 向客户端输出错误信息</span><br>        <span class="hljs-keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;<br>            writer.write(ResultUtil.resultWithMessage(errorCode, message));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;响应输出失败！原因如下：&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回一个空的ModelAndView表示已手动处理响应</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，<code>resolveException</code> 方法根据捕获到的异常类型，对错误信息进行定制，并将定制的错误消息以JSON格式写入HTTP响应。</p><p>这种方式有助于实现统一的错误处理逻辑，使得API的错误响应更加一致和标准化。</p><h3 id="6、返回统一接口ResultUtil"><a href="#6、返回统一接口ResultUtil" class="headerlink" title="6、返回统一接口ResultUtil"></a>6、返回统一接口ResultUtil</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工具类用于构建统一的API响应格式。</span><br><span class="hljs-comment"> * 提供了一系列方法来生成标准化的JSON字符串响应，</span><br><span class="hljs-comment"> * 包括成功或错误的状态代码、消息和数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultUtil</span> &#123;<br>    <span class="hljs-comment">// 常量定义</span><br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">CODE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;code&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">DATA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_TWO</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_THREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成包含状态码和数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">code</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成同时包含数据和消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_THREE</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，同时包含数据和消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ResultUtil</code> 是一个工具类，用于创建和格式化API响应。它提供了一系列静态方法来生成标准化的JSON字符串响应。这些方法允许包含各种类型的信息，如状态码、数据、消息等。</p><blockquote><p>类的作用</p></blockquote><ol><li><strong>统一API响应格式</strong>:<ul><li><code>ResultUtil</code> 类用于生成具有一致格式的API响应。这有助于前端开发者理解和处理后端发送的数据。</li></ul></li><li><strong>灵活的响应构建</strong>:<ul><li>提供了多种方法来构建响应，可以只包含数据、只包含消息或同时包含数据和消息。</li></ul></li></ol><blockquote><p>方法说明</p></blockquote><ul><li><code>result(Object code, Object data)</code>: 生成包含指定代码和数据的响应。</li><li><code>resultWithData(Object code, Object data)</code>: 生成只包含数据的响应。</li><li><code>resultWithMessage(Object code, String message)</code>: 生成只包含消息的响应。</li><li><code>resultWithDataAndMessage(Object code, Object data, String message)</code>: 生成同时包含数据和消息的响应。</li><li><code>successWithData(Object data)</code>: 生成表示操作成功的响应，只包含数据。</li><li><code>successWithMessage(String message)</code>: 生成表示操作成功的响应，只包含消息。</li><li><code>successWithDataAndMessage(Object data, String message)</code>: 生成表示操作成功的响应，包含数据和消息。</li><li><code>errorWithMessage(String message)</code>: 生成表示操作失败的响应，只包含消息。</li><li><code>errorWithData(Object data)</code>: 生成表示操作失败的响应，只包含数据。</li></ul><blockquote><p>使用示例</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 返回成功响应，只包含数据<br>String response <span class="hljs-operator">=</span> ResultUtil.successWithData(someData)<span class="hljs-comment">;</span><br><br>// 返回失败响应，只包含错误消息<br>String errorResponse <span class="hljs-operator">=</span> ResultUtil.errorWithMessage(<span class="hljs-string">&quot;An error occurred&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个类在实际的API开发中非常有用，它可以简化响应的创建过程，并确保API的返回格式统一和标准化。</p><p>对于维护API的一致性和可用性非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_基础概念</title>
    <link href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>消息队列的核心使用场景</li><li>技术选型</li><li>JMS和AMQP</li><li>RPC 和消息队列的区别</li></ul><blockquote><p>Start</p></blockquote><p>在面试的时候，当你的简历上面写了用过<code>MQ</code> ,那么面试官的面试这个时候便开始了：</p><ul><li><ol><li>你在系统里用过消息队列吗</li></ol></li><li><ol start="2"><li>你们在项目里是如何使用消息队列的。</li></ol></li><li><ol start="3"><li>为什么你们这里要使用消息队列呢，为什么不直接调用接口处理呢。</li></ol></li><li><ol start="4"><li>说说消息队列有哪些优点和缺点吧。</li></ol></li><li><ol start="5"><li>消息队列的选型，他们之间的区别。</li></ol></li><li><ol start="6"><li>如何保证消息不被重复消息，如何保证消费的时候是幂等，如何保证消息的可靠性，如何保证消息的顺序性。</li></ol></li><li><ol start="7"><li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该如何处理？有几百万消息持续堆积几小时，要怎么解决？</li></ol></li><li><ol start="8"><li>让你去设计一个MQ，该如何进行架构设计，说一下你的思路。</li></ol></li></ul><p>前几个问题的思考主要是围绕：为什么要使用消息队列；</p><p>陈述回答的时候需要从消息队列利弊、优缺点、风险点等方面考虑，在进行技术选型的时候，主要还是围绕使用场景来决定。</p><div style="box-shadow: 2px 2px 5px #888888; padding: 10px; border: 1px solid #3271ae;">    每一个 MQ 没有绝对的好坏，但是要看用在哪个场景可以扬长避短，利用其优势，规避其劣势。</div><h3 id="1、消息队列的核心使用场景"><a href="#1、消息队列的核心使用场景" class="headerlink" title="1、消息队列的核心使用场景"></a>1、消息队列的核心使用场景</h3><p>消息队列（MQ）的核心使用场景主要包括三个方面：解耦、异步处理和削峰。</p><blockquote><p>解耦</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，你在组织一个大型派对，你需要通知很多朋友。如果你直接一个个打电话，每当新朋友加入或某人退出，你都需要更新你的通知列表。这很麻烦，对吧？</p><p>现在，假设你创建了一个在线活动页面，你只需要更新这个页面，而你的朋友们自己决定是否查看这个页面。这就大大简化了你的工作。</p><p><strong>技术解释</strong></p><p>在没有消息队列的情况下，系统 A 需要直接和多个系统（如 B、C、D、E）进行通信。这种紧密耦合的方式使得系统 A 需要不断更新与其他系统的交互逻辑。使用消息队列后，系统 A 只需将消息发布到队列，而其他系统根据需要从队列中取出消息。</p><p>这种发布&#x2F;订阅模式（Pub&#x2F;Sub）使得系统 A 与其他系统解耦，简化了维护和扩展的复杂性。</p><blockquote><p>异步处理</p></blockquote><p><strong>类比解释</strong></p><p>假设你在一家餐厅点餐。如果厨师需要等待一个菜做完才开始做下一个，这将非常低效。但如果他们能同时处理多个订单，每道菜完成时就直接上菜，这样效率会更高。</p><p><strong>技术解释</strong></p><p>在同步处理模式中，系统 A 在完成所有操作（如更新多个数据库）之前不会响应用户请求，导致延迟。<br>而异步处理使用消息队列，系统 A 可以快速响应用户请求，将后续任务（如数据库更新）放入队列中，由其他系统或服务慢慢处理。这减少了用户的等待时间，提高了系统的响应能力。</p><blockquote><p>削峰</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，一个公交车站在高峰时段面临大量乘客。如果每个人都立即上车，公交车会被迅速塞满。但如果有一个等候区，让乘客按顺序上车，这样既保持了公交车的正常运行，又避免了拥挤。</p><p><strong>技术解释</strong></p><p>在流量削峰场景中，消息队列充当缓冲区，帮助处理短时的高流量。当系统 A 在高峰时段面临大量请求时，这些请求首先被放入消息队列。<br>系统 A 根据自己的处理能力逐渐从队列中取出并处理这些请求。这样可以避免在高峰期对系统造成过大的压力，同时保证了系统的稳定性和可用性。</p><p>上面提及到的削峰、解耦、异步就是<strong>在特殊场景下其对应的好处</strong>，而缺点对应的是系统的复杂性变高，可用性降低，以及还有一致性问题。</p><blockquote><p>使用消息队列会带来哪些问题？</p></blockquote><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况</li></ul><h3 id="2、技术选型"><a href="#2、技术选型" class="headerlink" title="2、技术选型"></a>2、技术选型</h3><p>技术选型可以参考看一下下面的内容</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><blockquote><p>Kafka</p></blockquote><p>优点</p><ol><li><strong>高吞吐量</strong>：Kafka 设计用于处理高吞吐量数据，适合大规模消息处理应用。</li><li><strong>分布式系统</strong>：它天生就是分布式的，易于扩展。</li><li><strong>持久性和可靠性</strong>：Kafka 可以持久化消息到磁盘，因此对消息不会因为系统故障而丢失。</li><li><strong>高效</strong>：Kafka 使用顺序磁盘I&#x2F;O，提供高性能与数据吞吐。</li></ol><p>缺点</p><ol><li><strong>复杂性</strong>：Kafka 的设置和管理相对复杂。</li><li><strong>消息积压</strong>：在高负载下，消息延迟可能会增加。</li><li><strong>不支持优先级队列</strong>。</li></ol><blockquote><p>ActiveMQ</p></blockquote><p>优点</p><ol><li><strong>支持多种传输协议</strong>：如 OpenWire, STOMP, MQTT 等。</li><li><strong>易于使用和配置</strong>：相比 Kafka，ActiveMQ 配置和管理较为简单。</li><li><strong>JMS 支持</strong>：完全支持 JMS API 和 J2EE 集成。</li></ol><p>缺点</p><ol><li><strong>较低的吞吐量</strong>：相比 Kafka，ActiveMQ 的吞吐量较低。</li><li><strong>可扩展性问题</strong>：在非常大的数据负载下，扩展性可能是一个问题。</li></ol><blockquote><p>RabbitMQ</p></blockquote><p>优点</p><ol><li><strong>灵活的路由</strong>：支持复杂的路由。</li><li><strong>多种消息协议</strong>：支持 AMQP, MQTT, STOMP 等。</li><li><strong>管理界面友好</strong>：提供易于使用的管理界面。</li></ol><p>缺点</p><ol><li><strong>性能问题</strong>：在高吞吐量时，性能可能会受限。</li><li><strong>持久化开销</strong>：消息持久化可能会导致性能问题。</li></ol><blockquote><p>RocketMQ</p></blockquote><p>优点</p><ol><li><strong>高性能和低延迟</strong>：在分布式系统中表现出色。</li><li><strong>丰富的功能</strong>：提供了大量的特性，如消息顺序、事务消息等。</li><li><strong>可靠性和扩展性</strong>：保证了消息的可靠传输，同时支持水平和垂直扩展。</li></ol><p>缺点</p><ol><li><strong>社区和生态</strong>：相比 Kafka，RocketMQ 的社区和生态相对较小。</li><li><strong>复杂性</strong>：配置和管理稍微复杂。</li></ol><blockquote><p>技术选型考虑因素</p></blockquote><ol><li><strong>吞吐量需求</strong>：如果你的系统需要处理大量的数据，Kafka 或 RocketMQ 可能是更好的选择。</li><li><strong>系统复杂性</strong>：如果你需要一个易于设置和管理的系统，ActiveMQ 或 RabbitMQ 可能更合适。</li><li><strong>功能需求</strong>：根据你需要的特定功能（如消息排序、事务处理等）选择相应的系统。</li><li><strong>社区支持和生态系统</strong>：强大的社区可以提供更好的支持和更多的资源。</li><li><strong>可靠性和持久性</strong>：如果这些是你的主要关注点，Kafka 和 RocketMQ 是不错的选择</li></ol><p>选择建议：</p><ul><li><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；</li><li><strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，Kafka 是业内标准，社区活跃度很高，几乎是全世界该领域的事实性规范。</li><li>ActiveMQ，最近逐年使用减少，没经过大规模吞吐量场景的验证，社区不是很活跃。</li></ul><h3 id="3、JMS和AMQP"><a href="#3、JMS和AMQP" class="headerlink" title="3、JMS和AMQP"></a>3、JMS和AMQP</h3><p>JMS（Java Message Service）和 AMQP（Advanced Message Queuing Protocol）都是消息传递的标准和规范，但它们在设计理念、实现方式和使用场景上有所不同</p><blockquote><p>JMS（Java Message Service）</p></blockquote><p>定义</p><ul><li>JMS 是一个 Java 平台中关于面向消息中间件（MOM）的 API，用于在两个应用程序之间，或分布式系统中发送消息，进行异步通信。</li></ul><p>特点</p><ul><li><strong>Java 标准</strong>：JMS 是 Java EE 的一部分，主要用于 Java 应用程序。</li><li><strong>API 规范</strong>：定义了一个通用的 API 来与消息服务进行交互，而不是一个网络协议。</li><li><strong>提供者依赖</strong>：JMS API 可以由多种供应商实现，如 ActiveMQ、IBM MQ 等。</li><li><strong>两种消息模型</strong>：支持点对点（Queue）和发布&#x2F;订阅（Topic）模型。</li><li><strong>不跨语言</strong>：主要用于 Java 应用程序，不适用于不同语言之间的通信。</li></ul><blockquote><p>AMQP（Advanced Message Queuing Protocol）</p></blockquote><p>定义</p><ul><li>AMQP 是一个开放标准的应用层协议，专为异步消息传递提供一个统一的框架，支持跨平台和跨语言的消息通信。</li></ul><p>特点</p><ul><li><strong>协议标准</strong>：AMQP 定义了网络协议，包括消息的格式、传输方式和队列的行为。</li><li><strong>供应商中立</strong>：旨在允许从不同供应商的消息系统中互操作。</li><li><strong>跨语言支持</strong>：不限于 Java，支持多种编程语言和平台。</li><li><strong>多种消息模式</strong>：支持灵活的消息模式，包括点对点、发布&#x2F;订阅、请求&#x2F;响应等。</li><li><strong>可靠性和安全性</strong>：提供了消息确认、交易、安全等机制。</li></ul><blockquote><p>主要区别</p></blockquote><ul><li><strong>设计范围</strong>：JMS 是一个针对 Java 的 API 规范，而 AMQP 是一个跨语言、跨平台的网络协议。</li><li><strong>适用范围</strong>：JMS 主要用于 Java 应用，AMQP 适用于任何支持该协议的客户端。</li><li><strong>实现依赖</strong>：使用 JMS 时，需要依赖特定供应商的实现，而 AMQP 的实现是供应商中立的，理论上任何 AMQP 兼容的客户端都可以与任何 AMQP 兼容的服务器通信。</li><li><strong>兼容性</strong>：AMQP 的设计目标是实现不同消息系统之间的互操作性，而 JMS 无法做到这一点。</li></ul><p><strong>ActiveMQ（已被淘汰） 是基于 JMS 规范实现的。</strong></p><p><strong>RabbitMQ 是基于 AMQP 协议实现的。</strong></p><blockquote><p>JMS vs AMQP</p></blockquote><table><thead><tr><th>对比方向</th><th>JMS</th><th>AMQP</th></tr></thead><tbody><tr><td>定义</td><td>Java API</td><td>协议</td></tr><tr><td>跨语言</td><td>否</td><td>是</td></tr><tr><td>跨平台</td><td>否</td><td>是</td></tr><tr><td>支持消息类型</td><td>提供两种消息模型：①Peer-2-Peer;②Pub&#x2F;sub</td><td>提供了五种消息模型：①direct exchange；②fanout exchange；③topic change；④headers exchange；⑤system exchange。本质来讲，后四种和 JMS 的 pub&#x2F;sub 模型没有太大差别，仅是在路由机制上做了更详细的划分；</td></tr><tr><td>支持消息类型</td><td>支持多种消息类型 ，我们在上面提到过</td><td>byte[]（二进制）</td></tr></tbody></table><ul><li>AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>JMS 支持 <code>TextMessage</code>、<code>MapMessage</code> 等复杂的消息类型；而 AMQP 仅支持 <code>byte[]</code> 消息类型（复杂的类型可序列化后发送）。</li><li>由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题&#x2F;订阅 方式两种</li></ul><h3 id="4、RPC-和消息队列的区别"><a href="#4、RPC-和消息队列的区别" class="headerlink" title="4、RPC 和消息队列的区别"></a>4、RPC 和消息队列的区别</h3><p>RPC（Remote Procedure Call）和消息队列是分布式系统中的两种不同的通信机制，它们在设计目的、通信方式、架构要求和时效性等方面存在显著差异。</p><blockquote><p>用途</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>目的是实现不同服务之间的直接同步调用。</li><li>类似于本地函数调用，用于服务与服务之间的紧密协作。</li><li>适用于对响应时间有严格要求的场景。</li></ul></li><li><strong>消息队列</strong>：<ul><li>目的是提供异步通信能力，解耦服务之间的依赖关系。</li><li>用于任务的异步处理、流量削峰和分布式事务等。</li><li>适用于处理高峰期流量或者执行耗时操作。</li></ul></li></ul><blockquote><p>通信方式</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>是一种同步操作，调用方发起请求并等待响应，直到远程过程执行完成并返回结果。</li><li>依赖直接的网络连接和即时的数据传输。</li></ul></li><li><strong>消息队列</strong>：<ul><li>提供了一种异步通信方式，发送方将消息发送到队列，接收方可以在任何时间从队列中获取消息。</li><li>引入了中间件作为消息传递的中间层，增加了消息的持久性。</li></ul></li></ul><blockquote><p>架构</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>没有消息存储的需求，因为它依赖即时的请求-响应模型。</li><li>通常不需要中间层来缓存或管理消息。</li></ul></li><li><strong>消息队列</strong>：<ul><li>必须要有消息存储和管理的机制，因为消息需要在队列中等待被处理。</li><li>消息中间件负责保证消息的持久性和可靠性。</li></ul></li></ul><blockquote><p>时效性</p></blockquote><ul><li><strong>RPC</strong>：<ul><li>一般期望立即处理，调用方通常会阻塞等待直到得到响应。</li><li>更适合于需要快速完成的交互式操作。</li></ul></li><li><strong>消息队列</strong>：<ul><li>消息可能不会立即处理，允许在系统资源允许的情况下随后处理。</li><li>支持高峰期的流量平滑，允许系统按照自己的节奏和能力处理消息。</li></ul></li></ul><p><strong>总结</strong></p><p>RPC 和消息队列解决的是分布式系统中不同的问题。</p><p>RPC 强调的是即时性和同步，适合于需要迅速响应的场景。而消息队列强调的是异步性和解耦，适合于需要提高系统整体效率和稳定性的场景。</p><p>在实际应用中，两者往往相互补充，共同支撑起一个高效、可靠、可扩展的分布式系统架构。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html">https://javaguide.cn/high-performance/message-queue/message-queue.html</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview">https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day02</title>
    <link href="/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/"/>
    <url>/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/</url>
    
    <content type="html"><![CDATA[<h3 id="Part01-我们应该去了解什么东西呢"><a href="#Part01-我们应该去了解什么东西呢" class="headerlink" title="Part01: 我们应该去了解什么东西呢"></a>Part01: 我们应该去了解什么东西呢</h3><p>这部分内容主要讲述一下基础的博客管理是怎么做的，如果需要做一个基础的博客系统需要怎么做，考虑哪些方面。</p><p>up 主 CodeSheep  在视频对于项目学习的一些建议，记录一下 <a href="https://www.bilibili.com/video/BV1y4411p74E/">https://www.bilibili.com/video/BV1y4411p74E/</a></p><ul><li><ol><li>运行项目并跑起来</li></ol></li><li><ol start="2"><li>阅读项目源码并调试（可以结合某个运行的功能入手，一个组件一个组件弄熟、看报错、看日志、看打印变量）</li></ol></li><li><ol start="3"><li>记录文档，从业务逻辑出发（逻辑很重要，你先学习这个，前端页面实现和二次改造想法先放后面，先去了解，再去摸索）</li></ol></li></ul><p>视频中推荐过这个项目（一个单体项目），有空也可以学习一下： <a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></p><p>在后台管理界面中，有一个很明显的模块是：博客管理</p><p>博客管理（界面）</p><ul><li>博客管理</li><li>分类管理</li><li>收藏管理</li><li>标签管理</li><li>推荐管理</li><li>专题管理</li></ul><h3 id="Part02-蘑菇博客中博客管理是如何实现的。"><a href="#Part02-蘑菇博客中博客管理是如何实现的。" class="headerlink" title="Part02: 蘑菇博客中博客管理是如何实现的。"></a>Part02: 蘑菇博客中博客管理是如何实现的。</h3><p>先了解这个问题，我们需要先回到技术栈的使用，知道他使用的是什么技术栈，才能对后面有更好的了解。</p><p>具体内容看一下 <a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></p><p>这里就不一一列举，需要知道的一个是项目中使用的 Java 持久层框架 是 MyBatis-Plus。</p><p>通过这个框架，你可以实现 <strong>代码生成器</strong>、<strong>自动 CRUD（Create, Read, Update, Delete）</strong> 等操作。</p><h4 id="博客管理"><a href="#博客管理" class="headerlink" title="博客管理"></a>博客管理</h4><blockquote><p>查找</p></blockquote><p>查询并分页获取博客列表</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据条件获取博客列表，并进行分页。</span><br><span class="hljs-comment"> * 使用MyBatis-Plus的QueryWrapper来构建查询条件。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param blogVO 包含查询条件的VO对象</span><br><span class="hljs-comment"> * @return 分页后的博客列表</span><br><span class="hljs-comment"> */</span><br>@Override<br>public IPage&lt;Blog&gt; getPageList(BlogVO blogVO) &#123;<br>    <span class="hljs-comment">// 创建查询包装器</span><br>    QueryWrapper&lt;Blog&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br><br>    <span class="hljs-comment">// 构建搜索条件</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(blogVO.getKeyword()) &amp;&amp; !StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getKeyword().<span class="hljs-built_in">trim</span>())) &#123;<br>        queryWrapper.like(SQLConf.TITLE, blogVO.getKeyword().<span class="hljs-built_in">trim</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getTagUid())) &#123;<br>        queryWrapper.like(SQLConf.TAG_UID, blogVO.getTagUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getBlogSortUid())) &#123;<br>        queryWrapper.like(SQLConf.BLOG_SORT_UID, blogVO.getBlogSortUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getLevelKeyword())) &#123;<br>        queryWrapper.eq(SQLConf.LEVEL, blogVO.getLevelKeyword());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsPublish())) &#123;<br>        queryWrapper.eq(SQLConf.IS_PUBLISH, blogVO.getIsPublish());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsOriginal())) &#123;<br>        queryWrapper.eq(SQLConf.IS_ORIGINAL, blogVO.getIsOriginal());<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getType())) &#123;<br>        queryWrapper.eq(SQLConf.TYPE, blogVO.getType());<br>    &#125;<br><br>    <span class="hljs-comment">// 设置分页参数</span><br>    Page&lt;Blog&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;();<br>    page.setCurrent(blogVO.getCurrentPage());<br>    page.setSize(blogVO.getPageSize());<br>    queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br><br>    <span class="hljs-comment">// 设置排序方式</span><br>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByAscColumn())) &#123;<br>        <span class="hljs-comment">// 将驼峰命名转换成下划线命名</span><br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByAscColumn())).toString();<br>        queryWrapper.orderByAsc(column);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByDescColumn())) &#123;<br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByDescColumn())).toString();<br>        queryWrapper.orderByDesc(column);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 默认排序</span><br>        <span class="hljs-keyword">if</span> (blogVO.getUseSort() == <span class="hljs-number">0</span>) &#123;<br>            queryWrapper.orderByDesc(SQLConf.CREATE_TIME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queryWrapper.orderByDesc(SQLConf.<span class="hljs-built_in">SORT</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行分页查询</span><br>    IPage&lt;Blog&gt; pageList = blogService.page(page, queryWrapper);<br>    List&lt;Blog&gt; list = pageList.getRecords();<br><br>    <span class="hljs-comment">// 若结果为空，直接返回</span><br>    <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> pageList;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理查询结果，例如添加分类、标签等额外信息</span><br>    <span class="hljs-comment">// ... 省略了额外信息处理的代码 ...</span><br><br>    <span class="hljs-comment">// 返回处理后的分页结果</span><br>    pageList.setRecords(list);<br>    <span class="hljs-keyword">return</span> pageList;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理查询结果</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pf">// ...省略方法的其它部分...<br><br>List<span class="hljs-variable">&lt;Blog&gt;</span> list = pageList.getRecords();<br><br>// 若查询结果为空，直接返回<br>if (list.isEmpty()) &#123;<br>    return pageList;<br>&#125;<br><br>// 初始化存储分类UID和标签UID的集合<br>List<span class="hljs-variable">&lt;String&gt;</span> sortUids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br>List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>Uids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br><br>// 遍历查询结果，收集分类UID和标签UID<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    if (StringUtils.isNotEmpty(blog.getB<span class="hljs-keyword">log</span>SortUid())) &#123;<br>        sortUids.add(blog.getB<span class="hljs-keyword">log</span>SortUid());<br>    &#125;<br>    if (StringUtils.isNotEmpty(blog.getTagUid())) &#123;<br>        <span class="hljs-keyword">tag</span>Uids.addAll(StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION));<br>    &#125;<br>&#125;<br><br>// 根据分类UIDs和标签UIDs获取对应的分类和标签对象<br>Collection<span class="hljs-variable">&lt;BlogSort&gt;</span> sortList = blogSortService.listByIds(sortUids);<br>Collection<span class="hljs-variable">&lt;Tag&gt;</span> <span class="hljs-keyword">tag</span>List = <span class="hljs-keyword">tag</span>Service.listByIds(<span class="hljs-keyword">tag</span>Uids);<br><br>// 将分类和标签对象转换为Map，便于快速查找<br>Map<span class="hljs-variable">&lt;String, BlogSort&gt;</span> sortMap = sortList.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(B<span class="hljs-keyword">log</span>Sort::getUid, Function.identity()));<br>Map<span class="hljs-variable">&lt;String, Tag&gt;</span> <span class="hljs-keyword">tag</span>Map = <span class="hljs-keyword">tag</span>List.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(Tag::getUid, Function.identity()));<br><br>// 遍历查询结果，设置每个博客的分类和标签<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    blog.<span class="hljs-built_in">set</span>B<span class="hljs-keyword">log</span>Sort(sortMap.get(blog.getB<span class="hljs-keyword">log</span>SortUid()));<br>    List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>UidList = StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION);<br>    List<span class="hljs-variable">&lt;Tag&gt;</span> blogTags = <span class="hljs-keyword">tag</span>UidList.stream()<br>        .map(<span class="hljs-keyword">tag</span>Map::get)<br>        .collect(Collectors.<span class="hljs-keyword">to</span>List());<br>    blog.<span class="hljs-built_in">set</span>TagList(blogTags);<br>&#125;<br><br>// 更新处理后的查询结果<br>pageList.<span class="hljs-built_in">set</span>Records(list);<br><br>// ...省略方法的其余部分...<br></code></pre></td></tr></table></figure><ol><li>首先检查查询结果列表是否为空，如果为空则直接返回。</li><li>遍历博客列表，从每个博客对象中提取分类和标签的UID。</li><li>使用收集的UIDs从服务层获取相应的分类和标签对象。</li><li>将分类和标签对象转换成Map，方便后续根据UID快速查找。</li><li>再次遍历博客列表，为每个博客设置对应的分类和标签列表。</li><li>最后，将更新后的博客列表设置回分页结果对象中。</li></ol><p>这个过程允许在返回博客列表之前丰富每个博客对象的信息，如添加分类和标签数据。以便提供更详细的信息给前端显示。</p><blockquote><p>添加博客</p></blockquote><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务场景和技术选型</title>
    <link href="/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <url>/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="业务场景和技术选型需要考虑的因素"><a href="#业务场景和技术选型需要考虑的因素" class="headerlink" title="业务场景和技术选型需要考虑的因素"></a>业务场景和技术选型需要考虑的因素</h3><h3 id="成长和思考"><a href="#成长和思考" class="headerlink" title="成长和思考"></a>成长和思考</h3><h4 id="1、当小A-接到需求后的反应-🏌️"><a href="#1、当小A-接到需求后的反应-🏌️" class="headerlink" title="1、当小A 接到需求后的反应 🏌️"></a>1、当小A 接到需求后的反应 🏌️</h4><p>对于一个需求来说，我们应该站在一个评审的态度去看待他。</p><p>接到产品经理的需求后，我们应该从有利于业务的角度出发思考，对这个需求进行删、改、增。</p><p>同时最重要的一个地方是，你需要有自己的一个思考和自己的实践，并去落实他和推动一些东西，让你的思考能够落地并看到成效。</p><p>有自己的思考和整体业务的理解，将有助于你整体的一个职业生涯，对于你目前所做的事情，也许在未来某个地方，能够结合你当时的一个背景，做出有点酷并很有用的东西。</p><h4 id="2、提高某件事情的效率-🦖"><a href="#2、提高某件事情的效率-🦖" class="headerlink" title="2、提高某件事情的效率  🦖"></a>2、提高某件事情的效率  🦖</h4><p>对于项目中的现成代码，我们应该去理性思考，</p><ul><li>第一，这些代码为什么这么写呢，写的逻辑是什么，有什么好处呢。</li><li>第二，这些代码能够优化吗，哪些地方存在瓶颈呢，如何优化。优化的解决方案有哪些，我们应该怎么处理。</li><li>第三，保持持续学习，了解程序实现的底层逻辑，对于计算机操作系统、数据结构、组成原理等能够有比较好的认识和理解。</li><li>第四，对于 ToC  的项目，我们应该考虑一下服务 QPS 能支撑多少，心里对于流量阈值有一个清楚认知，针对这个阈值如何提高优化，性能是否符合预期，是一个需要考虑很多方面和内容的问题。</li><li>第五，对于生产环境和测试环境的区别，是非常大的，生产环境遇到的复杂性问题，我们需要随时养成关注线上服务运行的一个情况；一些基础的内容，比如请求峰值的时候 CPU、内存的消耗、网络端口消耗等都是我们需要去关注的一些点，并在实践中养成这个习惯。</li><li>第六，了解整个项目整体业务，不要给自己的工作设定边界。</li><li>第七，归纳总结复盘。</li></ul><p>关于第二点，在 JavaGuide 网站文章中一句话写的很好，借鉴引用一下：</p><div style="background-color: #3498db; color: white; padding: 10px;">   主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！</div><h4 id="3、学习的时候一些坑不要去碰-🤕"><a href="#3、学习的时候一些坑不要去碰-🤕" class="headerlink" title="3、学习的时候一些坑不要去碰 🤕"></a>3、学习的时候一些坑不要去碰 🤕</h4><ul><li>多去看官方文档，多去看实际的源码，尽量少的去看一下垃圾博客</li><li>关注细节</li><li>及时反馈</li><li>规范，以及规范（代码，注释，接口，方法名称，文档，技术名称，日志，测试）</li><li>多实际去写代码（不要一说就会，一写就废）</li><li>重要的变更和接口内容一定要写文档</li><li>理解需求后，再开始写代码</li><li>多思考，有自己的理解后再去询问一些东西（积极沟通）</li><li>生产环境不要动</li></ul><h3 id="未来就业方向选择"><a href="#未来就业方向选择" class="headerlink" title="未来就业方向选择"></a>未来就业方向选择</h3><p>在目前这种趋势的未来中，对于顶层设计的要求从业人员其实是越来越高的，需求量也要减少（已经有很多现成的解决方案），未来的就业市场需要的反而是中低层人员，而随着GPT等人工智能的发展，技术人员的可替代性其实是很强的。</p><div style="background: linear-gradient(to right, #6dd5fa, #ff758c); color: white; padding: 15px;">  义无反顾的抓住每一个管理岗机会。</div><ul><li>驾驭管理<ul><li>模仿周围优秀管理者</li><li>找机会锻炼 展示能力</li></ul></li><li>顶层架构<ul><li>大量研读吸收  架构设计方案</li></ul></li></ul><p>推荐书籍：《软件平台管理架构设计与技术管理之道》</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_基础概念</title>
    <link href="/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Redis 是什么</li><li>Redis 的常用数据类型</li><li>Redis为什么这么快</li><li>Redis 和 Memcached 的区别和共同点</li><li>Redis的缓存读写策略</li><li>Redis 能做什么</li><li>Redis持久化机制</li><li>Redis线程模型</li><li>Redis内存管理</li></ul><h3 id="1、Redis-是什么"><a href="#1、Redis-是什么" class="headerlink" title="1、Redis 是什么"></a>1、Redis 是什么</h3><p>Redis是一种支持key-value等多种数据结构的存储系统；数据保存在内存中，支持持久化。</p><p>可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，支持事务、持久化、Lua脚本，集群。</p><p>下面是部分特性：</p><ul><li><strong>读写性能优异</strong><ul><li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （基于内存，基于Reactor 模式）</li></ul></li><li><strong>数据类型丰富</strong><ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li><strong>原子性</strong><ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li><strong>丰富的特性</strong><ul><li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li></ul></li><li><strong>持久化</strong><ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li><strong>分布式</strong><ul><li>Redis Cluster</li></ul></li></ul><h3 id="2、Redis-的常用数据类型"><a href="#2、Redis-的常用数据类型" class="headerlink" title="2、Redis 的常用数据类型"></a>2、Redis 的常用数据类型</h3><ul><li><strong>5种基础数据类型</strong>，分别是：String、List、Set、Zset、Hash。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><ul><li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置)</li></ul><p>Redis 的数据表示</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312251645493.png" alt="image.png"></p><h3 id="3、Redis为什么这么快？"><a href="#3、Redis为什么这么快？" class="headerlink" title="3、Redis为什么这么快？"></a>3、Redis为什么这么快？</h3><ul><li>基于内存操作</li><li>数据结构优化</li><li>单线程事件驱动模型</li><li>专门为高性能而设计（专注于核心功能，设计简洁，功能强大）</li></ul><h3 id="4、Redis-和-Memcached-的区别和共同点"><a href="#4、Redis-和-Memcached-的区别和共同点" class="headerlink" title="4、Redis 和 Memcached 的区别和共同点"></a>4、Redis 和 Memcached 的区别和共同点</h3><div style="background-color: #ecf0f1; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>区别点：</strong>实际回答的时候建议通过从Redis 的一些特性去回答，如果问到 Memcached 到时候可以从 数据类型、过期策略、集群、持久化方面去回答主要区别点。</div><p>Redis和Memcached都是广泛使用的高性能内存缓存系统，但它们在设计、功能和使用案例方面有一些显著的区别和共同点。</p><p>共同点</p><ol><li><strong>基于内存的存储</strong>：Redis和Memcached都是基于内存的键值存储系统，提供快速的数据读写能力。</li><li><strong>高性能</strong>：两者都是为了提高数据访问速度而设计的，能够处理大量并发请求。</li><li><strong>简单的键值数据模型</strong>：它们使用简单的键值对模型来存储数据。</li><li><strong>缓存用途</strong>：通常被用作数据库前的缓存系统，以减少对后端数据库的访问压力。</li></ol><p>区别</p><ol><li><strong>数据类型支持</strong>：<ul><li><strong>Redis</strong>：支持更丰富的数据类型，如字符串、哈希、列表、集合、有序集合、位图、HyperLogLogs等。</li><li><strong>Memcached</strong>：主要支持简单的键值数据类型。</li></ul></li><li><strong>持久化</strong>：<ul><li><strong>Redis</strong>：提供数据持久化功能，可以将内存中的数据保存到硬盘中，防止数据丢失。Redis支持RDB（快照）和AOF（追加文件）两种持久化方式。</li><li><strong>Memcached</strong>：不提供持久化功能，主要用作纯内存缓存。</li></ul></li><li><strong>数据过期机制</strong>：<ul><li><strong>Redis</strong>和<strong>Memcached</strong>都支持设置键的过期时间，但Redis在处理过期键方面更为灵活。</li></ul></li><li><strong>分布式支持</strong>：<ul><li><strong>Redis</strong>：有原生的集群模式，支持数据分片和高可用性。</li><li><strong>Memcached</strong>：通常依赖客户端来实现数据分布，没有内置的集群功能。</li></ul></li><li><strong>原子操作和脚本</strong>：<ul><li><strong>Redis</strong>：支持事务、原子操作和Lua脚本，这增加了其在复杂操作方面的能力。</li><li><strong>Memcached</strong>：提供有限的原子操作，不支持脚本。</li></ul></li><li><strong>发布&#x2F;订阅模式</strong>：<ul><li><strong>Redis</strong>：支持发布&#x2F;订阅消息模式，适用于消息队列等应用。</li><li><strong>Memcached</strong>：不支持发布&#x2F;订阅模式。</li></ul></li></ol><p>使用场景</p><ul><li><strong>Redis</strong>：<ul><li>由于其丰富的数据类型和功能，适用于需要复杂数据结构和原子操作的场景。</li><li>适用于需要数据持久化的场景。</li><li>可用作消息队列、会话存储、全页缓存等。</li></ul></li><li><strong>Memcached</strong>：<ul><li>由于其简单性和高效性，适用于需要快速轻量级缓存的场景。</li><li>适合作为纯内存缓存使用，如简单的会话缓存。</li></ul></li></ul><p>Redis和Memcached虽然都是内存缓存系统，但Redis提供了更丰富的数据类型和功能，包括数据持久化、复杂的操作和消息队列功能。</p><p>而Memcached则更加轻量级，适用于简单的缓存需求。选择哪一个取决于具体的应用需求和环境。</p><p>JavaGudie 的一些内容总结，也可以参考下:</p><p><strong>共同点</strong>：</p><ol><li>都是基于内存的数据库，一般都用来当做缓存使用。</li><li>都有过期策略。</li><li>两者的性能都非常高。</li></ol><p><strong>区别</strong>：</p><ol><li><strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k&#x2F;v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k&#x2F;v 数据类型。</li><li><strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li><strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li><strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li><strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li><strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 针对网络数据的读写引入了多线程）</li><li><strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li><strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h3 id="5、常用的缓存读写策略"><a href="#5、常用的缓存读写策略" class="headerlink" title="5、常用的缓存读写策略"></a>5、常用的缓存读写策略</h3><div style="background-color: #f2c867; color: #34495e; padding: 15px; border: 2px solid #bdc3c7; border-radius: 5px;">  <strong>缓存常用的三种读写策略：</strong>Cache Aside Pattern（旁路缓存模式）、Read/Write Through Pattern（读写穿透）、Write Behind Pattern（异步缓存写入）</div><p><strong>三种模式各有优劣，不存在最佳模式，根据具体的业务场景选择适合自己的缓存读写模式。</strong></p><h4 id="Cache-Aside-Pattern（旁路缓存模式）"><a href="#Cache-Aside-Pattern（旁路缓存模式）" class="headerlink" title="Cache Aside Pattern（旁路缓存模式）"></a>Cache Aside Pattern（旁路缓存模式）</h4><p>适合读比较多的情况</p><p>写：</p><ul><li>先更新 db</li><li>然后直接删除 cache</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225211100.png" alt="image.png"></p><p><strong>读</strong> :</p><ul><li>从 cache 中读取数据，读取到就直接返回</li><li>cache 中读取不到的话，就从 db 中读取数据返回</li><li>再把数据放到 cache 中。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225211235.png" alt="image.png"></p><blockquote><p><strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong></p></blockquote><p>这种操作不能进行，会造成数据库和缓存数据不一致。</p><p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p><p>说明：</p><p>当有一个请求（我们称之为请求1）来更新某个数据项（称为数据A）时，你面临一个选择：是先更新数据库中的数据A，然后再删除缓存中的数据A，还是先删除缓存中的数据A，然后更新数据库？</p><p>如果选择后者（即先删除缓存，后更新数据库），会有以下风险：</p><ol><li><strong>请求1</strong>先删除了缓存中的数据A。</li><li>然后，在<strong>请求1</strong>更新数据库中的数据A之前，另一个请求（称之为请求2）来读取数据A。</li><li><strong>请求2</strong>在缓存中找不到数据A（因为已经被删除），所以它从数据库中读取了旧的数据A。</li><li>此时，<strong>请求1</strong>更新了数据库中的数据A。</li><li>结果是，缓存中没有数据A的记录（已被删除），而数据库中有新的数据A。<strong>请求2</strong>持有的是过时的数据。</li></ol><p>这种情况就导致了数据不一致：缓存失效了，但是请求2读取到了旧的数据。下次有请求来读取数据A时，它会再次从数据库中读取并缓存新的数据A，但在这之前，系统中存在数据不一致的状态。</p><p>通常，更好的做法是：</p><ol><li><strong>先更新数据库</strong>中的数据A。</li><li><strong>然后删除缓存</strong>中的数据A。</li></ol><p>这样，即使在数据库更新和缓存删除之间有读取请求，它也只会读到旧的数据，一旦缓存被删除，<strong>下一个读取请求将从数据库中获取最新的数据，并更新缓存</strong>，从而保持了一致性。</p><blockquote><p><strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong></p></blockquote><p>理论上仍然是会出现的，但概率非常小，缓存的写入速度比数据库的写入速度快很多。</p><p>特定情况：</p><ul><li>在数据库更新之后，但在缓存删除之前，如果另一个请求（称为请求2）来读取同一数据，它将从缓存中获取到旧的数据。因为此时缓存尚未被更新或删除。</li><li>一旦缓存被删除，随后的请求将从数据库中读取最新的数据，并更新缓存。但在这个短暂的时期内，旧的缓存数据和新的数据库数据之间存在不一致。</li></ul><blockquote><p><strong>Cache Aside Pattern 的缺陷</strong>以及解决方案</p></blockquote><p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p><p>解决办法：可以将热点数据可以提前放入 cache 中。</p><p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p><p>解决办法：</p><ul><li>数据库和缓存数据强一致场景：<ul><li>更新 db 的时候同样更新 cache，不过我们需要加一个锁&#x2F;分布式锁来保证更新 cache 的时候不存在线程安全问题。</li></ul></li><li>可以短暂地允许数据库和缓存数据不一致的场景：<ul><li>更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小</li></ul></li></ul><h4 id="Read-Write-Through-Pattern（读写穿透）"><a href="#Read-Write-Through-Pattern（读写穿透）" class="headerlink" title="Read&#x2F;Write Through Pattern（读写穿透）"></a>Read&#x2F;Write Through Pattern（读写穿透）</h4><p>Read&#x2F;Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。</p><p>cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p><p><strong>写（Write Through）：</strong></p><ul><li>先查 cache，cache 中不存在，直接更新 db。</li><li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225212801.png" alt="image.png"></p><p><strong>读(Read Through)：</strong></p><ul><li>从 cache 中读取数据，读取到就直接返回 。</li><li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231225212846.png" alt="image.png"></p><p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p><p>Read&#x2F;Write Through Pattern（读写穿透）这种方式使用的不多，我们常用的分布式缓存Redis并没有提供 cache 将数据写入 db 的功能。</p><h4 id="Write-Behind-Pattern（异步缓存写入）"><a href="#Write-Behind-Pattern（异步缓存写入）" class="headerlink" title="Write Behind Pattern（异步缓存写入）"></a>Write Behind Pattern（异步缓存写入）</h4><p>Write Behind Pattern 和 Read&#x2F;Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p><p>不同点：</p><ul><li>**Read&#x2F;Write Through 是同步更新 cache 和 db，</li><li>Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db</li></ul><p>数据一致性风险很大，不过Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p><h3 id="6、Redis-能做什么"><a href="#6、Redis-能做什么" class="headerlink" title="6、Redis 能做什么"></a>6、Redis 能做什么</h3><ul><li>缓存</li><li><strong>分布式锁</strong></li><li>限流</li><li>消息队列</li><li>延时队列</li><li>分布式 session</li><li>复杂业务场景 …..</li></ul><h3 id="7-、Redis-持久化机制"><a href="#7-、Redis-持久化机制" class="headerlink" title="7 、Redis 持久化机制"></a>7 、Redis 持久化机制</h3><p>to be contined….</p><h3 id="8、Redis-线程模型"><a href="#8、Redis-线程模型" class="headerlink" title="8、Redis 线程模型"></a>8、Redis 线程模型</h3><h3 id="9、Redis-内存管理"><a href="#9、Redis-内存管理" class="headerlink" title="9、Redis 内存管理"></a>9、Redis 内存管理</h3><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/redis/cache-basics.html">https://javaguide.cn/database/redis/cache-basics.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis">https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis</a></li><li><a href="https://www.cnblogs.com/powertoolsteam/p/redis.html">https://www.cnblogs.com/powertoolsteam/p/redis.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_进阶内容</title>
    <link href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>线程模型</li><li>悲观锁</li><li>乐观锁</li><li>ReentrantLock<ul><li>AQS</li><li>CAS</li></ul></li></ul><h3 id="1、什么是线程模型？"><a href="#1、什么是线程模型？" class="headerlink" title="1、什么是线程模型？"></a>1、什么是线程模型？</h3><blockquote><p>先回顾一下线程和进程的区分</p></blockquote><ul><li>进程：<ul><li>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul></li><li>线程<ul><li>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><blockquote><p>什么是线程模型</p></blockquote><p>并发编程在计算机中如何实现的，在 Java 开发领域中，JVM线程对不同操作系统上的原生线程进行了高级抽象，使开发者大多数情况下可以不用关注下层细节，而只要专注上层开发。</p><p>JVM线程与操作系统线程之间存在着某种映射关系，这两种<strong>不同维度的线程之间的规范和协议</strong>，就是线程模型。</p><blockquote><p>用户线程和内核线程</p></blockquote><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><blockquote><p>线程模型类型</p></blockquote><p>JVM线程模型有三种模型：一对一、多对一、多对多。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161619698.png" alt="image.png"></p><p><strong>一对一</strong></p><p>在Jva线程（用户线程）与操作系统线程(KLT)之间建立一对一的关系，简单粗暴，但好用。</p><ul><li>优点：<ul><li>每个线程都是独立的调度单元，直接利用操作系统内核提供的调度功能。</li></ul></li><li>缺点：<ul><li>用户线程的阻塞唤醒，会直接映射到内核线程上，容易<strong>引起频繁切换，降低性</strong>能。但是一些语言引入了CAS来避免一部分的内核调用，比如Java 引入了AQS这种函数级别的锁，<strong>减少使用内核级别的锁</strong>，就能提升性能。</li></ul></li></ul><p>目前大部分主流 JVM 上都是采用的这种线程模型。</p><p><strong>多对一模型</strong></p><ul><li>优点<ul><li>用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快：</li></ul></li><li>缺点<ul><li>如果其中一个用户线程阻塞，其他用户线程也无法执行</li><li>这种模型下，内核并不知道用户态有哪些线程，调度和优先级等不完整。</li></ul></li></ul><p><strong>多对多模型</strong></p><ul><li>优点：兼具前两者的优点</li><li>缺点：实现复杂</li></ul><p>目前主流语言中，Java 使用的是 一对一线程模型；Go 语言使用的是 多对多线程模型；Python 的 gevent 使用的多对一线程模型。</p><h3 id="2、悲观锁机制"><a href="#2、悲观锁机制" class="headerlink" title="2、悲观锁机制"></a>2、悲观锁机制</h3><p>在了解悲观锁机制前，我们先来了解一下什么是锁。</p><h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>在并发环境下，会出现多个线程对同一个资源进行争抢的情况，假设A线程对资源正在进行修改，此时<br>B线程此时又对资源进行了修改，这就可能会导致数据不一致的问题。</p><p>为了解决这个问题，引入了锁机制，<strong>通过一种抽象的“锁”来对资源进行锁定</strong>，当一个线程持有“锁”的时候，其他线程必须等待“锁”，本质上是在临界资源上对线程进行一种串行化。</p><h4 id="Java语言的锁机制"><a href="#Java语言的锁机制" class="headerlink" title="Java语言的锁机制"></a>Java语言的锁机制</h4><blockquote><p>Java 虚拟机的内存结构</p></blockquote><p>在了解 Java语言锁机制之前，我们先对简单了解一下 Java 虚拟机的内存结构。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116222015.png" alt="image.png"></p><p>JVM 运行时内存结构主要包含了五个部分：</p><ul><li>程序计数器(PC寄存器)、</li><li>JVM栈、</li><li>Native方法栈、</li><li>堆、</li><li>方法区。</li></ul><p>上图中，红色区域是各个线程私有的。这个区域中的数据，不会出现线程竞争的关系。</p><p>而蓝色区域中的数据被所有线程共享，其中Jva堆中存放的是大量对象，方法区中<strong>存放类信息、常量、静态变<br>量</strong>等数据。</p><p>当多个线程在竞争其中的一些数据时，可能会发生难以预料的异常情况。在程序开发中，锁的主要应用范围就是在数据共享区域。</p><p>在代码层面，Jvva 主要采用了两种实现方式：</p><ul><li>1.基于Object的悲观锁。</li><li>2.基于CAS的乐观锁。</li></ul><p>本章主要讲解基于Object的悲观锁。</p><blockquote><p>悲观锁机制</p></blockquote><p>悲观锁总是假设最坏的情况，认为共享资源<strong>每次被访问的时候就会出现问题</strong>(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</p><p>也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><blockquote><p>基于Object的悲观锁</p></blockquote><p>在Java中，每个Object,也就是每个对象都拥有一把锁，这把锁存放在对象头中，记录了当前对象被哪个线程占用。</p><blockquote><p>对象和对象头的结构</p></blockquote><p><strong>Java 对象</strong></p><p>Java对象分为三个部分：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充字节</li></ul><p>其中对齐填充字节是为了满足“Java对象大小是8字节的倍数”这一条件而设计的，为对象对齐填充了一些无用字节。</p><p>实例数据是在初始化对象时设定的属性和状态等内容。</p><p><strong>对象头</strong></p><p>对象头存放了一些对象本身的运行时信息。对象头包含了两部分：</p><ul><li>Mark Word</li><li>Class Pointer</li></ul><p>相较于实例数据，对象头属于一些额外的存储开销，它被设计得极小（一般为232bt或264bt) 来提升效率。</p><p>Class Pointer是一个指针，指向当前对象类型所在方法区中的Class信息；</p><p>Mark Word 存储了<strong>很多当前对象的运行时状态信息</strong>，比如 HashCode.、锁状态标志、指向锁记录的指针、偏向线程 ID、锁标志位等等。</p><p>可以通过下面这张表对 Mark Word有一个更直观的认识：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116223405.png" alt="image.png"></p><p>“锁”的信息存储在对象头的Mark Word中。Mark Word 的最后两位，代表锁标志位，分别对应“无锁”、“偏向锁”、“轻量级锁”、“重量级锁”四种状态。</p><p>在Java中，启用对象锁的方式是使用<code>synchronized</code>关键字。</p><h4 id="对象锁的四种状态"><a href="#对象锁的四种状态" class="headerlink" title="对象锁的四种状态"></a>对象锁的四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p><p>锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><h3 id="3、乐观锁机制"><a href="#3、乐观锁机制" class="headerlink" title="3、乐观锁机制"></a>3、乐观锁机制</h3><p>在多个线程对于同一个资源进行访问的访问，互斥锁的方式是悲观的，在线程访问的时候，互斥锁会锁定资源，<strong>只供一个线程调用，而阻塞其他线程</strong>，让其他线程等待。</p><p>在一些情况下，同步代码块执行的耗时远远小于线程切换的耗时，这种情况下使用互斥锁对性能是不太划算的。在这种场景下，直接在用户态对线程的切换进行管理，效率更高。实际操作的时候是通过每次使用同步原语对共享资源进行锁定，让线程反复“乐观”地去尝试获取共享资源，如果发现空闲，那么使用，如果被占用，那么继续“乐观”地重试。</p><blockquote><p>乐观锁和悲观锁<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231207231904.png" alt="image.png"></p></blockquote><blockquote><p>CAS</p></blockquote><p>在 Java 中，实现这种同步原语的算法是 CAS (Compare And Swap)。</p><p>简单翻译是：比较然后交换</p><p>CAS操作包含三个操作数：内存位置（要更新的变量）、预期原值和新值。</p><p><strong>工作原理</strong></p><ol><li><strong>检查和更新</strong>：<ul><li>CAS首先检查<strong>目标内存位置的当前值</strong>是否与预期原值相同。如果相同，它会将该内存位置的值更新为新值。</li><li>如果目标值已被其他线程改变（不等于预期原值），CAS操作失败。</li></ul></li><li><strong>无锁操作</strong>：<ul><li>CAS提供了一种无需锁定的方式来实现并发控制，减少了锁的开销和复杂性。</li></ul></li></ol><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    CAS操作是原子性的。</div><h3 id="4、悲观锁和乐观锁"><a href="#4、悲观锁和乐观锁" class="headerlink" title="4、悲观锁和乐观锁"></a>4、悲观锁和乐观锁</h3><h4 id="悲观锁示例"><a href="#悲观锁示例" class="headerlink" title="悲观锁示例"></a>悲观锁示例</h4><p>在Java中，悲观锁通常是通过<code>synchronized</code>关键字或<code>ReentrantLock</code>类实现的。</p><p><code>synchronized</code> 使用示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PessimisticLockExample &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> increment() &#123;<br>        <span class="hljs-keyword">count</span>++;  <span class="hljs-comment">// 仅当持有对象锁时，才能执行此操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> getCount() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;  <span class="hljs-comment">// 同样，需要持有对象锁才能执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们用<code>synchronized</code>关键字锁定了整个方法。</p><p>当一个线程进入<code>increment</code>或<code>getCount</code>方法时，它必须先获得这个对象的锁。在这段时间内，其他任何试图进入这些同步方法的线程都会被阻塞。</p><h4 id="乐观锁示例"><a href="#乐观锁示例" class="headerlink" title="乐观锁示例"></a>乐观锁示例</h4><p>乐观锁通常是通过CAS（比较并交换）操作实现的。</p><p>在Java中，<code>AtomicInteger</code>类提供了一种使用乐观锁的方式。以下是一个使用<code>AtomicInteger</code>实现乐观锁的示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimisticLockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> void increment() &#123;<br>        int currentValue;<br>        int <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = count.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 获取当前值</span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">Value</span> = currentValue + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!count.compareAndSet(currentValue, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)); <span class="hljs-comment">// CAS操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int getCount() &#123;<br>        <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>AtomicInteger</code>的<code>compareAndSet</code>方法实现了CAS操作。</p><p>它会比较<code>count</code>的当前值和<code>currentValue</code>。如果相同，它会更新<code>count</code>为<code>newValue</code>。这个过程是无锁的，即使在并发环境下也不会阻塞其他线程。如果<code>count</code>的值在此期间被其他线程修改，<code>compareAndSet</code>会返回<code>false</code>，循环继续，直到更新成功。</p><blockquote><p>对比</p></blockquote><ul><li><strong>悲观锁</strong>（<code>synchronized</code>，<code>ReentrantLock</code>）适用于写操作多的场景，因为它防止了多个线程同时写入，减少了冲突。</li><li><strong>乐观锁</strong>（如<code>AtomicInteger</code>的CAS操作）适用于读操作多的场景，它不会阻塞线程，但在写操作频繁的情况下可能会导致高重试成本。</li></ul><h3 id="5、ReentrantLock"><a href="#5、ReentrantLock" class="headerlink" title="5、ReentrantLock"></a>5、ReentrantLock</h3><h4 id="ReentrantLock-的基础使用"><a href="#ReentrantLock-的基础使用" class="headerlink" title="ReentrantLock 的基础使用"></a>ReentrantLock 的基础使用</h4><p>在并发编程中，悲观锁是一种策略，它假设最坏的情况：即在多个线程尝试同时访问共享资源时，会发生冲突。因此，悲观锁在访问任何共享资源之前会先锁定它，以防止其他线程的访问，直到它完成操作并释放锁。</p><blockquote><p>ReentrantLock（可重入锁）</p></blockquote><p><code>ReentrantLock</code> 是一个可重入的互斥锁，它提供了比 <code>synchronized</code> 关键字更高级的功能，如可中断的锁获取操作、公平锁策略、锁绑定多个条件等。</p><blockquote><p>基于 AQS 的实现</p></blockquote><ul><li>AQS 提供了一种管理锁状态的框架，并处理了线程的排队和阻塞。在 <code>ReentrantLock</code> 的实现中，AQS 负责维护一个表示锁状态的变量和一个由等待锁的线程组成的队列。</li><li>当一个线程尝试获取 <code>ReentrantLock</code> 时，AQS 会检查锁的状态，然后要么授予锁（如果当前未被其他线程持有），要么将尝试获取锁的线程放入等待队列。</li></ul><blockquote><p>悲观锁的特性</p></blockquote><ul><li><code>ReentrantLock</code> 作为一种悲观锁，是基于这样的假设：如果不采取措施，多个线程同时修改同一个资源会导致问题。因此，它在修改资源之前先加锁，防止其他线程同时进行写操作。</li><li>这与乐观锁的策略不同，乐观锁允许多个线程进入临界区，但在实际修改数据时检查是否存在冲突。</li></ul><p>示例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>()</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();  <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们在修改 <code>count</code> 变量之前获取了锁，并在操作完成后释放了锁。</p><p>这确保了即使多个线程尝试同时调用 <code>increment</code> 方法，<code>count</code> 的增加也是线程安全的。</p><h4 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h4><p><code>ReentrantLock</code> 是 Java 并发包中的一个重要组件，基于 AQS 实现。</p><p>基本原理</p><ol><li><strong>可重入性</strong>：<ul><li><code>ReentrantLock</code> 是一个可重入锁。这意味着同一个线程可以多次获取同一个锁而不会发生死锁。这是通过为每个锁维护一个持有计数和一个指向当前持有锁的线程的引用来实现的。</li></ul></li><li><strong>基于 AQS</strong>：<ul><li><code>ReentrantLock</code> 的实现依赖于 AQS。AQS 使用一个整型的 volatile 变量来表示同步状态，并使用一个 FIFO 队列来管理那些等待获取锁的线程。</li></ul></li><li><strong>锁的状态</strong>：<ul><li>在 <code>ReentrantLock</code> 中，锁的状态是由 AQS 的同步状态变量来表示的。状态为 0 表示锁是可用的，状态为 1 表示锁被一个线程持有，大于 1 表示同一个线程重入了这个锁。</li></ul></li><li><strong>获取锁</strong>：<ul><li>当一个线程尝试获取锁时，如果同步状态为 0，AQS 会尝试通过 CAS（比较并交换）操作将状态设置为 1，从而获取锁。</li><li>如果锁已经被其他线程持有（同步状态非 0），那么尝试获取锁的线程会被加入到 AQS 维护的等待队列中。</li></ul></li><li><strong>释放锁</strong>：<ul><li>当线程完成任务后，它会调用 <code>unlock</code> 方法来释放锁。这将减少 AQS 同步状态的计数。当计数降到 0 时，锁被完全释放，等待队列中的下一个线程将有机会获取锁。</li></ul></li></ol><p>公平性和非公平性</p><ul><li><strong>公平锁</strong>：在公平模式下，<code>ReentrantLock</code> 会按照线程在等待队列中的等待顺序来获取锁。这意味着首先进入等待队列的线程将先获得锁。</li><li><strong>非公平锁</strong>：在非公平模式下，当锁可用时，任何请求它的线程都有机会获取锁。这可能不会遵守等待队列中的顺序。</li></ul><p>性能考量</p><ul><li><strong>选择公平性</strong>：公平锁通常会有较低的性能，因为它严格按照等待队列来分配锁，但它可以减少线程饥饿的情况。</li><li><strong>选择非公平性</strong>：非公平锁可能会有更好的性能，但可能导致线程饥饿，因为某些线程可能会长时间等待而不得不频繁地重新调度。</li></ul><p><code>ReentrantLock</code> 提供了一种灵活的锁定机制，通过 AQS 实现了可重入性和可选的公平性。</p><p>它允许更细粒度的锁控制，从而在高度竞争的环境中提供比内置 <code>synchronized</code> 更高的性能和更强的功能。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h5><p><code>ReentrantLock</code> 本身是一个相对简单的类，它依赖于内部类 <code>Sync</code> 的实现，而 <code>Sync</code> 是 <code>AbstractQueuedSynchronizer</code> 的子类。</p><p>在 <code>ReentrantLock</code> 中，有两个主要的内部类：<code>FairSync</code> 和 <code>NonfairSync</code>，分别对应公平锁和非公平锁的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-title">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> sync;<br><br>    <span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-comment">// ... 实现细节</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 非公平锁实现</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 公平锁实现</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数等其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Sync-类"><a href="#Sync-类" class="headerlink" title="Sync 类"></a>Sync 类</h5><p><code>Sync</code> 类是 <code>AbstractQueuedSynchronizer</code> 的一个扩展，提供了大部分与锁状态管理相关的功能。</p><p>它使用 AQS 的状态变量来表示锁的持有次数，以及持有锁的线程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean isHeldExclusively() &#123;<br>        <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == <span class="hljs-type">Thread</span>.currentThread();<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> void lock() &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法，包括 tryAcquire, tryRelease 等</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="公平锁和非公平锁的实现"><a href="#公平锁和非公平锁的实现" class="headerlink" title="公平锁和非公平锁的实现"></a>公平锁和非公平锁的实现</h5><p><code>FairSync</code> 和 <code>NonfairSync</code> 类重写了 <code>tryAcquire</code> 方法以提供不同的锁获取策略。</p><ul><li><strong>非公平锁</strong>（<code>NonfairSync</code>）：在尝试获取锁时，会立即尝试改变状态，而不检查等待队列。</li><li><strong>公平锁</strong>（<code>FairSync</code>）：在尝试获取锁之前，会检查等待队列，以确保队列中的线程先获得服务。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现非公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br><br>static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h5><p>AQS 是实现锁和其他同步器的框架。它使用一个 int 类型的 volatile 变量来表示同步状态，并使用一个队列来管理那些未能成功获取同步状态的线程。</p><ul><li><strong>状态管理</strong>：AQS 提供了一系列方法来操作其状态变量，如 <code>getState()</code>, <code>setState(int)</code> 和 <code>compareAndSetState(int, int)</code>。</li><li><strong>队列管理</strong>：AQS 维护了一个等待队列，当线程尝试获取资源失败时，它会被加入到这个队列中。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> head;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> tail;<br>    <span class="hljs-keyword">private</span> volatile int state;<br><br>    <span class="hljs-comment">// 内部类 Node，队列节点的定义</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-comment">// Node 的结构和方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 状态管理和队列操作的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="锁的获取与释放"><a href="#锁的获取与释放" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h5><ul><li><strong>获取锁</strong>：当 <code>ReentrantLock</code> 的 <code>lock()</code> 方法被调用时，实际上是调用了 <code>Sync</code> 类的 <code>acquire</code> 方法，该方法又会调用 <code>tryAcquire</code> 方法。<code>tryAcquire</code> 的具体实现取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>。</li><li><strong>释放锁</strong>：<code>unlock()</code> 方法调用 <code>Sync</code> 类的 <code>release</code> 方法，进而调用<code>tryRelease</code> 方法。这个方法会更新同步状态，并在状态变为 0 时（即锁被完全释放时），唤醒等待队列中的线程.</li></ul><h5 id="获取锁的过程"><a href="#获取锁的过程" class="headerlink" title="获取锁的过程"></a>获取锁的过程</h5><ol><li>当一个线程调用 <code>lock()</code> 方法时，它实际上调用的是 <code>Sync</code> 类中的 <code>acquire(int)</code> 方法。</li><li><code>acquire(int)</code> 方法会调用重写的 <code>tryAcquire(int)</code> 方法（取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>）。<ul><li>在 <code>NonfairSync</code> 中，它会立即尝试获取锁，不管其他线程是否在等待。</li><li>在 <code>FairSync</code> 中，它会先检查队列，以确保没有其他线程在等待时间更长。</li></ul></li></ol><h5 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h5><ol><li>当线程调用 <code>unlock()</code> 方法时，实际上是调用 <code>Sync</code> 类的 <code>release(int)</code> 方法。</li><li><code>release(int)</code> 方法内部会调用 <code>tryRelease(int)</code> 方法，该方法检查当前线程是否是锁的持有者，并尝试将同步状态设置回 0。</li><li>如果同步状态成功设置回 0，表示锁已经被释放，等待队列中的其他线程可能会被唤醒并尝试获取锁。</li></ol><h5 id="AQS-中的等待队列"><a href="#AQS-中的等待队列" class="headerlink" title="AQS 中的等待队列"></a>AQS 中的等待队列</h5><p>AQS 使用一个内部的 FIFO 队列来管理那些无法获取到锁的线程。</p><p>每个节点代表一个线程。当一个线程无法获取到锁时，它会被包装成一个节点加入到队列的末尾。当锁被释放时，队列头部的节点会被唤醒并尝试再次获取锁。</p><h5 id="CAS-在-AQS-中的使用"><a href="#CAS-在-AQS-中的使用" class="headerlink" title="CAS 在 AQS 中的使用"></a>CAS 在 AQS 中的使用</h5><p>AQS 使用 CAS 操作来安全地修改同步状态。这是一种无锁的原子操作，可以保证即使在多个线程同时尝试修改状态时，同步状态的更新也是一致的。</p><blockquote><p>总结</p></blockquote><p><code>ReentrantLock</code> 的实现依赖于 AQS 的强大功能，提供了一种灵活且高效的方式来处理并发编程中的同步问题。</p><p>通过将锁的具体实现细节委托给 AQS，<code>ReentrantLock</code> 不仅提供了基本的锁功能，还支持如公平性&#x2F;非公平性选择、条件变量、以及锁的可重入性等高级特性。</p><hr><p>参考:</p><ul><li><a href="https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866">https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866</a></li><li><a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></li><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.bilibili.com/video/BV1z44y1X7BJ">https://www.bilibili.com/video/BV1z44y1X7BJ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_SpringMVC</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是SpringMVC"><a href="#1、什么是SpringMVC" class="headerlink" title="1、什么是SpringMVC"></a>1、什么是SpringMVC</h3><p>SpringMVC是Spring框架中的一个模块，用于构建Web应用程序，采用了经典的MVC设计模式。</p><p>MVC英文是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><ol><li><strong>模型（Model）：</strong><ul><li>模型代表应用程序的业务逻辑和数据。在SpringMVC中，模型通常是一个POJO（Plain Old Java Object）类，负责封装业务数据。</li><li>模型对象存储应用程序的状态，与数据库进行交互，执行业务逻辑等。</li></ul></li><li><strong>视图（View）：</strong><ul><li>视图负责渲染模型数据并展示给用户。在SpringMVC中，视图通常是JSP（JavaServer Pages）或Thymeleaf等模板引擎。</li><li>视图负责将模型的数据以用户友好的方式呈现，与用户进行交互。</li></ul></li><li><strong>控制器（Controller）：</strong><ul><li>控制器接收用户的请求并决定调用哪个业务逻辑处理方法。在SpringMVC中，控制器通常是一个类，使用注解来标识处理请求的方法。</li><li>控制器处理请求后，调用适当的业务逻辑，获取或更新模型数据，然后选择合适的视图来渲染响应。</li></ul></li><li><strong>前端控制器（Front Controller）：</strong><ul><li>SpringMVC 使用DispatcherServlet作为前端控制器，它是Servlet的一个子类，负责拦截所有进入应用的请求。</li><li>DispatcherServlet将请求分发给相应的处理器（Controller），并将模型数据传递给合适的视图进行渲染。</li></ul></li><li><strong>处理器映射器和视图解析器：</strong><ul><li>处理器映射器负责将请求映射到合适的控制器，根据请求URL找到对应的处理器。</li><li>视图解析器负责将逻辑视图名解析为实际的视图对象，决定使用哪个视图来呈现模型数据。</li></ul></li></ol><h3 id="2、SpringMVC的核心组件"><a href="#2、SpringMVC的核心组件" class="headerlink" title="2、SpringMVC的核心组件"></a>2、SpringMVC的核心组件</h3><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="3、SpringMVC的工作原理"><a href="#3、SpringMVC的工作原理" class="headerlink" title="3、SpringMVC的工作原理"></a>3、SpringMVC的工作原理</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312061453227.png" alt="image.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html">https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc</a></li><li><a href="https://blog.csdn.net/Zhangsama1/article/details/131237139">https://blog.csdn.net/Zhangsama1/article/details/131237139</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_AOP</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h3><p>AOP（Aspect-Oriented Programming:面向切面编程）是一种编程范式，通过在代码中横向插入关注点（如日志、事务），实现对应用程序模块化、可维护性和可重用性的提升。</p><p>AOP 切面编程涉及到的一些专业术语：</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="2、Spring-AOP-的实现"><a href="#2、Spring-AOP-的实现" class="headerlink" title="2、Spring AOP 的实现"></a>2、Spring AOP 的实现</h3><p>Spring AOP基于动态代理实现，</p><ul><li>对于实现了接口的对象，使用JDK Proxy创建代理对象；</li><li>对于未实现接口的对象，使用Cglib生成被代理对象的子类。</li></ul><p>Spring AOP还集成了AspectJ，AspectJ是Java生态系统中最完整的AOP框架，拥有更多功能，特别在切面较多的情况下，选择AspectJ相比Spring AOP更为高效。</p><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-aop.html">https://www.pdai.tech/md/spring/spring-x-framework-aop.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Stream</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/</url>
    
    <content type="html"><![CDATA[<p>Stream 组件是用于封装消息队列来使用的，Bus这个组件一般会结合 Stream 使用；</p><p>看一般性文档解释，主要是围绕 Bus 可以做到配置的动态刷新、事件的传递。具体使用的时候可以看一下相关内容。</p><p>下面内容是引用 ChatGpt 的内容，分别是 Stream 和 Bus 的基本使用。</p><h3 id="1、Spring-Cloud-Stream的使用"><a href="#1、Spring-Cloud-Stream的使用" class="headerlink" title="1、Spring Cloud Stream的使用"></a>1、Spring Cloud Stream的使用</h3><p>Spring Cloud Stream 是一个用于构建消息驱动微服务架构的框架，它基于Spring Boot和Spring Integration，提供了一种简单的方式来实现各个微服务组件之间的消息通信。</p><p>以下是Spring Cloud Stream的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Cloud Stream 的依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-</span><span class="hljs-template-variable">&#123;binder&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>&#123;binder&#125;</code> 可以是不同的消息中间件的名称，比如 RabbitMQ、Kafka 等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置消息中间件的连接信息，以 RabbitMQ 为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">bindings:</span><br>        <span class="hljs-attr">output:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">my-output-topic</span><br>          <span class="hljs-attr">binder:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># RabbitMQ的binder</span><br>      <span class="hljs-attr">rabbit:</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-attr">exchangeType:</span> <span class="hljs-string">topic</span><br>            <span class="hljs-attr">routingKeyExpression:</span> <span class="hljs-string">&#x27;my-output-topic&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>发送消息</li></ol></blockquote><p>在应用程序中使用 <code>Source</code> 接口定义消息发送的输出通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.Output;<br><span class="hljs-keyword">import</span> org.springframework.messaging.MessageChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MySource</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;output&quot;</span>;<br><br>    <span class="hljs-meta">@Output(OUTPUT)</span><br>    MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在需要发送消息的地方注入 <code>MySource</code>，并使用 <code>output()</code> 方法发送消息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">Message</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">support</span>.<span class="hljs-property">MessageBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSenderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MySource</span> mySource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> payload</span>) &#123;<br>        <span class="hljs-title class_">Message</span>&lt;<span class="hljs-title class_">String</span>&gt; message = <span class="hljs-title class_">MessageBuilder</span>.<span class="hljs-title function_">withPayload</span>(payload).<span class="hljs-title function_">build</span>();<br>        mySource.<span class="hljs-title function_">output</span>().<span class="hljs-title function_">send</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>接收消息</li></ol></blockquote><p>在应用程序中使用 <code>@StreamListener</code> 注解定义消息接收的输入通道：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.<span class="hljs-keyword">annotation</span>.StreamListener;<br><span class="hljs-keyword">import</span> org.springframework.messaging.handler.<span class="hljs-keyword">annotation</span>.Payload;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageReceiverService</span> &#123;<br><br>    <span class="hljs-meta">@StreamListener(MySource.INPUT)</span><br>    <span class="hljs-keyword">public</span> void receiveMessage(<span class="hljs-meta">@Payload</span> String payload) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Received message: &quot;</span> + payload);<br>        <span class="hljs-comment">// 处理接收到的消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>运行时绑定</li></ol></blockquote><p>Spring Cloud Stream 会在运行时将消息通道绑定到消息中间件上，使得消息的发送和接收可以与底层的消息中间件解耦。根据配置的 <code>&#123;binder&#125;</code> 不同，可以支持 RabbitMQ、Kafka、ActiveMQ 等多种消息中间件。</p><p>通过以上步骤，你就可以使用 Spring Cloud Stream 在微服务中实现消息的发送和接收，从而构建消息驱动的微服务架构。</p><h3 id="2、SpringCloud-Bus-的使用"><a href="#2、SpringCloud-Bus-的使用" class="headerlink" title="2、SpringCloud Bus 的使用"></a>2、SpringCloud Bus 的使用</h3><p>Spring Cloud Bus是一个用于在分布式系统中传播事件的工具，它建立在Spring Cloud Stream之上。它允许微服务架构中的组件之间进行消息推送，实现配置的动态刷新、事件的传递等功能。</p><p>以下是Spring Cloud Bus的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的<code>pom.xml</code>文件中添加Spring Cloud Bus的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述示例中使用了AMQP（Advanced Message Queuing Protocol）作为消息传递的中间件，你也可以选择其他消息中间件，如Kafka等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在<code>application.properties</code>或<code>application.yml</code>中配置消息中间件的连接信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>配置Bus</li></ol></blockquote><p>在微服务的<code>application.properties</code>或<code>application.yml</code>中，添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">bus:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>4.发送消息</p></blockquote><p>在任意微服务中，可以使用Spring Cloud Bus发送消息来触发事件。可以使用HTTP POST请求向<code>/actuator/bus-refresh</code>端点发送刷新请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/actuator/</span>bus-refresh<br></code></pre></td></tr></table></figure><p>这样就会触发Spring Cloud Bus发送一个刷新事件，然后各个微服务都会接收到这个事件，从而触发配置的刷新操作。</p><blockquote><ol start="5"><li>接收消息</li></ol></blockquote><p>在微服务中，可以使用<code>@RefreshScope</code>注解标记一个类，使得该类中的配置在接收到刷新事件时能够重新加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;my.property&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String myProperty;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/property&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getProperty() &#123;<br>        <span class="hljs-keyword">return</span> myProperty;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，<code>@RefreshScope</code>注解使得<code>MyController</code>类中的配置在接收到刷新事件时会重新加载。</p><p>通过这些步骤，你就可以使用Spring Cloud Bus实现在分布式系统中传播事件，例如动态刷新配置、传递消息等。</p><p>to be contined…..</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Seata</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是分布式事务"><a href="#1、什么是分布式事务" class="headerlink" title="1、什么是分布式事务"></a>1、什么是分布式事务</h3><p>首先理解一下，为什么会用到分布式事务。</p><p>在分布式服务中，服务A中通过feign来调用服务B的方法，但是服务B的方法并不归属于服务A的事务体系中，因此如果此时服务B报错，并不会导致已经执行了的服务A的操作回退。</p><p>想要让服务A回退，那么就要让服务B纳入到服务A的事务体系中，也就是两者是同一个事务ID。这就是我们的分布式事务，它<strong>可以跨越服务来实现事务</strong>。</p><p>想要实现分布式事务，我们有多种方式，可以通过像redis这样的中间件来实现。</p><p>但也可以用到我们今天介绍的seata组件来实现。甚至发展至今，一般我们谈到分布式事务，基本上seata已经成了我们的不二选择。</p><h3 id="2、Seata-是什么"><a href="#2、Seata-是什么" class="headerlink" title="2、Seata 是什么"></a>2、Seata 是什么</h3><p>Seata 是一款分布式事务解决方案，为微服务架构提供了强一致性的分布式事务支持。提供了全局事务管理和本地事务协调的功能，可以用于确保多个微服务之间的事务操作的一致性；提供了 AT、TCC、SAGA和XA等几种事务模式。</p><p>常见的两种分布式事务模型：AT 模型（基于 TCC，Try-Confirm-Cancel）和 TCC 模型（基于两阶段提交）。</p><blockquote><p>AT模型</p></blockquote><p>默认使用的是AT模式</p><ol><li>在业务表所在的数据库中创建一个名为undo_log的表，用于记录回滚SQL，即与执行SQL相反的SQL（例如，执行insert则对应delete）。</li><li>当业务表执行操作时，Seata会解析执行的SQL，生成回滚SQL并存储到undo_log表中。</li><li>在本地事务提交前，向Seata服务端注册分支，申请业务表中对应数据行的全局锁，阻止其他事务对该数据进行更新操作。</li><li>本地事务提交时，业务数据的更新和生成的undo log一起提交。</li><li>将本地事务执行结果报告给Seata服务端，多个服务的本地事务使用相同的事务ID和分支ID记录在Seata服务端。</li><li>如果某个本地事务发生错误，Seata服务端发起对应分支的回滚请求。</li><li>同时开启本地事务，通过事务ID和分支ID查询undo_log表，执行回滚SQL，并将执行结果报告给Seata服务端。</li><li>如果没有错误发生，Seata服务端会在对应分支上发起请求，异步批量删除undo_log表中的记录。</li></ol><p>总体来说，Seata服务端记录了所有本地事务，同时在每个库中记录了undo log。</p><p>当发生错误时，通过事务ID和分支ID找到同一组的所有本地事务，利用记录的undo log统一回退数据。</p><h3 id="3、使用-Seata-的基本步骤"><a href="#3、使用-Seata-的基本步骤" class="headerlink" title="3、使用 Seata 的基本步骤"></a>3、使用 Seata 的基本步骤</h3><p>seata分为服务端（TC）和客户端（TM,RM）,</p><p>客户端通过引入jar包来使用。服务端需要我们单独安装。</p><ul><li>TC(Transaction Coordinator)：事务协调器，维护全局事务的运行状态，协调和落实全局事务的回滚提交</li><li>TM(Transaction Manager)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局事务提交或回滚的决议</li><li>RM(Resource Manager)：控制分支（本地）事务，负责分支注册、状态汇报，并接受TC的指令，驱动本地事务的提交和回滚</li></ul><h4 id="1-部署-Seata-服务器"><a href="#1-部署-Seata-服务器" class="headerlink" title="1. 部署 Seata 服务器"></a>1. 部署 Seata 服务器</h4><p>服务端下载地址： <a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p><p>部署过程：略</p><h4 id="2-seata客户端配置"><a href="#2-seata客户端配置" class="headerlink" title="2. seata客户端配置"></a>2. seata客户端配置</h4><p>在微服务的项目中，添加 Seata 的依赖。如果使用 Maven，可以在项目的 <code>pom.xml</code> 文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 请根据实际情况选择版本 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><p>在微服务的配置文件中，配置 Seata 客户端。通常需要指定 Seata 服务器的地址等信息。以下是一个示例配置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">seata:</span><br>  application-id: my-app<br>  tx-service-group: my-tx-group<br><span class="hljs-symbol">  enabled:</span> true<br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  registry:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  service:</span><br><span class="hljs-symbol">    vgroup:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br><span class="hljs-symbol">    group:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br></code></pre></td></tr></table></figure><h4 id="添加事务注解"><a href="#添加事务注解" class="headerlink" title="添加事务注解"></a>添加事务注解</h4><p>使用 @GlobalTransactional 注解</p><p>在需要分布式事务的方法上，使用 <code>@GlobalTransactional</code> 注解标记。这个注解表示这个方法需要参与全局事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.seata.spring.annotation.GlobalTransactional;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@GlobalTransactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">businessMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/github_38592071/article/details/131136986">https://blog.csdn.net/github_38592071/article/details/131136986</a></li><li><a href="https://juejin.cn/post/7087551217781620749">https://juejin.cn/post/7087551217781620749</a></li><li><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_OpenFeign</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/</url>
    
    <content type="html"><![CDATA[<h3 id="1、服务调用"><a href="#1、服务调用" class="headerlink" title="1、服务调用"></a>1、服务调用</h3><h4 id="服务注册、服务发现、服务调用"><a href="#服务注册、服务发现、服务调用" class="headerlink" title="服务注册、服务发现、服务调用"></a>服务注册、服务发现、服务调用</h4><p>在Spring Cloud Alibaba生态系统中，服务调用的核心组件是 <strong>Nacos Discovery</strong> 和 <strong>Feign</strong>。</p><blockquote><p>Nacos Discovery</p></blockquote><p>Nacos是一个开源的服务发现和配置管理平台，它提供了服务注册与发现的功能，可以让微服务应用在注册到Nacos注册中心后，方便地发现其他服务，并实现服务之间的调用。通过Nacos Discovery，服务之间的关系和位置信息能够得到维护，实现了服务注册和服务发现。</p><blockquote><p>Feign</p></blockquote><p>Feign是一个声明式的Web服务客户端，它简化了服务调用的过程。通过在接口上添加注解，Feign能够自动构造HTTP请求并将其发送到服务提供方。在Spring Cloud Alibaba中，Feign与Nacos Discovery集成，可以使用Feign来发起服务调用，而Nacos Discovery则用于服务的注册和发现。</p><h4 id="微服务间的调用方式"><a href="#微服务间的调用方式" class="headerlink" title="微服务间的调用方式"></a>微服务间的调用方式</h4><blockquote><p>微服务调用</p></blockquote><p>微服务之间的通信方式常见的方式有两种：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">RPC</span> 代表：dubbo  <br>HTTP 代表：SpringCloud<br></code></pre></td></tr></table></figure><p>在微服务架构中，最常见的场景就是微服务间的相互调用。</p><p>在 SpringCloud 中，默认是使用 HTTP  来进行微服务的通信，微服务间的相互调用方式主要有<code>RestTemplate</code>、<code>Feign</code> 、和<code>OpenFeign</code></p><blockquote><p>RestTemplate</p></blockquote><p>RestTemplate 是从 Spring3.0 开始支持的一个 http 请求工具，这个请求工具是 Spring 自带的</p><p>RestTemplate 提供了常见的 REST 请求方法模板，如 GET、POST、PUT、DELETE 请求以及一些通用的请求执行方法 exchange 和 execute 方法</p><blockquote><p>Feign</p></blockquote><p>Feign 是 Spring Cloud 组件中的一个<code>声明式</code>的<code>轻量级 RESTful 的 HTTP 服务客户端</code></p><p>Feign 内置了 Ribbon，用来做<code>客户端负载均衡</code>，去调用服务注册中心的服务；</p><blockquote><p>OpenFeign</p></blockquote><p>OpenFeign 是 Spring Cloud 在 Feign 的基础上支持 SpringMVC 的注解，如 @RequesMapping 等等。</p><p>OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p><blockquote><p>OpenFeign 和 Feign 组件的区别和关联</p></blockquote><p>OpenFeign 是 Feign 的增强版，它是 Spring Cloud 对 Feign 进行了扩展和优化的结果。虽然两者有关联，但在一些功能和使用上存在一些区别。</p><p><strong>Feign:</strong></p><ul><li>Feign 是一个声明式的Web服务客户端，用于简化服务调用的过程。</li><li>它基于接口定义，通过添加注解，可以轻松地发起HTTP请求。</li><li>在原始的 Spring Cloud 中，Feign 的默认实现不支持 Spring MVC 注解，因此使用起来有一些限制。</li></ul><p><strong>OpenFeign:</strong></p><ul><li>OpenFeign 是对 Feign 的增强，它引入了对 Spring MVC 注解的支持，使得 Feign 在使用上更加灵活。</li><li>OpenFeign 提供了更丰富的功能，例如继承性、支持 Spring Cloud Contract、支持多部分请求和响应等。</li><li>OpenFeign 可以通过 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性来实现多个 Feign 客户端实例之间的隔离。</li></ul><p>在Spring Cloud项目中，如果你使用 <code>@FeignClient</code> 注解，实际上默认是使用的 OpenFeign。</p><p>Spring Cloud 在 Hoxton.RELEASE 版本之后<strong>默认使用 OpenFeign，而不是原始的 Feign。</strong></p><p>关于使用 <code>@FeignClient</code> 注解创建 Feign 客户端的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>@FeignClient</code> 注解指定了服务的名称和URL，<code>ExampleFeignClient</code> 接口定义了服务调用的契约。通过添加 <code>@GetMapping</code> 注解，实现了对服务提供者的 <code>/hello</code> 接口的调用。</p><p>总体而言，OpenFeign 是对 Feign 的增强版本，提供了更多的功能和更好的灵活性，而在 Spring Cloud 中，我们常常通过 <code>@FeignClient</code> 注解来使用 OpenFeign。</p><h3 id="2、OpenFeign-的使用"><a href="#2、OpenFeign-的使用" class="headerlink" title="2、OpenFeign 的使用"></a>2、OpenFeign 的使用</h3><h4 id="FeignClient的基本使用方法"><a href="#FeignClient的基本使用方法" class="headerlink" title="@FeignClient的基本使用方法"></a><code>@FeignClient</code>的基本使用方法</h4><p><code>@FeignClient</code> 是 Spring Cloud 中用于声明式REST客户端的注解。通过使用该注解，可以定义一个接口，而不需要实现该接口，Spring Cloud会在运行时自动生成该接口的实现类，用于发起服务间的HTTP请求。</p><p>以下是<code>@FeignClient</code>的基本使用方法：</p><blockquote><p><strong>简单使用：</strong></p></blockquote><p>在一个接口上添加 <code>@FeignClient</code> 注解，并指定要调用的服务名称</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><br><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>ExampleFeignClient</code> 接口用于调用名为 “example-service” 的微服务，其中 <code>@GetMapping(&quot;/hello&quot;)</code> 定义了调用服务的路径。</p><blockquote><p>指定 URL</p></blockquote><p>可以通过 <code>url</code> 属性指定服务的URL，而不是通过服务名称进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，服务的URL被硬编码为 “<a href="http://example.com"./">http://example.com&quot;。</a></p><blockquote><p><strong>指定Fallback</strong></p></blockquote><p>可以通过 <code>fallback</code> 属性指定一个实现了 <code>ExampleFeignClient</code> 接口的类，作为调用失败时的降级处理。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;example-service&quot;</span>, fallback = ExampleFeignClientFallback.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExampleFeignClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/hello&quot;</span>)<br>    <span class="hljs-keyword">String</span> hello();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleFeignClientFallback</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ExampleFeignClient</span></span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fallback Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当调用服务失败时，会执行 <code>ExampleFeignClientFallback</code> 中的逻辑。</p><blockquote><p><strong>指定Decoder和Encoder</strong></p></blockquote><p>可以通过 <code>decoder</code> 和 <code>encoder</code> 属性指定自定义的解码器和编码器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, decoder = MyDecoder.class, encoder = MyEncoder.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyDecoder</code> 和 <code>MyEncoder</code> 分别是自定义的解码器和编码器。</p><p>这些是 <code>@FeignClient</code> 注解的基本用法，通过灵活使用这些属性，可以实现更多定制化的服务调用配置。</p><p>to be continued….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/IT__learning/article/details/116349843">https://blog.csdn.net/IT__learning/article/details/116349843</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Gateway</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/</url>
    
    <content type="html"><![CDATA[<h3 id="1、微服务网关是什么"><a href="#1、微服务网关是什么" class="headerlink" title="1、微服务网关是什么"></a>1、微服务网关是什么</h3><p>微服务网关是一个位于微服务架构前端的服务，作为客户端和后端微服务之间的中介。它的作用是集中处理和管理微服务系统的一些共享的非业务功能，提供统一的入口，同时可以进行路由、转发、过滤、监控等操作。</p><blockquote><p>Gateway 的基本功能</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041349886.png" alt="image.png"></p><ol><li><strong>路由转发：</strong><ul><li>网关负责接收客户端的请求，根据配置的路由规则将请求转发到不同的微服务。这有助于实现前后端的解耦，使得微服务可以独立演进。</li></ul></li><li><strong>流量控制：</strong><ul><li>网关可以对请求进行流量控制，限制每个微服务的访问频率，防止某个微服务被过度请求而影响整体系统的稳定性。</li></ul></li><li><strong>熔断保护：</strong><ul><li>网关可以实现熔断保护，当某个微服务出现故障或超时时，网关可以快速拦截请求，避免请求堆积导致整个系统的崩溃。Sentinel是一种专注于流量控制、熔断降级、系统自适应保护的开源框架，它提供了更丰富的熔断保护功能，因此有些项目选择引入Sentinel来增强熔断保护能力。</li></ul></li><li><strong>日志监控：</strong><ul><li>网关通常会记录请求和响应的日志信息，这有助于进行系统的监控和故障排查。业务日志和链路追踪也是重要的监控手段。</li></ul></li><li><strong>安全认证：</strong><ul><li>网关可以提供安全认证机制，确保只有经过认证和授权的用户才能访问微服务。这可以通过集成框架（如Spring Security）或使用专门的认证服务来实现。</li></ul></li></ol><blockquote><p>关于 Gateway 的熔断保护功能的说明</p></blockquote><p>Spring Cloud Gateway自身具备基本的熔断保护机制，可以在配置中设置断路器的一些参数，但相对简单。对于一些更复杂的熔断、限流、降级等场景，可能需要引入专门的框架如Sentinel。</p><p>在实际使用中，可以根据具体的需求来选择是否引入Sentinel。如果项目对熔断保护等功能的需求相对简单，Gateway的基本熔断保护足够使用。如果需要更复杂的流量控制和熔断降级策略，引入Sentinel可能会更为合适。</p><blockquote><p>服务网关和流量网关的区别</p></blockquote><p>对于 Nginx 和 Gateway 的两者区别：</p><p>流量网关（如Nignx)提供全局性的、与后端业务应用无关的策略，例如 HTTPS证书卸载、Web防火墙、全局流量监控等。</p><p>微服务网关（如Spring Cloud Gateway）是指与业务紧耦合的、提供单个业务域级别的策略，如服务治理、身份认证等。</p><p>流量网关负责南北向流量调度及安全防护，微服务网关负责东西向流量调度及服务治理。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041354467.png" alt="image.png|400"></p><h3 id="2、Gateway-的搭建和使用"><a href="#2、Gateway-的搭建和使用" class="headerlink" title="2、Gateway 的搭建和使用"></a>2、Gateway 的搭建和使用</h3><blockquote><p>网关的搭建</p></blockquote><p>略</p><blockquote><p>Spring Cloud Gateway 的配置项</p></blockquote><p>Spring Cloud Gateway的核心概念包括路由（Route）、断言（Predicate）和过滤器（Filter）。</p><p>这些概念共同构成了Gateway的基础，用于定义请求的路由规则、请求的匹配条件和请求的处理流程。</p><blockquote><p>路由</p></blockquote><p>路由定义了请求应该被定向到哪个目标服务。每个路由都包含一个唯一的ID、目标URI、一组断言和过滤器。通过配置多个路由，可以实现对请求的动态路由和负载均衡。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>上述配置表示将以<code>/example/**</code>路径开头的请求转发到<code>http://example.com</code>，并在转发时去掉路径的第一个段（StripPrefix&#x3D;1）。</p><blockquote><p>断言</p></blockquote><p>断言定义了请求匹配的条件，当条件满足时，对应的路由规则生效。断言可以基于请求的路径、方法、头部信息等进行匹配。</p><blockquote><p>过滤器</p></blockquote><p>过滤器是处理请求和响应的逻辑的组件，它们可以修改请求和响应，实现一些额外的功能，如添加头信息、修改请求体、进行认证等</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Header=foo</span><br></code></pre></td></tr></table></figure><p>上述配置中的过滤器<code>AddRequestHeader=X-Header=foo</code>表示在转发请求前，向请求头中添加一个名为<code>X-Header</code>的头，其值为<code>foo</code>。</p><blockquote><p>Gateway集成 nacos 注册中心实现服务发现</p></blockquote><p>略</p><blockquote><p>Gateway 整合 Apollo 实现动态路由配置</p></blockquote><p>略</p><blockquote><p>自定义全局异常处理器</p></blockquote><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yao583224426/article/details/122216804">https://blog.csdn.net/yao583224426/article/details/122216804</a></li><li><a href="https://cloud.tencent.com/developer/article/2135737">https://cloud.tencent.com/developer/article/2135737</a></li><li><a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Sentinel</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/</url>
    
    <content type="html"><![CDATA[<p>使用类似于 Sleuth，在对应服务添加依赖和注解配置后，Sentinel 能够对服务做一个服务流量监听，进行熔断降级、系统负载等操作。</p><p><strong>Sentinel控制台的下载</strong></p><p>下载地址： <a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.3">https://github.com/alibaba/Sentinel/releases/tag/1.8.3</a></p><p>注意的一些内容</p><ul><li>注解使用（服务程序中使用）</li><li>流控规则</li><li>熔断规则</li><li>系统规则</li></ul><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106899215">https://blog.csdn.net/qq_36903261/article/details/106899215</a></li><li><a href="https://blog.csdn.net/qq_38374397/article/details/125603109">https://blog.csdn.net/qq_38374397/article/details/125603109</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的安装与使用</title>
    <link href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、windows下rabbitMQ-的安装"><a href="#1、windows下rabbitMQ-的安装" class="headerlink" title="1、windows下rabbitMQ 的安装"></a>1、windows下rabbitMQ 的安装</h3><p>RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是需要安装一下Erlang</p><p>Erlang 下载地址： <a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p><p>环境变量配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">ERLANG_HOME<br><span class="hljs-tag">%<span class="hljs-selector-tag">ERLANG_HOME</span></span>%\bin<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203233950.png" alt="image.png"></p><p>打开 cmd 输入 erl -version 出现版本号即安装成功</p><blockquote><p>RabbitMQ</p></blockquote><p>rabbitmq 下载地址： <a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>下载进行安装操作。</p><p>CMD 进入终端 进入到安装目录 执行 rabbitmq-plugins enable rabbitmq_management 命令安装管理页面的插件，</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203234341.png" alt="image.png"></p><p>启动rabbitMQ服务：rabbitmq-service.bat start</p><p>双击 rabbitmq-service.bat 即完成安装。（关闭的话手动在服务列表进行关闭一下）</p><p>登陆： <a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></p><p>初始的默认用户及密码都是 <code>guest</code> ， 输入后即可登录</p><h3 id="2、centos-系统下-rabbitMQ-的安装"><a href="#2、centos-系统下-rabbitMQ-的安装" class="headerlink" title="2、centos 系统下 rabbitMQ 的安装"></a>2、centos 系统下 rabbitMQ 的安装</h3><h4 id="RabbitMQ-服务安装"><a href="#RabbitMQ-服务安装" class="headerlink" title="RabbitMQ 服务安装"></a>RabbitMQ 服务安装</h4><p>略</p><h4 id="Docker容器方式安装RabbitMQ"><a href="#Docker容器方式安装RabbitMQ" class="headerlink" title="Docker容器方式安装RabbitMQ"></a>Docker容器方式安装RabbitMQ</h4><p>1、拉取镜像（默认安装最新版本）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker pull rabbitmq<br></code></pre></td></tr></table></figure><p>2、启动RabbitMQ容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --hostname myRabbitMQ --name rabbit -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> rabbitmq<br></code></pre></td></tr></table></figure><p>这个命令的组成部分解释如下：</p><ul><li><code>docker run</code>：启动一个新的容器。</li><li><code>-d</code>：以守护进程模式运行容器，即容器在后台运行。</li><li><code>--hostname myRabbitMQ</code>：为容器设置主机名（<code>myRabbitMQ</code>）。你可以根据需要更改这个值。</li><li><code>--name rabbit</code>：设置容器的名称（<code>rabbit</code>）。这也可以根据你的命名约定来更改。</li><li><code>-p 5672:5672</code>：将容器内部的 5672 端口映射到宿主机的 5672 端口。5672 端口是 RabbitMQ 的默认AMQP端口。</li><li><code>-p 15672:15672</code>：将容器内的 15672 端口映射到宿主机的 15672 端口。15672 端口是 RabbitMQ 管理界面（Management Console）的默认端口。</li><li><code>rabbitmq</code>：指定要使用的 Docker 镜像。</li></ul><p>在 Docker 命令中使用 <code>-p</code> 参数来映射端口时，格式为 <code>-p &lt;宿主机端口&gt;:&lt;容器端口&gt;</code>。</p><p>开放一下端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=5672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=15672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><p>访问控制台界面</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//linuxip:15672</span><br></code></pre></td></tr></table></figure><p>用户名和密码默认都是guest</p><p>3、开启 Web 界面管控台插件</p><p>对于 Docker 容器中的 RabbitMQ</p><p>如果你是通过 Docker 容器运行 RabbitMQ，并且想要启用管理控制台，通常最简单的方式是直接使用带有管理插件的 RabbitMQ 镜像。例如：</p><p><code>docker run -d --hostname myRabbitMQ --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p><p>在这个命令中，<code>rabbitmq:3-management</code> 镜像已经包含了管理插件。如果你已经运行了一个不包含管理插件的 RabbitMQ 容器，你可以按照以下步骤启用管理插件：</p><ol><li><p>找出你的 RabbitMQ 容器的 ID 或名称：</p><p> <code>docker ps</code></p></li><li><p>进入容器：</p><p> <code>docker exec -it [容器ID或名称] bash</code></p></li><li><p>在容器内部，运行以下命令来启用管理插件：</p><p> <code>rabbitmq-plugins enable rabbitmq_management</code></p></li><li><p>退出容器：</p><p> <code>exit</code></p></li><li><p>重启 RabbitMQ 容器以应用更改。</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart<span class="hljs-meta"> [容器名称或ID]</span><br></code></pre></td></tr></table></figure><p>一旦完成，你就可以通过<code>http://linuxip:15672</code></p><p>访问 RabbitMQ 的管理界面。确保你已经将 15672 端口映射到了宿主机上。</p><hr><p>参考： </p><ul><li><a href="https://blog.csdn.net/u011709538/article/details/131396367">https://blog.csdn.net/u011709538/article/details/131396367</a></li><li><a href="https://zhuanlan.zhihu.com/p/609676322?utm_id=0">https://zhuanlan.zhihu.com/p/609676322?utm_id=0</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端依赖常见报错解决方案</title>
    <link href="/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题1： npm错误——npm ERR! code ERESOLVE 解决方法</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">npm ERR! code ERESOLVE<br>npm ERR! ERESOLVE unable to resolve dependency tree<br>npm ERR!<br>npm ERR! While resolving: vol.vue3@<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>npm ERR! Found: vue@<span class="hljs-number">3.2</span>.<span class="hljs-number">20</span><br>npm ERR! node_modules/vue<br>npm ERR!   vue@<span class="hljs-string">&quot;^3.0.0&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Could not resolve dependency:<br>npm ERR! peer vue@<span class="hljs-string">&quot;^2.5.17&quot;</span> from element-ui@<span class="hljs-number">2.15</span>.<span class="hljs-number">6</span><br>npm ERR! node_modules/element-ui<br>npm ERR!   element-ui@<span class="hljs-string">&quot;*&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Fix the upstream dependency conflict, or retry<br>npm ERR! this command with --force, or --legacy-peer-deps<br>npm ERR! to accept an incorrect (and potentially broken) dependency resolution.<br>npm ERR!<br>npm ERR! See C:\Users\Administrator\AppData\Local\npm-cache\eresolve-report.txt for a full report.<br> <br>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Users\Administrator\AppData\Local\npm-cache\_logs\<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">11</span>T06_27_44_908Z-debug.log<br></code></pre></td></tr></table></figure><p>在安装组件的时候出现以上问题，npm版本问题报错</p><p>解决方法：</p><p>在命令后面加上</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--legacy-peer-deps</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python环境安装</title>
    <link href="/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、python-3-9-版本安装"><a href="#1、python-3-9-版本安装" class="headerlink" title="1、python 3.9 版本安装"></a>1、python 3.9 版本安装</h3><p>下载地址： <a href="https://www.python.org/downloads/release/python-396/">https://www.python.org/downloads/release/python-396/</a></p><p>参考： <a href="https://blog.csdn.net/qq_53280175/article/details/121107748">https://blog.csdn.net/qq_53280175/article/details/121107748</a></p><p>下载链接： <a href="https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe">https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe</a></p><p>这里下载的是 win 64 位安装版</p><p>安装的时候勾选一下  Add Python 3.9 to PATH</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214357.png" alt="image.png"></p><p>选择自定义安装</p><p>查看是否安装成功，cmd 窗口输入一下 <code>python</code> 看一下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214605.png" alt="image.png"></p><h3 id="2、降级python为2-0-版本"><a href="#2、降级python为2-0-版本" class="headerlink" title="2、降级python为2.0 版本"></a>2、降级python为2.0 版本</h3><p>由于版本前端项目 node-sass 安装失败，部分建议是降级 Python 为 2.x 版本，这里记录一下实际操作。</p><p>找了一个 2.7.2 版本：<a href="https://www.python.org/downloads/release/python-273/">https://www.python.org/downloads/release/python-273/</a></p><p>仍然选择安装版本</p><p>安装完成后加一下 Path 环境变量（删除之前的）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">xxx\Pytho<span class="hljs-symbol">n27</span><br></code></pre></td></tr></table></figure><p>输入 <code>Python -V</code> 验证释放安装成功</p><p>实际操作在这一步输入后，没反映，<strong>使用完整路径运行 Python</strong> 却又是正常的</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">D</span>:\<span class="hljs-number">02</span>_Soft\xxxxx\Python27\python.exe -V<br></code></pre></td></tr></table></figure><p>实际的一个操作，<strong>需要设置path优先级，把python的路径放置顶部</strong></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统下 java环境变量的配置</title>
    <link href="/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="linux系统下-java环境变量的配置"><a href="#linux系统下-java环境变量的配置" class="headerlink" title="linux系统下 java环境变量的配置"></a>linux系统下 java环境变量的配置</h3><p>输入<code>echo $JAVA_HOME</code>结果为空，说明没有配置java环境变量</p><p>查看yum安装的jdk在哪个目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /etc/alternatives/java<br></code></pre></td></tr></table></figure><p>默认安装路径是在 <code>/usr/lib/jvm</code></p><p>配置环境变量  <code>vim /etc/profile</code></p><p>追加内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/lib/java/jdk1.8.0_231 <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib  <br><span class="hljs-built_in">export</span>  <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p>刷新环境变量配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><blockquote><p>卸载重装</p></blockquote><p>卸载参考（Linux上卸载JDK）： <a href="https://blog.csdn.net/weixin_44990104/article/details/117589372">https://blog.csdn.net/weixin_44990104/article/details/117589372</a></p><p>linux安装jdk8详细步骤，参考： <a href="https://blog.csdn.net/qq_33794744/article/details/107838128">https://blog.csdn.net/qq_33794744/article/details/107838128</a></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7 安装 nacos 操作</title>
    <link href="/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="centos7-安装-nacos-操作"><a href="#centos7-安装-nacos-操作" class="headerlink" title="centos7 安装 nacos 操作"></a>centos7 安装 nacos 操作</h3><p>前提需要：项目运行环境需要安装 nacos </p><p>在 centos 中进行安装nacos，这里演示安装版本是 1.3.2，</p><p>下载地址： <a href="https://github.com/alibaba/nacos/releases/tag/1.3.2">https://github.com/alibaba/nacos/releases/tag/1.3.2</a></p><p>nacos 运行需要先安装一下 JDK 环境，注意一下</p><p>可以自己点击下载   <code>nacos-server-1.3.2.tar.gz</code></p><p>或者在 Linux系统中下载命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://github.com/alibaba/nacos/releases/download/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>/nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>下载完压缩包之后，上传指服务器任意目录，进行解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压后会生成 nacos 文件夹，进入到 nacos 目录，输入命令启动(以单机的形式启动)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/startup.sh -m standalone<br></code></pre></td></tr></table></figure><p>如果需要持久化 配置到mysql，则调整nacos的配置</p><p>如果你的服务器开了防火墙，则需要开放相应的端口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#开放端口</span><br>firewall-cmd <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=8848/tcp</span> <span class="hljs-params">--permanent</span> <br><span class="hljs-comment"># 重启防火墙 </span><br>firewall-cmd <span class="hljs-params">--reload</span><br><span class="hljs-comment"># 查看开放的端口列表 </span><br>firewall-cmd <span class="hljs-params">--list-port</span><br></code></pre></td></tr></table></figure><p>nacos默认的启动端口是 8848，访问 <code>http://ip:端口/nacos</code> 即可看到登录页面.默认的用户名密码是 <code>nacos/naocs</code>，登录即可使用</p>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透工具Neutrino-Proxy</title>
    <link href="/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/"/>
    <url>/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/</url>
    
    <content type="html"><![CDATA[<p>一款简单易用的内网穿透使用工具</p><p>官网： <a href="https://neutrino-proxy.dromara.org/">https://neutrino-proxy.dromara.org/</a></p><p>项目地址： <a href="https://gitee.com/dromara/neutrino-proxy/releases">https://gitee.com/dromara/neutrino-proxy/releases</a></p><p>部署方式有三种，这里通过原生部署的方式进行启动</p><p>原生部署的方式需要下载zip包，进行解压，然后启动 exe 文件。部分exe程序同一目录下有Pom.xml配置文件，可进行修改对应配置。</p><p>服务器下载<code>neutrino-proxy-server-ubuntu-20.04-native.zip</code>文件，</p><p>客户端下载<code>neutrino-proxy-client-windows-2022-native.zip</code></p><blockquote><p>部署服务器端</p></blockquote><p>默认先采用原生配置h2数据库，实际使用中，个人使用的是h2数据库（这种数据库的缺点是数据放在内存中，如果需要持久化放到本地，建议修改配置为 mysql 数据库）</p><p>实际操作：</p><p>1、将下载文件复制到服务器的某个目录下，进行解压操作：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">unzip  neutrino-proxy-<span class="hljs-keyword">server</span>-ubuntu<span class="hljs-number">-20.04</span>-native.zip<br><br><span class="hljs-meta">#启动服务端可执行程序</span><br>./neutrino-proxy-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><ul><li>服务端部署成功后，访问http:&#x2F;&#x2F;{服务端IP}:8888打开后台管理页面。使用默认的管理员帐号登录：admin&#x2F;123456</li><li>打开代理配置&gt;License管理页面，系统已经自动为管理员初始化了一条License记录，复制该LicenseKey备用，后续客户端配置需要。</li></ul><p>2、将 exe 程序后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./neutrino-proxy-server &amp;<br></code></pre></td></tr></table></figure><p><code>nohup</code> 命令用于忽略挂断信号（SIGHUP），并且 <code>&amp;</code> 符号用于将程序放到后台运行。</p><p><code>nohup.out</code> 文件通常会生成在你运行 <code>nohup</code> 命令的当前工作目录（current working directory）。如果你没有指定具体的输出文件路径，<code>nohup</code> 默认将输出重定向到 <code>nohup.out</code> 文件</p><p>关闭后台程序</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#查看进程号PID</span><br>ps aux | <span class="hljs-keyword">grep</span> neutrino-proxy-server<br><span class="hljs-comment">#杀死进程</span><br><span class="hljs-keyword">kill</span> &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>后台运行的时候发现使用 xshell 直接启动程序会随着关闭 ssh 连接而中断运行，这里是采用 screen + nohup 的方式运行程序。</p><p>上面这种方式在关闭 ssh 连接后，会话中的进程就直接关闭了。尝试一下 screen 的使用</p><p><code>screen</code> 是一个终端复用工具，它允许你在一个终端窗口中创建多个虚拟终端，并在这些虚拟终端中运行不同的程序。通过使用 <code>screen</code>，你可以在一个会话中保持你的程序在后台运行，即使你关闭了SSH连接也不会影响这些程序的执行</p><p>安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> screen<br></code></pre></td></tr></table></figure><ol><li><p><strong>启动一个新的 <code>screen</code> 会话：</strong></p><p> <code>screen</code></p><p> 这将创建一个新的 <code>screen</code> 会话，并将你切换到该会话中。</p></li><li><p><strong>在 <code>screen</code> 会话中运行你的程序：</strong></p><p> 在 <code>screen</code> 会话中，你可以运行你的程序，比如：</p><p> <code>./your_program.exe</code></p><p> 如果你需要在程序后台运行，你可以使用 <code>Ctrl + A</code> 然后按下 <code>d</code> 键，这会将 <code>screen</code> 会话放入后台，但会话中的程序仍在运行。</p></li><li><p><strong>列出 <code>screen</code> 会话：</strong></p><p> <code>screen -ls</code></p><p> 这将显示当前所有的 <code>screen</code> 会话。</p></li><li><p><strong>重新连接到 <code>screen</code> 会话：</strong></p><p> 如果你关闭了终端或断开了SSH连接，你可以重新连接到之前创建的 <code>screen</code> 会话：</p><p> <code>screen -r</code></p><p> 如果有多个会话，你可能需要指定要连接的会话ID，例如：</p><p> <code>screen -r &lt;session_id&gt;</code></p></li><li><p><strong>退出 <code>screen</code> 会话：</strong></p><p> 在 <code>screen</code> 会话中，你可以使用 <code>exit</code> 或者 <code>Ctrl + D</code> 来退出。</p></li></ol><p>这是 <code>screen</code> 的基本用法。</p><blockquote><p>部署客户端</p></blockquote><p>需要下载后修改一下配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neutrino:</span><br>  <span class="hljs-attr">proxy:</span><br>    <span class="hljs-attr">tunnel:</span><br>      <span class="hljs-comment"># ssl证书密钥（使用jjar包内自带的证书，则此处无需修改）</span><br>      <span class="hljs-attr">key-store-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-comment"># ssl证书管理密钥（使用jjar包内自带的证书，则此处无需修改。自定义证书，则此处配置对应的路径）</span><br>      <span class="hljs-attr">jks-path:</span> <span class="hljs-string">classpath:/test.jks</span><br>      <span class="hljs-comment"># 代理服务端IP</span><br>      <span class="hljs-attr">server-ip:</span> <span class="hljs-string">xxxx</span><br>      <span class="hljs-comment"># 代理服务端IP, 若是非ssl端口，则ssl-enable需要配置为false</span><br>      <span class="hljs-attr">server-port:</span> <span class="hljs-number">9002</span><br>      <span class="hljs-comment"># 是否启用ssl</span><br>      <span class="hljs-attr">ssl-enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># licenseKey，客户端凭证。此处需要配置刚刚从管理后台复制的LicenseKey</span><br>      <span class="hljs-attr">license-key:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>这里有一个注意的地方就是 9002 这个端口，需要我们去看一下服务器端的配置文件对应的端口，它默认是 9002 ，需要在防火墙端口开启一下，<strong>或者改一下这个端口配置</strong></p><p>server-port  →  服务端端口(对应服务端app.yml中的tunnel.port、tunnel.ssl-port)</p><p>然后复制一下客户端凭证即可</p><p>如果出现问题，建议先删掉文件重新解压，再配置一遍，重新启动。</p><p>Linux 客户端配置同理。（注意是一个客户端对应一个凭证）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unzip</span>  neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native.zip<br><span class="hljs-attribute">cd</span> neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native<br><br><span class="hljs-attribute">screen</span><br><br><span class="hljs-attribute">nohup</span> ./neutrino-proxy-client &amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Zipkin</title>
    <link href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/"/>
    <url>/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Sleuth"><a href="#1、什么是-Sleuth" class="headerlink" title="1、什么是 Sleuth"></a>1、什么是 Sleuth</h3><p>Sleuth是Spring Cloud的组件之一，它为Spring Cloud实现了一种分布式追踪解决方案。</p><p>一般是和 zipkin 或者其他基于日志的追踪系统一起使用的。</p><p>简单理解：sleuth 是链路追踪器，将链路信息放到日志中，zipkin 是链路分析器，将链路日志进行可视化分析和聚合检索。</p><h3 id="2、Zipkin是什么"><a href="#2、Zipkin是什么" class="headerlink" title="2、Zipkin是什么"></a>2、Zipkin是什么</h3><p>Zipkin是一个分布式追踪系统。它有助于收集对服务架构中的延迟问题进行故障排除所需的计时数据。功能包括收集和查找这些数据。</p><p>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures. Features include both the collection and lookup of this data.</p><p>在微服务架构中，随着业务的不断扩张，服务之间互相调用会越来越复杂。而Zipkin能收集服务中的一些数据，我们能够通过明显的可视化效果去查看链路中的情况（支持日志聚合，进行可视化展示和全文检索）。</p><p><strong>分布式链路追踪（Distributed Tracing）</strong>： 将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p>常用的链路追踪技术还有好几种，有兴趣可以去了解一下。</p><ul><li><a href="https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/">https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/</a></li><li><a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></li><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li></ul><hr><h3 id="3、Sleuth入门"><a href="#3、Sleuth入门" class="headerlink" title="3、Sleuth入门"></a>3、Sleuth入门</h3><blockquote><p>Sleuth 术语</p></blockquote><ul><li>Trace (一条完整链路–包含很多span(微服务接口))<ul><li>由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</li></ul></li><li>Span<ul><li>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</li></ul></li><li>Annotation<ul><li>用它记录一段时间内的事件，内部使用的重要注释：<ul><li>cs（Client Send）客户端发出请求，开始一个请求的生命</li><li>sr（Server Received）服务端接受到请求开始进行处理， sr－cs &#x3D; 网络延迟（服务调用的时间）</li><li>ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr &#x3D; 服务器上的请求处理时间</li><li>cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr &#x3D; 请求的总时间</li></ul></li></ul></li></ul><blockquote><p>Sleuth 使用</p></blockquote><p>在pom.xml文件添加Sleuth依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--sleuth依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目整合 sleuth 后，在日志输出会多一些链路信息。</p><p>我们在启动这个微服务后，调用其中某个请求，可以在控制台观察到sleuth的日志输出</p><h3 id="4、链路解决方案-Sleuth-Zipkin"><a href="#4、链路解决方案-Sleuth-Zipkin" class="headerlink" title="4、链路解决方案 Sleuth + Zipkin"></a>4、链路解决方案 <strong>Sleuth</strong> + <strong>Zipkin</strong></h3><p>使用 Zipkin 需要下载一下他的服务端： <a href="https://zipkin.io/pages/quickstart.html">https://zipkin.io/pages/quickstart.html</a></p><p>官方文档里面有介绍他对应的下载和启动方式。</p><p>通过浏览器访问 <a href="http://localhost:9411/">http://localhost:9411</a>访问</p><p>Zipkin 跟 Nacos 类似，需要启动他的服务端程序，并在微服务模块中添加客户端相关的配置。</p><blockquote><p><strong>Sleuth</strong> + <strong>Zipkin</strong> 集成</p></blockquote><p>这里是选用 ZipKin客户端和Sleuth 进行集成。</p><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置zipkin</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://192.168.31.60:9411</span><br>    <span class="hljs-attr">discovery-client-enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 不要让nacos把zipkin注册进去（可以不写）</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>启动后，便可以在 Zipkin 观察该服务下的请求链路。</p><blockquote><p>持久化操作</p></blockquote><p>Zipkin 默认是将数据保存到内存，生产环境一般是选择持久化到本地。</p><p><strong>Zipkin</strong> 提供可插拔数据存储方式，下面这些都支持：In-Memory、MySql、Cassandra 以及 Elasticsearch。</p><blockquote><p>使用mysql实现数据持久化操作</p></blockquote><p>略，待更新</p><p>to be contined….</p><hr><p>参考：</p><ul><li><a href="https://zipkin.io/pages/quickstart">https://zipkin.io/pages/quickstart</a></li><li><a href="https://blog.csdn.net/qq_40587263/article/details/117338097">https://blog.csdn.net/qq_40587263/article/details/117338097</a></li><li><a href="https://zhuanlan.zhihu.com/p/71024024">https://zhuanlan.zhihu.com/p/71024024</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB_基本操作</title>
    <link href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>mongodb 的数据库中的一种，是面向文档存储的数据库；</p><p>他的概念和关系型数据有些区别。</p><p>跟 MySQL 类似，他能够执行 CRUD，事务，索引 等操作。</p><p>在技术选型的时候，对于高并发、海量数据读写、高可用、搞可扩展有需求，数据量大，写入频率，价值较低，对事务性要求不高的时候，可以考虑使用 MongoDB来实现数据的存储。</p><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301336438.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/efew212efe/article/details/124524863">https://blog.csdn.net/efew212efe/article/details/124524863</a></li><li><a href="https://www.mongodb.com/docs/manual/">https://www.mongodb.com/docs/manual/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows常用操作</title>
    <link href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>windows_查看端口被占用情况、结束进程</p></blockquote><p>查看指定端口占用情况（端口引号有没有都可以，此处以5040为例）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -aon<span class="hljs-string">|findstr 5040</span><br></code></pre></td></tr></table></figure><p>根据PID查看相应的进程或程序(也可以任务管理器查看)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist<span class="hljs-string">|findstr 5340</span><br></code></pre></td></tr></table></figure><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /f /t /im 进程名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用操作</title>
    <link href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h4><ul><li>wq：保存当前文件并退出</li><li>wqa：保存所有文件并退出</li><li>q!： 不保存，强制退出</li><li>qa!： 有多个文件被打开，同时退出</li></ul><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89042423">https://zhuanlan.zhihu.com/p/89042423</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_基础内容</title>
    <link href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Spring 概念</li><li>常用模块</li><li>IOC</li><li>AOP</li><li>Spring 事务</li><li>Spring MVC</li></ul><blockquote><p>什么是Spring</p></blockquote><p>Spring 是一个轻量级的开源Java开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>一般来说，我们常说的 Spring 框架指的是 Spring Framework, 他是多模块的一个集合，这些模块能够比较方便的帮助我们来进行开发。</p><p>Spring 有很多特性，也支持很多功能，了解Spring 框架，我们一般会从它支持的 IOC 和 AOP 这两个核心功能来最开始认识它。</p><p><strong>目前Spring 最大的一个优势是它构建了一个非常不错的Java生态，你能够在这里面找到不同需求需要的处理方案。</strong></p><p>Spring 的官网： <a href="https://spring.io/">https://spring.io/</a></p><p>Github地址： <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p>Spring 的具体模块可以放后面了解，主要模块了解下。</p><p>Spring 5.x 主要模块</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212051.png" alt="image.png"><br>各个模块的依赖关系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212107.png" alt="image.png"></p><blockquote><p>Core Container</p></blockquote><p>其中主要模块中，Core Container  是 Spring 框架的核心模块，也是基础模块，它提供了 IOC 的依赖注入功能，Spring 的<strong>其他模块实现的功能也是在依赖该模块的基础上进行实现的</strong>。</p><p>Core Container 的子模块：</p><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</li></ul><blockquote><p>AOP</p></blockquote><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。(这个模块的使用场景非常有限)</li></ul><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://www.pdai.tech/md/spring/spring.html">https://www.pdai.tech/md/spring/spring.html</a></li><li><a href="https://blog.csdn.net/Mixzi/article/details/123980213">https://blog.csdn.net/Mixzi/article/details/123980213</a></li><li><a href="https://www.moguit.cn/info/794">https://www.moguit.cn/info/794</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows旧电脑重装CentOs7系统制作为个人服务器</title>
    <link href="/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>如果需要将一台 winodws 电脑重装为 centos 系统，需要分为下面几步</p><ul><li>1、先对 windows 进行磁盘格式化操作</li><li>2、通过 iso 文件进行对某个U盘刻录操作</li><li>3、电脑通过这个U盘进行安装 centos 系统</li><li>4、基本配置与使用</li></ul><p>具体操作见如下内容：</p><h3 id="1、格式化windows-的盘符"><a href="#1、格式化windows-的盘符" class="headerlink" title="1、格式化windows 的盘符"></a>1、格式化windows 的盘符</h3><p>重新安装 centos 系统前，需要在 window 系统下先进入PE环境，将原来装有Windows系统的盘符使用分区工具格式化为FAT32格式.</p><blockquote><p>制作U盘启动盘</p></blockquote><p>使用老毛桃U盘启动工具制作U盘启动盘:  <a href="http://lmt.psydrj.com/udisk.html">http://lmt.psydrj.com/udisk.html</a></p><p>模式选择USB—HDD，格式选择“NTFS”；制作完成后，可以选择模拟启动测试，若能够进入老毛桃winpe主菜单，即表示老毛桃U盘启动盘制作成功。【这里主要是要用到他的第四个 DiskGenius 工具】</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126214740.png" alt="image.png"></p><p>重新启动电脑，进入bios</p><p>界面会让你选择一个 boot device ，你这里根据英文选择一下 U 盘启动（界面是显示的U盘名称）</p><p>然后会进入到上面图片的内容（选择  DiskGenius ）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126220736.png" alt="image.png"></p><p>选择快速分区，选择分区类型FAT32，选择 1 个分区，</p><h3 id="2、重装-centos-系统"><a href="#2、重装-centos-系统" class="headerlink" title="2、重装 centos 系统"></a>2、重装 centos 系统</h3><p>下载好 centos7 的镜像文件： </p><ul><li><a href="https://man.linuxde.net/download/CentOS_7_4">https://man.linuxde.net/download/CentOS_7_4</a></li><li><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></li></ul><h4 id="刻录操作"><a href="#刻录操作" class="headerlink" title="刻录操作"></a>刻录操作</h4><p>下载 UltraISO 软碟通 </p><p>格式化之前的U盘，格式化为 FAT32 文件系统（或者准备第二个U盘）</p><p>选择写入硬盘映像</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222516.png" alt="image.png"></p><p>写入方式默认（USB-HDD+），单击便携启动，单击写入新的驱动器引导扇区，单击Syslinux。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222715.png" alt="image.png"></p><p>完毕后，单击下方写入，等待进度条满写入完毕。</p><blockquote><p>记：中间遇到一次 提示格式化重新操作</p></blockquote><p>UltraISO的软件提示其实是准确的，但却是程序员思维下科学素养级别的提示。这里的建议格式化U盘后再试，意思是建议你删除所有分区后重试</p><p>解决处理：</p><ul><li>1、下载 DiskGenius 格式化所有分区 </li><li>2、用win+R打开cmd，输入“diskpart”    输入“list disk”查看所有磁盘   依据大小选中对应磁盘“select disk x”    输入“clean”删除所有分区</li></ul><p>第一种方式的下载地址： <a href="https://xiazai.zol.com.cn/detail/33/327603.shtml">https://xiazai.zol.com.cn/detail/33/327603.shtml</a></p><p>格式化转换盘符为FAT32格式</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126234720.png" alt="image.png|500"></p><p>实际操作的时候显示设备写入错误 55</p><p>也试了一下网上说的通过管理员运行，或者上面说的格式化操作，都不行；最后通过买了一个新的 U 盘解决。</p><blockquote><p>通过 balenaEtcher 进行刻录操作</p></blockquote><p>下载地址：</p><ul><li><a href="https://www.ssdtop.com/balenaetcher.html">https://www.ssdtop.com/balenaetcher.html</a></li><li><a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></li></ul><p>下载  balenaEtcher 进行刻录操作，还是失败</p><p>猜测大概是U盘有问题，或者换一台电脑进行操作；这里选择重新购买一个新的 U 盘进行操作</p><p>Later…</p><p>新 U盘 通过 DiskGenius 格式化U盘分区，再通过 UltraISO 成功进行了刻录操作。</p><hr><h4 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h4><p>将 U 盘 插入需要重装的电脑并开机。如果已经设置完毕以USB为第一启动项，则不用再次进入bios界面。</p><p>没有的话再进入一次，通过 USB 启动。</p><blockquote><p>安装操作</p></blockquote><ul><li>1、选择Install CentOS 7</li><li>2、按回车键</li><li>3、成功进入CentOS系统图形化的安装界面后，进行初始化</li></ul><p>初始化配置</p><ul><li>①中文（语言）</li><li>②软件选择：GNOME桌面</li><li>③安装位置：选择磁盘，手动分区（选择“我要配置分区”）<ul><li>&#x2F;boot     也可以不添加     1G</li><li>&#x2F;swap   交互分区             2G</li><li>&#x2F;            根目录，分配剩下所有空间</li></ul></li></ul><blockquote><p>初始化配置</p></blockquote><p>②软件选择</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234606.png" alt="image.png"></p><p>③添加新挂载点 &#x2F;boot</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234855.png" alt="image.png"></p><p><strong>设置好后点击完成，选择接受更改</strong></p><blockquote><p>网络与主机名</p></blockquote><p>网络与主机名：<strong>打开网络，自己设置一个主机名，然后点击完成</strong></p><blockquote><p>用户设置</p></blockquote><p>开始安装</p><ul><li><strong>点击设置root密码</strong></li><li>等待过程中可以 <strong>创建一个普通用户</strong></li></ul><blockquote><p>重启电脑后配置内容</p></blockquote><p>重启电脑</p><p><strong>重启后进入初始设置界面，接受许可，然后点击完成配置</strong>  → 完成配置</p><p><strong>等待，然后来到登录页面，我们选择未列出，然后输入root和root的密码，然后点击登录。</strong></p><p><strong>来到桌面，我们选择语言为中文</strong></p><p><strong>关闭位置服务</strong></p><p>跳过在线账号</p><hr><h3 id="3、使用-windows-访问同一个局域网下的-linux-系统"><a href="#3、使用-windows-访问同一个局域网下的-linux-系统" class="headerlink" title="3、使用 windows 访问同一个局域网下的 linux 系统"></a>3、使用 windows 访问同一个局域网下的 linux 系统</h3><p>设置完成后，连接同一个wife</p><p>在 windows 中使用 xshell&#x2F;termius 工具访问即可</p><h3 id="4、内网穿透的使用"><a href="#4、内网穿透的使用" class="headerlink" title="4、内网穿透的使用"></a>4、内网穿透的使用</h3><p>略</p><p>暂未有这个需求，后续考虑使用。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/m0_59302403/article/details/132119884">https://blog.csdn.net/m0_59302403/article/details/132119884</a></li><li><a href="https://blog.csdn.net/weixin_42292697/article/details/110285529">https://blog.csdn.net/weixin_42292697/article/details/110285529</a></li><li><a href="https://www.bilibili.com/video/BV1c3411T7Td">https://www.bilibili.com/video/BV1c3411T7Td</a></li><li><a href="https://blog.csdn.net/m0_51545690/article/details/123238360">https://blog.csdn.net/m0_51545690/article/details/123238360</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人在线网盘_ZFile</title>
    <link href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/"/>
    <url>/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/</url>
    
    <content type="html"><![CDATA[<p>看到有一个还不错的项目，有时候需要将文件放置在云端，这里学习使用一下这个工具。（支持预览操作）</p><p>项目地址： <a href="https://github.com/zfile-dev/zfile">https://github.com/zfile-dev/zfile</a></p><p>部署文档地址： <a href="https://docs.zfile.vip/">https://docs.zfile.vip/</a></p><h3 id="1、项目运行"><a href="#1、项目运行" class="headerlink" title="1、项目运行"></a>1、项目运行</h3><p>下载项目后，需要系统里面有 JDK8 的环境</p><blockquote><p>Centos 系统运行</p></blockquote><blockquote><p>安装 JDK8</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk unzip<br></code></pre></td></tr></table></figure><blockquote><p>下载并解压</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ZFILE_INSTALL_PATH=~/zfile                        <span class="hljs-comment"># 声明安装到的路径</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ZFILE_INSTALL_PATH</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>   <span class="hljs-comment"># 创建文件夹并进入</span><br>wget --no-check-certificate https://c.jun6.net/ZFILE/zfile-release.war          <span class="hljs-comment"># 下载 zfile 最新版</span><br>unzip zfile-release.war &amp;&amp; <span class="hljs-built_in">rm</span> -rf zfile-release.war      <span class="hljs-comment"># 解压并删除压缩包</span><br><span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>/bin/*.sh                    <span class="hljs-comment"># 授权启动停止脚本</span><br></code></pre></td></tr></table></figure><p>ZFile 提供了一个 在线下载路径，也可以本地下载后自定义设备某些内容后，打包为 war ，放置在 linux 系统上运行。</p><p>如需修改配置文件，配置文件路径为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>WEB-INF<span class="hljs-regexp">/classes/</span>application.properties<br></code></pre></td></tr></table></figure><hr><p>安装说明</p><p>下面命令中第一行表示默认安装到用户目录下: <code>~/zfile</code> 下。</p><p>对于 <code>root</code> 用户, <code>~</code> &#x3D; <code>/root</code>, <code>~/zfile</code> 表示在 <code>/root/zfile</code> 路径下。</p><p>对于其他用户, <code>~</code> &#x3D; <code>/home/用户名</code> 表示在 <code>/home/用户名/</code> 路径下。如对于 <code>oracle</code> 用户, <code>~/zfile</code> 则表示安装在 <code>/home/oracle/zfile</code> 下。</p><p>如需更改安装路径, 请自行修改，如 <code>export ZFILE_INSTALL_PATH=/data/zfile</code>，表示安装在 <code>/data/zfile</code> 路径下。</p><hr><h3 id="2、启动项目"><a href="#2、启动项目" class="headerlink" title="2、启动项目"></a>2、启动项目</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br></code></pre></td></tr></table></figure><hr><p>启动后浏览器访问 <strong><code>http://ip:8080</code></strong> 即可，如启动后无法访问，请检查 <strong><code>端口是否冲突</code></strong> 或 <code>防火墙/安全组是否开启</code>。</p><p>简单检查方式为在服务器执行 <code>curl http://127.0.0.1:8080</code></p><ul><li>如返回 <code>curl: (7) Failed connect to 127.0.0.1:8080; Connection refused</code> 表示未启动成功。</li><li>如返回 <code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt;……</code> 等字样表示启动成功，如启动成功但通过服务器 IP 无法访问，那一般就是防火墙&#x2F;安全组未放行端口问题。</li></ul><hr><p>更新程序前务必停止程序再进行操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br>~<span class="hljs-regexp">/zfile/</span>bin/stop.sh        <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch_基础内容</title>
    <link href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><code>Elasticsearch</code>是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本  身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p><p>ES也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得  简单。</p><blockquote><p>Elasticsearch比传统关系型数据库如下：</p></blockquote><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Relational</span> <span class="hljs-variable constant_">DB</span> ‐&gt; <span class="hljs-title class_">Databases</span> ‐&gt; <span class="hljs-title class_">Tables</span> ‐&gt; <span class="hljs-title class_">Rows</span> ‐&gt; <span class="hljs-title class_">Columns</span>  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Elasticsearch</span> ‐&gt; <span class="hljs-title class_">Indices</span> ‐&gt; <span class="hljs-title class_">Types</span> ‐&gt; <span class="hljs-title class_">Documents</span> ‐&gt; <span class="hljs-title class_">Fields</span></span><br></code></pre></td></tr></table></figure><p>to be contined…..</p><p>参考</p><ul><li><a href="https://elasticsearch.bookhub.tech/getting_started/">https://elasticsearch.bookhub.tech/getting_started/</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li><a href="https://www.cnblogs.com/coderxz/p/13268417.html">https://www.cnblogs.com/coderxz/p/13268417.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/516698885">https://zhuanlan.zhihu.com/p/516698885</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习_基础内容</title>
    <link href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Vue 基础</li><li>Vue 语法</li><li>组件化开发</li><li>路由</li><li>webpack</li><li>脚手架</li></ul><hr><p>参考</p><ul><li><a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li><li><a href="https://blog.csdn.net/fmk1023/article/details/111381876">https://blog.csdn.net/fmk1023/article/details/111381876</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven工具_基础使用</title>
    <link href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Maven-下载与安装"><a href="#1、Maven-下载与安装" class="headerlink" title="1、Maven 下载与安装"></a>1、Maven 下载与安装</h3><p>略</p><h3 id="2、Maven配置文件修改"><a href="#2、Maven配置文件修改" class="headerlink" title="2、Maven配置文件修改"></a>2、Maven配置文件修改</h3><blockquote><p>maven 配置文件内容</p></blockquote><p>设置本地仓库路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置本地仓库路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\maven\localRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置阿里云私服（或换成自己公司搭建的私服）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在mirrors标签里添加mirror标签，并指定阿里云私服下载依赖会快点 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置 maven 默认jdk版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在已有的profiles标签中添加profile标签，限定maven项目默认的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- 让增加的 profile生效 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置华为云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.huaweicloud.com/repository/maven/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>阿里云:   <a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个论点，配置的时候注意一下：<strong>一个仓库只能对应一个镜像，当有多个镜像的mirrorOf指定了同一个仓库，maven只会从第一个匹配的仓库中进行查找</strong></p><h3 id="3、IDEA-配置-maven"><a href="#3、IDEA-配置-maven" class="headerlink" title="3、IDEA 配置 maven"></a>3、IDEA 配置 maven</h3><blockquote><p>IDEA 配置 maven</p></blockquote><p>快捷查找框中输入maven，查找与maven相关的设置，然后点击maven</p><p>修改maven的路径（使用本地的Maven），以及修改settings文件的位置和本地仓库的位置</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242131645.png" alt="image.png"></p><p>IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，进行勾选</p><p>他的意思是： mvn(directory):  位于项目的顶级目录中，文件 maven.config、jvm.config和extensions.xml 包含运行Maven的项目特定配置。这个目录应该是项目的一部分，需要被版本管理工具管理</p><blockquote><p>推荐配置：设置maven在不联网的情况下使用本地插件</p></blockquote><p>一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。（根据骨架创建项目速度会加快）</p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242133069.png" alt="image.png"></p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><h3 id="4、IDEA导入项目后maven-常见报错"><a href="#4、IDEA导入项目后maven-常见报错" class="headerlink" title="4、IDEA导入项目后maven 常见报错"></a>4、IDEA导入项目后maven 常见报错</h3><p>方法一：改一下 maven 配置文件，修改 mirror 仓库位置，重新导入项目，重新加载 maven 依赖</p><p>方法二：IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，不进行勾选试一下</p><p>方法三：去一下仓库地址，查看是否是否有该版本依赖，如果没有，改一下版本，或者手动下载，手动导入到本地仓库中</p><blockquote><p>报错1：解决Maven ‘parent.relativePath‘ of POM</p></blockquote><p>错误分析  </p><p>子模块的parent写的不是父模块，而是继承了springboot</p><p>解决方法  </p><p>在该<code>&lt;parent&gt;</code>标签中加上<code>&lt;relativePath /&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>   /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>报错2：对于类似于xxx-maven-plugin的插件报红</p></blockquote><p>类似于这样的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>报红就直接用不了了</p><p>我们可以通过添加依赖的方式解决（原来的插件就是上面的代码<strong>不要删</strong>）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yang_yzl11/article/details/120764764">https://blog.csdn.net/yang_yzl11/article/details/120764764</a></li><li><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">https://blog.csdn.net/qq_42057154/article/details/106114515</a></li><li><a href="https://www.cnblogs.com/SherlockLynn/p/15079467.html">https://www.cnblogs.com/SherlockLynn/p/15079467.html</a></li><li><a href="https://blog.csdn.net/qq_38217990/article/details/129257106">https://blog.csdn.net/qq_38217990/article/details/129257106</a></li><li><a href="https://zhuanlan.zhihu.com/p/653017610">https://zhuanlan.zhihu.com/p/653017610</a></li><li><a href="https://blog.csdn.net/qq_39505065/article/details/111559890">https://blog.csdn.net/qq_39505065/article/details/111559890</a></li><li><a href="https://blog.csdn.net/m0_46682011/article/details/120626933">https://blog.csdn.net/m0_46682011/article/details/120626933</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Nacos</title>
    <link href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/"/>
    <url>/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Nacos-是什么"><a href="#1、Nacos-是什么" class="headerlink" title="1、Nacos 是什么"></a>1、Nacos 是什么</h3><p>Nacos 是一个构建云原生应用的动态服务发现、配置管理和服务管理平台；致力于帮助发现、配置和管理微服务。</p><h3 id="2、下载与运行"><a href="#2、下载与运行" class="headerlink" title="2、下载与运行"></a>2、下载与运行</h3><p>下载地址： <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>windows版本使用<code>nacos-server-x.x.x.zip</code>包即可</p><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154048.png" alt="image.png"><br>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154144.png" alt="image.png"></p><blockquote><p>启动命令(Windows)</p></blockquote><p>启动非常简单，进入bin目录</p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><blockquote><p>访问</p></blockquote><p>在浏览器输入地址： <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> </p><p>默认的账号和密码都是nacos</p><blockquote><p>Namespace+Group+DataID三者的关系</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250024118.png" alt="image.png|400"></p><blockquote><p>多环境配置</p></blockquote><p>略</p><h3 id="3、Nacos-的基本使用"><a href="#3、Nacos-的基本使用" class="headerlink" title="3、Nacos 的基本使用"></a>3、Nacos 的基本使用</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>在 spring-cloud-alibaba-service 的主启动类上，使用 @EnableDiscoveryClient 注解开启 Nacos 服务发现功能</p><p>你访问该服务下的某个请求链接，再查看 nacos “服务管理”下的“服务列表”，会发现已经注册上了。</p><p>一般在消费端会引入 spring-cloud-loadbalancer 进行调用服务提供者提供的服务</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p><strong>动态获取配置内容</strong></p></blockquote><p>在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config ，可实现配置的获取与动态刷新</p><p>示例 </p><p>bootstrap.yml 文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span> <span class="hljs-comment">#端口号</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span> <span class="hljs-comment">#服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活 dev 的配置</span><br></code></pre></td></tr></table></figure><p>在 icu.luoqi.nacos.controller 包下，创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;<br><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;config.info&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String ConfigInfo;<br>    <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/config/info&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getConfigInfo()&#123;<br>        <span class="hljs-keyword">return</span> ConfigInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p><p>启动 Nacos Server，并在 Nacos Server 控制台的“配置管理”下的“配置列表”中，点击“+”按钮，新建如下配置</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Data ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">       config-client-dev.yaml</span><br><br><span class="hljs-attribute">Group</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         DEFAULT_GROUP</span><br><br><span class="hljs-attribute">配置格式</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      YAML</span><br><br><span class="hljs-attribute">配置内容</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      config:</span><br>                   <span class="hljs-attribute">info</span><span class="hljs-punctuation">:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>&#123;prefix&#125;-<span class="hljs-symbol">$</span>&#123;spring.profiles.active&#125;.<span class="hljs-symbol">$</span>&#123;<span class="hljs-keyword">file</span>-extension&#125;<br></code></pre></td></tr></table></figure><p>启动该服务，并使用浏览器访问“<a href="http://localhost:3377/config/info%E2%80%9D%EF%BC%8C">http://localhost:3377/config/info”，</a></p><p>在这种情况下，能够实现不重启后台服务，当你手动修改 nacos 的配置时，能够动态获取到配置内容。</p><blockquote><p>Nacos Config配置集的三种方式和加载顺序</p></blockquote><ul><li>通过 spring.cloud.nacos.config.shared-configs 配置项，支持多个共享 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.extension-configs 配置项，支持多个拓展 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.name 配置项，支持一个 Nacos 配置集。</li></ul><p>当三种方式共同使用时，它们的优先级关系是：A &lt; B &lt; C。另外，A 和 B 的命名带有“共享”或是“拓展”，没有任何含义，只是优先级不同</p><h3 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h3><p>命名空间id用于唯一标识命名空间， 新建命名空间时候，如果不填写命名空间id，则系统会自动生成命名空间id，生成规则为UUID方式。</p><p>但在spring 项目中集成nacos 的时候，配置文件中填写的namespace就是命名空间的id</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260000905.png" alt="image.png"></p><p>因此尽量保持nacos的命名空间名称和id 一致</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260002165.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106835279">https://blog.csdn.net/qq_36903261/article/details/106835279</a></li><li><a href="https://m.biancheng.net/springcloud/nacos.html">https://m.biancheng.net/springcloud/nacos.html</a></li><li><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></li><li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></li><li><a href="https://blog.csdn.net/weixin_45397785/article/details/128076533">https://blog.csdn.net/weixin_45397785/article/details/128076533</a></li><li><a href="https://blog.csdn.net/ysj1241267542/article/details/112562611">https://blog.csdn.net/ysj1241267542/article/details/112562611</a></li><li><a href="https://blog.csdn.net/u010520146/article/details/118703413">https://blog.csdn.net/u010520146/article/details/118703413</a></li><li><a href="https://blog.csdn.net/wangwei021933/article/details/129590430">https://blog.csdn.net/wangwei021933/article/details/129590430</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_实现在百度中搜索到自己的博客</title>
    <link href="/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1、注册一个百度站长账号</p></blockquote><p>地址： <a href="https://ziyuan.baidu.com/?castk=LTE=">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><p>验证网站所有权： <a href="https://ziyuan.baidu.com/site/index">https://ziyuan.baidu.com/site/index</a></p><p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Vercel</code>的地址，然后点击下一步。</p><p>站点领域： 信息技术</p><p>验证：选择第二种验证方式  →  HTML 验证</p><p><strong>本博客使用的是 fluid 主题</strong>，</p><p>进入博客目录下 <code>scripts</code> 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容（content 见百度具体验证内容)：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab">hexo.extend.filter.register(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(injects)</span> &#123;</span><br>  injects.head.raw(<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;&lt;meta name=&quot;</span>baidu-site-verification<span class="hljs-string">&quot; content=&quot;</span>xxxxxxxxxxxxxxx<span class="hljs-string">&quot; /&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在博客 <code>_config.yml</code> 文件加一句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_site_verification:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了。</p><p>点击验证按钮，如果没问题则已成功。</p><blockquote><p>2、站点地图功能</p></blockquote><p>需要生成一个站点地图</p><p>先确认一下 <code>_config.yml</code> 配置里面的 URL 值，如果不是改为自己的域名地址。</p><p>博客目录执行命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save        <span class="hljs-comment">#安装sitemap插件</span><br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save  <span class="hljs-comment">#安装baidu-sitemap插件</span><br><br>  <br>hexo g  <span class="hljs-comment">#生成网站静态文件到public文件夹</span><br></code></pre></td></tr></table></figure><blockquote><p>查看根目录下的public目录，会生成两个文件，“sitemap.xml ”和 “baidusitemap.xml”</p></blockquote><p>其中“sitemap.xml”文件是搜索引擎通用的文件，</p><p>“baidusitemap.xml”是百度专用的sitemap文件，</p><blockquote><p>3、提交sitemap到百度资源搜索平台</p></blockquote><p>选择资源提交，点击普通收录，选择sitemap， <a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a></p><p>填写网站地址，例：“域名&#x2F;baidusitemap.xml”，点击提交，过一段时间后博客就可以在百度中搜素到。</p><p>个人使用的时候这一步显示提交上限是 0 ；只能使用他手动提交的方式，而且只能是访问链接。</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/Passerby_Wang/article/details/124704475">https://blog.csdn.net/Passerby_Wang/article/details/124704475</a></li><li><a href="https://py-wang.blog.csdn.net/article/details/121202486">https://py-wang.blog.csdn.net/article/details/121202486</a></li><li><a href="https://cloud.tencent.com/developer/article/2317858">https://cloud.tencent.com/developer/article/2317858</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81</a></li><li><a href="https://zhuanlan.zhihu.com/p/150999914">https://zhuanlan.zhihu.com/p/150999914</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vercel的开箱使用_同步Hexo静态博客</title>
    <link href="/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>官网： <a href="https://vercel.com/">https://vercel.com/</a></p><p>部署无脑式导入 Github 原项目，然后进行 deploy 就行。命令可以自定义设置，一般是 hexo -s 之类的。(Vercels是支持你推送代码到Github的时候你在Vercel的项目也是会进行自动更新的)</p><p>点击部署的时候项目配置添加自定义域名操作：</p><p>Setting →  Domains →  选择添加解析域名</p><p>官网文档参考的解析域名地址</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240050203.png" alt="image.png"></p><p>实际操作记录：</p><p>个人使用的是阿里云的域名解析，在对应域名下添加了这一条记录<br>（对应 的记录值是 <code>cname.vercel-dns.com</code> ，记录类型需要是 CNAME）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240052961.png" alt="image.png"></p><p>domain 选择编辑对应的域名地址: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">varcel. + 你的阿里云域名<br></code></pre></td></tr></table></figure><p>最后部署访问成功。</p><hr><p>参考</p><ul><li><a href="https://juejin.cn/post/7143067114025254919">https://juejin.cn/post/7143067114025254919</a></li><li><a href="https://zhuanlan.zhihu.com/p/646818470">https://zhuanlan.zhihu.com/p/646818470</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day01</title>
    <link href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/"/>
    <url>/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/</url>
    
    <content type="html"><![CDATA[<h3 id="1、项目下载"><a href="#1、项目下载" class="headerlink" title="1、项目下载"></a>1、项目下载</h3><p>项目下载地址： <a href="https://gitee.com/moxi159753/mogu_blog_v2">https://gitee.com/moxi159753/mogu_blog_v2</a></p><h3 id="2、项目后端启动"><a href="#2、项目后端启动" class="headerlink" title="2、项目后端启动"></a>2、项目后端启动</h3><p>后端项目启动：</p><p>相关环境需要先启动和运行</p><p><code>nacos</code>，<code>nginx</code>，<code>rabbitmq</code>， <code>redis</code>，<code>mysql</code>，</p><p>模块启动：</p><p><code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p><blockquote><p>配置 Nacos</p></blockquote><p>模块启动前先配置一下 nacos </p><p>mogu 的启动方式是将数据放在了 mysql 数据库中，因此我们需要先执行它项目中的 nacos_config.sql 脚本</p><p>创建一个数据库 nacos_config，将配置导入到mysql中</p><p>解压nacos 到另外一个文件夹，然后进入 conf目录，打开 application.properties文件</p><p>在文件的末尾添加mysql的配置信息，注意mysql的账号和密码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mysql配置</span><br><span class="hljs-attr">spring.datasource.platform</span>=mysql<br><span class="hljs-attr">db.num</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">db.url.0</span>=jdbc:mysql://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span>/nacos_config?characterEncoding=utf8&amp;connectTimeout=<span class="hljs-number">1000</span>&amp;socketTimeout=<span class="hljs-number">3000</span>&amp;autoReconnect=<span class="hljs-literal">true</span>&amp;serverTimezone=UTC<br><span class="hljs-attr">db.user</span>=root<br><span class="hljs-attr">db.password</span>=root<br></code></pre></td></tr></table></figure><p>到nacos下的 bin 目录，启动服务</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><p>访问： <a href="http://127.0.0.1:8848/nacos/#/login">http://127.0.0.1:8848/nacos/#/login</a></p><p>启动模块前先将 dev 命名空间下的 配置文件对应的 redis, zipkin,mysql,rabbitmq的配置文件改一下</p><p>启动一下 相应服务</p><blockquote><p>执行一下数据库SQL 脚本</p></blockquote><blockquote><p>修改一下 Nacos 配置文件</p></blockquote><blockquote><p>依次启动服务：<code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p></blockquote><p>如果显示 zipkin 连接失败，尝试修改一下配置，添加一下 serviceName</p><p>Spring Cloud Sleuth配置中设置服务名称的示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  sleuth:</span><br><span class="hljs-symbol">    sampler:</span><br><span class="hljs-symbol">      probability:</span> <span class="hljs-number">1.0</span><br><span class="hljs-symbol">    zipkin:</span><br><span class="hljs-symbol">      baseUrl:</span> http:<span class="hljs-comment">//192.168.31.79:9411</span><br><span class="hljs-symbol">      serviceName:</span> your-service-name<br></code></pre></td></tr></table></figure><p>后端启动成功后，能够查看到对应的Swagger接口文档</p><blockquote><p>nacos版本：swagger-ui使用的是3.X，访问的页面是 <a href="http://localhost:8601/swagger-ui/index.html">http://localhost:8601/swagger-ui/index.html</a><br>sms 服务里面有短信和邮箱的配置，也注意改一下</p></blockquote><hr><h3 id="3、前端项目启动"><a href="#3、前端项目启动" class="headerlink" title="3、前端项目启动"></a>3、前端项目启动</h3><blockquote><p>vue_mogu_admin</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 指定node-sass的国内镜像源</span><br>npm i node-sass <span class="hljs-attribute">--sass_binary_site</span>=https://npm.taobao.org/mirrors/node-sass<br><br><span class="hljs-comment"># 使用淘宝镜像源进行依赖安装，解决国内下载缓慢的问题(出现警告可以忽略)</span><br>npm install <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 启动项目</span><br>npm <span class="hljs-built_in">run</span> dev<br><br><span class="hljs-comment">#打包项目（在部署的时候才需要使用）</span><br>npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><p>启动项目成功后，会跳转到：localhost:9528 ，</p><p>默认账号密码： admin, mogu2018 </p><p>实际在运行项目的时候，第一步有些问题，做了以下操作：</p><ul><li><ol><li>更新了一下依赖版本：”html-webpack-plugin”: “3.2.0”,</li></ol></li><li><ol start="2"><li>将windows 下的 3.x 的python 版本降级安装为 2.x 版本，且不超过 2.7</li></ol></li><li><ol start="3"><li>安装了 Visual C++ Build Tools for Visual Studio 2015</li></ol></li></ul><p>关于第三步，下载地址：<a href="https://my.visualstudio.com/Downloads?q=C++%20build">Downloads &amp; Keys - Visual Studio Subscriptions</a></p><p>在类型处选择DVD，然后下载下来，解压缩后运行其中的exe文件</p><blockquote><p>vue_mogu_web</p></blockquote><p>与上面一致，访问界面：localhost:9527</p><p>实际操作，有一些更改</p><ul><li><ol><li>由于依赖中 “node-sass”: “^4.14.1”, 需要和 node 版本对应，这里切换 Node 14 版本（使用NVM)</li></ol></li><li><ol start="2"><li>再次执行上面相同的运行命令</li></ol></li><li><ol start="3"><li>遇到运行命令可以尝试先删除node_module 文件夹再执行，或者执行 <code>npm cache clean --force</code> 再试一下。</li></ol></li></ul><p>至此，项目是能够完整运行并在浏览器上面访问。</p><hr><p>参考</p><ul><li><a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></li><li><a href="https://moxi159753.gitee.io/mogu_blog_doc/#/README">https://moxi159753.gitee.io/mogu_blog_doc/#/README</a></li><li><a href="https://blog.csdn.net/colleges/article/details/123769410">https://blog.csdn.net/colleges/article/details/123769410</a></li><li><a href="https://www.jb51.net/article/281818.htm">https://www.jb51.net/article/281818.htm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Eureka</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Eureka-是什么"><a href="#1、Eureka-是什么" class="headerlink" title="1、Eureka 是什么"></a>1、Eureka 是什么</h3><p>Eureka 是一个Netflix 开源的服务发现组件，包括 Server 和 Client 两部分。在 Spring Cloud 子项目 Spring Cloud Netflix 中。</p><blockquote><p>服务注册与发现</p></blockquote><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。</p><p>而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。</p><p>这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。</p><p>RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何 rpc 远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址）)</p><p>Eureka 系统架构（右图是Dubbo的架构）<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222335266.png" alt="image.png"></p><blockquote><p>Eureka Server 与 Eureka Client</p></blockquote><p>Eureka Server 提供服务注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>Eureka Client通过注册中心进行访问， Eureka Client 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h3 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h3><blockquote><p>服务端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--热部署工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向注册中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#为false表示自己是注册中心</span><br>    <span class="hljs-attr">service-url:</span>    <span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableEurekaServer</span> <span class="hljs-comment">//启动服务发现，接受注册</span><br><span class="hljs-variable">@SpringBootApplication</span><br>public class EurekaServer_7001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目，访问 <a href="http://localhost:7001/">http://localhost:7001/</a></p><blockquote><p>客户端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept-8001</span>   <span class="hljs-comment"># 修改eureka上的默认描述信息</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># true,可以显示服务的IP地址</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br>public class DeptProvider_8001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(DeptProvider_8001.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106551120">https://blog.csdn.net/qq_36903261/article/details/106551120</a></li><li><a href="https://blog.csdn.net/qq_45078781/article/details/118671285">https://blog.csdn.net/qq_45078781/article/details/118671285</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/142941185">https://zhuanlan.zhihu.com/p/142941185</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过RestTemplate进行远程调用</title>
    <link href="/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <url>/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>RestTemplate 是从 Spring3.0 开始支持的一个 HTTP 请求工具，它提供了常见的REST请求方案的模版。对于远程请求进行了一定封装，从而通过建议配置可以实现远程调用。</p><p>他底层用的是 JDK 的 HTTP 请求</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置类</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.demo.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.http.client.ClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RestTemplate配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(factory);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;<br>        SimpleClientHttpRequestFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleClientHttpRequestFactory</span>();<br>        factory.setReadTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        factory.setConnectTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>示例调用操作</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">//因为浏览器只支持get请求，为了方便这里就用get</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/create&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; create(Payment payment)&#123;<br>        log.info(<span class="hljs-string">&quot;********插入的数据：&quot;</span> + payment);<br>        <span class="hljs-comment">//postForObject分别有三个参数：请求地址，请求参数，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/get/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; getPayment(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id)&#123;<br>        log.info(<span class="hljs-string">&quot;********查询的id：&quot;</span> + id);<br>        <span class="hljs-comment">//getForObject两个参数：请求地址，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined… </p><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44073321/article/details/102804615">https://blog.csdn.net/weixin_44073321/article/details/102804615</a></li><li><a href="https://blog.csdn.net/weixin_43702146/article/details/116567707">https://blog.csdn.net/weixin_43702146/article/details/116567707</a></li><li><a href="https://blog.csdn.net/dqxiaoxiao/article/details/114375873">https://blog.csdn.net/dqxiaoxiao/article/details/114375873</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CodeProgram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见工程报错问题</title>
    <link href="/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_基础概念</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SpringCloud是什么"><a href="#1、SpringCloud是什么" class="headerlink" title="1、SpringCloud是什么"></a>1、SpringCloud是什么</h3><p>SpringCloud 提供了一整套的分布式系统解决方案，通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。</p><p>SpringCloud 包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等。</p><p>Spring Cloud 包含很多子项目，国内主要是采用 Netflix 和 Alibaba 两个标准实现，前者由于不再维护，目前一般采用Spring Cloud Alibaba 这一套微服务解决方案。</p><blockquote><p>了解组件</p></blockquote><p>Spring Cloud Netflix 第一代</p><p>针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。</p><ul><li><code>Netflix Eureka</code>：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。</li><li><code>Netflix Ribbon</code>：客户端负载均衡的服务调用组件。</li><li><code>Netflix Hystrix</code>：容错管理工具，实现断路器模式，通过控制服务的节点，从而对延迟和故障提供更强大的容错能力。</li><li><code>Netflix Feign</code>：基于 Ribbon 和 Hystrix 的声明式服务调用组件。</li><li><code>Netflix Zuul</code>：微服务网关，提供动态路由，访问过滤等服务。</li><li><code>Netflix Archaius</code>：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li></ul><p>Spring Cloud Alibaba 第二代</p><p><strong>阿里开源组件</strong></p><ul><li><code>Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><p><strong>阿里商业化组件</strong></p><ul><li><code>Alibaba Cloud ACM</code>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><code>Alibaba Cloud OSS</code>：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><code>Alibaba Cloud SchedulerX</code>：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><code>Alibaba Cloud SMS</code>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><blockquote><p>关于Cloud各种组件的停更升级替换</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221942122.png" alt="image.png"></p><blockquote><p>SpringCloud 版本介绍</p></blockquote><p>略</p><h3 id="2、创建cloud聚合父工程"><a href="#2、创建cloud聚合父工程" class="headerlink" title="2、创建cloud聚合父工程"></a>2、创建cloud聚合父工程</h3><h4 id="初始化工程及配置"><a href="#初始化工程及配置" class="headerlink" title="初始化工程及配置"></a>初始化工程及配置</h4><ol><li>New Project</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221957842.png" alt="image.png"></p><ol start="2"><li>聚合总父工程名字</li><li>Maven选版本</li><li>开启自动导入</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221958787.png" alt="image.png"></p><ol start="5"><li>字符编码</li></ol><p>Settings → Editor →  File Encodings</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222220247.png" alt="image.png"></p><ol start="6"><li>注解生效激活</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222222672.png" alt="image.png"></p><ol start="7"><li>java编译版本选8</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222223525.png" alt="image.png"></p><ol start="8"><li>File Type过滤</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222225655.png" alt="image.png"></p><p>这里File Type 配置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*.idea</span><br><span class="hljs-comment">*.iml</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222226068.png" alt="image.png"></p><h4 id="父工程-pom-配置"><a href="#父工程-pom-配置" class="headerlink" title="父工程 pom 配置"></a>父工程 pom 配置</h4><p>父工程 Pom 文件参考配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.luoqi.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2023<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--统一管理jar包版本--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud alibaba--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mysql--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- druid--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;druid.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mybatis.spring.boot.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--junit--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;junit.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--log4j--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log4j.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><ul><li><ol><li>新建模块</li></ol></li><li><ol start="2"><li>pom文件对应依赖</li></ol></li><li><ol start="3"><li>yml 配置文件</li></ol></li><li><ol start="4"><li>启动类以及其他业务类</li></ol></li></ul><hr><p>参考</p><ul><li><a href="https://gitee.com/lixiaogou/cloud2020">https://gitee.com/lixiaogou/cloud2020</a></li><li><a href="https://blog.csdn.net/qq_36903261/article/details/106507150">https://blog.csdn.net/qq_36903261/article/details/106507150</a></li><li><a href="https://github.com/angenin/cloud2020">https://github.com/angenin/cloud2020</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/110249846">https://zhuanlan.zhihu.com/p/110249846</a></li></ul><p>引用</p><ul><li><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></li><li><a href="https://www.springcloud.cc/">https://www.springcloud.cc/</a></li><li><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapters1_极限与连续</title>
    <link href="/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/"/>
    <url>/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、映射与函数"><a href="#1、映射与函数" class="headerlink" title="1、映射与函数"></a>1、映射与函数</h3><p>学习极限前，先了解一些基础概念，对于函数整个内容有一个认识。</p><h4 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210437941.png" alt="image.png"></p><p>定义：定义域内<strong>任何</strong>元素，都在值域中有<strong>唯一</strong>的元素与之对应。</p><p>函数概念有两个基本要素：定义域、对应法则。</p><p>理解：函数是研究关系的，是在研究两个变量之间的关系。具体来说，函数是研究因变量是怎么随着自变量的变化而变化的。</p><blockquote><p>举例</p></blockquote><p>举个例子，在速度为40km&#x2F;h的匀速运动过程中，路程随时间的变化而变化：</p><ul><li>时间是1时，路程是40；</li><li>时间是2时，路程就是80。</li></ul><p>路程&#x3D;40 * 时间。路程就叫做时间的函数。</p><p>但不是有关系就是函数，不是因变量随自变量变化就是函数。还得满足一个重要的条件：对于自变量的每一个取值，因变量都有唯一的值与它对应！</p><p>例如，上述匀速运动过程中，时间每取一个值，对应计算出路程也是一个值。</p><p>反例：|y|&#x3D;x，在这个式子里，y也随x的变化而变化，但x&#x3D;1时，y&#x3D;1或—1，有两个值了。那y就不是x的函数了。</p><p>所以，函数是两个变量之间的特殊关系</p><h4 id="几个常见函数"><a href="#几个常见函数" class="headerlink" title="几个常见函数"></a>几个常见函数</h4><ul><li>绝对值函数</li><li>符号函数</li><li>取整函数</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210449362.png" alt="image.png"></p><h4 id="函数的特性"><a href="#函数的特性" class="headerlink" title="函数的特性"></a>函数的特性</h4><ul><li>有界性</li><li>单调性</li><li>奇偶性</li><li>周期性</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210452693.png" alt="image.png"></p><h4 id="反函数与复合函数"><a href="#反函数与复合函数" class="headerlink" title="反函数与复合函数"></a>反函数与复合函数</h4><blockquote><p>反函数</p></blockquote><p>定义：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210455686.png" alt="image.png"></p><blockquote><p>复合函数</p></blockquote><p>复合条件：内层函数值域与外层函数定义域的交集非空</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210456045.png" alt="image.png"></p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>函数的运算（加减乘除）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210457870.png" alt="image.png"></p><p>其中函数相除的时候 g(x) 不等于 0 </p><p>相关定理：任何一个函数(定义域对称)都可以找到一个奇函数和一个偶函数，使得这个函数等于偶函数加奇函数</p><blockquote><p>例题（证明题）</p></blockquote><p>以函数的运算证明:任给f(x)的定义域为(-L,L),证明必存在(-L,L)上的偶函数g(x)以及奇函数h(x),使得f(x)&#x3D;g(x)+h(x)</p><p>解析：</p><p>根据前面函数特征中的奇偶性，可以得知 奇函数 h( -x ) &#x3D; -h(x) ; 偶函数 g(-x) &#x3D; g(x)</p><p>先假设存在这样的奇偶函数，</p><p>to be improve….</p><p>解答：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210502430.png" alt="image.png"></p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><p>定义：由常数和基本初等函数经过有限次的加、减、乘、 除和复合所得到且能用一个解析式表示的函数,称为初等函数</p><blockquote><p>基本初等函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210504661.png" alt="image.png"></p><blockquote><p>关于反三角函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210505070.png" alt="image.png"></p><blockquote><p>内容小结</p></blockquote><ul><li>函数的定义及函数的二要素<ul><li>定义域</li><li>对应法则</li></ul></li><li>函数的特性<ul><li>有界性，单调性，奇偶性，周期性</li></ul></li><li>复合函数与反函数</li><li>基本初等函数与初等函数</li></ul><h3 id="2、数列的极限"><a href="#2、数列的极限" class="headerlink" title="2、数列的极限"></a>2、数列的极限</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210548604.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>用定义证明下列极限</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210550053.png" alt="image.png"></p><h4 id="收敛函数的性质"><a href="#收敛函数的性质" class="headerlink" title="收敛函数的性质"></a>收敛函数的性质</h4><p>收敛函数的性质</p><ul><li>唯一性<ul><li>收敛数列的极限唯一</li></ul></li><li>有界性<ul><li>收敛数列必有界</li></ul></li><li>保号性</li><li>任一子数列收敛于同一极限</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210553054.png" alt="image.png"></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210554140.png" alt="image.png"></p><p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/563178651">https://zhuanlan.zhihu.com/p/563178651</a></li><li><a href="https://www.zhihu.com/question/457091692/answer/2763695044">https://www.zhihu.com/question/457091692/answer/2763695044</a></li><li><a href="https://zhuanlan.zhihu.com/p/31206539">https://zhuanlan.zhihu.com/p/31206539</a></li><li>《武忠详高数零基础》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Exam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx_基础概念</title>
    <link href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、启动Nginx"><a href="#1、启动Nginx" class="headerlink" title="1、启动Nginx"></a>1、启动Nginx</h3><blockquote><p>Windows 下启动 nginx</p></blockquote><p>在下载 nginx 后，在nginx安装目录的绝对路径的框框内输入 <code>cmd</code></p><p>直接输入 <code>nginx</code> 或者 <code>start nginx</code>，然后回车，就可以启动nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nginx<br><br><span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>在浏览器地址栏输入 <code>localhost:80</code>，然后再回车, 查看是否有 nginx 访问主页，如果有，则启动成功。</p><p>一般访问问题是端口占用，可以改一下 nginx 访问端口，或者杀掉对应进程。</p><p>关闭nginx的命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nginx -s stop<br></code></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44251179/article/details/129700793">https://blog.csdn.net/weixin_44251179/article/details/129700793</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify使用教程</title>
    <link href="/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、快速开始"><a href="#1、快速开始" class="headerlink" title="1、快速开始"></a>1、快速开始</h3><p>全局安装 <code>docsify-cli</code> 工具，可以方便地创建及在本地预览生成的文档。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i docsify-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><blockquote><p>初始化项目</p></blockquote><p>如果想在项目的 <code>./docs</code> 目录里写文档，直接通过 <code>init</code> 初始化项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docsify init ./docs<br></code></pre></td></tr></table></figure><blockquote><p>开始写文档</p></blockquote><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新文档内容，当然也可以添加更多页面。</p><blockquote><p>本地预览</p></blockquote><p>通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。</p><p>默认访问地址 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docsify serve docs</span><br></code></pre></td></tr></table></figure><h3 id="2、多页文档设置"><a href="#2、多页文档设置" class="headerlink" title="2、多页文档设置"></a>2、多页文档设置</h3><p>在 docsify 中，你访问的文档 URL 路径地址和你的文档文件夹结构是一个映射关系（实现多级路由）；</p><p>比如你在 doc 文件夹中创建<code>guide.md</code>、<code>zh-cn/READEME.md</code>、<code>zh-cn/guide.md</code>，结构如下所示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos">.<br>├── README.<span class="hljs-built_in">md</span><br>├── guide.<span class="hljs-built_in">md</span><br>├── index.html<br>└── zh-cn<br>    ├── README.<span class="hljs-built_in">md</span><br>    └── guide.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>此时我们访问如下url即可以访问到对应的页面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">README.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span><br>guide.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/gui</span>de<br><span class="hljs-regexp">/zh-cn/</span>README.md  =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/<br><span class="hljs-regexp">/zh-cn/gui</span>de.md   =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/guide<br><br></code></pre></td></tr></table></figure><h3 id="3、定制化配置"><a href="#3、定制化配置" class="headerlink" title="3、定制化配置"></a>3、定制化配置</h3><h4 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h4><p>需要先在 docs&#x2F;index.html 中修改一下配置，开启侧边栏的选项添加<code>loadSiderbar: true</code></p><p>这样设置后就会加载 Docsify 目录下的 _ sidebar.md 文件,  进行加载而渲染成我们定制的侧边栏</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span><br>loadSidebar: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311201949003.png" alt="image.png"></p><p>我们在 docs 目录下创建一个 <code>_sidebar.md</code> 文件，里面可以对侧边栏进行配置，比如这里配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>这里使用的是 MarkDown 中的超链接语法，后面的路径对应着上述多页文档的路由路径</p><p>我们还可以指定页面的标题，比如这里指定首页的标题为home 【后面添加双引号进行别名】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/ &quot;home&quot;) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><h4 id="侧边栏嵌套设置"><a href="#侧边栏嵌套设置" class="headerlink" title="侧边栏嵌套设置"></a>侧边栏嵌套设置</h4><p>在对应子目录 docs&#x2F;zh-cn 下创建一个 <code>_sidebar.md</code> 文件，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/zh-cn/_sidebar.md --&gt;</span><br><br>* [zh-ch首页](/zh-cn) <br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>_ sidebar.md 的加载逻辑是从每层目录下获取文件，如果当前目录不存在该文件则回退到上一级目录。<br>例如当前路径为 &#x2F;zh-cn 则从 &#x2F;zh-cn&#x2F;_ sidebar.md 获取文件，如果不存在则从 &#x2F;_ sidebar.md 获取，</p><p>我们也可以在 index.html 中如下配置表示默认都走根路径下的 <code>_sidebar.md</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="开启目录功能"><a href="#开启目录功能" class="headerlink" title="开启目录功能"></a>开启目录功能</h4><p>自定义侧边栏同时也可以开启目录功能。设置 <code>subMaxLevel</code> 配置项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">    <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="目录折叠功能"><a href="#目录折叠功能" class="headerlink" title="目录折叠功能"></a>目录折叠功能</h4><p>需要引入一下 docsify-sidebar-collapse 样式 , 具体配置可以看一下下面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Description&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 文件夹样式 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar-folder.min.css&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 箭头样式 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar.min.css&quot; /&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span></span><br><span class="language-javascript">  <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">  <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Docsify v4 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 侧边栏目录折叠 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>添加导航栏有两种方式，一是直接到 index.html 中添加，二是和侧边栏类似，通过 md 文件的形式来添加。</p><blockquote><p><strong>通过md文件来添加</strong></p></blockquote><p>首先在 index.html 中配置 <code>loadNavbar</code>，默认加载的文件为 <code>_navbar.md</code> </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启导航栏,加载_navbar.md </span><br>loadNavbar: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套列表</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;!-- _navbar<span class="hljs-selector-class">.md</span> --&gt;<br><br>* 入门<br>  * <span class="hljs-selector-attr">[快速开始]</span>(zh-cn/quickstart.md)<br>  * <span class="hljs-selector-attr">[多页文档]</span>(zh-cn/more-pages.md)<br>  * <span class="hljs-selector-attr">[定制导航栏]</span>(zh-cn/custom-navbar.md)<br>  * <span class="hljs-selector-attr">[封面]</span>(zh-cn/cover.md)<br><br><br>* 配置<br>  * <span class="hljs-selector-attr">[配置项]</span>(zh-cn/configuration.md)<br>  * <span class="hljs-selector-attr">[主题]</span>(zh-cn/themes.md)<br>  * <span class="hljs-selector-attr">[使用插件]</span>(zh-cn/plugins.md)<br>  * <span class="hljs-selector-attr">[Markdown 配置]</span>(zh-cn/markdown.md)<br>  * <span class="hljs-selector-attr">[代码高亮]</span>(zh-cn/language-highlight.md)<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311202158957.png" alt="image.png"></p><h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p>在 index.html 中设置 <code>coverpage</code> 参数开启封面功能</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启封面,加载_coverpage.md</span><br>coverpage: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p>在文档根目录创建 <code>_coverpage.md</code> 文件，用于配置封面内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docsify <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span></span>3.5<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span></span></span><br><br><span class="hljs-quote">&gt; 一个神奇的文档网站生成器。</span><br><br><span class="hljs-bullet">-</span> 简单、轻便 (压缩后 ~21kB)<br><span class="hljs-bullet">-</span> 无需生成 html 文件<br><span class="hljs-bullet">-</span> 众多主题<br><br>[<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com/docsifyjs/docsify/</span>)<br></code></pre></td></tr></table></figure><p>目前的背景是随机生成的渐变色，可以自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 网站图标 --&gt;</span><br>![logo](_media/icon.jpg)<br><br># docsify <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br>&gt; 一个神奇的文档网站生成器。<br><br>- 简单、轻便 (压缩后 ~21kB)<br>- 无需生成 html 文件<br>- 众多主题<br><br>[GitHub](https://github.com/docsifyjs/docsify/)<br><br><span class="hljs-comment">&lt;!-- 背景图片 --&gt;</span><br>![](_media/玩家.png)<br><br><span class="hljs-comment">&lt;!-- 背景色 --&gt;</span><br>![color](#f0f0f0)<br></code></pre></td></tr></table></figure><p>通常封面和首页是同时出现的，你可以将封面独立出来</p><p>配置（只在访问主页时加载封面）：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">window</span>.<span class="hljs-variable">$docsify</span> = &#123;<br>  onlyCover:<span class="hljs-built_in"> false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>见： <a href="https://docsify.js.org/#/zh-cn/themes">https://docsify.js.org/#/zh-cn/themes</a></p><h3 id="4、基于nginx-docsify搭建"><a href="#4、基于nginx-docsify搭建" class="headerlink" title="4、基于nginx + docsify搭建"></a>4、基于nginx + docsify搭建</h3><p>nginx 配置文件中，在 <code>http</code> 块内添加一个新的 <code>server</code> 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /docs &#123;<br><span class="hljs-built_in">alias</span> D:/shareDocs/docs; <span class="hljs-comment"># 修改为你的 Docsify 项目绝对路径</span><br>index index.html;<br>try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://docsify.js.org/#/zh-cn/quickstart">https://docsify.js.org/#/zh-cn/quickstart</a></li><li><a href="https://www.cnblogs.com/Can-daydayup/p/15413267.html">https://www.cnblogs.com/Can-daydayup/p/15413267.html</a></li><li><a href="https://ysgstudyhards.github.io/Docsify-Guide/#/README">https://ysgstudyhards.github.io/Docsify-Guide/#/README</a></li><li><a href="https://blog.csdn.net/qq_45173404/article/details/122683872">https://blog.csdn.net/qq_45173404/article/details/122683872</a></li><li><a href="https://developer.aliyun.com/article/1266542">https://developer.aliyun.com/article/1266542</a></li><li><a href="https://clotliu.com/archives/docsify-advanced">https://clotliu.com/archives/docsify-advanced</a></li><li><a href="https://www.cnblogs.com/yangstar/articles/16690435.html">https://www.cnblogs.com/yangstar/articles/16690435.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL_基础概念</title>
    <link href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、NoSQL-是什么"><a href="#1、NoSQL-是什么" class="headerlink" title="1、NoSQL 是什么"></a>1、NoSQL 是什么</h3><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><h4 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h4><table><thead><tr><th></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td>发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td>例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td>ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td>性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td>扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td>用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td>查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h4 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h4><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231119123254.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/nosql.html">https://javaguide.cn/database/nosql.html</a></li><li><a href="https://www.ibm.com/cn-zh/topics/nosql-databases">https://www.ibm.com/cn-zh/topics/nosql-databases</a></li><li><a href="https://zhuanlan.zhihu.com/p/345342966">https://zhuanlan.zhihu.com/p/345342966</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插件实现Obsidian实时同步</title>
    <link href="/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、插件下载和服务安装"><a href="#1、插件下载和服务安装" class="headerlink" title="1、插件下载和服务安装"></a>1、插件下载和服务安装</h3><p>使用插件： Self-hosted LiveSync</p><p>在服务器上面安装 docker 后，</p><p>创建一个文件 <code>local.ini</code></p><p>复制以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[couchdb]</span><br><span class="hljs-attr">single_node</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd_auth]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">authentication_redirect</span> = /_utils/session.html<br><br><span class="hljs-section">[httpd]</span><br><span class="hljs-attr">WWW-Authenticate</span> = Basic realm=<span class="hljs-string">&quot;couchdb&quot;</span><br><span class="hljs-attr">enable_cors</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[cors]</span><br><span class="hljs-attr">origins</span> = app://obsidian.md,capacitor://localhost,http://localhost<br><span class="hljs-attr">credentials</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">headers</span> = accept, authorization, content-type, origin, referer<br><span class="hljs-attr">methods</span> = GET, PUT, POST, HEAD, DELETE<br><span class="hljs-attr">max_age</span> = <span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>将该文件移动到 <code>/opt/couchdb</code>目录下</p><p>运行下面命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d --restart always -e <span class="hljs-attribute">COUCHDB_USER</span>=luo -e <span class="hljs-attribute">COUCHDB_PASSWORD</span>=luo123 -v /opt/couchdb/local.ini:/opt/couchdb/etc/local.ini -p 6900:5984 couchdb<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>COUCHDB_USER</code> 后面的是你的用户名</li><li><code>COUCHDB_PASSWORD</code> 后面的是你的密码</li><li><code>/opt/couchdb/local.ini</code> 是配置文件的路径</li><li><code>/opt/couchdb/db</code> 是数据库的路径</li><li><code>-p 6900:5984</code> 前面的 6900 是暴露在外的端口。</li></ul><p>检查是否运行成功</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo docker <span class="hljs-keyword">ps</span> |<span class="hljs-keyword">grep</span> couchdb<br></code></pre></td></tr></table></figure><h3 id="2、插件配置"><a href="#2、插件配置" class="headerlink" title="2、插件配置"></a>2、插件配置</h3><p>打开Obsidian的设置-第三方插件，在插件市场安装<code>Self-hosted LiveSync</code></p><blockquote><p>客户端配置</p></blockquote><p>安装并启用后打开插件的设置界面，填写箭头内容，URI 为刚刚的<code>http://IP+端口（6900）</code>，例如：<code>http://127.0.0.1:6900</code>，</p><p>Username 和 Password 为前面的参数设置的内容，</p><p>Database name 可以自己取，注意不要填大写字母，完成后点击test 按钮</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230051.png" alt="image.png"></p><p>右上角出现 <code>Connect to 数据库名</code>，则为连接成功</p><p>如果你之前配置连接过，并存放过数据，你连接后会将对应的数据库中的文件同步到你目前的工作空间中；也可以理解他的数据是存放在了服务器中的数据库，设备连接该服务后的同步操作，本质上都是在操作更新服务器上面的数据库文件内容，然后更新对应映射内容到设备的Obsidian文件中。</p><p>完成后点击下面的check ，将所有提示错误的选择fix，然后再次点击check ，直到没有错误</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230528.png" alt="image.png"></p><p>划到最下方，选择端对端加密（End to End Encryption），在输入框中设置密码，点击启用</p><p><strong>如果仅想要同步文章无需开启端对端加密</strong></p><p>在Sync Setting 选项卡中，选择LiveSync（实时同步），点击Apply启用</p><p>建议启用 <code>Use Trash for deleted files</code>（删除文件到回收站）</p><p>建议启用 <code>Miscellaneous</code> 选项卡中的 <code>Show staus inside editor</code> （会在编辑器右上角显示状态）</p><blockquote><p>复制配置到其他设备</p></blockquote><p>在插件Setup wizard 选项卡中，点击 <code>Copy Setup URI</code>，弹出的对话框设置密码，即可复制当前的配置信息</p><p>复制后打开自己需要同步的设备点击Open setup URI 粘贴复制的内容，输入设置的密码，点击第一个</p><hr><p>参考</p><ul><li><a href="https://sspai.com/post/82161#">https://sspai.com/post/82161#</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装和下载</title>
    <link href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Node-js-下载安装"><a href="#1、Node-js-下载安装" class="headerlink" title="1、Node.js 下载安装"></a>1、Node.js 下载安装</h3><p>官网下载： <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>安装后，验证一下是否安装成功</p><p>打开 cmd, 输入node -v，npm -v，出现如下界面安装成功</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117221300.png" alt="image.png"></p><h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><blockquote><p>环境变量配置</p></blockquote><p>新增<strong>用户变量</strong>  <code>NODE_PATH</code>，变量值设置为 <code>xxx\nodejs</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224932.png" alt="image.png"></p><p>编辑<strong>用户变量</strong>中的【Path】</p><p>修改 变量名 <code>Path</code></p><p>将默认的 C 盘下【 <code>AppData\Roaming\npm</code> 】修改成 <code>%NODE_PATH%</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224741.png" alt="image.png"></p><p>设置完后也打开 cmd, 输入一下  node -v，npm -v  看是否OK。</p><blockquote><p>配置npm的全局模块的存放路径以及cache的路径</p></blockquote><p>找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】</p><p>使用管理员身份打开cmd窗口，执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;xxx\Node.js\node_global&quot;</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;xxx\Node.js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>新增系统Path变量</p></blockquote><p>在【系统变量】中选择【Path】点击【编辑】添加你刚才配置的两个路径。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117225456.png" alt="image.png"></p><h3 id="3、安装淘宝镜像"><a href="#3、安装淘宝镜像" class="headerlink" title="3、安装淘宝镜像"></a>3、安装淘宝镜像</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>查看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h3 id="4、NVM-安装"><a href="#4、NVM-安装" class="headerlink" title="4、NVM 安装"></a>4、NVM 安装</h3><p>下载地址： <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>NVM 是一个 node 版本管理工具，这里主要是由于前端项目中有时候需要的版本不同，需要切换</p><ul><li><ol><li>下载 nvm-setup.zip 文件</li></ol></li><li><ol start="2"><li>卸载电脑安装的 node ，在程序与功能上卸载 node ，同时删除之前的环境变量</li></ol></li><li>3.解压文件后，有一个 nvm-setup.exe ，点击安装</li><li>4.安装你需要的版本</li><li>5.可能需要重新启动一下你的电脑</li></ul><p>常用命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nvm ls               // 查看已安装<span class="hljs-keyword">node</span><span class="hljs-title">版本</span><br><span class="hljs-title">nvm</span> install vXX      // 安装对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> uninstall vXX    // 卸载对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> use xxx          // 选择使用XXX版本<br></code></pre></td></tr></table></figure><p>实际操作</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#安装并切换版本到 14.21.3，安装需要一点时间</span><br><span class="hljs-attribute">nvm</span> install <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">nvm</span> use <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/m0_62617719/article/details/130423504">https://blog.csdn.net/m0_62617719/article/details/130423504</a></li><li><a href="https://blog.csdn.net/JingYan_Chan/article/details/125405423">https://blog.csdn.net/JingYan_Chan/article/details/125405423</a></li><li><a href="https://blog.csdn.net/MyronCham/article/details/119561972">https://blog.csdn.net/MyronCham/article/details/119561972</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dokcer入门_基础概念</title>
    <link href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Docker"><a href="#1、什么是-Docker" class="headerlink" title="1、什么是 Docker"></a>1、什么是 Docker</h3><blockquote><p>理解虚拟化技术</p></blockquote><p>人们为了提高系统及硬件资源的利用率而引入了<strong>虚拟化技术</strong>。虚拟化是一种<strong>资源管理技术</strong>，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。</p><p>虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。</p><p>从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。</p><blockquote><p>基于软件的虚拟化</p></blockquote><p>软件虚拟化是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p><p>对软件虚拟化进行细分，又可以分为以下几类：</p><ul><li>完全虚拟化</li><li>硬件辅助虚拟化</li><li>部分虚拟化</li><li>平行虚拟化</li><li>操作系统层虚拟化</li></ul><p>Docker容器技术就是属于操作系统层虚拟化的范畴。</p><p>虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。</p><blockquote><p>虚拟机和Docker</p></blockquote><p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源。</p><p>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p><blockquote><p>虚拟机和 Docker 的对比<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171252304.png" alt="image.png"></p></blockquote><blockquote><p>图解物理机,虚拟机与容器</p></blockquote><p>物理机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456074.png" alt="image.png"></p><p>虚拟机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456887.png" alt="image.png"><br>容器</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171457700.png" alt="image.png"></p><p>虚拟机和Docker容器各自有自己的应用场景，<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。</p><p>而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p><h3 id="2、Docker-基本概念"><a href="#2、Docker-基本概念" class="headerlink" title="2、Docker 基本概念"></a>2、Docker 基本概念</h3><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><blockquote><p><strong>Docker Registry 公开服务和私有 Docker Registry</strong></p></blockquote><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" title="https://hub.docker.com/">https://hub.docker.com/open in new window</a> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171534204.png" alt="image.png"></p><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ docker <span class="hljs-keyword">search</span> mysql<br><span class="hljs-type">NAME</span>                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>mysql                             MySQL <span class="hljs-keyword">is</span> a widely used, <span class="hljs-keyword">open</span>-source relation…   <span class="hljs-number">8763</span>                [OK]<br>mariadb                           MariaDB <span class="hljs-keyword">is</span> a community-developed fork <span class="hljs-keyword">of</span> MyS…   <span class="hljs-number">3073</span>                [OK]<br>mysql/mysql-<span class="hljs-keyword">server</span>                Optimized MySQL <span class="hljs-keyword">Server</span> Docker images. <span class="hljs-keyword">Create</span>…   <span class="hljs-number">650</span>                                     [OK]<br></code></pre></td></tr></table></figure><p>在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" title="阿里云镜像库">阿里云镜像库</a>。</p><p>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。</p><p>Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="3、基本命令"><a href="#3、基本命令" class="headerlink" title="3、基本命令"></a>3、基本命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker <span class="hljs-keyword">version</span> <span class="hljs-comment"># 查看docker版本</span><br>docker images <span class="hljs-comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span><br>docker container <span class="hljs-keyword">ls</span> <span class="hljs-comment"># 查看所有容器</span><br>docker ps <span class="hljs-comment">#查看正在运行的容器</span><br>docker image prune <span class="hljs-comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span><br></code></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search mysql <span class="hljs-comment"># 查看mysql相关镜像</span><br>docker pull mysql:5.7 <span class="hljs-comment"># 拉取mysql镜像</span><br>docker image <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 查看所有已下载镜像</span><br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID 删除）。</p><p>通过我们前面讲的<code>docker ps</code>命令即可查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br>c4cd691d9f80        mysql:5.7           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   7 weeks ago         Up 12 days          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql<br></code></pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code>暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  ~ docker images<br>REPOSITORY              <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>mysql                   <span class="hljs-number">5.7</span>                 f6509bac4980        <span class="hljs-number">3</span> months ago        <span class="hljs-number">373M</span>B<br></code></pre></td></tr></table></figure><p>通过 IMAGE ID 或者 REPOSITORY 名字即可删除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi f6509bac4980 <span class="hljs-comment">#  或者 docker rmi mysql</span><br></code></pre></td></tr></table></figure><h3 id="4、Build-Ship-and-Run"><a href="#4、Build-Ship-and-Run" class="headerlink" title="4、Build Ship and Run"></a>4、Build Ship and Run</h3><p>搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。</p><ul><li><strong>Build（构建镜像）</strong>：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong>Run （运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p>Docker 运行过程是会去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p><p>Docker 也被称为码头工人或码头装卸工，这和 Docker 的中文翻译<strong>搬运工人</strong>如出一辙。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171603190.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html">https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-03-basic2.html">https://www.pdai.tech/md/devops/docker/docker-03-basic2.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM入门_基础概念</title>
    <link href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-JVM"><a href="#1、什么是-JVM" class="headerlink" title="1、什么是 JVM"></a>1、什么是 JVM</h3><p>JVM 全称是 Java Virtual Machine，中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。</p><p>JVM 充当着一个翻译官的角色，能够将我们编写出的Java程序，翻译给系统“听”，告诉它我们的程序需要做什么操作。</p><p>Java的代码需要经过编译器，生成.Class文件后，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。</p><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机，这里也是以 HotSpot 虚拟机展开，对JVM 基础概念进行阐述。</p><h3 id="2、类加载机制"><a href="#2、类加载机制" class="headerlink" title="2、类加载机制"></a>2、类加载机制</h3><p>上文提到，Java的代码经过编译器，生成.Class文件后，JVM才能识别并运行。</p><blockquote><p>类加载过程</p></blockquote><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>整个类加载的过程中，包括<strong>加载、验证、准备、解析、初始化</strong>五个阶段。</p><p>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。</p><p>另外注意<strong>这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>类的加载: 查找并加载类的二进制数据</li><li>连接<ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</li><li>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li>卸载： 结束生命周期</li></ul><blockquote><p>类加载的层次</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116234810.png" alt="image.png"></p><ul><li><strong>启动类加载器</strong>: Bootstrap ClassLoader，<ul><li>负责加载存放在<code>JDK\jre\lib</code> (JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.* 开头的类均被Bootstrap ClassLoader加载)。</li><li>启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><strong>扩展类加载器</strong>: Extension ClassLoader，<ul><li>该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库(如javax.* 开头的类)，</li><li>开发者可以直接使用扩展类加载器。</li></ul></li><li><strong>应用程序类加载器</strong>: Application ClassLoader，<ul><li>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，</li><li>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><strong>自定义类加载器</strong>: <ul><li>因为JVM自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:<ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul></li></ul><blockquote><p>Class.forName() 和 ClassLoader.loadClass()区别?</p></blockquote><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li></ul><h3 id="3、JVM的结构体系"><a href="#3、JVM的结构体系" class="headerlink" title="3、JVM的结构体系"></a>3、JVM的结构体系</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116235359.png" alt="image.png"></p><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><blockquote><p>运行时数据区根据线程是否私有或者共享进行区分</p></blockquote><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><p>直接内存（Java7的永久代或JDK8的元空间、代码缓存）</p><blockquote><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p></blockquote><p>1.8之前版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000248.png" alt="image.png|600"></p><p>JVM1.8之后版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000319.png" alt="image.png|600"></p><p>1.8之前的版本，线程共享为两个区域：堆与方法区；其中方法区只是JVM虚拟机规范的一部分，不是实际的实现；</p><p>直接内存：是JVM以外的本地内存；</p><p><strong>版本区别介绍</strong></p><ul><li>区别一（方法区）<ul><li>1.8版本之后，使用元数据区实现了方法区，之前是使用永久代来实现方法区，大小是启动时固定好的；</li><li>元空间不在虚拟机中，而是使用本地内存，并且大小可以自动增长，减少了OOM（内存溢出）的几率；</li></ul></li><li>区别二（堆区）<ul><li>Java7之后运行时常量池从方法区移到了这里，为Java8移出永久代做好准备；</li></ul></li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>to be continued ….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98">https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98</a></li><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></li><li><a href="https://blog.csdn.net/fllow_wind/article/details/117027924">https://blog.csdn.net/fllow_wind/article/details/117027924</a></li><li><a href="https://zhuanlan.zhihu.com/p/25713880">https://zhuanlan.zhihu.com/p/25713880</a></li><li><a href="https://blog.csdn.net/xianyun1992/article/details/126555575">https://blog.csdn.net/xianyun1992/article/details/126555575</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_基础概念</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>线程基础概念</li><li>Java 线程</li><li>生命周期</li><li>创建线程</li><li>线程的调用方法</li><li>Synchronized 和 Lock</li></ul><h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li></ul><p>并行和并发的区别</p><ul><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行</p><p>同步和异步的区别</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p><h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" alt="image.png"></p><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" alt="image.png"></p><p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p><p>Java线程具有五中基本状态</p><ul><li>新建状态（New）<ul><li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li></ul></li><li>就绪状态（Runnable）<ul><li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li><li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li></ul></li><li>运行状态（Running）<ul><li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li><li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li></ul></li><li>阻塞状态（Blocked）<ul><li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li><li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul><li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li><li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡状态（Dead）<ul><li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul><blockquote><p>Java多线程的就绪、运行和死亡状态</p></blockquote><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p><p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p><p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p><p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p><h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p><ol><li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>Runnable接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure><ul><li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li><li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li><li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li></ul><blockquote><p>写法简化（Java 8)</p></blockquote><ul><li><strong>方式一：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote><p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p></blockquote><table><thead><tr><th>名称</th><th>描述</th><th>注意事项</th></tr></thead><tbody><tr><td>​<code>start()</code>​</td><td>启动一个新线程，<br />在新的线程运行 run 方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td></tr><tr><td>​<code>run()</code>​</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td></tr><tr><td>​<code>join()</code>​</td><td>等待线程运行结束</td><td></td></tr><tr><td>​<code>join(long n)</code>​</td><td>等待线程运行结束，<br />最多等待 n 毫秒</td><td></td></tr><tr><td>​<code>getId()</code>​</td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>​<code>getName()</code>​</td><td>获取线程名</td><td></td></tr><tr><td>​<code>setName(String name)</code>​</td><td>修改线程名</td><td></td></tr><tr><td>​<code>getPriority()</code>​</td><td>获取线程优先级</td><td></td></tr><tr><td>​<code>setPriority(int priority)</code>​</td><td>修改线程优先级</td><td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td></tr><tr><td>​<code>getState()</code>​</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td></tr><tr><td>​<code>interrupt()</code>​</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td></tr><tr><td><font color=Coral>interrupted()</font></td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>​<code>isInterrupted()</code>​</td><td>判断当前线程是否被打断</td><td>不会清除打断标记</td></tr><tr><td>​<code>isAlive()</code>​</td><td>判断当前线程是否存活</td><td></td></tr><tr><td>​<code>isDaemon()</code>​</td><td>判断当前线程是否是守护线程</td><td></td></tr><tr><td>​<code>setDaemon(boolean on)</code>​</td><td>设置当前线程为守护线程</td><td></td></tr><tr><td><font color=Coral>currentThread()</font></td><td>获取当前正在执行的线程</td><td></td></tr><tr><td><font color=Coral>sleep(long n)</font></td><td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td><td></td></tr><tr><td><font color=Coral>yield()</font></td><td>提示线程调度器让出当前线程<br />对 CPU 的使用</td><td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td></tr></tbody></table><h3 id="6、Synchronized-和-Lock-的使用"><a href="#6、Synchronized-和-Lock-的使用" class="headerlink" title="6、Synchronized 和 Lock 的使用"></a>6、Synchronized 和 Lock 的使用</h3><p>并发编程中，锁是经常需要用到的。这里讲述一下 Synchronized 和 Lock 的使用。</p><p>Synchronized 是 Java 并发编程 中很重要的关键字，另外一个很重要的是 volatile。</p><p>Syncronized 的目的是一次<strong>只允许一个线程进入由他修饰的代码段</strong>，从而允许他们进行自我保护。</p><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要<strong>手动加锁和手动解锁</strong>，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><blockquote><p>在方法上使用 Synchronized</p></blockquote><p>方法声明时使用，放在范围操作符之后,返回类型声明之前。即一次只能有一个线程进入该方法，其他线程要想在此时调用该方法，只能排队等候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numIncrease</span><span class="hljs-params">()</span>&#123;<br>  number++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在某个代码段使用 Synchronized</p></blockquote><p>可以在某个代码块上使用 Synchronized 关键字，表示只能有一个线程进入某个代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numDecrease</span><span class="hljs-params">(Object num)</span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (num)&#123;<br>    number++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Synchronized 锁住整个对象</p></blockquote><p>synchronized后面括号里是一对象，此时线程获得的是对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，相关方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用方法</p><ul><li>lock()<ul><li>用来获取锁。如果锁被其他线程获取，则进行等待。</li><li>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁</li></ul></li><li>tryLock()<ul><li>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，</li><li>这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li></ul></li><li>tryLock(long time, TimeUnit unit)<ul><li>和tryLock()方法是类似</li><li>在拿不到锁时<strong>会等待一定的时间</strong>，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li></ul></li><li>lockInterruptibly()<ul><li>去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即<strong>中断线程的等待状态</strong>。</li><li>当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用 threadB.interrupt() 方法能够中断线程B的等待过程。</li><li>由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在try块中或者在调用lockInterruptibly() 的方法外声明抛出 InterruptedException。</li></ul></li></ul><blockquote><p>代码示例：</p></blockquote><p>lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>tryLock()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Lock</span> lock = ...;<br><span class="hljs-keyword">if</span>(lock.<span class="hljs-title function_">tryLock</span>()) &#123;<br>     <span class="hljs-keyword">try</span>&#123;<br>         <span class="hljs-comment">//处理任务</span><br>     &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-title class_">Exception</span> ex)&#123;<br>         <br>     &#125;<span class="hljs-keyword">finally</span>&#123;<br>         lock.<span class="hljs-title function_">unlock</span>();   <span class="hljs-comment">//释放锁</span><br>     &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不能获取锁，则直接做其他事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>    lock.<span class="hljs-title function_">lockInterruptibly</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//.....</span><br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        lock.<span class="hljs-title function_">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将<strong>释放锁的操作放在finally块中进行</strong>，以保证锁一定被被释放，防止死锁的发生。</p><blockquote><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能<strong>中断阻塞过程中的线程</strong>。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，<strong>只有进行等待的情况下，是可以响应中断的</strong>。<br>而<strong>用synchronized修饰的话</strong>，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li><li><a href="https://cloud.tencent.com/developer/article/1497476">https://cloud.tencent.com/developer/article/1497476</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_HashMap学习</title>
    <link href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>HashMap 主要用来存放键值对，基于哈希表的 Map 接口实现，是常用的 Java 集合之一。</p><p>HashMap是非线程安全的，效率较高。</p><p>它可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><strong>底层数据结构</strong>：</p><ul><li>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li><li>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>扩充机制</strong>：<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><blockquote><p>HashMap的常用方法</p></blockquote><p>1、put(K key, V value)： 将键（key）&#x2F;值（value）映射存放到Map集合中。</p><p>2、get(Object key)： 返回指定键所映射的值，没有该key对应的值则返回 null。</p><p>3、size()： 返回Map集合中数据数量。</p><p>4、clear()： 清空Map集合。</p><p>5、isEmpty()： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。</p><p>6、remove(Object key)： 删除Map集合中键为key的数据并返回其所对应value值。</p><p>7、values()： 返回Map集合中所有value组成的以Collection数据类型格式数据。</p><p>8、containsKey(Object key)： 判断集合中是否包含指定键，包含返回 true，否则返回false。</p><p>9、containsValue(Object value)： 判断集合中是否包含指定值，包含返回 true，否则返回false。</p><p>10、keySet()： 返回Map集合中所有key组成的Set集合。</p><p>11、entrySet()： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。</p><blockquote><p>HashMap 常用方法测试</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sas">package map;<br><br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.<span class="hljs-keyword">Set</span>;<br><br>public class HashMapDemo &#123;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>        // 键不能重复，值可以重复<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;san&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王2&quot;</span>);// 老王被覆盖<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;lao&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------直接输出hashmap:-------&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历HashMap</span><br><span class="hljs-comment">         */</span><br>        // 1.获取Map中的所有键<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span>+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 2.获取Map中所有值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);<br>        Collection&lt;String&gt; values = map.values();<br>        for (String value : values) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(value+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 3.得到<span class="hljs-keyword">key</span>的值的同时得到<span class="hljs-keyword">key</span>所对应的值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys2 = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys2) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span> + <span class="hljs-string">&quot;：&quot;</span> + map.get(<span class="hljs-keyword">key</span>)+<span class="hljs-string">&quot;   &quot;</span>);<br><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="hljs-comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="hljs-comment">         */</span><br>        // 当我调用<span class="hljs-meta">put</span>(<span class="hljs-keyword">key</span>,value)方法的时候，首先会把<span class="hljs-keyword">key</span>和value封装到<br>        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取<br>        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来<br>        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了<br>        <span class="hljs-keyword">Set</span>&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();<br>        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;<br>            System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HashMap其他常用方法</span><br><span class="hljs-comment">         */</span><br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.size()：&quot;</span>+map.size());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;san&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.remove()：&quot;</span>+map);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;李四&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四2&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.replace(si, 李四2):&quot;</span>+map);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用（ <strong>链表散列</strong>）。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115224010.png" alt="image.png"></p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<strong>如果相同的话，直接覆盖</strong>，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。</p><p>使用 hash 方法（扰动函数）是为了防止一些实现比较差的 hashCode() 方法 ，使用扰动函数之后可以减少碰撞。</p><p>所谓 <strong>“拉链法”</strong> 是：将链表和数组相结合。也就是说创建一个链表数组，<strong>数组中每一格就是一个链表</strong>。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><strong>hash 方法</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能稍差一点，因为毕竟扰动了 4 次。</p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。</p><p>这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。</p><p>否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115223309.png" alt="image.png"></p><h4 id="HashMap-的类属性"><a href="#HashMap-的类属性" class="headerlink" title="HashMap 的类属性"></a>HashMap 的类属性</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span> &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">362498820763181265</span>L;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    transient Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    transient <span class="hljs-built_in">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    transient <span class="hljs-built_in">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-built_in">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的字段</p><ul><li>loadFactor   负载因子</li><li>threshold   阈值（HashMap 实际能存储的大小）</li><li>DEFAULT_INITIAL_CAPACITY  默认初始容量</li><li>MAXIMUM_CAPACITY  最大容量</li><li>size   HashMap实际存储的元素个数</li><li>modCount     HashMap的结构被修改的次数，用于迭代器</li></ul><blockquote><p>loadFactor 负载因子</p></blockquote><p>loadFactor 负载因子 是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor 的默认值为 0.75f</strong> ，是官方给出的一个比较好的临界值。</p><p>HashMap 给定的默认容量为 16，负载因子为 0.75。<br>Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 , 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><blockquote><p>threshold   阈值</p></blockquote><p><strong>threshold &#x3D; capacity * loadFactor</strong>，阈值(容量 * 负载因子) </p><p>当实际大小超过阈值时，就要考虑对数组的扩增。阈值是衡量数组是否需要扩增的一个标准。</p><h4 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br>static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">K,V</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-type">K,V</span>&gt; &#123;<br>       <span class="hljs-keyword">final</span> int hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       <br>       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String toString() &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int hashCode() &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br><span class="hljs-comment">//相当于把原来的值给覆盖掉，但是返回被覆盖掉的值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V newValue) &#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean equals(Object o) &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 父</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;           <span class="hljs-comment">// 判断颜色</span><br>        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; root() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、HashMap-源码分析"><a href="#3、HashMap-源码分析" class="headerlink" title="3、HashMap 源码分析"></a>3、HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> threshold;<br>   <br>   <span class="hljs-comment">// 默认构造函数。</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    &#125;<br><br>    <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>        <span class="hljs-comment">//指定负载因子</span><br>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在 resize 中再赋值给 newCap 进行table初始化</span><br>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面第二个构造函数中调用了 putMapEntries 方法，下面进行分析：</p><p><strong>putMapEntries 方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> s = m.size();  <br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size  </span><br>            <span class="hljs-comment">//如果未初始化，s 为 m 的实际元素个数；ft=s/loadFactor =&gt; s=ft*loadFactor；其中 ft 指的是要添加 s 个元素所需要的最小的容量</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0</span>F;  <br>            <span class="hljs-comment">//与最大容量作比较，如果小于则 t 为 ft，否则为 MAXIMUM_CAPACITY</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?  <br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);  <br>            <span class="hljs-comment">//根据上面的构造函数，可以得知此时 table 未初始化，threshold 实际上是存放的初始化容量</span><br>            <span class="hljs-comment">//如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。（注意这里不是初始化阈值）</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)  <br>                threshold = tableSizeFor(t);  <br>        &#125;  <br>        <span class="hljs-comment">// 如果已经初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)  <br>            resize();  <br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容    </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet()) &#123;  <br>            K key = e.getKey();  <br>            V value = e.getValue();  <br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor 方法：返回一个最接近 cap 的2的幂次方大小数值</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;  <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;  <br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法是 put 方法调用的一个方法，并没有提供给用户使用。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>putVal 方法 图解</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115230931.png" alt="image.png"></p><p>putVal 方法添加元素分析：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，<ul><li>如果 key 相同就直接覆盖，</li><li>如果 key 不相同，就判断 p 是否是一个树节点，<ul><li>如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</li><li>如果不是就遍历链表插入(插入的是链表尾部)。</li></ul></li></ul></li></ul><blockquote><p>putVal 方法</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对比 JDK1.7 put 方法的代码</strong></p></blockquote><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value)<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    <span class="hljs-title function_">inflateTable</span>(threshold);<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123; <span class="hljs-comment">// 先遍历</span><br>        <span class="hljs-built_in">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">public V get(Object key) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(<span class="hljs-built_in">hash</span>(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br>final Node&lt;K,V&gt; getNode(int <span class="hljs-built_in">hash</span>, Object key) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; int n; K k;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = <span class="hljs-literal">tab</span>[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span>.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">first</span>;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = <span class="hljs-built_in">first</span>.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(<span class="hljs-built_in">hash</span>, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">https://javaguide.cn/java/collection/hashmap-source-code.html</a></li><li><a href="https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507">https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507</a></li><li><a href="https://blog.csdn.net/rain67/article/details/124043769">https://blog.csdn.net/rain67/article/details/124043769</a></li><li><a href="https://segmentfault.com/a/1190000039302830">https://segmentfault.com/a/1190000039302830</a></li><li><a href="https://blog.csdn.net/weixin_47257050/article/details/118926555">https://blog.csdn.net/weixin_47257050/article/details/118926555</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>面试题</p><ul><li><a href="/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%9F%BA%E7%A1%80/" title="面试题_Java基础">面试题_Java基础</a></li><li><a href="/2023/12/30/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E9%9B%86%E5%90%88/" title="面试题_Java集合">面试题_Java集合</a></li><li><a href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Java%E5%B9%B6%E5%8F%91/" title="面试题_Java并发">面试题_Java并发</a></li><li><a href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_JVM/" title="面试题_JVM">面试题_JVM</a></li><li><a href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_MySQL/" title="面试题_MySQL">面试题_MySQL</a></li><li><a href="/2024/01/02/%E9%9D%A2%E8%AF%95%E9%A2%98_Redis/" title="面试题_Redis">面试题_Redis</a></li></ul><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p>Java 基础</p><p><strong>Java 集合</strong></p><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li><li><a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">Java集合_HashMap学习</a></li></ul><p> <strong>Java多线程</strong></p><ul><li><a href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java并发编程_基础概念">Java并发编程_基础概念</a></li><li><a href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java并发编程_进阶内容">Java并发编程_进阶内容</a></li><li><a href="/2023/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/" title="Java并发编程_线程池">Java并发编程_线程池</a></li><li><a href="/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/" title="Java并发编程_线程池最佳实践">Java并发编程_线程池最佳实践</a></li><li><a href="/2023/12/21/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E4%BB%8EJava%E6%9E%84%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%E5%88%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0ThreadPoolExecutor%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/" title="从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析">从Java构建线程的方式到线程池ThreadPoolExecutor源码剖析</a></li></ul><p><strong>Java 8</strong> </p><ul><li><a href="/2023/12/20/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java8新特性">Java8新特性</a></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><a href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="JVM入门_基础概念">JVM入门_基础概念</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>数据库基础</p><ul><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据库_基础知识">数据库_基础知识</a></li><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E8%AF%AD%E6%B3%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" title="数据库_SQL语法基础知识">数据库_SQL语法基础知识</a></li><li><a href="/2023/12/24/%E6%95%B0%E6%8D%AE%E5%BA%93_SQL%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="数据库_SQL常见面试题">数据库_SQL常见面试题</a></li></ul><p>MySQL</p><ul><li><a href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B901/" title="MySQL学习_基础内容01">MySQL学习_基础内容01</a></li><li><a href="/2023/12/22/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B902/" title="MySQL学习_基础内容02">MySQL学习_基础内容02</a></li><li><a href="/2023/12/24/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B903/" title="MySQL学习_基础内容03">MySQL学习_基础内容03</a></li><li><a href="/2023/12/15/MySQL%E5%AD%A6%E4%B9%A0_%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="MySQL学习_性能优化">MySQL学习_性能优化</a></li></ul><p>NOSQL</p><ul><li><a href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="NoSQL_基础概念">NoSQL_基础概念</a></li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><p>Spring</p><ul><li><a href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Spring学习_基础内容">Spring学习_基础内容</a></li><li><a href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/" title="Spring学习_IOC">Spring学习_IOC</a></li><li><a href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/" title="Spring学习_Spring_Bean的作用域">Spring学习_Spring_Bean的作用域</a></li><li><a href="/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/" title="Spring学习_Spring_Bean的生命周期">Spring学习_Spring_Bean的生命周期</a></li><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/" title="Spring学习_AOP">Spring学习_AOP</a></li></ul><p>SpringMVC</p><ul><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/" title="Spring学习_SpringMVC">Spring学习_SpringMVC</a></li></ul><p>Mybatis</p><p>MybatisPlus</p><ul><li><a href="/2023/12/25/%E6%A1%86%E6%9E%B6%E5%AD%A6%E4%B9%A0_MyBatis-Plus%E4%BD%BF%E7%94%A8/" title="框架学习_MyBatis-Plus使用">框架学习_MyBatis-Plus使用</a></li></ul><p>SpringSecurity</p><p>SpringBoot</p><ul><li><a href="/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/" title="SpringBoot学习_SpringBoot 自动装配原理">SpringBoot学习_SpringBoot 自动装配原理</a></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><strong>Redis</strong></p><ul><li><a href="/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Redis入门_基础概念">Redis入门_基础概念</a></li><li><a href="/2023/12/21/Redis%E5%85%A5%E9%97%A8_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Redis入门_进阶内容">Redis入门_进阶内容</a></li><li><a href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Redis入门_常见面试题">Redis入门_常见面试题</a></li><li><a href="/2023/12/25/Redis%E5%85%A5%E9%97%A8_Redis%E5%AE%9E%E6%88%98%E7%AF%87/" title="Redis入门_Redis实战篇">Redis入门_Redis实战篇</a></li></ul><p><strong>MQ</strong></p><ul><li><a href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="消息队列_基础概念">消息队列_基础概念</a></li></ul><p>RabbitMQ</p><ul><li><a href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_RabbitMQ_基础使用">消息队列_RabbitMQ_基础使用</a></li><li><a href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85/" title="RabbitMQ的安装与使用">RabbitMQ的安装与使用</a></li></ul><p>RocketMQ</p><ul><li><a href="/2023/12/28/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_RocketMQ_基础使用">消息队列_RocketMQ_基础使用</a></li><li><a href="/2023/12/21/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RocketMQ_%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="消息队列_RocketMQ_安装与使用">消息队列_RocketMQ_安装与使用</a></li></ul><p>Kafka</p><ul><li><a href="/2023/12/30/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_Kafka_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_Kafka_基础使用">消息队列_Kafka_基础使用</a></li></ul><p>Elasticsearch</p><ul><li><a href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Elasticsearch_基础内容">Elasticsearch_基础内容</a></li></ul><p>MongoDB</p><ul><li><a href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="MongoDB_基本操作">MongoDB_基本操作</a></li></ul><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><ul><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="SpringCloud_组件基本使用_基础概念">SpringCloud_组件基本使用_基础概念</a></li><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/" title="SpringCloud_组件基本使用_Eureka">SpringCloud_组件基本使用_Eureka</a></li><li><a href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/" title="SpringCloud_组件基本使用_Nacos">SpringCloud_组件基本使用_Nacos</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/" title="SpringCloud_组件基本使用_OpenFeign">SpringCloud_组件基本使用_OpenFeign</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/" title="SpringCloud_组件基本使用_Gateway">SpringCloud_组件基本使用_Gateway</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/" title="SpringCloud_组件基本使用_Seata">SpringCloud_组件基本使用_Seata</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/" title="SpringCloud_组件基本使用_Stream">SpringCloud_组件基本使用_Stream</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/" title="SpringCloud_组件基本使用_Sentinel">SpringCloud_组件基本使用_Sentinel</a></li><li><a href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/" title="SpringCloud_组件基本使用_Zipkin">SpringCloud_组件基本使用_Zipkin</a></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Dokcer入门_基础概念">Dokcer入门_基础概念</a></li><li><a href="/2024/01/12/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Docker入门_Docker的基本使用">Docker入门_Docker的基本使用</a></li></ul><h3 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h3><p>Vue</p><ul><li><a href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Vue学习_基础内容">Vue学习_基础内容</a></li></ul><p>Node</p><ul><li><a href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="node安装和下载">node安装和下载</a></li></ul><p>Nginx</p><ul><li><a href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Nginx_基础概念">Nginx_基础概念</a></li></ul><h3 id="项目学习"><a href="#项目学习" class="headerlink" title="项目学习"></a>项目学习</h3><p>使用工具</p><ul><li><a href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/" title="个人在线网盘_ZFile">个人在线网盘_ZFile</a></li><li><a href="/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/" title="内网穿透工具Neutrino-Proxy">内网穿透工具Neutrino-Proxy</a></li></ul><p>蘑菇博客</p><ul><li><a href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/" title="蘑菇博客项目_Day01">蘑菇博客项目_Day01</a></li><li><a href="/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/" title="蘑菇博客项目_Day02">蘑菇博客项目_Day02</a></li><li><a href="/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/" title="蘑菇博客项目_Day03">蘑菇博客项目_Day03</a></li><li><a href="/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/" title="蘑菇博客项目_Day04">蘑菇博客项目_Day04</a></li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li><a href="/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/" title="业务场景和技术选型">业务场景和技术选型</a></li></ul><h3 id="运维工具和项目构建"><a href="#运维工具和项目构建" class="headerlink" title="运维工具和项目构建"></a>运维工具和项目构建</h3><p>Maven</p><ul><li><a href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="Maven工具_基础使用">Maven工具_基础使用</a></li></ul><p>Linux</p><ul><li><a href="/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/" title="linux系统下 java环境变量的配置">linux系统下 java环境变量的配置</a></li><li><a href="/2024/01/12/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="centos7系统_常用操作">centos7系统_常用操作</a></li><li><a href="/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/" title="centos7 安装 nacos 操作">centos7 安装 nacos 操作</a></li><li><a href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="vim常用操作">vim常用操作</a></li></ul><p>Windows</p><ul><li><a href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="windows常用操作">windows常用操作</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>ArrayList 是 List 的主要实现类，内部基于动态数组实现，支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。</p><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。</p><p><code>ArrayList</code>创建时不需要指定大小，下面是常用方法示例代码：</p><p>ArrayList</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h3 id="2、ArrayList-扩容机制"><a href="#2、ArrayList-扩容机制" class="headerlink" title="2、ArrayList 扩容机制"></a>2、ArrayList 扩容机制</h3><p>以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><h3 id="3、相关内容"><a href="#3、相关内容" class="headerlink" title="3、相关内容"></a>3、相关内容</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>HashMap保证key的不重复性，对于重复的key，HashMap会根据参数onlyIfAbsent的设置和原value是否为空两个条件来<strong>判断是否替换新value</strong>，</p><p>但要注意的是，对于HashSet，这个value只是个空的Object类的对象，没有任何实际作用，HashSet中的元素实际上是存储在key上的。针对重复的key，<strong>HashMap只有对于value的处理，并不会替换key</strong>，因此在HashSet中加入相同元素不会覆盖。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><p><strong>总结</strong>：结果向HashSet中加入相同元素不会进行覆盖。因为HashSet底层使用HashMap实现，元素存在HashMap的key中。在HashMap中，多次put相同的key，只会覆盖value，而不存在key的情况。</p><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢"><a href="#4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢" class="headerlink" title="4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢"></a>4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢</h4><p>为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？</p><p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p><p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会<strong>显著提高效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20231114</title>
    <link href="/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%9220231127/"/>
    <url>/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%9220231127/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><ul><li><input checked="" disabled="" type="checkbox"> Java集合、Java多线程、MySQL数据库、Spring 进行复习</li><li><input checked="" disabled="" type="checkbox"> Redis、MQ </li><li><input checked="" disabled="" type="checkbox"> 微服务 SpringCloud Alibaba 学习</li><li><input checked="" disabled="" type="checkbox"> <del>学成在线项目进行（放弃）</del></li><li><input disabled="" type="checkbox"> 项目：蘑菇博客的学习（个人一直趋向学习这个项目，趁这段时间有空，学习一下）</li><li><input disabled="" type="checkbox"> 考研数学</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_基础概念</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="1、成员关系"><a href="#1、成员关系" class="headerlink" title="1、成员关系"></a>1、成员关系</h4><p>Java 集合相关的成员关系图<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" alt="image.png"></p><ul><li>Collection<ul><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li></ul></li><li>List<ul><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li><li>LinkedList</li></ul></li><li>Queue<ul><li>Deque<ul><li>ArrayDeque</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>Hashtable</li><li>SortedMap<ul><li>TreeMap</li></ul></li></ul></li></ul><p>通过下面表格可说明之间部分的区别和联系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123120.png" alt="image.png"><br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123036.png" alt="image.png"></p><h4 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection接口：最基本的集合接口，所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List接口：有序的Collection，用某种特定的插入顺序来维护元素顺序；用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141634443.png" alt="image.png"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map接口：由一系列键值对组成的集合，提供了key到Value的映射。同时它没有继承Collection；它保证了key与value之间的一一对应关系，一个key对应一个value，它不能存在相同的key值，value值可以相同。</p><p>实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><ul><li>HashMap（JDK1.8及以上）<ul><li>基于哈希表的Map接口的非同步实现</li><li>允许使用 null 值和 null 键</li><li>数据结构可以看成数组+链表+红黑树</li><li>采用了Fail-  Fast机制</li></ul></li><li>Hashtable<ul><li>基于哈希表的Map接口的同步实现, 使用synchronized实现线程安全</li><li>不允许使用null值和null键</li><li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li></ul></li><li>ConcurrentHashMap（JDK1.7版本）<ul><li>采用数组+分段锁的方式实现</li><li>数据结构：Segment 数组 + HashEntry 数组 + 链表</li></ul></li><li>ConcurrentHashMap（JDK1.8版本）<ul><li>数据结构：Node 数组 + 链表 &#x2F; 红黑树。</li><li>当冲突链表达到一定长度时，链表会转换成红黑树。</li></ul></li><li>TreeMap<ul><li>实现了SortedMap接口，键以某种排序规则排序</li><li>内部以red-black（红-黑）树数据结构实现</li></ul></li><li>LinkedHashMap<ul><li>继承于HashMap</li><li>非同步，允许使用null值和null键</li><li>底层使用哈希表和双向链表来保存所有元素</li></ul></li><li>WeakHashMap<ul><li>支持null值和null键，fast-fail机制，不允许重复</li><li>key只保留对实际对象的弱引用，当key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。</li></ul></li><li>IdentifyHashMap<ul><li>在IdentityHashMap中，当且仅当两个key严格相等（key1&#x3D;&#x3D; key2）时，IdentityHashMap才认为两个key相等；相对于普通HashMap而言，只要key1和key2通过equals()方法返回true，且它们的hashCode值相等即可。</li></ul></li><li>EnumMap<ul><li>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显示或隐式的指定它对应的枚举类。</li></ul></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 接口：不包括重复元素的Collection，同样允许 null的存在但是仅有一个</p><p>实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><ul><li>HashSet<ul><li>基于HashMap实现，API 对 HashMap的行为进行了封装</li><li>允许使用null元素</li></ul></li><li>LinkedHashSet<ul><li>继承于 HashSet、又基于LinkedHashMap来实现</li><li>底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上与HashSet相同</li></ul></li><li>TreeSet<ul><li>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。</li><li>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的  <code>Comparator</code> 进行排序</li></ul></li><li>EnumSet<ul><li>枚举的专用Set。所有的元素都是枚举类型</li></ul></li></ul><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列，主要分为两大类，</p><p>一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。</p><p>另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html">https://javaguide.cn/java/collection/java-collection-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h3><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍<br>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p><h3 id="常用的一些命令"><a href="#常用的一些命令" class="headerlink" title="常用的一些命令"></a>常用的一些命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看用户名 ：git config <span class="hljs-keyword">user</span>.name<br><br>查看密码： git config <span class="hljs-keyword">user</span>.<span class="hljs-keyword">password</span><br><br>查看邮箱：git config <span class="hljs-keyword">user</span>.email<br><br>查看配置信息： $ git config <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门_基本操作</title>
    <link href="/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1、将某个目录文件上传到-Github-某个仓库"><a href="#1、将某个目录文件上传到-Github-某个仓库" class="headerlink" title="1、将某个目录文件上传到 Github 某个仓库"></a>1、将某个目录文件上传到 Github 某个仓库</h3><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p><blockquote><p>Git的工作流程核心</p></blockquote><ul><li>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</li><li>1、<strong>搬砖</strong>：在工作目录中添加、修改代码。</li><li>2、<strong>暂存</strong>（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>3、<strong>提交</strong>（git commit）：将暂存区域的文件提交到Git仓库。</li><li>4、<strong>推送</strong>（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>5、<strong>获取更新</strong>（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250040140.png" alt="image.png"></p><ul><li><code>git commit -a</code>指令省略了<code>add</code>到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是<code>git pull</code>多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、 <code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code>是专门用来撤销修改、回退版本的指令，替代上面<code>checkout</code>的撤销功能。</li></ul><hr><p>参考</p><ul><li><a href="https://www.cnblogs.com/anding/p/16987769.html">https://www.cnblogs.com/anding/p/16987769.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
