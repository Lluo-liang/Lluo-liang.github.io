<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java并发编程_线程池</title>
    <link href="/2023/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <url>/2023/12/19/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是线程池"><a href="#1、什么是线程池" class="headerlink" title="1、什么是线程池"></a>1、什么是线程池</h3><p>线程池是管理一系列线程的资源池，其提供了一种限制和管理线程资源的方式。</p><p><strong>线程池一般用于执行多个不相关联的耗时任务，没有多线程的情况下，任务顺序执行，使用了线程池的话可让多个不相关联的任务同时执行</strong></p><p>使用线程池的一些好处：</p><ul><li><strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="2、Executor-框架介绍"><a href="#2、Executor-框架介绍" class="headerlink" title="2、Executor 框架介绍"></a>2、Executor 框架介绍</h3><p><code>Executor</code> 框架是 Java5 之后引进的，在 Java 5 之后，通过 <code>Executor</code> 来启动线程比使用 <code>Thread</code> 的 <code>start</code> 方法更好，除了更易管理，效率更好（用线程池实现，节约开销）外，还有关键的一点：有助于避免 this 逃逸问题。</p><blockquote><p>this 逃逸是指在构造函数返回之前其他线程就持有该对象的引用，调用尚未构造完全的对象的方法可能引发令人疑惑的错误。</p></blockquote><p> Executor 框架 三大部分组成</p><ul><li><strong>任务(<code>Runnable</code> &#x2F;<code>Callable</code>)</strong></li><li><strong>任务的执行(<code>Executor</code>)</strong></li><li><strong>异步计算的结果(<code>Future</code>)</strong></li></ul><blockquote><p><strong>任务的执行(<code>Executor</code>)</strong></p></blockquote><p>看这个图，了解一下对应核心类的关系：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219213228.png" alt="image.png"></p><p>任务的执行(<code>Executor</code>) 包括任务执行机制的核心接口 <code>Executor</code> ，以及继承自 <code>Executor</code> 接口的 <code>ExecutorService</code> 接口。</p><p><code>ThreadPoolExecutor</code> 和 <code>ScheduledThreadPoolExecutor</code>** 这两个关键类实现了 <code>ExecutorService</code> 接口。</p><h3 id="3、ThreadPoolExecutor-类使用-★"><a href="#3、ThreadPoolExecutor-类使用-★" class="headerlink" title="3、ThreadPoolExecutor 类使用 ★"></a>3、ThreadPoolExecutor 类使用 ★</h3><p>线程池实现类 <code>ThreadPoolExecutor</code> 是 <code>Executor</code> 框架最核心的类。</p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p><code>ThreadPoolExecutor</code> 类中提供的四个构造方法。我们来看最长的那个，其余三个都是在这个构造方法的基础上产生。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 用给定的初始参数创建一个新的ThreadPoolExecutor。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> ThreadPoolExecutor(int corePoolSize,     <span class="hljs-comment">//线程池的核心线程数量</span><br>                          int maximumPoolSize,  <span class="hljs-comment">//线程池的最大线程数</span><br>                          long keepAliveTime,   <span class="hljs-comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span><br>                          TimeUnit unit,        <span class="hljs-comment">//时间单位</span><br>                          BlockingQueue&lt;Runnable&gt; workQueue, <span class="hljs-comment">//任务队列，用来储存等待执行任务的队列</span><br>                          ThreadFactory threadFactory,       <span class="hljs-comment">//线程工厂，用来创建线程，一般默认即可</span><br>                          RejectedExecutionHandler handler  <span class="hljs-comment">//拒绝策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span><br>  )&#123;<br>    <span class="hljs-comment">// 参数检查：核心线程数不能小于0，最大线程数不能小于或等于0，最大线程数不能小于核心线程数，keepAliveTime不能小于0</span><br>    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||<br>        maximumPoolSize &lt; corePoolSize ||<br>        keepAliveTime &lt; <span class="hljs-number">0</span>)<br>        <span class="hljs-keyword">throw</span> new IllegalArgumentException();<br><br>    <span class="hljs-comment">// 参数检查：工作队列、线程工厂和拒绝策略不能为null</span><br>    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-literal">null</span> || threadFactory == <span class="hljs-literal">null</span> || handler == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">throw</span> new NullPointerException();<br><br>    <span class="hljs-comment">// 获取安全管理器的上下文，这是Java安全模型的一部分</span><br>    <span class="hljs-keyword">this</span>.acc = System.getSecurityManager() == <span class="hljs-literal">null</span> ?<br>            <span class="hljs-literal">null</span> :<br>            AccessController.getContext();<br><br>    <span class="hljs-comment">// 设置线程池的核心线程数</span><br>    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;<br><br>    <span class="hljs-comment">// 设置线程池的最大线程数</span><br>    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;<br><br>    <span class="hljs-comment">// 设置工作队列</span><br>    <span class="hljs-keyword">this</span>.workQueue = workQueue;<br><br>    <span class="hljs-comment">// 设置线程保持活动的时间，单位转换为纳秒</span><br>    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);<br><br>    <span class="hljs-comment">// 设置线程工厂，用于创建新线程</span><br>    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;<br><br>    <span class="hljs-comment">// 设置拒绝策略，当线程池不能接受任务时使用</span><br>    <span class="hljs-keyword">this</span>.handler = handler;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li><strong><code>corePoolSize</code> :</strong> 任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li><strong><code>maximumPoolSize</code> :</strong> 任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li><strong><code>workQueue</code>:</strong> 新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li><strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁。</li><li><strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li><strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li><strong><code>handler</code></strong> :饱和策略。</li></ul><h4 id="线程池创建的两种方式"><a href="#线程池创建的两种方式" class="headerlink" title="线程池创建的两种方式"></a>线程池创建的两种方式</h4><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）</strong></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>我们可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>**<code>FixedThreadPool</code>**：该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li><li>**<code>ScheduledThreadPool</code>**：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><blockquote><p>不建议使用第二种，原因如下：</p></blockquote><p>《阿里巴巴 Java 开发手册》强制线程池不允许使用 <code>Executors</code> 去创建，</p><p>而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li>**<code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code>**：使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li>**<code>CachedThreadPool</code>**：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li><strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h4 id="线程池常用阻塞队列"><a href="#线程池常用阻塞队列" class="headerlink" title="线程池常用阻塞队列"></a>线程池常用阻塞队列</h4><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><ul><li>容量为 <code>Integer.MAX_VALUE</code> 的 <code>LinkedBlockingQueue</code>（无界队列）：<code>FixedThreadPool</code> 和 <code>SingleThreadExector</code> 。<code>FixedThreadPool</code>最多只能创建核心线程数的线程（核心线程数和最大线程数相等），<code>SingleThreadExector</code>只能创建一个线程（核心线程数和最大线程数都是 1），二者的任务队列永远不会被放满。</li><li><code>SynchronousQueue</code>（同步队列）：<code>CachedThreadPool</code> 。<code>SynchronousQueue</code> 没有容量，不存储元素，目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。也就是说，<code>CachedThreadPool</code> 的最大线程数是 <code>Integer.MAX_VALUE</code> ，可以理解为线程数是可以无限扩展的，可能会创建大量线程，从而导致 OOM。</li><li><code>DelayedWorkQueue</code>（延迟阻塞队列）：<code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code> 。<code>DelayedWorkQueue</code> 的内部元素并不是按照放入的时间排序，而是会按照延迟的时间长短对任务进行排序，内部采用的是“堆”的数据结构，可以保证每次出队的任务都是当前队列中执行时间最靠前的。<code>DelayedWorkQueue</code> 添加元素满了之后会自动扩容原来容量的 1&#x2F;2，即永远不会阻塞，最大扩容可达 <code>Integer.MAX_VALUE</code>，所以最多只能创建核心线程数的线程。</li></ul><h3 id="4、线程池原理分析"><a href="#4、线程池原理分析" class="headerlink" title="4、线程池原理分析"></a>4、线程池原理分析</h3><p>to be contined….</p><h3 id="5、从Java构建线程的方式-到-线程池ThreadPoolExecutor源码剖析"><a href="#5、从Java构建线程的方式-到-线程池ThreadPoolExecutor源码剖析" class="headerlink" title="5、从Java构建线程的方式 到 线程池ThreadPoolExecutor源码剖析"></a>5、从Java构建线程的方式 到 线程池ThreadPoolExecutor源码剖析</h3><p>视频地址： <a href="https://www.bilibili.com/video/BV1244y1n7bz">https://www.bilibili.com/video/BV1244y1n7bz</a></p><p>一、Java 构建线程的方式（常识）</p><ul><li>继承 Thread</li><li>实现 Runnable</li><li>实现 Callable</li><li>线程池方式（Java提供了构建线程池的方式）<ul><li>Java提供了 Executors 可以去创建（规范中不允许使用这种方式创建线程池，这种方式对线程的控制粒度比较低）</li><li>推荐手动创建线程池</li></ul></li></ul><p>二、线程池的7个参数（常识）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-type">int</span> corePoolSize,   <span class="hljs-comment">//核心线程池</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">int</span> maximumPoolSize,   <span class="hljs-comment">//最大线程数</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          <span class="hljs-type">long</span> keepAliveTime,    <span class="hljs-comment">//最大空闲时间</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          TimeUnit unit,         <span class="hljs-comment">//时间单位</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          BlockingQueue&lt;Runnable&gt; workQueue,  <span class="hljs-comment">//阻塞队列</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          ThreadFactory threadFactory,        <span class="hljs-comment">//线程工厂</span></span></span><br><span class="hljs-params"><span class="hljs-function">                          RejectedExecutionHandler handler)</span> </span>&#123;   <span class="hljs-comment">//拒绝策略</span><br></code></pre></td></tr></table></figure><p>三、线程池的执行流程（常识）</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-thread-pool-summary.html">https://javaguide.cn/java/concurrent/java-thread-pool-summary.html</a></li><li><a href="https://www.bilibili.com/video/BV1eD4y1w7Rp">https://www.bilibili.com/video/BV1eD4y1w7Rp</a></li><li><a href="https://www.bilibili.com/video/BV1244y1n7bz">https://www.bilibili.com/video/BV1244y1n7bz</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringBoot学习_SpringBoot 自动装配原理</title>
    <link href="/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/"/>
    <url>/2023/12/19/SpringBoot%E5%AD%A6%E4%B9%A0_SpringBoot%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>面试题：讲述一下Spring Boot 的自动装配原理。</p></blockquote><p>Spring Boot 的自动装配原理基于 Spring 框架的依赖注入和条件注册特性，通过一系列的“启动器”（starters）和自动配置（auto-configuration）类来简化配置过程。</p><p>以下是关键点：</p><ol><li><strong>启动器（Starters）</strong>:<ul><li>Spring Boot 提供了一系列的启动器，它们是预先打包好的依赖集合，旨在提供不同功能的快速集成，如 Web 应用、数据库访问等。</li></ul></li><li><strong>@EnableAutoConfiguration</strong>:<ul><li>这是自动装配的核心注解。通常，这个注解是通过 <code>@SpringBootApplication</code> 杂注引入的，它会触发 Spring Boot 的自动配置机制。</li><li>它利用了 Spring 的 <code>ImportSelector</code> 接口来加载 <code>META-INF/spring.factories</code> 中指定的配置类。</li></ul></li><li><strong>条件注解（Conditional Annotations）</strong>:<ul><li>自动配置类使用一系列的条件注解（如 <code>@ConditionalOnClass</code>，<code>@ConditionalOnBean</code>），确保只有在满足特定条件时才启用配置。这些条件通常包括类路径上的类存在、某个 Bean 不存在、某个属性有特定的值等。</li></ul></li><li><strong>spring.factories</strong>:<ul><li>这是一个位于每个自动配置库 <code>META-INF</code> 目录下的属性文件。它列出了所有可用的自动配置类，这些类由 <code>AutoConfigurationImportSelector</code> 读取和处理。</li></ul></li><li><strong>自动配置类（AutoConfiguration Classes）</strong>:<ul><li>这些类通常采用 <code>@Configuration</code> 形式，并且它们自身也可以包含 <code>@Bean</code>、<code>@Component</code> 和其他配置相关的注解。</li><li>自动配置类可以提供默认的 Bean 定义、属性绑定和其他自动化配置。</li></ul></li><li><strong>细粒度控制</strong>:<ul><li>开发者可以通过 <code>application.properties</code> 或 <code>application.yml</code> 文件来覆盖自动配置的默认值。</li><li>如果需要，可以通过 <code>@EnableAutoConfiguration</code> 的 <code>exclude</code> 属性排除特定的自动配置类。</li></ul></li><li><strong>事件监听与发布</strong>:<ul><li>在自动配置的过程中，Spring Boot 也会发布和监听各种事件，允许用户在应用生命周期的不同阶段进行交互。</li></ul></li></ol><p>总结来说，Spring Boot 的自动装配是一个智能且灵活的机制，它减轻了传统 Spring 应用配置的负担，通过一系列条件匹配和约定优于配置的原则，提供了一个即插即用的开发体验。</p><h3 id="1、什么是Spring-Boot-的自动装配"><a href="#1、什么是Spring-Boot-的自动装配" class="headerlink" title="1、什么是Spring Boot 的自动装配"></a>1、什么是Spring Boot 的自动装配</h3><p>先了解一下自动装配类主要用的注解和自动配置类，了解其概念，并继续往下进行学习。</p><p>Spring Boot 的自动装配原理是基于 Spring 框架的依赖注入和条件装配特性。</p><p>自动装配主要通过 <code>@EnableAutoConfiguration</code> 注解和一系列的自动配置类 (<code>*AutoConfiguration</code> 类) 来实现。</p><p>以下是从源码角度对其原理的解析：</p><blockquote><ol><li>@EnableAutoConfiguration</li></ol></blockquote><ul><li><code>@EnableAutoConfiguration</code> 注解是 Spring Boot 自动装配的入口。它通常与 <code>@SpringBootApplication</code> 注解一起使用，在应用启动时被激活。</li><li>该注解背后使用了 <code>@Import</code> 注解来导入 <code>EnableAutoConfigurationImportSelector</code> 类，这是启动自动装配的关键。</li></ul><blockquote><ol start="2"><li>EnableAutoConfigurationImportSelector</li></ol></blockquote><ul><li><code>EnableAutoConfigurationImportSelector</code> 实现了 <code>ImportSelector</code> 接口，负责选择需要导入的配置类。</li><li>它读取 <code>META-INF/spring.factories</code> 文件中的内容，这个文件列出了所有可用的自动配置类。</li><li>每个自动配置类都是以条件注解（如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnBean</code>）标注的，这些注解确保只有在特定条件满足时，相关配置才会被应用。</li></ul><blockquote><ol start="3"><li>条件注解</li></ol></blockquote><ul><li>条件注解是 Spring Framework 的核心特性之一，Spring Boot 在此基础上实现了自动装配。</li><li><code>@Conditional</code> 注解家族（比如 <code>@ConditionalOnClass</code>、<code>@ConditionalOnMissingBean</code>）允许在满足特定条件时，才执行某些操作（如实例化 Bean）。</li><li>这些注解确保了只有当相关的类存在于类路径上、或者某个 Bean 尚未定义时，对应的自动配置类才会被激活。</li></ul><blockquote><ol start="4"><li>自动配置类 (<code>*AutoConfiguration</code>)</li></ol></blockquote><ul><li>自动配置类通常命名为 <code>*AutoConfiguration</code>，它们包含了一系列的 Bean 定义和条件逻辑。</li><li>这些类利用 Spring 的依赖注入特性，定义了如何创建和配置 Bean，从而简化了许多常见场景的配置工作。</li><li>例如，<code>DataSourceAutoConfiguration</code> 可以在类路径上检测到数据库连接池实现时自动配置数据源（DataSource）。</li></ul><p>示例：DataSourceAutoConfiguration</p><p>以 <code>DataSourceAutoConfiguration</code> 为例，展示自动配置类的典型结构：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123;DataSource.class, EmbeddedDatabaseType.class&#125;)<br>public class DataSourceAutoConfiguration &#123;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    <span class="hljs-variable">@Configuration</span><br>    <span class="hljs-variable">@Conditional</span>(DataSourceAutoConfiguration.DataSourceAvailableCondition.class)<br>    public static class DataSourceConfiguration &#123;<br>        <span class="hljs-comment">// Bean 定义和配置</span><br>    &#125;<br><br>    <span class="hljs-comment">// ...省略其他代码...</span><br><br>    static class DataSourceAvailableCondition extends SpringBootCondition &#123;<br>        <span class="hljs-comment">// 条件判断逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>小结</p></blockquote><p>Spring Boot 的自动装配是通过一系列的自动配置类以及条件注解实现的。</p><p>这些自动配置类位于应用的类路径上，并在满足特定条件时被 <code>@EnableAutoConfiguration</code> 注解激活。</p><p>这种机制极大地简化了 Spring 应用的配置过程，允许开发者以最少的努力实现强大的功能。</p><h3 id="2、解读-SpringBootApplication-注解"><a href="#2、解读-SpringBootApplication-注解" class="headerlink" title="2、解读@SpringBootApplication 注解"></a>2、解读@SpringBootApplication 注解</h3><p>上述内容也谈论到 条件注解是 Spring Framework 的核心特性之一，Spring Boot 在其基础上，通过 SPI 的方式，做了进一步优化，并进而实现了自动装配。</p><blockquote><p>我们从启动类开始了解其自动装配原理</p></blockquote><p>本地的版本是：org.springframework.boot:spring-boot-autoconfigure:2.2.5.RELEASE</p><h4 id="2-1-SpringBootApplication"><a href="#2-1-SpringBootApplication" class="headerlink" title="2.1  SpringBootApplication"></a>2.1  SpringBootApplication</h4><p>@SpringBootApplication注解是放置在 Spring Boot 应用的主类上，注解的作用是启用组件扫描和自动配置。</p><p>我们找到一个启动类，进入其注解代码，</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.TYPE) <span class="hljs-comment">// 注解作用于类型上（比如类、接口）</span><br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME) <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-variable">@Documented</span> <span class="hljs-comment">// 将此注解包含在 Javadoc 中</span><br><span class="hljs-variable">@Inherited</span> <span class="hljs-comment">// 注解可以被继承</span><br><span class="hljs-variable">@SpringBootConfiguration</span> <span class="hljs-comment">// 特殊的@Configuration，表明这是一个 Spring Boot 配置类</span><br><span class="hljs-variable">@EnableAutoConfiguration</span> <span class="hljs-comment">// 启用 Spring Boot 的自动配置机制</span><br><span class="hljs-comment">//启用组件扫描，让 Spring 自动发现和注册应用中的 Beans。通常，它会扫描与主类相同的包以及子包中的组件。</span><br><span class="hljs-comment">//`excludeFilters` 属性用于排除某些类型的组件，这里特别排除了 `TypeExcludeFilter` 和 `AutoConfigurationExcludeFilter` 类型的组件</span><br><span class="hljs-variable">@ComponentScan</span>(<br>    excludeFilters = &#123;<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;TypeExcludeFilter.class&#125;<br>        ),<br>        <span class="hljs-variable">@Filter</span>(<br>            type = FilterType.CUSTOM,<br>            classes = &#123;AutoConfigurationExcludeFilter.class&#125;<br>        )<br>    &#125;<br>) <br>public <span class="hljs-variable">@interface</span> SpringBootApplication &#123;<br>    <span class="hljs-comment">// ... 其他属性定义 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-EnableAutoConfiguration"><a href="#2-2-EnableAutoConfiguration" class="headerlink" title="2.2 EnableAutoConfiguration"></a>2.2 EnableAutoConfiguration</h4><blockquote><p>作用</p></blockquote><p><code>@EnableAutoConfiguration</code> 是 Spring Boot 的核心注解之一，用于启动自动配置的机制。这个注解通过 <code>@Import</code> 注解导入 <code>AutoConfigurationImportSelector</code>，后者负责根据条件选择和应用自动配置类。</p><blockquote><p>代码</p></blockquote><p><code>@EnableAutoConfiguration</code> 是实现自动装配的重要注解，我们以这个注解继续往下看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.TYPE)</span> <span class="hljs-comment">// 指定注解可以应用于类型级别（类、接口等）</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span> <span class="hljs-comment">// 注解在运行时有效</span><br><span class="hljs-meta">@Documented</span> <span class="hljs-comment">// 注解将被包含在javadoc中</span><br><span class="hljs-meta">@Inherited</span> <span class="hljs-comment">// 注解可以被子类继承</span><br><span class="hljs-meta">@AutoConfigurationPackage</span> <span class="hljs-comment">// 自动配置包，将主配置类的包视为自动配置包</span><br><span class="hljs-meta">@Import(&#123;AutoConfigurationImportSelector.class&#125;)</span> <span class="hljs-comment">// 导入AutoConfigurationImportSelector</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableAutoConfiguration &#123;<br>    <br>    <span class="hljs-comment">// 用于覆盖自动配置是否启用的属性</span><br>    <span class="hljs-type">String</span> <span class="hljs-variable">ENABLED_OVERRIDE_PROPERTY</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>;<br><br>    <span class="hljs-comment">// 排除特定的自动配置类</span><br>    Class&lt;?&gt;[] exclude() <span class="hljs-keyword">default</span> &#123;&#125;;<br><br>    <span class="hljs-comment">// 通过名称排除特定的自动配置类</span><br>    String[] excludeName() <span class="hljs-keyword">default</span> &#123;&#125;;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用示例</p></blockquote><p>通常，我们是不会显式地使用 <code>@EnableAutoConfiguration</code>，它已经包含在 <code>@SpringBootApplication</code> 注解中。</p><p>但如果需要单独使用，可以像下面这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@EnableAutoConfiguration</span>(exclude = &#123;DataSourceAutoConfiguration.class&#125;)<br>public class MyConfiguration &#123;<br>    <span class="hljs-comment">// 配置内容</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面这个例子，<code>@EnableAutoConfiguration</code> 注解用于启动自动配置，但排除了特定的自动配置类 <code>DataSourceAutoConfiguration</code>。</p><hr><h4 id="2-3-AutoConfigurationImportSelector"><a href="#2-3-AutoConfigurationImportSelector" class="headerlink" title="2.3 AutoConfigurationImportSelector"></a>2.3 AutoConfigurationImportSelector</h4><p><code>AutoConfigurationImportSelector</code> 是 Spring Boot 自动装配机制的关键组成部分。这个类实现了多个 Spring 框架的接口，使其能够在启动时选择和注册自动配置类。</p><p>先看一下这个类 <code>AutoConfigurationImportSelector</code>的继承体系：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">AutoConfigurationImportSelector</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">DeferredImportSelector, <span class="hljs-symbol">BeanClassLoaderAware</span>, <span class="hljs-symbol">ResourceLoaderAware</span>, <span class="hljs-symbol">BeanFactoryAware</span>, <span class="hljs-symbol">EnvironmentAware</span>, <span class="hljs-symbol">Ordered</span></span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">DeferredImportSelector</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">ImportSelector</span> &#123;<br>    String[] selectImports(AnnotationMetadata var1);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的两层继承关系可以看出 <code>AutoConfigurationImportSelector</code> 类实现了 <code>ImportSelector</code>接口，这意味着它实现了这个接口中的 <code>selectImports</code>方法，</p><p><code>selectImports</code> 方法是 <code>AutoConfigurationImportSelector</code> 类的核心部分，用于根据当前的应用上下文环境选择合适的自动配置类。</p><p>以下是对这个方法的代码注释解释：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>    <span class="hljs-comment">// 检查是否启用自动配置</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-comment">// 如果自动配置没有启用，则不导入任何配置</span><br>        <span class="hljs-keyword">return</span> NO_IMPORTS;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 加载自动配置的元数据</span><br>        AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(<span class="hljs-keyword">this</span>.beanClassLoader);<br><br>        <span class="hljs-comment">// 获取自动配置条目（即自动配置类的列表）</span><br>        AutoConfigurationImportSelector.AutoConfigurationEntry autoConfigurationEntry = <br>                <span class="hljs-keyword">this</span>.getAutoConfigurationEntry(autoConfigurationMetadata, annotationMetadata);<br><br>        <span class="hljs-comment">// 将自动配置类转换为字符串数组并返回</span><br>        <span class="hljs-comment">// 这些类名将被 Spring 容器进一步处理，以实现自动配置</span><br>        <span class="hljs-keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>方法解释</p></blockquote><ol><li><strong>isEnabled 方法</strong>:<ul><li>检查是否启用了自动配置。这通常是通过检查某个特定的属性或条件来决定的。如果自动配置被禁用，则此方法返回一个空的数组，意味着不进行任何自动配置。</li></ul></li><li><strong>加载自动配置元数据</strong>:<ul><li>使用 <code>AutoConfigurationMetadataLoader</code> 加载自动配置的元数据。这些元数据通常从 <code>META-INF/spring.factories</code> 文件中读取，其中列出了所有可用的自动配置类。</li></ul></li><li><strong>获取自动配置条目</strong>:<ul><li><code>getAutoConfigurationEntry</code> 方法根据当前的应用上下文环境和已加载的元数据确定哪些自动配置类应该被激活。这涉及到一系列条件匹配，例如检查类路径上是否存在特定的类。</li></ul></li><li><strong>返回自动配置类的名称</strong>:<ul><li>最后，该方法返回一个包含应该激活的自动配置类名称的字符串数组。Spring 容器随后将使用这些类名来实例化相应的 Bean 定义。</li></ul></li></ol><h4 id="2-4-getAutoConfigurationEntry"><a href="#2-4-getAutoConfigurationEntry" class="headerlink" title="2.4 getAutoConfigurationEntry"></a>2.4 getAutoConfigurationEntry</h4><p>重点关注一下<code>getAutoConfigurationEntry()</code>方法，这个方法的主要职责是收集所有应该被激活的自动配置类，并根据给定的条件来筛选和排除某些配置。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> AutoConfigurationImportSelector.AutoConfigurationEntry getAutoConfigurationEntry(<br>    AutoConfigurationMetadata autoConfigurationMetadata, AnnotationMetadata annotationMetadata) &#123;<br>    <br>    <span class="hljs-comment">// 检查自动配置是否被启用，如果没有，则返回一个空的配置条目</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isEnabled(annotationMetadata)) &#123;<br>        <span class="hljs-keyword">return</span> EMPTY_ENTRY;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 获取注解的属性</span><br>        AnnotationAttributes attributes = <span class="hljs-keyword">this</span>.getAttributes(annotationMetadata);<br>        <br>        <span class="hljs-comment">// 获取所有候选的配置类</span><br>        List&lt;String&gt; configurations = <span class="hljs-keyword">this</span>.getCandidateConfigurations(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 移除重复的配置</span><br>        configurations = <span class="hljs-keyword">this</span>.removeDuplicates(configurations);<br>        <br>        <span class="hljs-comment">// 获取需要排除的配置类</span><br>        Set&lt;String&gt; exclusions = <span class="hljs-keyword">this</span>.getExclusions(annotationMetadata, attributes);<br>        <br>        <span class="hljs-comment">// 检查排除的类是否真的存在于候选配置中，并抛出异常如果有的话</span><br>        <span class="hljs-keyword">this</span>.checkExcludedClasses(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 从候选配置中移除排除的配置</span><br>        configurations.removeAll(exclusions);<br>        <br>        <span class="hljs-comment">// 过滤配置，可能使用条件服务等进一步筛选配置</span><br>        configurations = <span class="hljs-keyword">this</span>.filter(configurations, autoConfigurationMetadata);<br>        <br>        <span class="hljs-comment">// 触发自动配置导入相关事件</span><br>        <span class="hljs-keyword">this</span>.fireAutoConfigurationImportEvents(configurations, exclusions);<br>        <br>        <span class="hljs-comment">// 返回一个新的 AutoConfigurationEntry 对象，包含最终确定的配置类和排除的类</span><br>        <span class="hljs-keyword">return</span> new AutoConfigurationImportSelector.AutoConfigurationEntry(configurations, exclusions);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法解释</p><ol><li><strong>isEnabled</strong>:<ul><li>检查是否在注解元数据中设置了启用自动配置的属性。</li></ul></li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">protected</span> boolean isEnabled(AnnotationMetadata metadata) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass() == AutoConfigurationImportSelector.<span class="hljs-keyword">class</span> ? (<span class="hljs-built_in">Boolean</span>)<span class="hljs-keyword">this</span>.getEnvironment().getProperty(<span class="hljs-string">&quot;spring.boot.enableautoconfiguration&quot;</span>, <span class="hljs-built_in">Boolean</span>.<span class="hljs-keyword">class</span>, <span class="hljs-literal">true</span>) : <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>isEnabled</code> 方法会判断自动装配开关是否打开。</p><p>默认<code>spring.boot.enableautoconfiguration=true</code>，可在 <code>application.properties</code> 或 <code>application.yml</code> 中设置</p><ol start="2"><li><strong>getAttributes</strong>:<ul><li>提取注解元数据中的属性，这些属性可能会影响自动配置的选择。</li><li>用于获取<code>EnableAutoConfiguration</code>注解中的 <code>exclude</code> 和 <code>excludeName</code></li></ul></li><li><strong>getCandidateConfigurations</strong>:<ul><li>获取需要自动装配的所有配置类，读取<code>META-INF/spring.factories</code></li></ul></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">spring-<span class="hljs-keyword">boot</span>/spring-<span class="hljs-keyword">boot</span>-project/spring-<span class="hljs-keyword">boot</span>-autoconfigure/src/main/resources/<span class="hljs-keyword">META</span>-<span class="hljs-keyword">INF</span>/spring.factories<br></code></pre></td></tr></table></figure><p>不光是单个依赖下的<code>META-INF/spring.factories</code>被读取到，所有 Spring Boot Starter 下的<code>META-INF/spring.factories</code>都会被读取到。</p><p>你可以看一下 druid 数据库连接池的 Spring Boot Starter ，在它里面就创建了<code>META-INF/spring.factories</code>文件。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231219202949.png" alt="image.png"></p><p>如果，我们自己要创建一个 Spring Boot Starter，这一步是必不可少的。</p><ol start="4"><li><strong>removeDuplicates</strong>:<ul><li>保证配置列表中没有重复的条目。</li></ul></li><li><strong>getExclusions</strong>:<ul><li>读取注解元数据，找出需要从自动配置中排除的类。</li></ul></li><li><strong>checkExcludedClasses</strong>:<ul><li>确保排除的类是候选配置列表中的成员，如果不是，则抛出异常。</li></ul></li><li><strong>configurations.removeAll(exclusions)</strong>:<ul><li>实际从候选配置列表中移除被排除的类。</li></ul></li><li><strong>filter</strong>:<ul><li>使用 <code>AutoConfigurationMetadata</code> 对候选配置进行进一步的条件筛选。</li></ul></li><li><strong>fireAutoConfigurationImportEvents</strong>:<ul><li>发布事件，这可能会影响后续处理过程，例如通过监听器来进一步修改配置列表。</li></ul></li><li><strong>返回 AutoConfigurationEntry</strong>:<ul><li>创建并返回一个 <code>AutoConfigurationEntry</code> 对象，该对象包含了最终确定要导入的自动配置类和已排除的类。</li></ul></li></ol><p>我们在具体使用的时候，<code>spring.factories</code>中会有很多配置，但每次启动并不是全部加载；</p><p>我们会在配置类上使用 ConditionalOnxxx 注解，<code>@ConditionalOnXXX</code> 中的所有条件都满足，该类才会生效。</p><p>例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-comment">// 检查相关的类：RabbitTemplate 和 Channel是否存在</span><br><span class="hljs-comment">// 存在才会加载</span><br><span class="hljs-variable">@ConditionalOnClass</span>(&#123; RabbitTemplate.class, Channel.class &#125;)<br><span class="hljs-variable">@EnableConfigurationProperties</span>(RabbitProperties.class)<br><span class="hljs-variable">@Import</span>(RabbitAnnotationDrivenConfiguration.class)<br>public class RabbitAutoConfiguration &#123;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、新建一个-starter"><a href="#3、新建一个-starter" class="headerlink" title="3、新建一个 starter"></a>3、新建一个 starter</h3><p>创建过程：</p><blockquote><ol><li>创建项目结构</li></ol></blockquote><p>需要创建一个 Maven项目。</p><p>为了遵循 Spring Boot Starter 命名约定，项目的名称通常以 <code>spring-boot-starter-</code> 开头，例如 <code>spring-boot-starter-myfeature</code>。</p><blockquote><ol start="2"><li>添加必要的依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Boot 以及其他所需库的依赖。</p><p>示例 Maven <code>pom.xml</code>:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 添加其他自己 Starter 需要的依赖 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>创建自动配置类</li></ol></blockquote><p>在项目中创建一个或多个配置类，使用 <code>@Configuration</code> 注解，并根据需要使用 <code>@Conditional</code> 注解来条件化配置。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Configuration</span><br><span class="hljs-variable">@ConditionalOnClass</span>(MyFeature.class)<br><span class="hljs-variable">@ConditionalOnProperty</span>(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>, name = <span class="hljs-string">&quot;enabled&quot;</span>, havingValue = <span class="hljs-string">&quot;true&quot;</span>, matchIfMissing = true)<br>public class MyFeatureAutoConfiguration &#123;<br><br>    <span class="hljs-variable">@Bean</span><br>    <span class="hljs-variable">@ConditionalOnMissingBean</span><br>    public MyFeature <span class="hljs-built_in">myFeature</span>() &#123;<br>        <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">MyFeature</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>创建 <code>spring.factories</code> 文件</li></ol></blockquote><p>在项目的资源目录中创建一个 <code>META-INF/spring.factories</code> 文件，并指定自动配置类。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.boot</span><span class="hljs-selector-class">.autoconfigure</span>.EnableAutoConfiguration=\<br>com<span class="hljs-selector-class">.example</span>.MyFeatureAutoConfiguration<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>配置属性类（可选）</li></ol></blockquote><p>如果你的 Starter 需要配置属性，创建一个属性类使用 <code>@ConfigurationProperties</code> 注解。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@ConfigurationProperties(prefix = <span class="hljs-string">&quot;myfeature&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyFeatureProperties</span> &#123;<br>    <span class="hljs-keyword">private</span> boolean enabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// ... 其他属性和getter/setter</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="6"><li>测试 Starter</li></ol></blockquote><p>创建一个简单的 Spring Boot 应用来验证 Starter 是否按预期工作。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyStarterTestApp</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">SpringApplication</span>.<span class="hljs-title function_">run</span>(<span class="hljs-title class_">MyStarterTestApp</span>.<span class="hljs-property">class</span>, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="7"><li>打包和发布</li></ol></blockquote><p>使用 Maven 将 Starter 打包，并发布到 Maven 中央仓库或私有仓库，使得其他项目可以添加依赖使用。</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`mvn clean install`</span><br></code></pre></td></tr></table></figure><p>同时最好编写清晰的文档，说明如何添加 Starter 的依赖，以及如何配置和使用提供的功能。</p><blockquote><p>总结</p></blockquote><p>Spring Boot 通过<code>@EnableAutoConfiguration</code>开启自动装配，</p><p>通过 SpringFactoriesLoader 最终加载<code>META-INF/spring.factories</code>中的自动配置类实现自动装配，</p><p>自动配置类其实就是通过<code>@Conditional</code>按需加载的配置类，想要其生效必须引入<code>spring-boot-starter-xxx</code>包实现起步依赖</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html">https://javaguide.cn/system-design/framework/spring/spring-boot-auto-assembly-principles.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>SpringBoot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springboot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的生命周期</title>
    <link href="/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2023/12/18/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>本篇讲述一下关于Bean的生命周期。</p><p>bean的作用域有很多种，这里讨论一下完全被 IOC容器控制的单例 Bean。</p><h3 id="1、Spring-Bean-生命周期的四个阶段"><a href="#1、Spring-Bean-生命周期的四个阶段" class="headerlink" title="1、Spring Bean 生命周期的四个阶段"></a>1、Spring Bean 生命周期的四个阶段</h3><blockquote><p>普通的 Java 对象</p></blockquote><p>对于普通的 Java 对象来说，它们的生命周期是：</p><ul><li>实例化</li><li>该对象不再被使用时通过垃圾回收机制进行回收</li></ul><blockquote><p>Spring Bean</p></blockquote><p>而对于 Spring Bean 的生命周期来说，可以分为四个阶段：</p><ul><li>实例化 Instantiation</li><li>属性赋值 Populate</li><li>初始化 Initialization</li><li>销毁 Destruction</li></ul><p>其中初始化完成之后，就代表这个 Bean 可以使用了</p><p>上述四个阶段的大概的一个逻辑</p><p>前面三个阶段的操作（先大概了解有这个印象，具体内容继续往下面看）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> Object <span class="hljs-title function_">doCreateBean</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable</span> Object[] args)</span> <span class="hljs-keyword">throws</span> BeanCreationException &#123;<br>    <span class="hljs-type">BeanWrapper</span> <span class="hljs-variable">instanceWrapper</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">if</span> (mbd.isSingleton()) &#123;<br>        instanceWrapper = (BeanWrapper)<span class="hljs-built_in">this</span>.factoryBeanInstanceCache.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (instanceWrapper == <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 实例化阶段</span><br>        instanceWrapper = <span class="hljs-built_in">this</span>.createBeanInstance(beanName, mbd, args);<br>    &#125;<br><br>    ...<br><br>    <span class="hljs-type">Object</span> <span class="hljs-variable">exposedObject</span> <span class="hljs-operator">=</span> bean;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 属性赋值阶段</span><br>        <span class="hljs-built_in">this</span>.populateBean(beanName, mbd, instanceWrapper);<br>        <span class="hljs-comment">// 初始化阶段</span><br>        exposedObject = <span class="hljs-built_in">this</span>.initializeBean(beanName, exposedObject, mbd);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var18) &#123;<br>        ...<br>    &#125;<br><br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>销毁操作，是在容器关闭时调用的，详见 <code>ConfigurableApplicationContext#close()</code></p><h3 id="2、Spring-Bean-的生命周期的扩展点"><a href="#2、Spring-Bean-的生命周期的扩展点" class="headerlink" title="2、Spring Bean 的生命周期的扩展点"></a>2、Spring Bean 的生命周期的扩展点</h3><p>上面讲述到Bean的生命周期有四个阶段，分别是：实例化  →  属性赋值  →  初始化  →  销毁；</p><p>在不同阶段中间，Spring 框架会进行一些功能的扩展点，下面分四个部分分别讲解这些扩展点。</p><ul><li>Bean 自身方法</li><li>容器级别方法</li><li>工厂后处理器方法</li><li>Bean 级生命周期方法</li></ul><h4 id="2-1-Bean-自身的方法"><a href="#2-1-Bean-自身的方法" class="headerlink" title="2.1  Bean 自身的方法"></a>2.1  Bean 自身的方法</h4><p>在Bean的生命周期中，Bean自身是有一些特定方法是能够被调用的，以便完成其生命周期过程。</p><p>比如构造函数、getter&#x2F;setter 以及 init-method 和 destory-method 所指定的方法等，而这些方法又分别对应着上文说的四个阶段：例化、属性赋值、初始化和销毁。</p><p>这些Bean自身的方法一般是我们在配置Bean的时候就已经定义好的，下面我们通过一个简单 Bean 的使用来看一下其用法。</p><blockquote><p>Bean 示例</p></blockquote><p>我们定义一个简单的 Bean，名为 <code>MyBean</code>，</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">MyBean</span> &#123;<br><br>    <span class="hljs-keyword">private</span> String <span class="hljs-keyword">value</span>;<br><br>    <span class="hljs-comment">// 构造函数 - 实例化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBean</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean Constructor: Bean is being instantiated.&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Setter 方法 - 属性赋值阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span>(<span class="hljs-params">String <span class="hljs-keyword">value</span></span>)</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean setValue: Setting property value.&quot;</span>);<br>        <span class="hljs-keyword">this</span>.<span class="hljs-keyword">value</span> = <span class="hljs-keyword">value</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化方法 - 初始化阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean init: Bean is being initialized.&quot;</span>);<br>        <span class="hljs-comment">// 执行初始化逻辑</span><br>    &#125;<br><br>    <span class="hljs-comment">// 销毁方法 - 销毁阶段</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span>()</span> &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;MyBean destroy: Bean is being destroyed.&quot;</span>);<br>        <span class="hljs-comment">// 执行清理逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们通过注解或者xml 配置声明  init-method 和 destory-method  对应的方法。</p><blockquote><p>xml 配置</p></blockquote><p><strong>在 Spring 配置中定义 Bean</strong></p><p>在 Spring 的 XML 配置文件中，如下配置这个 Bean，并指定 <code>init-method</code> 和 <code>destroy-method</code>：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">&lt;bean id<span class="hljs-operator">=</span><span class="hljs-string">&quot;myBean&quot;</span> class<span class="hljs-operator">=</span><span class="hljs-string">&quot;com.example.MyBean&quot;</span> init-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;init&quot;</span> destroy-method<span class="hljs-operator">=</span><span class="hljs-string">&quot;destroy&quot;</span>&gt;<br>    &lt;property name<span class="hljs-operator">=</span><span class="hljs-string">&quot;value&quot;</span> value<span class="hljs-operator">=</span><span class="hljs-string">&quot;Some value&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><blockquote><p>注解配置</p></blockquote><p>在基于 Java 的配置中，可以使用 <code>@Bean</code> 注解：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span>(initMethod = <span class="hljs-string">&quot;init&quot;</span>, destroyMethod = <span class="hljs-string">&quot;destroy&quot;</span>)<br>    <span class="hljs-keyword">public</span> MyBean myBean() &#123;<br>        MyBean myBean = <span class="hljs-keyword">new</span> <span class="hljs-type">MyBean</span>();<br>        myBean.setValue(<span class="hljs-string">&quot;Some value&quot;</span>);<br>        <span class="hljs-keyword">return</span> myBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Bean</p></blockquote><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;appContext.xml&quot;</span>);<br>        SimpleBean simpleBean = context.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;myBean&quot;</span>, MyBean.<span class="hljs-keyword">class</span>);<br>        <span class="hljs-comment">// 使用 simpleBean ...</span><br>        ((ClassPathXmlApplicationContext) context).<span class="hljs-built_in">close</span>(); <span class="hljs-comment">// 关闭上下文以触发销毁方法</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>四个主要阶段以及代码解释</p></blockquote><p>通过注解或者xml配置的方式，我们指定了初始化和销毁方法，并在 <code>MyBean</code> 定义了 Setter 方法，具体在容器执行的时候，会进行以下的操作：</p><ol><li><strong>实例化阶段</strong>:<ul><li>当 Spring 容器创建 <code>MyBean</code> 的实例时，首先调用其构造函数。</li></ul></li><li><strong>属性赋值阶段</strong>:<ul><li>接着，Spring 容器通过调用 <code>setValue</code> 方法来注入属性值。</li></ul></li><li><strong>初始化阶段</strong>:<ul><li>在所有属性都设置之后，Spring 容器调用指定的 <code>init</code> 方法。</li></ul></li><li><strong>销毁阶段</strong>:<ul><li>当 Spring 容器关闭时，它会调用 <code>destroy</code> 方法。</li></ul></li></ol><h4 id="2-2-容器级别方法"><a href="#2-2-容器级别方法" class="headerlink" title="2.2  容器级别方法"></a>2.2  容器级别方法</h4><p>将这个容器级别方法理解为阶段中间容器会进行的一些操作，这些方法一般是 BeanPostProcessor 的一系列接口。</p><p>在上述讲到的Bean 四个阶段，在这四个阶段的执行过程中，进行一些前置或者后置的操作。</p><p>这些操作独立于 Bean 之外，并且会注册到 Spring 容器中，在Spring 容器创建Bean的时候，会进行一些处理。</p><p>具体的一个关系看下图（比较清晰）：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312150342853.png" alt="image.png"></p><p>你可以理解  <code>InstantiationAwareBeanPostProcessor</code> 接口方法是 作为 实例化阶段的”产前产后护理”；<code>BeanPostProcessor</code> 是 初始化阶段的 “关键调整和增强”。</p><h5 id="源码内容分析（容器级别方法）"><a href="#源码内容分析（容器级别方法）" class="headerlink" title="源码内容分析（容器级别方法）"></a>源码内容分析（容器级别方法）</h5><p>需要去了解Bean的生命周期，这个源码对应的方法是必须去了解和看的。</p><h5 id="InstantiationAwareBeanPostProcessor-接口分析"><a href="#InstantiationAwareBeanPostProcessor-接口分析" class="headerlink" title="InstantiationAwareBeanPostProcessor 接口分析"></a>InstantiationAwareBeanPostProcessor 接口分析</h5><p>查看源码，可以看到 InstantiationAwareBeanPostProcessor 接口是继承  BeanPostProcessor</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-symbol">InstantiationAwareBeanPostProcessor</span> <span class="hljs-symbol">extends</span> <span class="hljs-symbol">BeanPostProcessor</span><br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>  <br>    <span class="hljs-meta">@Nullable</span>  <br>    <span class="hljs-keyword">default</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;  <br>        <span class="hljs-keyword">return</span> bean;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>AbstractAutowireCapableBeanFactory#createBean</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 创建Bean实例的方法，接收Bean的名称、RootBeanDefinition（Bean的定义信息）和参数数组</span><br>protected Object createBean(<span class="hljs-keyword">String</span> beanName, RootBeanDefinition mbd, <span class="hljs-meta">@Nullable Object[] args) throws BeanCreationException &#123;</span><br>    <span class="hljs-comment">// 如果启用了跟踪日志，输出创建Bean实例的跟踪信息</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>        <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 解析Bean的类信息，如果已经有解析过的类信息，使用之前解析得到的类信息</span><br>    RootBeanDefinition mbdToUse = mbd;<br>    Class&lt;?&gt; resolvedClass = <span class="hljs-built_in">this</span>.resolveBeanClass(mbd, beanName, <span class="hljs-keyword">new</span> <span class="hljs-type">Class</span>[<span class="hljs-number">0</span>]);<br>    <span class="hljs-comment">// 如果解析得到的类信息不为空，且当前Bean的定义信息没有指定类信息，则更新Bean的定义信息</span><br>    <span class="hljs-keyword">if</span> (resolvedClass != <span class="hljs-literal">null</span> &amp;&amp; !mbd.hasBeanClass() &amp;&amp; mbd.getBeanClassName() != <span class="hljs-literal">null</span>) &#123;<br>        mbdToUse = <span class="hljs-keyword">new</span> <span class="hljs-type">RootBeanDefinition</span>(mbd);<br>        mbdToUse.setBeanClass(resolvedClass);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 准备处理方法的覆盖，即准备解析方法注解</span><br>        mbdToUse.prepareMethodOverrides();<br>    &#125; <span class="hljs-keyword">catch</span> (BeanDefinitionValidationException var9) &#123;<br>        <span class="hljs-comment">// 如果方法注解解析失败，抛出BeanDefinitionStoreException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanDefinitionStoreException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Validation of method overrides failed&quot;</span>, var9);<br>    &#125;<br><br>    Object beanInstance;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 在实例化Bean之前，尝试调用BeanPostProcessor的beforeInstantiation方法</span><br>        beanInstance = <span class="hljs-built_in">this</span>.resolveBeforeInstantiation(beanName, mbdToUse);<br>        <span class="hljs-comment">// 如果beforeInstantiation方法返回非空，表示已经创建了Bean实例，直接返回该实例</span><br>        <span class="hljs-keyword">if</span> (beanInstance != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> beanInstance;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var10) &#123;<br>        <span class="hljs-comment">// 如果beforeInstantiation方法抛出异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;BeanPostProcessor before instantiation of bean failed&quot;</span>, var10);<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">// 执行真正的Bean创建逻辑，包括实例化、属性注入等过程</span><br>        beanInstance = <span class="hljs-built_in">this</span>.doCreateBean(beanName, mbdToUse, args);<br>        <span class="hljs-comment">// 如果启用了跟踪日志，输出Bean实例创建完成的跟踪信息</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.logger.isTraceEnabled()) &#123;<br>            <span class="hljs-built_in">this</span>.logger.<span class="hljs-built_in">trace</span>(<span class="hljs-string">&quot;Finished creating instance of bean &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27;&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">// 返回创建的Bean实例</span><br>        <span class="hljs-keyword">return</span> beanInstance;<br>    &#125; <span class="hljs-keyword">catch</span> (ImplicitlyAppearedSingletonException | BeanCreationException var7) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了异常，抛出异常</span><br>        <span class="hljs-keyword">throw</span> var7;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var8) &#123;<br>        <span class="hljs-comment">// 如果Bean创建过程中出现了未捕获的异常，抛出BeanCreationException异常</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">BeanCreationException</span>(mbdToUse.getResourceDescription(), beanName, <span class="hljs-string">&quot;Unexpected exception during bean creation&quot;</span>, var8);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-工厂后处理器方法"><a href="#2-3-工厂后处理器方法" class="headerlink" title="2.3 工厂后处理器方法"></a>2.3 <strong>工厂后处理器方法</strong></h4><p><strong>BeanFactoryProcessor 一系列接口</strong></p><p>包括 AspectJWeavingEnabler、CustomAutowireConfigurer、ConfigurationClassPostProcessor 等。</p><p>这些都是 Spring 框架中已经实现好的 BeanFactoryPostProcessor，用来实现某些特定的功能</p><blockquote><p>BeanFactoryProcessor 接口 vs  BeanPostProcessor接口</p></blockquote><p><code>BeanFactoryPostProcessor</code> 接口和 <code>BeanPostProcessor</code> 接口都是 Spring 框架中用于定制和扩展 Bean 的关键接口，但它们的作用和时机略有不同。</p><p>BeanFactoryPostProcessor 接口：</p><ol><li><p><strong>作用：</strong> <code>BeanFactoryPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 之前修改或定制 BeanFactory 的配置。</p></li><li><p><strong>时机：</strong> 在 Spring 容器读取了 Bean 的定义（配置元数据）但在实例化任何 Bean 之前，<code>BeanFactoryPostProcessor</code> 接口提供了机会来修改 Bean 的定义，例如修改属性值、添加属性等。</p></li><li><p><strong>实现方法：</strong> 实现 <code>postProcessBeanFactory</code> 方法，该方法传递了 BeanFactory 对象，可以在此方法中修改 BeanFactory 的配置。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">ConfigurableListableBeanFactory</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistryPostProcessor</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">support</span>.<span class="hljs-property">BeanDefinitionRegistry</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanDefinitionRegistryPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanFactory</span>(<span class="hljs-params">ConfigurableListableBeanFactory beanFactory</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以修改 BeanFactory 的配置</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">postProcessBeanDefinitionRegistry</span>(<span class="hljs-params">BeanDefinitionRegistry registry</span>) &#123;<br>        <span class="hljs-comment">// 在这里可以注册新的 BeanDefinition</span><br>        <span class="hljs-title class_">BeanDefinitionBuilder</span> builder = <span class="hljs-title class_">BeanDefinitionBuilder</span>.<span class="hljs-title function_">genericBeanDefinition</span>(<span class="hljs-title class_">MyBean</span>.<span class="hljs-property">class</span>);<br>        registry.<span class="hljs-title function_">registerBeanDefinition</span>(<span class="hljs-string">&quot;myBean&quot;</span>, builder.<span class="hljs-title function_">getBeanDefinition</span>());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>BeanPostProcessor 接口</p></blockquote><ol><li><p><strong>作用：</strong> <code>BeanPostProcessor</code> 接口用于在 Spring 容器实例化 Bean 后，在 Bean 的初始化前后执行一些自定义的逻辑。</p></li><li><p><strong>时机：</strong> 当 Bean 被实例化后，但在调用其初始化方法（如果有的话）之前，<code>BeanPostProcessor</code> 提供了 <code>postProcessBeforeInitialization</code> 和 <code>postProcessAfterInitialization</code> 方法用于在初始化阶段进行定制操作。</p></li><li><p><strong>实现方法：</strong> 实现 <code>BeanPostProcessor</code> 接口的两个方法，可以在这两个方法中添加定制逻辑。</p></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">BeansException</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">config</span>.<span class="hljs-property">BeanPostProcessor</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">BeanPostProcessor</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessBeforeInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之前的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Object</span> <span class="hljs-title function_">postProcessAfterInitialization</span>(<span class="hljs-title class_">Object</span> bean, <span class="hljs-title class_">String</span> beanName) throws <span class="hljs-title class_">BeansException</span> &#123;<br>        <span class="hljs-comment">// 在初始化之后的逻辑</span><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>总结</p><ul><li><code>BeanFactoryPostProcessor</code> 主要用于修改整个 BeanFactory 的配置，它在 Bean 实例化之前执行。</li><li><code>BeanPostProcessor</code> 主要用于在每个 Bean 的初始化阶段添加自定义逻辑，它在 Bean 实例化后，初始化方法调用前后执行。</li></ul><p>在实际应用中，可以同时使用这两个接口来完成更复杂的定制需求。</p><h4 id="2-4-Bean-级生命周期方法"><a href="#2-4-Bean-级生命周期方法" class="headerlink" title="2.4  Bean 级生命周期方法"></a>2.4  <strong>Bean 级生命周期方法</strong></h4><p>关于 Bean 级生命周期方法的理解：</p><ul><li>这些方法提供了针对 Bean 实例的<strong>个性化行为</strong>，允许 Bean 在其生命周期的关键点做出响应。</li></ul><p>通过这些方法，是可以对于某个Bean实例进行个性化操作的。</p><p>可以理解为 Bean 类直接实现接口的方法，比如 <code>BeanNameAware</code>、<code>BeanFactoryAware</code>、<code>ApplicationContextAware</code>、<code>InitializingBean</code>、<code>DisposableBean</code> 等方法，这些方法只对当前 Bean 生效。</p><p>Aware 类型的接口</p><p>Aware 类型的接口的作用就是让我们能够拿到 Spring 容器中的一些资源。</p><p>基本都能够见名知意，Aware 之前的名字就是可以拿到什么资源，例如 BeanNameAware 可以拿到 BeanName，以此类推。</p><h3 id="3、Spring-Bean-详细生命周期"><a href="#3、Spring-Bean-详细生命周期" class="headerlink" title="3、Spring Bean 详细生命周期"></a>3、Spring Bean 详细生命周期</h3><blockquote><p>Bean 的生命周期</p></blockquote><ul><li>Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>如果涉及到一些属性值 利用 set() 方法设置一些属性值。</li><li>如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName() 方法，传入 Bean 的名字。</li><li>如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader() 方法，传入 ClassLoader 对象的实例。</li><li>如果 Bean 实现了 BeanFactoryAware 接口，调用 setBeanFactory() 方法，传入 BeanFactory 对象的实例。</li><li>与上面的类似，如果实现了其他 * .Aware 接口，就调用相应的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessBeforeInitialization() 方法</li><li>如果 Bean 实现了 InitializingBean 接口，执行 afterPropertiesSet() 方法。</li><li>如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行 postProcessAfterInitialization() 方法</li><li>当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。</li><li>当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><h3 id="4、Bean-创建流程入口-refresh"><a href="#4、Bean-创建流程入口-refresh" class="headerlink" title="4、Bean 创建流程入口 refresh()"></a>4、Bean 创建流程入口 refresh()</h3><h4 id="相关概念回顾"><a href="#相关概念回顾" class="headerlink" title="相关概念回顾"></a>相关概念回顾</h4><h5 id="Spring上下文"><a href="#Spring上下文" class="headerlink" title="Spring上下文"></a>Spring上下文</h5><p>从代码级别来说，就是指Spring Context</p><p>从源码级别，我们初始化Spring Context的时候，一堆的Spring组件围绕在一起，使其能够正常工作，这个状态就被称为Spring环境。</p><h5 id="Spring-初始化操作"><a href="#Spring-初始化操作" class="headerlink" title="Spring 初始化操作"></a>Spring 初始化操作</h5><p>具体操作可以见下#ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用</p><p>使用前需要引入 spring-context 相关的依赖，初始化Bean可以通过注解的方式也可以通过xml的方式。</p><h5 id="BeanFactory-与-ApplicationContext"><a href="#BeanFactory-与-ApplicationContext" class="headerlink" title="BeanFactory  与  ApplicationContext"></a><code>BeanFactory</code>  与  <code>ApplicationContext</code></h5><p>先了解一下  <code>BeanFactory</code> 与  <code>ApplicationContext</code> 接口两个的作用与概念：</p><ul><li><code>org.springframework.beans</code> 和 <code>org.springframework.context</code> 包是Spring Framework的IoC容器的基础。 </li><li><code>BeanFactory</code> 提供了配置框架和基本功能，提供了一种高级配置机制，能够管理任何类型的对象。</li><li><code>ApplicationContext</code> 是 <code>BeanFactory</code> 的一个子接口，相比于 <code>BeanFactory</code>  来说，增加了更多的企业特定功能, 是 <code>BeanFactory</code> 的一个完整的超集。</li><li><code>BeanFactory</code> 实现了<strong>延迟</strong>加载（懒加载），只有在请求获取Bean时（例如，通过<code>getBean()</code>方法），容器才会创建该Bean。这意味着如果应用中未使用某个Bean，它就不会被实例化。</li><li><code>ApplicationContext</code>其下管理的 Bean 是<strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li></ul><h5 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a><code>ApplicationContext</code></h5><p><code>org.springframework.context.ApplicationContext</code> 接口代表Spring IoC容器，负责实例化、配置和组装bean。</p><h5 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a><code>AbstractApplicationContext</code></h5><p><code>AbstractApplicationContext</code> 实现了 <code>ApplicationContext</code> 接口，提供了这个接口的大部分通用功能。</p><p>它是实际应用上下文类（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>）的父类</p><p>通过继承和扩展 <code>AbstractApplicationContext</code>，Spring 允许开发者自定义应用上下文的行为，以满足特定的业务需求。</p><h5 id="ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？"><a href="#ClassPathXmlApplicationContext-的构造方法哪里会被加载并使用？" class="headerlink" title="ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？"></a>ClassPathXmlApplicationContext 的构造方法哪里会被加载并使用？</h5><p>以下是几个典型场景，其中可能会加载并使用 <code>ClassPathXmlApplicationContext</code> 的构造方法：</p><ol><li>Java 应用的主方法 (main)</li></ol><p>在一个标准的 Java 应用程序中，你可以在 <code>main</code> 方法中创建 <code>ClassPathXmlApplicationContext</code> 的实例来启动 Spring 容器。这是最常见的用法。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApp</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>) &#123;<br>        <span class="hljs-title class_">ApplicationContext</span> context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">// 使用 context 获取 Bean 实例...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>ClassPathXmlApplicationContext</code> 用于加载名为 “applicationContext.xml” 的配置文件。</p><ol start="2"><li>Web 应用程序</li></ol><p>在基于 Servlet 的传统 Web 应用程序中，可以在 Servlet 的 <code>init</code> 方法中创建 <code>ClassPathXmlApplicationContext</code>，或者使用 Spring 的 <code>ContextLoaderListener</code> 在 Web 应用启动时自动加载 Spring 上下文。</p><ol start="3"><li>单元测试</li></ol><p>在编写 Spring 应用的单元测试时，可以在测试类中创建 <code>ClassPathXmlApplicationContext</code> 来加载所需的 Spring 配置，并进行测试。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyTest</span> &#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">testSomeService</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">ApplicationContext</span> <span class="hljs-variable">context</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ClassPathXmlApplicationContext</span>(<span class="hljs-string">&quot;testContext.xml&quot;</span>);<br>        <span class="hljs-type">MyService</span> <span class="hljs-variable">myService</span> <span class="hljs-operator">=</span> context.getBean(MyService.class);<br>        <span class="hljs-comment">// 执行测试...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这里，测试使用了单独的配置文件 “testContext.xml”。</p><ol start="4"><li>Spring Boot 应用</li></ol><p>使用 Spring Boot 时通常不直接使用 <code>ClassPathXmlApplicationContext</code></p><p> Spring Boot 提供了基于注解的配置和自动配置的能力，一般是使用注解配置的方式进行声明Bean操作 ，但在一些旧的或特殊的情况下，可能仍然需要手动加载 XML 配置的方式。</p><hr><h4 id="Bean-创建流程入口"><a href="#Bean-创建流程入口" class="headerlink" title="Bean 创建流程入口"></a>Bean 创建流程入口</h4><p>这里直接跟一下源码看一下相关内容</p><p>下面的代码是从 spring-context-5.2.4.RELEASE 版本中的 AbstractApplicationContext 抽象类下相关方法和内容说明。</p><p>在实际应用上下文类中（如 <code>ClassPathXmlApplicationContext</code> 和 <code>AnnotationConfigApplicationContext</code>），他们的构造方法中会调用这个 refresh() 方法类进行初始化 Spring 容器。</p><p>因此可以判断出  Bean 创建流程入口 是定义在 AbstractApplicationContext 抽象类下 refresh() 方法。</p><h5 id="refressh方法"><a href="#refressh方法" class="headerlink" title="refressh方法"></a>refressh方法</h5><p>这里实际看一下相关代码 AbstractApplicationContext#refresh()</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> void refresh() throws BeansException, IllegalStateException &#123;<br>    <span class="hljs-comment">// 同步锁确保容器刷新时的线程安全</span><br>    synchronized (<span class="hljs-keyword">this</span>.startupShutdownMonitor) &#123;<br><br>        <span class="hljs-comment">// 准备刷新，设置启动日期和活跃状态等</span><br>        <span class="hljs-keyword">this</span>.prepareRefresh();<br><br>        <span class="hljs-comment">// 获取新的 BeanFactory，初始化 BeanFactory，并加载 Bean 定义</span><br>        ConfigurableListableBeanFactory beanFactory = <span class="hljs-keyword">this</span>.obtainFreshBeanFactory();<br><br>        <span class="hljs-comment">// 配置 BeanFactory，设置类加载器、事件处理器等</span><br>        <span class="hljs-keyword">this</span>.prepareBeanFactory(beanFactory);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 允许在 BeanFactory 标准初始化之后进行定制修改</span><br>            <span class="hljs-keyword">this</span>.postProcessBeanFactory(beanFactory);<br><br>            <span class="hljs-comment">// 调用在容器中注册的 BeanFactoryPostProcessor</span><br>            <span class="hljs-keyword">this</span>.invokeBeanFactoryPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 注册 BeanPostProcessor，这些处理器影响所有 Bean 的创建</span><br>            <span class="hljs-keyword">this</span>.registerBeanPostProcessors(beanFactory);<br><br>            <span class="hljs-comment">// 初始化 MessageSource 组件，用于国际化处理</span><br>            <span class="hljs-keyword">this</span>.initMessageSource();<br><br>            <span class="hljs-comment">// 初始化 ApplicationEventMulticaster，用于事件广播</span><br>            <span class="hljs-keyword">this</span>.initApplicationEventMulticaster();<br><br>            <span class="hljs-comment">// 特定于 ApplicationContext 的刷新操作</span><br>            <span class="hljs-keyword">this</span>.onRefresh();<br><br>            <span class="hljs-comment">// 注册监听器到事件广播器</span><br>            <span class="hljs-keyword">this</span>.registerListeners();<br><br>            <span class="hljs-comment">// 初始化所有剩余的非懒加载单例</span><br>            <span class="hljs-keyword">this</span>.finishBeanFactoryInitialization(beanFactory);<br><br>            <span class="hljs-comment">// 完成刷新过程，通知生命周期处理器以及发布相应的事件</span><br>            <span class="hljs-keyword">this</span>.finishRefresh();<br>        &#125; <span class="hljs-keyword">catch</span> (BeansException var9) &#123;<br>            <span class="hljs-comment">// 在上下文初始化过程中捕获并处理异常</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logger.isWarnEnabled()) &#123;<br>                <span class="hljs-keyword">this</span>.logger.warn(<span class="hljs-string">&quot;Exception encountered during context initialization - cancelling refresh attempt: &quot;</span> + var9);<br>            &#125;<br><br>            <span class="hljs-comment">// 销毁已创建的 Bean，以防有些 Bean 已经初始化了，但后续的初始化过程失败了</span><br>            <span class="hljs-keyword">this</span>.destroyBeans();<br><br>            <span class="hljs-comment">// 取消刷新操作，重置上下文的同步标志</span><br>            <span class="hljs-keyword">this</span>.cancelRefresh(var9);<br><br>            <span class="hljs-comment">// 重新抛出异常，通知外部调用者</span><br>            <span class="hljs-keyword">throw</span> var9;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 重置公共缓存（例如 Reflection 缓存）</span><br>            <span class="hljs-keyword">this</span>.resetCommonCaches();<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><p>可以看到初始化单例这步操作是在 this.finishBeanFactoryInitialization(beanFactory); 这里进行的</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-type">void</span> <span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>    <span class="hljs-comment">// 如果 BeanFactory 包含名为 &quot;conversionService&quot; 的 Bean，并且这个 Bean 适配于 ConversionService 类型</span><br>    <span class="hljs-keyword">if</span> (beanFactory.<span class="hljs-built_in">containsBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>) &amp;&amp; beanFactory.<span class="hljs-built_in">isTypeMatch</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>)) &#123;<br>        <span class="hljs-comment">// 将这个 Bean 设置为容器的 ConversionService</span><br>        beanFactory.<span class="hljs-built_in">setConversionService</span>((ConversionService)beanFactory.<span class="hljs-built_in">getBean</span>(<span class="hljs-string">&quot;conversionService&quot;</span>, ConversionService.<span class="hljs-keyword">class</span>));<br>    &#125;<br><br>    <span class="hljs-comment">// 如果 BeanFactory 还没有嵌入的值解析器</span><br>    <span class="hljs-keyword">if</span> (!beanFactory.<span class="hljs-built_in">hasEmbeddedValueResolver</span>()) &#123;<br>        <span class="hljs-comment">// 添加一个嵌入的值解析器，用于解析占位符</span><br>        beanFactory.<span class="hljs-built_in">addEmbeddedValueResolver</span>(strVal -&gt; &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getEnvironment</span>().<span class="hljs-built_in">resolvePlaceholders</span>(strVal);<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">// 获取所有实现 LoadTimeWeaverAware 接口的 Bean 的名称</span><br>    <span class="hljs-type">String</span>[] weaverAwareNames = beanFactory.<span class="hljs-built_in">getBeanNamesForType</span>(LoadTimeWeaverAware.<span class="hljs-keyword">class</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);<br>    <br>    <span class="hljs-comment">// 遍历这些 Bean 名称</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">String</span> weaverAwareName : weaverAwareNames) &#123;<br>        <span class="hljs-comment">// 初始化相应的 Bean，以确保它们能够执行加载时织入（Load Time Weaving）的相关逻辑</span><br>        <span class="hljs-keyword">this</span>.<span class="hljs-built_in">getBean</span>(weaverAwareName);<br>    &#125;<br><br>    <span class="hljs-comment">// 将 BeanFactory 的临时类加载器设置为 null</span><br>    beanFactory.<span class="hljs-built_in">setTempClassLoader</span>(null);<br><br>    <span class="hljs-comment">// 冻结所有的 Bean 定义，表示注册的 Bean 定义将不再被修改或任何进一步的处理</span><br>    beanFactory.<span class="hljs-built_in">freezeConfiguration</span>();<br><br>    <span class="hljs-comment">// 预实例化单例，确保所有非懒加载的单例都被实例化</span><br>    beanFactory.<span class="hljs-built_in">preInstantiateSingletons</span>();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>实例化 Instantiation</p></blockquote><p>其中第一阶段 —— 实例化 Instantiation，</p><p>Bean 实例化的时机分为两种，一种是 BeanFactory，还有一种是  ApplicationContext；</p><p>下面是两者差别：</p><ul><li>BeanFactory<ul><li>其下管理的Bean <strong>在使用到Bean的时候</strong> 才会进行实例化Bean操作（懒加载策略）</li></ul></li><li>ApplicationContext  <ul><li>其下管理的 Bean <strong>在IOC容器初始化</strong>的时候完成 Bean 实例化。</li><li><code>ApplicationContext</code>是<code>BeanFactory</code>的子接口，复杂程度更高一些。</li><li>如<code>AnnotationConfigApplicationContext</code>和<code>ClassPathXmlApplicationContext</code>等，提供了多种方便的方式来创建ApplicationContext实例</li></ul></li></ul><hr><p>视频地址：  <a href="https://www.bilibili.com/video/BV1584y1r7n6/">https://www.bilibili.com/video/BV1584y1r7n6/</a></p><h4 id="Spring-Bean-的生命周期"><a href="#Spring-Bean-的生命周期" class="headerlink" title="Spring Bean 的生命周期"></a>Spring Bean 的生命周期</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231218215844.png" alt="image.png"></p><p>生产 →  使用  →  销毁</p><h5 id="生产"><a href="#生产" class="headerlink" title="生产"></a>生产</h5><p>启动，准备容器&#x2F;环境等</p><p>① 加载 Bean 定义（BeanDefinitions)</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">加载Bean定义<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">obtainFreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>通过 loadBeanDefinitions 扫描所有xml配置、注解将Bean记录在 Bean定义集合 beanDefinitionMap 中</p><p>②创建 Bean 对象（createBean)</p><p>遍历“Bean定义”集合</p><p>通过 createBean 遍历 beanDefinitionMap 创建bean</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs stylus">创建Bean<br><br><span class="hljs-function"><span class="hljs-title">run</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">refreshContext</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">refresh</span><span class="hljs-params">()</span></span><br>→ <br><span class="hljs-function"><span class="hljs-title">finishBeanFactoryInitialization</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">preInstantiateSingletioins</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">doGetBean</span><span class="hljs-params">()</span></span><br>→<br><span class="hljs-function"><span class="hljs-title">createBean</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><blockquote><p>2.1.构造对象</p></blockquote><p>通过 createBeanInstance 方法进行对象的构造</p><p>使用反射机制从“Bean定义”中的BeanClass拿到类的构造方法</p><p>准备参数：在单例池中，根据参数的Class类进行查找</p><p>构造对象：通过反射进行Bean的构造（如果是无参则无需准备参数直接构造）</p><hr><p>查找Class类<br>    当匹配到多个实例，<br>    会再根据参数名进行匹配</p><blockquote><p>2.2.填充属性</p></blockquote><p>通过 populateBean 方法对 Bean 内部所需属性进行属性填充, 通常是 @Autowired 注解的变量</p><p>三级缓存进行依赖注入</p><blockquote><p>2.3.初始化实例</p></blockquote><p>通过 initializeBean 方法对实例进行初始化</p><p>初始化操作：</p><ol><li>初始化容器相关信息<br>通过 invokeAwareMethods 方法为实现各种 Aware 接口的Bean设置诸如 beanName, beanFactory 等容器信息<br>Aware 接口指代：信息感知接口</li><li>通过 invokeInitMethods 方法执行 Bean 的初始化方法</li></ol><p>该 invokeInitMethods 方法是通过实现 InitializingBean 接口而实现的 afterPropertiesSet 方法<br>【Bean填充属性后执行】  ((InitializingBean)bean).afterPropertiesSet()</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs csharp">afterPropertiesSet <br><br>↓ <br><br><span class="hljs-keyword">init</span>-Methods<br><br>↓<br><br>BeanPostProcessors<br></code></pre></td></tr></table></figure><hr><h5 id="销毁操作"><a href="#销毁操作" class="headerlink" title="销毁操作"></a>销毁操作</h5><p>销毁操作<br>销毁前<br>    销毁之前会执行 postProcessBeforeDestruction “销毁前处理器“，这步会执行 Bean 中 @PreDestroy 注解的方法<br>容器销毁<br>    后续通过 destoryBeans 方法逐一“销毁”容器中的Bean，销毁的时候会执行 destroy 方法（通过registerDisposableBean方法注册的Bean，该接口只有一个方法 destroy。在Bean销毁的时候，Spring容器会调用这个方法。）<br>Bean自定义销毁方法<br>    “客户销毁方法”invokeCustomDestroyMethod; →  执行Bean上自定义的 destoryMethod 方法</p><h3 id="5、Spring-Bean-生命周期流程图"><a href="#5、Spring-Bean-生命周期流程图" class="headerlink" title="5、Spring Bean 生命周期流程图"></a>5、<strong>Spring Bean 生命周期流程图</strong></h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312160247944.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html">https://docs.spring.io/spring-framework/reference/6.1-SNAPSHOT/core/beans.html</a></li><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://www.bilibili.com/video/BV1584y1r7n6">https://www.bilibili.com/video/BV1584y1r7n6</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://blog.csdn.net/riemann_/article/details/118500805">https://blog.csdn.net/riemann_/article/details/118500805</a></li><li><a href="https://blog.csdn.net/qq_20021569/article/details/109178816">https://blog.csdn.net/qq_20021569/article/details/109178816</a></li><li><a href="https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90">https://gitee.com/moxi159753/LearningNotes/tree/master/%E6%A0%A1%E6%8B%9B%E9%9D%A2%E8%AF%95/Spring%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90</a></li><li><a href="https://cloud.tencent.com/developer/article/2216932">https://cloud.tencent.com/developer/article/2216932</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_Spring_Bean的作用域</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_Spring_Bean%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>复习概念</p></blockquote><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="Spring-中的-bean-的作用域有哪些"><a href="#Spring-中的-bean-的作用域有哪些" class="headerlink" title="Spring 中的 bean 的作用域有哪些"></a>Spring 中的 bean 的作用域有哪些</h3><p>这个问题是面试题场景的一个问题，我们首先来看一下基本的一个回答。</p><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li><strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li><strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li><strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li><strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li><strong>application&#x2F;global-session</strong> （仅 Web 应用可用）：每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li><strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><blockquote><p>如何配置 bean 的作用域</p></blockquote><p>xml 方式：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">&lt;bean <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">class</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attribute">scope</span>=<span class="hljs-string">&quot;singleton&quot;</span>&gt;&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>注解方式：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Bean</span><br><span class="hljs-variable">@Scope</span>(value = ConfigurableBeanFactory.SCOPE_PROTOTYPE)<br>public Person <span class="hljs-built_in">personPrototype</span>() &#123;<br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">new</span> <span class="hljs-selector-tag">Person</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>具体怎么配置的看你实际使用，这里大概讲一下使用场景，通过不同场景下的使用示例对 Spring 中 Bean 的作用域有一个基本认知。</p><h4 id="Singleton-Bean（默认作用域）"><a href="#Singleton-Bean（默认作用域）" class="headerlink" title="Singleton Bean（默认作用域）"></a>Singleton Bean（默认作用域）</h4><p><strong>场景</strong>: 在一个在线书店应用中，有一个库存管理服务负责跟踪所有书籍的库存。这个服务需要是单例的，因为它维护着整个应用中书籍库存的统一视图。</p><p>代码逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><span class="hljs-keyword">import</span> java.util.Map;<br><span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InventoryService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Integer&gt; bookInventory = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addBook</span><span class="hljs-params">(String isbn, <span class="hljs-type">int</span> quantity)</span> &#123;<br>        bookInventory.put(isbn, bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) + quantity);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">checkStock</span><span class="hljs-params">(String isbn)</span> &#123;<br>        <span class="hljs-keyword">return</span> bookInventory.getOrDefault(isbn, <span class="hljs-number">0</span>) &gt; <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他与库存管理相关的方法 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里，<code>InventoryService</code> 是一个singleton作用域的Bean，它在应用的整个生命周期内只会有一个实例。</p><p>所有对书籍库存的操作都通过这个单一实例进行，确保了库存数据的一致性。</p><h4 id="Prototype作用域"><a href="#Prototype作用域" class="headerlink" title="Prototype作用域"></a>Prototype作用域</h4><p><strong>场景</strong>: 在同一在线书店应用中，当用户想要购买书籍时，每个购物车都应该是独立的。因此，每个用户的购物车应该有其自己的状态。</p><p>代码逻辑</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">context</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Scope</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Component</span>;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope</span>(<span class="hljs-string">&quot;prototype&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingCart</span> &#123;<br><br>    <span class="hljs-keyword">private</span> final <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; items = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">addItem</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> isbn</span>) &#123;<br>        items.<span class="hljs-title function_">put</span>(isbn, items.<span class="hljs-title function_">getOrDefault</span>(isbn, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Map</span>&lt;<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Integer</span>&gt; <span class="hljs-title function_">getItems</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> items;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 购物车的其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShoppingService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">ApplicationContext</span> context;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ShoppingCart</span> <span class="hljs-title function_">createNewShoppingCart</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> context.<span class="hljs-title function_">getBean</span>(<span class="hljs-title class_">ShoppingCart</span>.<span class="hljs-property">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ShoppingService</code> 使用Spring的应用上下文来为每个用户创建一个新的<code>ShoppingCart</code>实例。</p><p>每次调用<code>createNewShoppingCart</code>方法时，都会返回一个全新的购物车实例，保证了用户之间购物车的隔离。</p><h4 id="Request作用域"><a href="#Request作用域" class="headerlink" title="Request作用域"></a>Request作用域</h4><p><strong>场景</strong>: 在一个新闻网站应用中，你需要跟踪每个HTTP请求的访问信息，例如用户的地理位置和设备类型，以便为他们提供定制化的新闻内容。</p><p>代码逻辑</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> org.springframework.web.context.annotation.RequestScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RequestScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> location;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">String</span> deviceType;<br><br>    <span class="hljs-keyword">public</span> UserContext(HttpServletRequest request) &#123;<br>        <span class="hljs-comment">// 通过请求获取用户的位置和设备类型</span><br>        <span class="hljs-built_in">this</span>.location = request.getHeader(<span class="hljs-string">&quot;Location&quot;</span>);<br>        <span class="hljs-built_in">this</span>.deviceType = request.getHeader(<span class="hljs-string">&quot;Device-Type&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getLocation() &#123;<br>        <span class="hljs-keyword">return</span> location;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> getDeviceType() &#123;<br>        <span class="hljs-keyword">return</span> deviceType;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">NewsController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserContext userContext;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/news&quot;</span>)<br>    <span class="hljs-keyword">public</span> ResponseEntity&lt;List&lt;NewsItem&gt;&gt; getNews() &#123;<br>        List&lt;NewsItem&gt; <span class="hljs-keyword">new</span><span class="hljs-type">s</span> = <span class="hljs-keyword">new</span><span class="hljs-type">sService</span>.getNewsForLocation(userContext.getLocation());<br>        <span class="hljs-comment">// 返回定制化的新闻内容</span><br>        <span class="hljs-keyword">return</span> ResponseEntity.ok(<span class="hljs-keyword">new</span><span class="hljs-type">s</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>UserContext</code>是一个request作用域的Bean，它为每个HTTP请求提供了一个新实例，</p><p>包含了请求特定的用户上下文信息，如位置和设备类型。</p><h4 id="Session作用域"><a href="#Session作用域" class="headerlink" title="Session作用域"></a>Session作用域</h4><p><strong>场景</strong>: 在一个在线考试平台上，每个用户的考试过程需要被追踪。用户可能会在考试中断后返回继续考试，所以考试状态需要在会话中保持。</p><p>代码逻辑</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.web.context.<span class="hljs-keyword">annotation</span>.SessionScope;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@SessionScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamSession</span> &#123;<br><br>    <span class="hljs-keyword">private</span> Exam currentExam;<br>    <span class="hljs-keyword">private</span> int currentQuestionIndex;<br><br>    <span class="hljs-comment">// 考试会话的方法，例如开始考试、回答问题等</span><br>&#125;<br><br><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExamController</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ExamSession examSession;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/start&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String startExam() &#123;<br>        examSession.startNewExam();<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;exam_started&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/exam/answer&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String answerQuestion(Answer answer) &#123;<br>        examSession.answerQuestion(answer);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;answer_recorded&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个场景中，<code>ExamSession</code> 是一个session作用域的Bean，它记录了用户的当前考试状态。每个用户会话都有自己的<code>ExamSession</code>实例。</p><blockquote><p>Session vs Global-Session vs WebSocket</p></blockquote><ol><li><strong>Session</strong>:<ul><li><strong>作用域</strong>: 限定在一个用户的HTTP会话中。</li><li><strong>典型用例</strong>: 在用户登录到网站后，你可能需要跟踪该用户的特定状态（比如购物车、偏好设置等）。这种情况下，每个用户都有自己的会话，每个会话都有自己的Bean实例。</li></ul></li><li><strong>Global-Session</strong>:<ul><li><strong>作用域</strong>: 限定在Portlet环境的全局HTTP会话中。在Spring 5及之后的版本中已不再使用，因为Spring 5不再支持Portlet。</li><li><strong>典型用例</strong>: 在Portlet环境中，多个Portlet可能需要共享全局会话数据。例如，用户的语言偏好可能需要跨多个Portlet保持一致。</li></ul></li><li><strong>WebSocket</strong>:<ul><li><strong>作用域</strong>: 绑定到WebSocket的会话中。</li><li><strong>典型用例</strong>: 当用户通过WebSocket连接到你的服务器时，你可能需要为每个WebSocket会话保存状态，例如游戏中的玩家状态或聊天应用中的用户会话</li></ul></li></ol><h4 id="Singleton-vs-Prototype"><a href="#Singleton-vs-Prototype" class="headerlink" title="Singleton vs Prototype"></a>Singleton vs Prototype</h4><blockquote><p>Singleton vs Prototype</p></blockquote><ol><li><strong>Singleton</strong>:<ul><li><strong>描述</strong>: 在Spring IoC容器中只创建一个Bean实例。</li><li><strong>典型用例</strong>: 大多数服务层和数据访问层的组件都是无状态的，可以被应用中的所有其他Bean共享。例如，数据库连接池、业务服务等。</li></ul></li><li><strong>Prototype</strong>:<ul><li><strong>描述</strong>: 每次请求时，Spring IoC容器都会创建一个新的Bean实例。</li><li><strong>典型用例</strong>: 比如在一个应用中，你想要为每个文件上传创建一个新的处理器（FileUploadHandler）实例，以防不同用户上传的数据相互冲突。</li></ul></li></ol><p>两种作用域的使用主要取决于Bean的状态管理需求。</p><p>Singleton用于那些不需要维护状态信息的共享组件，而Prototype适用于每次使用都需要一个新状态的场景。</p><blockquote><p>Singleton vs Prototype   对比两者的生命周期区别</p></blockquote><p>单例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 只有一个Bean实例被创建。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 如果Bean实现了<code>InitializingBean</code>接口或定义了自定义的初始化方法（如使用<code>@PostConstruct</code>注解或在XML配置中指定<code>init-method</code>），将会执行。</li><li><strong>后处理</strong>: <code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean现在可以被应用中的其他Bean使用。</li><li><strong>销毁</strong>: 当容器关闭时，如果Bean实现了<code>DisposableBean</code>接口或定义了自定义的销毁方法（如使用<code>@PreDestroy</code>注解或在XML配置中指定<code>destroy-method</code>），将会执行。</li></ol><p>多例Bean的生命周期：</p><ol><li><strong>实例化</strong>: 每次请求时都创建一个新的Bean实例。</li><li><strong>属性填充</strong>: 容器注入依赖的属性。</li><li><strong>初始化</strong>: 与单例Bean相同，如果有指定的初始化方法，将会执行。</li><li><strong>后处理</strong>: 与单例Bean相同，<code>BeanPostProcessors</code>在初始化前后执行。</li><li><strong>使用</strong>: Bean被客户端获取并使用。</li><li><strong>销毁</strong>: 容器不会管理多例Bean的完整生命周期；销毁由客户端负责。</li></ol><p>区别：</p><ul><li><strong>实例化频率</strong>:<ul><li><strong>单例</strong>: 只在Spring IoC容器创建时实例化一次。</li><li><strong>多例</strong>: 每次请求时实例化。</li></ul></li><li><strong>依赖注入时机</strong>:<ul><li><strong>单例</strong>: 依赖项在容器创建单例Bean时注入。</li><li><strong>多例</strong>: 依赖项在每次创建新实例时注入。</li></ul></li><li><strong>生命周期管理</strong>:<ul><li><strong>单例</strong>: 容器负责整个生命周期，包括销毁。</li><li><strong>多例</strong>: 容器启动后，不再管理Bean的生命周期；Bean的销毁不由Spring容器管理，需要用户手动管理。</li></ul></li><li><strong>销毁回调</strong>:<ul><li><strong>单例</strong>: 容器关闭时，可以调用销毁方法。</li><li><strong>多例</strong>: 容器不自动调用销毁方法，必须由获取Bean的客户端代码来处理。</li></ul></li></ul><p>在实际应用中，单例Bean通常用于无状态的服务，例如业务逻辑组件和数据访问对象。</p><p>而多例Bean则用于有明确状态的操作，这些状态不能共享给其他实例或线程，例如用户的会话或独立的任务处理器。</p><p>多例Bean 的销毁操作有兴趣可以了解一下： <a href="https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype">https://springdoc.cn/spring/core.html#beans-factory-scopes-prototype</a></p><blockquote><p>为了让Spring容器释放由 prototype scopeBean 持有的资源，可以尝试使用自定义 <a href="https://springdoc.cn/spring/core.html#beans-factory-extension-bpp">Bean后处理器</a>，它持有对需要清理的Bean的引用。</p></blockquote><hr><p>参考</p><ul><li><a href="https://springdoc.cn/spring/core.html#spring-core">https://springdoc.cn/spring/core.html#spring-core</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#bean-%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%9C%89%E5%93%AA%E4%BA%9B">Spring常见面试题总结 | JavaGuide(Java面试 + 学习指南)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_IOC</title>
    <link href="/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/"/>
    <url>/2023/12/14/Spring%E5%AD%A6%E4%B9%A0_IOC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、IOC是什么"><a href="#1、IOC是什么" class="headerlink" title="1、IOC是什么"></a>1、IOC是什么</h3><p>IoC &amp; AOP 不是 Spring 提出来的，它们在 Spring 之前已经存在了，只不过当时更加偏向于理论。Spring 在技术层次将这两个思想进行了很好的实现。</p><p>IOC （Inversion of Control ）指的是控制反转&#x2F;反转控制。</p><blockquote><p>IOC 理论说明</p></blockquote><p>例如：现有类 A 依赖于类 B</p><ul><li>在传统的开发方式中，往往是在类 A 中手动通过 new 关键字来 new 一个 B 的对象出来</li><li>使用IOC思想的开发方式：不通过 new 关键字来创建对象，而是通过 IoC 容器(Spring 框架) 来帮助我们实例化对象。我们需要哪个对象，直接从 IoC 容器里面获取。</li></ul><p>控制反转主要指的是将对象的创建和对象之间的关系维护交给IOC容器去管理，而不是由程序员手动进行管理。在传统的应用中，对象的创建通常是由程序员通过<code>new</code>关键字来完成的，而对象之间的关系也需要由程序员进行硬编码。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312051438413.png" alt="image.png"></p><ul><li><strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li><strong>反转</strong> ：控制权交给外部环境（IoC 容器）</li></ul><blockquote><p>IOC 和 DI  的关系</p></blockquote><p>其实它们是同一个概念的不同角度描述，由于控制反转概念比较含糊（可能只是理解为容器控制对象这一个层面，很难让人想到谁来维护对象关系），所以2004年大师级人物Martin Fowler又给出了一个新的名字：“依赖注入”，相对IoC 而言，“依赖注入”明确描述了“被注入对象依赖IoC容器配置依赖对象”。</p><p>通俗来说就是<strong>IoC是设计思想，DI是实现方式</strong>。</p><div style="background-color: #3498db; color: white; padding: 10px;">    IoC是设计思想，DI是实现方式。</div><hr><blockquote><p>IOC 容器</p></blockquote><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p><blockquote><p>什么是 Spring Bean</p></blockquote><p>Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><h3 id="2、IOC-配置的三种方式"><a href="#2、IOC-配置的三种方式" class="headerlink" title="2、IOC 配置的三种方式"></a>2、IOC 配置的三种方式</h3><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    主流方式是 注解 + Java 配置.</div><p>Spring框架提供了三种主要的IoC配置方式：XML配置、注解配置和Java配置。开发者可以选择其中一种或混合使用这些方式，来声明对象的依赖关系和配置信息。</p><p>Spring容器会根据这些配置信息，自动扫描并加载所需的对象，实现对象的创建、装配和管理。</p><h4 id="xml-配置"><a href="#xml-配置" class="headerlink" title="xml 配置"></a>xml 配置</h4><p>顾名思义，就是将bean的信息配置.xml文件里，通过Spring加载文件为我们创建bean。</p><p>这种方式出现很多早前的SSM项目中，将第三方类库或者一些配置工具类都以这种方式进行配置，主要原因是由于第三方类不支持Spring注解。</p><ul><li><strong>优点</strong>： 可以使用于任何场景，结构清晰，通俗易懂</li><li><strong>缺点</strong>： 配置繁琐，不易维护，枯燥无味，扩展性差</li></ul><p><strong>举例</strong>：</p><ol><li>配置xx.xml文件</li><li>声明命名空间和配置bean</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-string"><span class="hljs-tag"> http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- services --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;tech.pdai.springframework.service.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- additional collaborators and configuration for this bean go here --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- more bean definitions for services go here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="Java-配置"><a href="#Java-配置" class="headerlink" title="Java 配置"></a>Java 配置</h4><p>将类的创建交给我们配置的JavcConfig类来完成，Spring只负责维护和管理，采用纯Java创建方式。</p><p>其本质上就是把在XML上的配置声明转移到Java配置类中</p><ul><li><strong>优点</strong>：适用于任何场景，配置方便，因为是纯Java代码，扩展性高，十分灵活</li><li><strong>缺点</strong>：由于是采用Java类的方式，声明不明显，如果大量配置，可读性比较差</li></ul><p><strong>举例</strong>：</p><ol><li>创建一个配置类， 添加@Configuration注解声明为配置类</li><li>创建方法，方法上加上@bean，该方法用于创建实例并返回，该实例创建后会交给spring管理，方法名建议与实例名相同（首字母小写）。注：实例类不需要加任何注解</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> <span class="hljs-variable">pdai</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BeansConfig</span> &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user dao</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userDao&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserDaoImpl</span> <span class="hljs-title function_">userDao</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserDaoImpl</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> user service</span><br><span class="hljs-comment">    */</span><br>    <span class="hljs-meta">@Bean</span>(<span class="hljs-string">&quot;userService&quot;</span>)<br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">UserServiceImpl</span> <span class="hljs-title function_">userService</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">UserServiceImpl</span> userService = <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserServiceImpl</span>();<br>        userService.<span class="hljs-title function_">setUserDao</span>(<span class="hljs-title function_">userDao</span>());<br>        <span class="hljs-keyword">return</span> userService;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h4><p>通过在类上加注解的方式，来声明一个类交给Spring管理，Spring会自动扫描带有@Component，@Controller，@Service，@Repository这四个注解的类，然后帮我们创建并管理，前提是需要先配置Spring的注解扫描器。</p><ul><li><strong>优点</strong>：开发便捷，通俗易懂，方便维护。</li><li><strong>缺点</strong>：具有局限性，对于一些第三方资源，无法添加注解。只能采用XML或JavaConfig的方式配置</li></ul><p><strong>举例</strong>：</p><ol><li>对类添加@Component相关的注解，比如@Controller，@Service，@Repository</li><li>设置ComponentScan的basePackage, 比如<code>&lt;context:component-scan base-package=&#39;tech.pdai.springframework&#39;&gt;</code>, 或者<code>@ComponentScan(&quot;tech.pdai.springframework&quot;)</code>注解，或者 <code>new AnnotationConfigApplicationContext(&quot;tech.pdai.springframework&quot;)</code>指定扫描的basePackage.<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @author pdai</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * user dao impl.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserDaoImpl userDao;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * find user list.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return user list</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;User&gt; findUserList() &#123;<br>        <span class="hljs-keyword">return</span> userDao.findUserList();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="3、依赖注入的三种方式"><a href="#3、依赖注入的三种方式" class="headerlink" title="3、依赖注入的三种方式"></a>3、依赖注入的三种方式</h3><p>参考看一下这个： <a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></p><p>依赖注入有三种主要的实现方式：属性注入、Setter注入和构造方法注入。</p><p>属性注入最简单，但通用性较差。Spring官方推荐使用构造方法注入，因为它支持注入不可变对象，通用性更强。对于可变对象，可以考虑使用Setter注入。</p><p><strong>代码示例</strong></p><blockquote><ol><li>属性注入（Field Injection）</li></ol></blockquote><p><strong>属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式</strong>(直接在类的字段上注入依赖)</p><p>这种方式在某些场景下很方便，但可能会导致难以测试和难以维护的代码，因为它隐藏了类的依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Component</span><br>public class MyService &#123;<br><br>    <span class="hljs-variable">@Autowired</span><br>    private DependencyClass dependency;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-variable">@Component</span><br>public class DependencyClass &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>优点是简单易用，缺点也随之而来</p><ol><li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li><li>通用性问题：只能适应于 IoC 容器；</li><li>设计原则问题：更容易违背单一设计原则。</li></ol><blockquote><ol start="2"><li>Setter注入（Setter Injection）</li></ol></blockquote><p>在Setter注入中，Spring通过调用类的setter方法来注入依赖。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> void setDependency(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>setter 的方式可能会麻烦一点，不过他是完全符合单一职责的设计原则，每一个 Setter 只针对一个对象。</p><p>缺点：</p><ol><li>不能注入不可变对象（final 修饰的对象）；</li><li>注入的对象可被修改</li></ol><blockquote><ol start="3"><li>构造方法注入（Constructor Injection）</li></ol></blockquote><p>这种方式通过类的构造方法来注入依赖。这是最推荐的方式，因为它可以确保所需的依赖项在对象创建时即被提供，从而保证了对象的不变性和依赖的不可更改性。</p><p><strong>示例代码</strong>:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyService</code> 类依赖于 <code>DependencyClass</code>。</p><p>当Spring创建 <code>MyService</code> 的实例时，它会查找 <code>DependencyClass</code> 的实例并通过构造方法注入它。</p><p>从Spring 4.3开始，当一个类只有一个构造函数时，<code>@Autowired</code> 注解是可选的(可以省略）。Spring会自动将这个唯一的构造函数用作依赖注入的入口。</p><p>上面的代码可以简化为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DependencyClass dependency;<br><br>    <span class="hljs-keyword">public</span> MyService(DependencyClass dependency) &#123;<br>        <span class="hljs-keyword">this</span>.dependency = dependency;<br>    &#125;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DependencyClass</span> &#123;<br>    <span class="hljs-comment">// ... 类的实现 ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这种写法符合“约定优于配置”的原则，减少了不必要的注解使用。</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html">https://javaguide.cn/system-design/framework/spring/ioc-and-aop.html</a></li><li><a href="https://www.martinfowler.com/articles/injection.html">https://www.martinfowler.com/articles/injection.html</a></li><li><a href="https://www.iteye.com/blog/jinnianshilongnian-1413846">https://www.iteye.com/blog/jinnianshilongnian-1413846</a></li><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F">https://www.pdai.tech/md/spring/spring-x-framework-ioc.html#%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F</a></li><li><a href="https://zhuanlan.zhihu.com/p/557140781">https://zhuanlan.zhihu.com/p/557140781</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day04</title>
    <link href="/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/"/>
    <url>/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/</url>
    
    <content type="html"><![CDATA[<p>继续讲述蘑菇博客里面一些写法的使用说明</p><p>解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AvoidRepeatableCommit</span>  <br><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@OperationLogger</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>)  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;增加博客&quot;</span>, notes = <span class="hljs-string">&quot;增加博客&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/add&quot;</span>)  <br>public String <span class="hljs-built_in">add</span>(<span class="hljs-variable">@Validated</span>(&#123;Insert.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-comment">// 参数校验  </span><br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">blogService</span><span class="hljs-selector-class">.addBlog</span>(blogVO);  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解AvoidRepeatableCommit的使用"><a href="#1、自定义注解AvoidRepeatableCommit的使用" class="headerlink" title="1、自定义注解AvoidRepeatableCommit的使用"></a>1、自定义注解<code>AvoidRepeatableCommit</code>的使用</h3><p><code>@AvoidRepeatableCommit</code> 注解用于防止用户在指定时间内重复提交表单或请求。</p><p>与Spring AOP（面向切面编程）一起使用，以便在方法执行之前执行某些预处理操作。</p><blockquote><p>自定义注解 AvoidRepeatableCommit</p></blockquote><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Target</span>(ElementType.METHOD)<br><span class="hljs-variable">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-variable">@interface</span> AvoidRepeatableCommit &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指定时间内不可重复提交,单位毫秒，默认1秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-selector-tag">long</span> <span class="hljs-selector-tag">timeout</span>() <span class="hljs-selector-tag">default</span> <span class="hljs-number">1000</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表明这个注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表明这个注解在运行时保留，可以通过反射读取。</li><li><code>timeout()</code>: 注解的属性，表示不允许重复提交的时间窗口，默认为1000毫秒（1秒）。</li></ul><p>使用场景：在Spring MVC的控制器方法上使用此注解，防止用户在短时间内重复提交相同的请求</p><blockquote><p>AvoidRepeatableCommitAspect 切面</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AvoidRepeatableCommitAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于处理带有 <span class="hljs-doctag">@AvoidRepeatableCommit</span> 注解的方法。</span><br><span class="hljs-comment">     * 防止同一个用户在指定时间内重复提交相同的请求。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点，提供对连接点的访问</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行的返回值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(com.moxi.mogublog.admin.annotion.AvoidRepeatableCommit.AvoidRepeatableCommit)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br>        <span class="hljs-comment">// 获取请求者的IP地址</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br><br>        <span class="hljs-comment">// 获取注解标记的方法</span><br>        <span class="hljs-type">MethodSignature</span> <span class="hljs-variable">signature</span> <span class="hljs-operator">=</span> (MethodSignature) point.getSignature();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">method</span> <span class="hljs-operator">=</span> signature.getMethod();<br><br>        <span class="hljs-comment">// 获取类名和方法名</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> method.getDeclaringClass().getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">methodName</span> <span class="hljs-operator">=</span> method.getName();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ipKey</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s#%s&quot;</span>, className, methodName);<br><br>        <span class="hljs-comment">// 生成基于IP和方法的唯一标识</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">hashCode</span> <span class="hljs-operator">=</span> Math.abs(ipKey.hashCode());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;%s:%s_%d&quot;</span>, RedisConf.AVOID_REPEATABLE_COMMIT, ip, hashCode);<br>        log.info(<span class="hljs-string">&quot;ipKey=&#123;&#125;, hashCode=&#123;&#125;, key=&#123;&#125;&quot;</span>, ipKey, hashCode, key);<br><br>        <span class="hljs-type">AvoidRepeatableCommit</span> <span class="hljs-variable">avoidRepeatableCommit</span> <span class="hljs-operator">=</span> method.getAnnotation(AvoidRepeatableCommit.class);<br>        <span class="hljs-type">long</span> <span class="hljs-variable">timeout</span> <span class="hljs-operator">=</span> avoidRepeatableCommit.timeout();<br><br>        <span class="hljs-comment">// 检查Redis中是否已存在该请求的标记</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> redisUtil.get(key);<br>        <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(value)) &#123;<br>            log.info(<span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>            <span class="hljs-keyword">return</span> ResultUtil.result(SysConf.ERROR, <span class="hljs-string">&quot;请勿重复提交表单&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置Redis标记以防止在timeout时间内重复提交</span><br>        redisUtil.setEx(key, StringUtils.getUUID(), timeout, TimeUnit.MILLISECONDS);<br><br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Around(&quot;@annotation(...AvoidRepeatableCommit)&quot;)</code>: 表明这个切面的方法会在所有标记有 <code>@AvoidRepeatableCommit</code> 注解的方法之前执行。</li><li>切面的实现逻辑是：首先检查Redis中是否已经存储了针对该请求的标记。如果存在，表示该请求在指定时间内已经提交过，因此拒绝重复提交。如果不存在，允许执行方法，并在Redis中设置一个标记，以防止在指定时间内的重复提交。</li></ul><p>在这个方法中：</p><ol><li>首先，它获取当前请求的 <code>HttpServletRequest</code> 对象，并从中提取请求者的IP地址。</li><li>然后，它获取了被 <code>@AvoidRepeatableCommit</code> 注解的方法的信息，包括类名和方法名，并生成一个基于这些信息和IP地址的唯一标识。</li><li>接着，它检查Redis缓存中是否已经存在这个请求的标记。如果存在，表示在指定的时间窗口内该请求已经提交过，因此返回一个错误信息，防止重复处理相同的请求。</li><li>如果不存在，则将该请求的标记存储到Redis中，并设置过期时间为注解中指定的 <code>timeout</code>。这样，如果在 <code>timeout</code> 时间内再次收到相同的请求，就会被拦截。</li><li>最后，它执行原来标记了 <code>@AvoidRepeatableCommit</code> 注解的方法。</li></ol><p>通过这种方式，<code>AvoidRepeatableCommitAspect</code> 切面有效地防止了在短时间内对同一方法的重复调用，特别是对于防止表单的重复提交非常有效。</p><h3 id="2、自定义注解-OperationLogger-的使用"><a href="#2、自定义注解-OperationLogger-的使用" class="headerlink" title="2、自定义注解 OperationLogger 的使用"></a>2、自定义注解 <code>OperationLogger</code> 的使用</h3><p><code>@OperationLogger</code> 是一个自定义注解，用于记录操作日志。结合Spring AOP，在方法执行前后添加日志记录的逻辑。</p><h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-keyword">@Target</span>(ElementType.METHOD)<br><span class="hljs-keyword">@Retention</span>(RetentionPolicy.RUNTIME)<br>public <span class="hljs-keyword">@interface</span> OperationLogger &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 业务名称。</span><br><span class="hljs-comment">     */</span><br>    String <span class="hljs-built_in">value</span>() default &quot;&quot;;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 平台</span><br><span class="hljs-comment">     */</span><br>    PlatformEnum <span class="hljs-built_in">platform</span>() default PlatformEnum<span class="hljs-selector-class">.ADMIN</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否将当前日志记录到数据库中。</span><br><span class="hljs-comment">     */</span><br>    boolean <span class="hljs-built_in">save</span>() default true;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(ElementType.METHOD)</code>: 表示该注解只能用于方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>: 表示该注解在运行时有效，可以通过反射获取。</li><li><code>value()</code>: 提供业务名称，默认为空。</li><li><code>platform()</code>: 指定操作发生的平台，默认为 <code>ADMIN</code>。</li><li><code>save()</code>: 指示是否将日志记录保存到数据库，默认为 <code>true</code>。</li></ul><h4 id="LoggerAspect"><a href="#LoggerAspect" class="headerlink" title="LoggerAspect"></a>LoggerAspect</h4><p><code>LoggerAspect</code> 是一个切面类，用于处理带有 <code>@OperationLogger</code> 注解的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">LoggerAspect</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisUtil redisUtil;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ThreadPoolTaskExecutor threadPoolTaskExecutor;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始时间，用于计算方法执行时长</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date startTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定义切点，匹配带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(OperationLogger operationLogger)</span> &#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 环绕通知，用于在方法执行前后添加日志记录逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationLogger 自定义注解</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 方法执行结果</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable 可能抛出的任何异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(operationLogger)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, OperationLogger operationLogger)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        startTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-comment">// 执行原方法</span><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> joinPoint.proceed();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 日志收集</span><br>            handle(joinPoint);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;日志记录出错!&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 日志处理逻辑</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 切点信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">handle</span><span class="hljs-params">(ProceedingJoinPoint point)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br>        <span class="hljs-type">Method</span> <span class="hljs-variable">currentMethod</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.getMethod(point);<br>        <span class="hljs-type">OperationLogger</span> <span class="hljs-variable">annotation</span> <span class="hljs-operator">=</span> currentMethod.getAnnotation(OperationLogger.class);<br><br>        <span class="hljs-comment">// 判断是否需要保存日志</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">save</span> <span class="hljs-operator">=</span> annotation.save();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(point.getArgs(), annotation.value());<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ua</span> <span class="hljs-operator">=</span> RequestUtil.getUa();<br>        log.info(<span class="hljs-string">&quot;&#123;&#125; | &#123;&#125; - &#123;&#125; &#123;&#125; - &#123;&#125;&quot;</span>, bussinessName, IpUtils.getIpAddr(request), RequestUtil.getMethod(), RequestUtil.getRequestUrl(), ua);<br><br>        <span class="hljs-keyword">if</span> (!save) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 获取参数名称和值</span><br>        Map&lt;String, Object&gt; nameAndArgsMap = AopUtils.getFieldsName(point);<br>        <span class="hljs-type">SecurityUser</span> <span class="hljs-variable">securityUser</span> <span class="hljs-operator">=</span> (SecurityUser) SecurityContextHolder.getContext().getAuthentication().getPrincipal();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">paramsJson</span> <span class="hljs-operator">=</span> JSONObject.toJSONString(nameAndArgsMap);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> request.getMethod();<br>        <span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 异步存储日志</span><br>        threadPoolTaskExecutor.execute(<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLogHandle</span>(ip, type, url, securityUser, paramsJson, point.getTarget().getClass().getName(),<br>                        point.getSignature().getName(), bussinessName, startTime, redisUtil));<br>    &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在执行带有 <span class="hljs-doctag">@OperationLogger</span> 注解的方法时抛出异常后执行的通知。</span><br><span class="hljs-comment"> * 用于记录异常信息和相关操作日志。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> joinPoint 连接点，提供对目标方法的访问</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> operationLogger 操作日志的自定义注解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> e 抛出的异常</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> Exception 可能抛出的异常</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@AfterThrowing(value = &quot;pointcut(operationLogger)&quot;, throwing = &quot;e&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAfterThrowing</span><span class="hljs-params">(JoinPoint joinPoint, OperationLogger operationLogger, Throwable e)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><br><span class="hljs-comment">// 创建一个异常日志对象</span><br><span class="hljs-type">ExceptionLog</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExceptionLog</span>();<br><span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> RequestHolder.getRequest();<br><br><span class="hljs-comment">// 获取请求IP地址</span><br><span class="hljs-type">String</span> <span class="hljs-variable">ip</span> <span class="hljs-operator">=</span> IpUtils.getIpAddr(request);<br>exception.setIp(ip);<br><br><span class="hljs-comment">// 解析操作名称</span><br><span class="hljs-type">String</span> <span class="hljs-variable">operationName</span> <span class="hljs-operator">=</span> AspectUtil.INSTANCE.parseParams(joinPoint.getArgs(), operationLogger.value());<br><br><span class="hljs-comment">// 尝试从Redis中获取IP来源信息</span><br><span class="hljs-type">String</span> <span class="hljs-variable">jsonResult</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip);<br><span class="hljs-keyword">if</span> (StringUtils.isEmpty(jsonResult)) &#123;<br><span class="hljs-comment">// 如果Redis中没有IP来源信息，则查询并保存</span><br><span class="hljs-type">String</span> <span class="hljs-variable">addresses</span> <span class="hljs-operator">=</span> IpUtils.getAddresses(SysConf.IP + SysConf.EQUAL_TO + ip, SysConf.UTF_8);<br><span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(addresses)) &#123;<br>exception.setIpSource(addresses);<br>redisUtil.setEx(RedisConf.IP_SOURCE + Constants.SYMBOL_COLON + ip, addresses, <span class="hljs-number">24</span>, TimeUnit.HOURS);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 如果Redis中已有IP来源信息，直接使用</span><br>exception.setIpSource(jsonResult);<br>&#125;<br><br><span class="hljs-comment">// 设置异常日志的其他信息</span><br>exception.setIp(ip);<br>exception.setMethod(joinPoint.getSignature().getName());<br>exception.setExceptionJson(JSON.toJSONString(e,<br>SerializerFeature.DisableCircularReferenceDetect,<br>SerializerFeature.WriteMapNullValue));<br>exception.setExceptionMessage(e.getMessage());<br>exception.setOperation(operationName);<br>exception.setCreateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>exception.setUpdateTime(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br><br><span class="hljs-comment">// 将异常日志保存到数据库</span><br>exception.insert();<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SysLogHandle-类"><a href="#SysLogHandle-类" class="headerlink" title="SysLogHandle 类"></a><code>SysLogHandle</code> 类</h4><p><code>SysLogHandle</code> 是一个Runnable实现，用于异步记录日志信息。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SysLogHandle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">AbstractRequestAwareRunnable</span> &#123;<br><br>    <span class="hljs-comment">// Redis工具类，用于操作Redis</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RedisUtil</span> redisUtil;<br><br>    <span class="hljs-comment">// 请求的参数列表，以JSON字符串格式保存</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> paramsJson;<br><br>    <span class="hljs-comment">// 被调用的类的完整路径</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> classPath;<br><br>    <span class="hljs-comment">// 被调用的方法名称</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> methodName;<br><br>    <span class="hljs-comment">// 方法请求的开始时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">Date</span> startTime;<br><br>    <span class="hljs-comment">// 操作名称，通常从注解中获取</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> operationName;<br><br>    <span class="hljs-comment">// 请求的IP地址</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> ip;<br><br>    <span class="hljs-comment">// 请求类型（如GET、POST）</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>;<br><br>    <span class="hljs-comment">// 请求的URL</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> requestUrl;<br><br>    <span class="hljs-comment">// 当前操作的安全用户信息</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">SecurityUser</span> securityUser;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造函数，初始化日志处理所需的各种参数。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ip           请求的IP地址</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type         请求类型（如GET、POST）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requestUrl   请求的URL</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> securityUser 当前操作的安全用户</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> paramsJson   请求的参数列表（JSON格式）</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> classPath    被调用的类的完整路径</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> methodName   被调用的方法名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> operationName 操作名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startTime    方法请求的开始时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> redisUtil    Redis工具类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">SysLogHandle</span>(<span class="hljs-title class_">String</span> ip, <span class="hljs-title class_">String</span> <span class="hljs-keyword">type</span>, <span class="hljs-title class_">String</span> requestUrl, <span class="hljs-title class_">SecurityUser</span> securityUser,<br>                        <span class="hljs-title class_">String</span> paramsJson, <span class="hljs-title class_">String</span> classPath,<br>                        <span class="hljs-title class_">String</span> methodName, <span class="hljs-title class_">String</span> operationName,<br>                        <span class="hljs-title class_">Date</span> startTime, <span class="hljs-title class_">RedisUtil</span> redisUtil) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">ip</span> = ip;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">type</span> = <span class="hljs-keyword">type</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">requestUrl</span> = requestUrl;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">securityUser</span> = securityUser;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">paramsJson</span> = paramsJson;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">classPath</span> = classPath;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">methodName</span> = methodName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">operationName</span> = operationName;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">startTime</span> = startTime;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">redisUtil</span> = redisUtil;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行日志记录的逻辑。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onRun</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-title class_">SysLog</span> sysLog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SysLog</span>();<br><br>        <span class="hljs-comment">// 从Redis中获取IP来源信息</span><br>        <span class="hljs-title class_">String</span> jsonResult = redisUtil.<span class="hljs-title function_">get</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isEmpty</span>(jsonResult)) &#123;<br>            <span class="hljs-title class_">String</span> addresses = <span class="hljs-title class_">IpUtils</span>.<span class="hljs-title function_">getAddresses</span>(<span class="hljs-title class_">SysConf</span>.<span class="hljs-property">IP</span> + <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">EQUAL_TO</span> + ip, <span class="hljs-title class_">SysConf</span>.<span class="hljs-property">UTF_8</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-title class_">StringUtils</span>.<span class="hljs-title function_">isNotEmpty</span>(addresses)) &#123;<br>                sysLog.<span class="hljs-title function_">setIpSource</span>(addresses);<br>                redisUtil.<span class="hljs-title function_">setEx</span>(<span class="hljs-title class_">RedisConf</span>.<span class="hljs-property">IP_SOURCE</span> + <span class="hljs-title class_">Constants</span>.<span class="hljs-property">SYMBOL_COLON</span> + ip, addresses, <span class="hljs-number">24</span>, <span class="hljs-title class_">TimeUnit</span>.<span class="hljs-property">HOURS</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sysLog.<span class="hljs-title function_">setIpSource</span>(jsonResult);<br>        &#125;<br><br>        <span class="hljs-comment">// 设置日志的其他属性</span><br>        sysLog.<span class="hljs-title function_">setIp</span>(ip);<br>        sysLog.<span class="hljs-title function_">setClassPath</span>(classPath);<br>        sysLog.<span class="hljs-title function_">setMethod</span>(methodName);<br>        sysLog.<span class="hljs-title function_">setType</span>(<span class="hljs-keyword">type</span>);<br>        sysLog.<span class="hljs-title function_">setUrl</span>(requestUrl);<br>        sysLog.<span class="hljs-title function_">setOperation</span>(operationName);<br>        sysLog.<span class="hljs-title function_">setCreateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUpdateTime</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>        sysLog.<span class="hljs-title function_">setUserName</span>(securityUser.<span class="hljs-title function_">getUsername</span>());<br>        sysLog.<span class="hljs-title function_">setAdminUid</span>(securityUser.<span class="hljs-title function_">getUid</span>());<br>        sysLog.<span class="hljs-title function_">setParams</span>(paramsJson);<br><br>        <span class="hljs-comment">// 计算并设置请求耗时</span><br>        <span class="hljs-title class_">Date</span> endTime = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>();<br>        <span class="hljs-title class_">Long</span> spendTime = <span class="hljs-title class_">DateUtil</span>.<span class="hljs-title function_">between</span>(startTime, endTime, <span class="hljs-title class_">DateUnit</span>.<span class="hljs-property">MS</span>);<br>        sysLog.<span class="hljs-title function_">setSpendTime</span>(spendTime);<br><br>        <span class="hljs-comment">// 将日志信息保存到数据库</span><br>        sysLog.<span class="hljs-title function_">insert</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>SysLogHandle</code> 继承自 <code>AbstractRequestAwareRunnable</code>，它是一个Runnable实现，用于异步执行日志记录任务。</li><li>构造函数接收所有必要的参数，包括请求信息、用户信息和方法信息。</li><li><code>onRun</code> 方法是日志记录逻辑的实现。它首先从Redis中获取IP来源信息，然后创建一个 <code>SysLog</code> 对象并设置各种属性，包括请求信息、用户信息、操作名称、参数等。</li><li>最后，计算请求耗时并将日志信息保存到数据库。</li></ul><p>这个类的主要作用是异步记录每次请求的详细日志，包括请求参数、执行时间等，</p><p>通过异步处理，它还有助于减少日志记录对应用性能的影响。</p><h4 id="异步日志记录的功能"><a href="#异步日志记录的功能" class="headerlink" title="异步日志记录的功能"></a>异步日志记录的功能</h4><p>在切面的时候，handle 方法保存日志的操作是异步进行的，这里单独拿出来分析一下。</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-comment">// 异步存储日志</span><br><span class="hljs-selector-tag">threadPoolTaskExecutor</span><span class="hljs-selector-class">.execute</span>(<br>        new <span class="hljs-built_in">SysLogHandle</span>(ip, type, url, securityUser,<br>                        paramsJson, point.<span class="hljs-built_in">getTarget</span>().<span class="hljs-built_in">getClass</span>().<span class="hljs-built_in">getName</span>(),<br>                        point.<span class="hljs-built_in">getSignature</span>().<span class="hljs-built_in">getName</span>(), bussinessName,<br>                        startTime, redisUtil));<br><br></code></pre></td></tr></table></figure><ol><li><strong>使用线程池</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这部分代码利用Spring框架中的 <code>ThreadPoolTaskExecutor</code> 来执行一个任务。<code>ThreadPoolTaskExecutor</code> 是一个基于线程池的TaskExecutor实现，允许异步执行任务。</li></ul></li><li><strong>创建日志处理任务</strong>:<ul><li><code>new SysLogHandle(...)</code>: 这里创建了一个 <code>SysLogHandle</code> 对象，它是一个实现了 <code>Runnable</code> 接口的类，用于处理日志记录的具体逻辑。</li></ul></li><li><strong>传递参数给日志处理任务</strong>:<ul><li>向 <code>SysLogHandle</code> 构造器传递了多个参数，包括请求的IP地址 (<code>ip</code>)、请求类型 (<code>type</code>)、请求URL (<code>url</code>)、当前安全用户 (<code>securityUser</code>)、请求参数的JSON字符串 (<code>paramsJson</code>)、被调用的类名和方法名（通过 <code>point.getTarget().getClass().getName()</code> 和 <code>point.getSignature().getName()</code> 获取）、业务名称 (<code>bussinessName</code>)、方法开始执行的时间 (<code>startTime</code>)，以及Redis工具类 (<code>redisUtil</code>)。</li></ul></li><li><strong>执行任务</strong>:<ul><li><code>threadPoolTaskExecutor.execute(...)</code>: 这个方法将 <code>SysLogHandle</code> 的实例提交到线程池进行异步执行，不会阻塞当前线程的执行。这意味着原方法（被 <code>@OperationLogger</code> 注解的方法）的执行和日志的记录是并发进行的。</li></ul></li></ol><blockquote><p>实际应用</p></blockquote><p>在实际应用中，这种异步日志记录方法非常有用，尤其是在高流量的Web应用中。它允许应用快速响应用户请求，同时将耗时的日志记录操作放在后台线程中执行，从而不会显著影响用户体验和应用性能。</p><p>通过将日志记录逻辑从主执行路径中分离出来，可以减少对主业务逻辑的干扰，同时确保了重要的操作日志被正确记录和存储。</p><h4 id="工具类AspectUtil"><a href="#工具类AspectUtil" class="headerlink" title="工具类AspectUtil"></a>工具类AspectUtil</h4><p>对于上面使用到的工具类 AspectUtil 进行记录说明</p><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">public</span> <span class="hljs-variable">enum</span> <span class="hljs-title class_">AspectUtil</span> &#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例实例，枚举类型保证全局唯一。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">INSTANCE</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取以类路径为前缀的键。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> prefix 前缀字符串</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 以类路径为前缀的键字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getKey</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>, <span class="hljs-params">String</span> <span class="hljs-params">prefix</span>) &#123;<br>        <span class="hljs-title class_">String</span> <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-operator">!</span><span class="hljs-title class_">StringUtils</span>.<span class="hljs-property">isEmpty</span>(<span class="hljs-variable">prefix</span>)) &#123;<br>            <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-variable">prefix</span>;<br>        &#125;<br>        <span class="hljs-variable">keyPrefix</span> <span class="hljs-operator">+</span><span class="hljs-operator">=</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-variable">point</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">keyPrefix</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法所在的类的名称，替换所有的点为下划线。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 处理后的类名字符串</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getClassName</span>(<span class="hljs-params">JoinPoint</span> <span class="hljs-params">point</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>().<span class="hljs-property">getClass</span>().<span class="hljs-property">getName</span>().<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>.&quot;</span>, <span class="hljs-string">&quot;_&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取当前切面执行的方法的Method对象。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point 当前切面执行的方法的连接点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 当前执行方法的Method对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> NoSuchMethodException 如果无法找到相应的方法</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">Method</span> <span class="hljs-title function_">getMethod</span>(<span class="hljs-title class_">JoinPoint</span> <span class="hljs-variable">point</span>) <span class="hljs-variable">throws</span> <span class="hljs-title class_">NoSuchMethodException</span> &#123;<br>        <span class="hljs-title class_">Signature</span> <span class="hljs-variable">sig</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getSignature</span>();<br>        <span class="hljs-title class_">MethodSignature</span> <span class="hljs-variable">msig</span> <span class="hljs-operator">=</span> (<span class="hljs-title class_">MethodSignature</span>) <span class="hljs-variable">sig</span>;<br>        <span class="hljs-title class_">Object</span> <span class="hljs-variable">target</span> <span class="hljs-operator">=</span> <span class="hljs-variable">point</span>.<span class="hljs-property">getTarget</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">target</span>.<span class="hljs-property">getClass</span>().<span class="hljs-property">getMethod</span>(<span class="hljs-variable">msig</span>.<span class="hljs-property">getName</span>(), <span class="hljs-variable">msig</span>.<span class="hljs-property">getParameterTypes</span>());<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 解析业务名称中的占位符，并用方法参数替换。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> params 方法参数数组</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> bussinessName 带占位符的业务名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 解析后的业务名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">parseParams</span>(<span class="hljs-params">Object</span>[] <span class="hljs-params">params</span>, <span class="hljs-params">String</span> <span class="hljs-params">bussinessName</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#123;&quot;</span>) <span class="hljs-operator">&amp;&amp;</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">contains</span>(<span class="hljs-string">&quot;&#125;&quot;</span>)) &#123;<br>            <span class="hljs-title class_">List</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">String</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> <span class="hljs-title class_">RegexUtils</span>.<span class="hljs-property">match</span>(<span class="hljs-variable">bussinessName</span>, <span class="hljs-string">&quot;(?&lt;=<span class="hljs-char escape_">\\</span>&#123;)(<span class="hljs-char escape_">\\</span>d+)&quot;</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-title class_">String</span> <span class="hljs-variable">s</span> : <span class="hljs-variable">result</span>) &#123;<br>                int index <span class="hljs-operator">=</span> <span class="hljs-title class_">Integer</span>.<span class="hljs-property">parseInt</span>(<span class="hljs-variable">s</span>);<br>                <span class="hljs-variable">bussinessName</span> <span class="hljs-operator">=</span> <span class="hljs-variable">bussinessName</span>.<span class="hljs-property">replaceAll</span>(<span class="hljs-string">&quot;<span class="hljs-char escape_">\\</span>&#123;&quot;</span> <span class="hljs-operator">+</span> index <span class="hljs-operator">+</span> <span class="hljs-string">&quot;&#125;&quot;</span>, <span class="hljs-variable">JSON</span>.<span class="hljs-property">toJSONString</span>(<span class="hljs-variable">params</span>[index <span class="hljs-operator">-</span> <span class="hljs-number">1</span>]));<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable">bussinessName</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>AspectUtil</code> 是一个枚举类型，提供了一个全局唯一的实例 <code>INSTANCE</code>。</li><li><code>getKey</code> 方法根据连接点 (<code>JoinPoint</code>) 和给定的前缀生成一个字符串键。该键通常用于识别特定的方法或类。</li><li><code>getClassName</code> 方法获取连接点指向的目标类的名称，并将其中的点替换为下划线。这在需要基于类名生成唯一标识时很有用。</li><li><code>getMethod</code> 方法返回连接点指向的具体方法的 <code>Method</code> 对象，用于进一步的反射操作。</li><li><code>parseParams</code> 方法解析业务名称字符串中的占位符，并用方法的实际参数替换这些占位符。这对于生成动态的日志消息或错误消息非常有用，特别是当消息内容依赖于方法的输入参数时。</li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day03</title>
    <link href="/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/"/>
    <url>/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/</url>
    
    <content type="html"><![CDATA[<p>这里讲述蘑菇博客里面一些写法的使用说明</p><p>下面的章节都是为了解释下面这段代码的使用</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1、自定义注解-AuthorityVerify-的使用"><a href="#1、自定义注解-AuthorityVerify-的使用" class="headerlink" title="1、自定义注解 AuthorityVerify 的使用"></a>1、自定义注解 AuthorityVerify 的使用</h3><h4 id="注解定义"><a href="#注解定义" class="headerlink" title="注解定义"></a>注解定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AuthorityVerify &#123;<br>    String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</code>：这表明这个注解可以应用于方法和类。如果放在类上，通常意味着类中的所有方法都应用这个注解；如果放在方法上，则只针对该方法。</li><li><code>@Retention(RetentionPolicy.RUNTIME)</code>：这指定了注解的保留策略是在运行时。这意味着这个注解不仅被保存在class文件中，还可以通过反射在运行时被读取。</li><li><code>String value() default &quot;&quot;</code>：这是一个可选的注解元素，允许在使用注解时设置一个字符串值。它的默认值是空字符串。</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>这个注解可以应用于类或方法来实现权限验证。例如：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span><br>public class SomeController &#123;<br><br>    <span class="hljs-variable">@AuthorityVerify</span>(<span class="hljs-string">&quot;admin&quot;</span>)<br>    <span class="hljs-variable">@GetMapping</span>(<span class="hljs-string">&quot;/someSecureMethod&quot;</span>)<br>    public String <span class="hljs-built_in">someSecureMethod</span>() &#123;<br>        <span class="hljs-comment">// 方法实现</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>@AuthorityVerify</code> 应用于一个控制器方法。<br>你可以将其放在任何Spring Controller的方法上，表示该方法需要进行权限验证。<br>注解中的 <code>&quot;admin&quot;</code> 字符串可以用来指定需要哪种权限才能访问该方法。</p><p>要让这个注解真正起作用，还需要编写额外的代码来处理这个注解。通常是通过Spring的AOP（面向切面编程）功能来实现的，可以创建一个切面来拦截带有 <code>@AuthorityVerify</code> 注解的方法调用，然后执行权限验证逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityAspect</span> &#123;<br><br>    <span class="hljs-meta">@Around(&quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">around</span><span class="hljs-params">(ProceedingJoinPoint point, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br>        <span class="hljs-comment">// 获取注解中的值</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> authorityVerify.value();<br><br>        <span class="hljs-comment">// 这里实现权限验证逻辑</span><br>        <span class="hljs-comment">// ...</span><br><br>        <span class="hljs-comment">// 继续执行原方法</span><br>        <span class="hljs-keyword">return</span> point.proceed();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里蘑菇博客项目也是这样使用的。</p><p>上面的示例是通过注解的值，然后在环绕通知里面的方法，根据获取值来进行下一步操作。</p><p>蘑菇博客的这个方法有所不同的是，他是通过判断添加该注解的方法，获取访问请求路径，获取用户，判定该用户下是否有该访问路径的权限。</p><p>getList 方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@AuthorityVerify</span>  <br><span class="hljs-variable">@ApiOperation</span>(value = <span class="hljs-string">&quot;获取博客列表&quot;</span>, notes = <span class="hljs-string">&quot;获取博客列表&quot;</span>, response = String.class)  <br><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="AuthorityVerifyAspect"><a href="#AuthorityVerifyAspect" class="headerlink" title="AuthorityVerifyAspect"></a><code>AuthorityVerifyAspect</code></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 权限校验 切面实现</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 陌溪</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span>: 2020-03-06-19:05</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AuthorityVerifyAspect</span> &#123;<br><br>    <span class="hljs-comment">// 自动注入所需的服务和工具类</span><br>    <span class="hljs-meta">@Autowired</span><br>    CategoryMenuService categoryMenuService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RoleService roleService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    AdminService adminService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    RedisUtil redisUtil;<br><br>    <span class="hljs-comment">// 定义切点，指向使用AuthorityVerify注解的方法</span><br>    <span class="hljs-meta">@Pointcut(value = &quot;@annotation(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pointcut</span><span class="hljs-params">(AuthorityVerify authorityVerify)</span> &#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">// 环绕通知，用于在方法执行前后添加额外的处理</span><br>    <span class="hljs-meta">@Around(value = &quot;pointcut(authorityVerify)&quot;)</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">doAround</span><span class="hljs-params">(ProceedingJoinPoint joinPoint, AuthorityVerify authorityVerify)</span> <span class="hljs-keyword">throws</span> Throwable &#123;<br><br>        <span class="hljs-comment">// 获取当前HTTP请求的属性</span><br>        <span class="hljs-type">ServletRequestAttributes</span> <span class="hljs-variable">attribute</span> <span class="hljs-operator">=</span> (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();<br>        <span class="hljs-type">HttpServletRequest</span> <span class="hljs-variable">request</span> <span class="hljs-operator">=</span> attribute.getRequest();<br><br>        <span class="hljs-comment">// 获取请求路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> request.getRequestURI();<br><br>        <span class="hljs-comment">// 解析出请求者的ID</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">adminUid</span> <span class="hljs-operator">=</span> request.getAttribute(SysConf.ADMIN_UID).toString();<br><br>        <span class="hljs-comment">// 尝试从Redis获取管理员能够访问的路径</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">visitUrlStr</span> <span class="hljs-operator">=</span> redisUtil.get(RedisConf.ADMIN_VISIT_MENU + RedisConf.SEGMENTATION + adminUid);<br>        LinkedTreeMap&lt;String, String&gt; visitMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedTreeMap</span>&lt;&gt;();<br><br>        <span class="hljs-comment">// 判断Redis中是否有数据</span><br>        <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(visitUrlStr)) &#123;<br>            <span class="hljs-comment">// 从Redis中获取</span><br>            visitMap = (LinkedTreeMap&lt;String, String&gt;) JsonUtils.jsonToMap(visitUrlStr, String.class);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Redis中没有，则查询数据库</span><br>            <span class="hljs-type">Admin</span> <span class="hljs-variable">admin</span> <span class="hljs-operator">=</span> adminService.getById(adminUid);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">roleUid</span> <span class="hljs-operator">=</span> admin.getRoleUid();<br>            <span class="hljs-type">Role</span> <span class="hljs-variable">role</span> <span class="hljs-operator">=</span> roleService.getById(roleUid);<br><br>            <span class="hljs-type">String</span> <span class="hljs-variable">categoryMenuUids</span> <span class="hljs-operator">=</span> role.getCategoryMenuUids();<br>            String[] uids = categoryMenuUids.replace(<span class="hljs-string">&quot;[&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;]&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).replace(<span class="hljs-string">&quot;\&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>);<br><br>            List&lt;String&gt; categoryMenuUids = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Arrays.asList(uids));<br><br>            <span class="hljs-comment">// 只查询访问的按钮</span><br>            QueryWrapper&lt;CategoryMenu&gt; queryWrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;&gt;();<br>            queryWrapper.in(SQLConf.UID, categoryMenuUids);<br>            queryWrapper.eq(SQLConf.MENU_TYPE, EMenuType.BUTTON);<br>            queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br>            List&lt;CategoryMenu&gt; buttonList = categoryMenuService.list(queryWrapper);<br><br>            <span class="hljs-keyword">for</span> (CategoryMenu item : buttonList) &#123;<br>                <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(item.getUrl())) &#123;<br>                    visitMap.put(item.getUrl(), item.getUrl());<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将访问URL存储到Redis中</span><br>            redisUtil.setEx(RedisConf.ADMIN_VISIT_MENU + SysConf.REDIS_SEGMENTATION + adminUid, JsonUtils.objectToJson(visitMap), <span class="hljs-number">1</span>, TimeUnit.HOURS);<br>        &#125;<br><br>        <span class="hljs-comment">// 判断该角色是否能够访问该接口</span><br>        <span class="hljs-keyword">if</span> (visitMap.get(url) != <span class="hljs-literal">null</span>) &#123;<br>            log.info(<span class="hljs-string">&quot;用户拥有操作权限，访问的路径: &#123;&#125;，拥有的权限接口：&#123;&#125;&quot;</span>, url, visitMap.get(url));<br>            <span class="hljs-comment">// 用户有权限，继续执行业务</span><br>            <span class="hljs-keyword">return</span> joinPoint.proceed();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.info(<span class="hljs-string">&quot;用户不具有操作权限，访问的路径: &#123;&#125;&quot;</span>, url);<br>            <span class="hljs-comment">// 用户无权限，返回无权限的响应</span><br>            <span class="hljs-keyword">return</span> ResultUtil.result(ECode.NO_OPERATION_AUTHORITY, MessageConf.RESTAPI_NO_PRIVILEGE);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、-Validated-注解的使用"><a href="#2、-Validated-注解的使用" class="headerlink" title="2、@Validated 注解的使用"></a>2、@Validated 注解的使用</h3><h4 id="解释如何使用的"><a href="#解释如何使用的" class="headerlink" title="解释如何使用的"></a>解释如何使用的</h4><p>Spring框架中，<code>@Validated</code> 注解是用来启用方法参数级别的验证的。这个注解告诉Spring需要对被注解的参数执行验证。</p><blockquote><p>如何使用 <code>@Validated</code></p></blockquote><p>一般会结合 验证组、<code>@RequestBody</code>、<code>BindingResult</code> 结合使用</p><ol><li><strong>指定验证组</strong>:<ul><li><code>@Validated</code> 可以指定一个或多个验证组，例如 <code>@Validated(&#123;GetList.class&#125;)</code>。这意味着只有在 <code>GetList</code> 组中定义的验证规则会被应用于 <code>blogVO</code> 对象。如果没有指定组，将应用默认的验证规则。</li></ul></li><li><strong>与 <code>@RequestBody</code> 结合</strong>:<ul><li>在REST控制器中，<code>@Validated</code> 通常与 <code>@RequestBody</code> 结合使用，用于验证JSON请求体映射到的Java对象。</li></ul></li><li><strong>处理验证结果</strong>:<ul><li>通常与 <code>BindingResult</code> 结合使用，后者用于捕获验证过程中发现的错误。如果存在错误，可以通过检查 <code>BindingResult</code> 对象来响应相应的错误信息。</li></ul></li></ol><h4 id="基本使用用法"><a href="#基本使用用法" class="headerlink" title="基本使用用法"></a>基本使用用法</h4><blockquote><p>使用示例</p></blockquote><p>展示如何在Spring Boot应用中对一个REST API端点的请求体进行验证。</p><p><strong>场景描述</strong></p><p>假设我们正在编写一个博客应用程序，需要一个API来创建新的博客文章。</p><p>我们希望确保传入的数据满足某些条件，比如标题不为空，内容长度不低于一定字符数等。</p><p><strong>实体类定义</strong></p><p>首先，我们定义一个 <code>BlogPost</code> 类，它包含文章的标题和内容，这些字段都有特定的验证规则：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">NotBlank</span>;<br><span class="hljs-keyword">import</span> javax.<span class="hljs-property">validation</span>.<span class="hljs-property">constraints</span>.<span class="hljs-property">Size</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogPost</span> &#123;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Title is required&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-meta">@NotBlank</span>(message = <span class="hljs-string">&quot;Content is required&quot;</span>)<br>    <span class="hljs-meta">@Size</span>(min = <span class="hljs-number">100</span>, message = <span class="hljs-string">&quot;Content must be at least 100 characters long&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> content;<br><br>    <span class="hljs-comment">// Getters and setters</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getTitle</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTitle</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> title</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">title</span> = title;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getContent</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setContent</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> content</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">content</span> = content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>控制器方法</strong></p><p>接下来，我们创建一个REST控制器方法来接收博客文章的数据：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.validation.BindingResult;<br><span class="hljs-keyword">import</span> org.springframework.validation.<span class="hljs-keyword">annotation</span>.Validated;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.PostMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RequestBody;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">BlogController</span> &#123;<br><br>    <span class="hljs-meta">@PostMapping(<span class="hljs-string">&quot;/createBlog&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String createBlog(<span class="hljs-meta">@Validated</span> <span class="hljs-meta">@RequestBody</span> BlogPost blogPost, BindingResult result) &#123;<br>        <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>            <span class="hljs-comment">// 处理验证错误，例如返回错误信息</span><br>            <span class="hljs-keyword">return</span> result.getFieldError().getDefaultMessage();<br>        &#125;<br>        <span class="hljs-comment">// 如果数据有效，执行业务逻辑，例如保存博客文章</span><br>        <span class="hljs-comment">// saveBlogPost(blogPost);</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Blog post created successfully&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>解释一下上面的用法</p><ul><li><code>BlogPost</code> 类中的字段 <code>title</code> 和 <code>content</code> 使用了JSR 380（Hibernate Validator）注解来声明验证规则。<code>@NotBlank</code> 确保字段不为空，<code>@Size</code> 指定了 <code>content</code> 字段的最小长度。</li><li>在 <code>BlogController</code> 的 <code>createBlog</code> 方法中，<code>@Validated</code> 注解用于启用对 <code>@RequestBody</code> 注解的 <code>BlogPost</code> 对象的自动验证。</li><li><code>BindingResult</code> 参数用于捕获任何验证错误。如果存在错误，可以从 <code>BindingResult</code> 中获取错误信息并适当响应。</li></ul><p>在接口调用的时候，当客户端发送POST请求到 <code>/createBlog</code> 端点，并提供JSON格式的博客文章数据时，Spring将自动验证该数据是否符合 <code>BlogPost</code> 类中定义的规则。如果数据不符合规则，将返回相应的错误信息。</p><h4 id="如果需要使用验证组，是如何使用的"><a href="#如果需要使用验证组，是如何使用的" class="headerlink" title="如果需要使用验证组，是如何使用的"></a>如果需要使用验证组，是如何使用的</h4><blockquote><p>使用示例2</p></blockquote><p>这里主要说明一下验证组的使用</p><p>在Spring框架中，当 <code>@Validated</code> 注解被应用于一个方法参数，并且指定了一个或多个组类，进行验证时只会考虑那些属于指定组的验证约束。</p><p><strong>验证组的作用</strong></p><ol><li><strong>分组验证</strong>:<ul><li>验证组允许你将一个实体类（如 <code>BlogVO</code>）的验证规则分成不同的组。这样，你可以在不同的场景下应用不同的验证规则集合。</li><li>例如，一个实体在创建时可能需要一组验证规则，在更新时需要另一组规则。</li></ul></li><li><strong>定义验证组</strong>:<ul><li>验证组通常是空接口，用于标识验证规则属于哪个组。</li><li>例如，<code>public interface GetList &#123;&#125;</code> 可以作为一个验证组的声明。</li></ul></li></ol><p><strong>代码示例</strong></p><p>实体类中的验证规则</p><p>在 <code>BlogVO</code> 实体类中，验证注解可能像这样使用：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs ruby"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Blog</span>VO &#123;<br><br>    <span class="hljs-variable">@NotBlank</span>(groups = <span class="hljs-title class_">GetList</span>.<span class="hljs-keyword">class</span>, message = <span class="hljs-string">&quot;Title cannot be empty when getting list&quot;</span>)<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> title;<br><br>    <span class="hljs-regexp">//</span> 其他字段和getter/setter<br>&#125;<br></code></pre></td></tr></table></figure><p>这个例子中：</p><ul><li><code>@NotBlank</code> 注解只有在执行针对 <code>GetList</code> 组的验证时才会生效。</li><li>如果在一个方法中使用了 <code>@Validated(&#123;GetList.class&#125;)</code> 对 <code>BlogVO</code> 实例进行验证，那么只有那些指定为 <code>GetList</code> 组的验证规则（如上面的 <code>title</code> 字段）会被考虑。</li><li>这种方式提供了灵活性，允许在不同的操作（如获取列表、创建、更新等）中重复使用同一个实体类，同时应用不同的验证规则。</li></ul><p>控制器方法</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@PostMapping</span>(<span class="hljs-string">&quot;/getList&quot;</span>)  <br>public String <span class="hljs-built_in">getList</span>(<span class="hljs-variable">@Validated</span>(&#123;GetList.class&#125;) <span class="hljs-variable">@RequestBody</span> BlogVO blogVO, BindingResult result) &#123;  <br>  <br>    <span class="hljs-selector-tag">ThrowableUtils</span><span class="hljs-selector-class">.checkParamArgument</span>(result);  <br>    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">ResultUtil</span><span class="hljs-selector-class">.successWithData</span>(blogService.<span class="hljs-built_in">getPageList</span>(blogVO));  <br>&#125;<br></code></pre></td></tr></table></figure><p>GetList 接口定义</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * GetList Group  用于getList方法查询时  </span><br><span class="hljs-comment"> *  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span>: 陌溪  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span>: 2019年12月4日22:49:01  </span><br><span class="hljs-comment"> */</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">GetList</span> &#123;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Validated(&#123;GetList.class&#125;)</code> 表明只有标记为 <code>GetList</code> 组的验证约束会被应用于 <code>BlogVO</code> 对象。</li><li>这意味着 <code>BlogVO</code> 类中的某些验证注解可能被指定为仅在 <code>GetList</code> 组上下文中有效。</li></ul><hr><h3 id="3、抛出异常工具类ThrowableUtils"><a href="#3、抛出异常工具类ThrowableUtils" class="headerlink" title="3、抛出异常工具类ThrowableUtils"></a>3、抛出异常工具类ThrowableUtils</h3><p>这个类主要用法是处理验证结果，当传入接口数据时，映射对象  BlogVO 里面的参数校验，对应的验证结果  result ，对验证结果进行处理</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 抛出异常工具类</span><br><span class="hljs-comment"> * 用于处理和格式化由Spring Validation框架抛出的验证错误。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * @author 陌溪</span><br><span class="hljs-comment"> * @date 2019年12月4日22:47:18</span><br><span class="hljs-comment"> */</span><br>public <span class="hljs-keyword">class</span> ThrowableUtils &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验参数正确性，如果发现验证错误，则拼装并抛出自定义异常。</span><br><span class="hljs-comment">     * 这个方法主要用于处理由Spring Validation框架产生的验证错误。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @param result BindingResult对象，包含验证过程中产生的错误信息。</span><br><span class="hljs-comment">     */</span><br>    public static void checkParamArgument(BindingResult result) &#123;<br>        <span class="hljs-comment">// 检查是否存在验证错误</span><br>        <span class="hljs-keyword">if</span> (result != null &amp;&amp; result.hasErrors()) &#123;<br>            StringBuilder sb = new StringBuilder();<br><br>            <span class="hljs-comment">// 获取所有字段级别的错误</span><br>            <span class="hljs-keyword">List</span>&lt;FieldError&gt; errors = result.getFieldErrors();<br>            <span class="hljs-keyword">if</span> (CollectionUtil.isNotEmpty(errors)) &#123;<br>                <span class="hljs-comment">// 只处理第一个错误</span><br>                FieldError <span class="hljs-keyword">error</span> = errors.<span class="hljs-built_in">get</span>(0);<br>                <br>                <span class="hljs-comment">// 获取被拒绝的值（即不合法的输入值）</span><br>                String rejectedValue = Objects.<span class="hljs-keyword">toString</span>(<span class="hljs-keyword">error</span>.getRejectedValue(), <span class="hljs-string">&quot;&quot;</span>);<br>                <span class="hljs-comment">// 获取默认错误信息</span><br>                String defMsg = <span class="hljs-keyword">error</span>.getDefaultMessage();<br><br>                <span class="hljs-comment">// 排除在类级别上的注解提示</span><br>                <span class="hljs-keyword">if</span> (rejectedValue.contains(Constants.DELIMITER_TO)) &#123;<br>                    <span class="hljs-comment">// 对于类级别的错误，直接使用错误信息</span><br>                    sb.<span class="hljs-keyword">append</span>(defMsg);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 对于字段级别的错误，拼接字段名和错误信息</span><br>                    <span class="hljs-keyword">if</span> (Constants.DELIMITER_COLON.contains(defMsg)) &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        sb.<span class="hljs-keyword">append</span>(<span class="hljs-keyword">error</span>.getField()).<span class="hljs-keyword">append</span>(<span class="hljs-string">&quot; &quot;</span>).<span class="hljs-keyword">append</span>(defMsg);<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-comment">// 处理非字段级别的错误（如类级别的错误）</span><br>                String msg = result.getAllErrors().<span class="hljs-built_in">get</span>(0).getDefaultMessage();<br>                sb.<span class="hljs-keyword">append</span>(msg);<br>            &#125;<br>            <br>            <span class="hljs-comment">// 抛出自定义异常，包含处理过的错误信息</span><br>            throw new ApiInvalidParamException(sb.<span class="hljs-keyword">toString</span>());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4、自定义异常-ApiInvalidParamException-的使用"><a href="#4、自定义异常-ApiInvalidParamException-的使用" class="headerlink" title="4、自定义异常 ApiInvalidParamException 的使用"></a>4、自定义异常 ApiInvalidParamException 的使用</h3><p><code>ApiInvalidParamException</code> 类是一个自定义异常类，继承自 <code>RuntimeException</code>。其主要作用是封装和表示与API参数相关的错误或异常情况。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自定义的运行时异常类，用于表示API操作中的参数无效或不符合预期的情况。</span><br><span class="hljs-comment"> * 这个类主要用于在API层抛出参数相关的异常，并能够被全局异常处理器捕获和处理，</span><br><span class="hljs-comment"> * 以便返回统一格式的错误响应给客户端。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApiInvalidParamException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1</span>L;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无参构造函数。</span><br><span class="hljs-comment">     * 创建一个没有详细错误消息的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息和原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述和原因的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message, cause);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带消息的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含具体错误描述的ApiInvalidParamException异常实例。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 描述异常的详细信息。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 带原因的构造函数。</span><br><span class="hljs-comment">     * 创建一个包含原因的ApiInvalidParamException异常实例，但不提供详细信息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> cause 引发此异常的原因。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ApiInvalidParamException</span><span class="hljs-params">(Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>代码解释</p><p>类中定义了几个构造函数，允许在创建异常实例时提供不同类型的信息：</p><ol><li><p><strong>无参构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException()</code>: 创建一个没有详细错误消息的异常实例。</li></ul></li><li><p><strong>带消息的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message)</code>: 创建一个带有具体错误描述的异常实例。</li></ul></li><li><p><strong>带消息和原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(String message, Throwable cause)</code>: 创建一个异常实例，同时提供错误描述和一个原始异常（原始异常表示这个新异常的原因）。</li></ul></li><li><p><strong>带原因的构造函数</strong>:</p><ul><li><code>public ApiInvalidParamException(Throwable cause)</code>: 创建一个异常实例，只包含一个原始异常。</li></ul></li></ol><blockquote><p>自定义异常类的使用</p></blockquote><p><strong>使用场景</strong></p><p>在API的各个层面（如控制器、服务或数据访问层）中，当遇到不符合要求的参数或其他与参数相关的问题时，可以抛出 <code>ApiInvalidParamException</code>。</p><p>然后，全局异常处理器可以捕获这些异常，并将它们转换为统一的、用户友好的响应格式，如JSON，包含错误代码和错误消息。</p><p><strong>作用和用途</strong></p><ol><li><strong>自定义异常处理</strong>:<ul><li>这个类用于表示在API中遇到的特定类型的参数错误。通过创建这样的自定义异常，可以更清晰地表达代码中可能出现的特定错误情况。</li></ul></li><li><strong>全局异常拦截</strong>:<ul><li>在一个基于Spring Boot的REST API项目中，通常会有一个全局异常处理器（如使用 <code>@ControllerAdvice</code> 注解的类）。</li><li><code>ApiInvalidParamException</code> 可以被这样的全局处理器捕获，并转换为统一的响应格式发送给API的调用者。这有助于维持API的响应格式的一致性。</li></ul></li><li><strong>错误消息定制</strong>:<ul><li>这个异常类允许在抛出异常时附带一个自定义的错误消息，这对于提供更详细的错误信息（例如，哪个参数错误以及为什么错误）非常有用。</li></ul></li></ol><h3 id="5、全局异常处理"><a href="#5、全局异常处理" class="headerlink" title="5、全局异常处理"></a>5、全局异常处理</h3><p><code>GlobalExceptionConfig</code> 类和 <code>HandlerExceptionResolver</code> 类是Spring框架中用于全局异常处理的配置和实现</p><p>针对蘑菇博客相关实现，进行说明</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@Configuration  </span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">GlobalExceptionConfig</span> </span>&#123;  <br>  <br>    <span class="hljs-meta">@Bean  </span><br>    <span class="hljs-keyword">public</span> HandlerExceptionResolver getHandlerExceptionResolver() &#123;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">HandlerExceptionResolver</span>();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Configuration</code>: 表示这个类包含Spring容器的bean定义。</li><li><code>@Bean</code>: 表示该方法将返回一个对象，该对象应该被注册为Spring应用程序上下文中的bean。</li><li><code>getHandlerExceptionResolver()</code>: 这个方法创建并返回 <code>HandlerExceptionResolver</code> 的一个实例，用于全局异常处理</li></ul><blockquote><p>HandlerExceptionResolver 类解释</p></blockquote><p><code>HandlerExceptionResolver</code> 类实现了Spring的 <code>HandlerExceptionResolver</code> 接口，用于处理Spring MVC抛出的所有异常。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">web</span>.<span class="hljs-property">servlet</span>.<span class="hljs-property">HandlerExceptionResolver</span> &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">ModelAndView</span> <span class="hljs-title function_">resolveException</span>(<span class="hljs-params">HttpServletRequest request, HttpServletResponse response, <span class="hljs-built_in">Object</span> handler, Exception exception</span>) &#123;<br>        <span class="hljs-comment">// 异常处理逻辑...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>@Slf4j</code>: Lombok库提供的注解，为类提供了一个日志对象 <code>log</code>。</li><li><code>resolveException(...)</code>: 这是异常处理的核心方法，它接收发生异常的HTTP请求和响应、处理器（handler）对象以及实际抛出的异常。</li><li>在这个方法内部，可以根据不同类型的异常进行处理，并生成适当的响应</li></ul><p>具体代码分析</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@Slf</span>4j<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">org</span>.<span class="hljs-title">springframework</span>.<span class="hljs-title">web</span>.<span class="hljs-title">servlet</span>.<span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理Spring MVC抛出的所有异常。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> request   当前的HTTP请求</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> response  当前的HTTP响应</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> handler   处理当前请求的处理器</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> exception 抛出的异常</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> ModelAndView - Spring MVC的模型和视图对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function">ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object <span class="hljs-keyword">handler</span>, Exception exception)</span> </span>&#123;<br>        log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;系统统一异常处理：&quot;</span>, exception);<br><br>        <span class="hljs-comment">// 检查响应是否已经提交</span><br>        <span class="hljs-keyword">if</span> (response.isCommitted()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化错误代码和信息</span><br>        String errorCode = ErrorCode.ERROR;<br>        String message = BaseMessageConf.OPERATION_FAIL;<br><br>        <span class="hljs-comment">// 根据异常类型设置不同的错误代码和消息</span><br>        <span class="hljs-keyword">if</span> (exception <span class="hljs-keyword">instanceof</span> BusinessException) &#123;<br>            errorCode = ((BusinessException) exception).getCode();<br>            message = exception.getMessage();<br>        &#125; <span class="hljs-function"><span class="hljs-keyword">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(exception <span class="hljs-keyword">instanceof</span> ApiInvalidParamException)</span> </span>&#123;<br>            errorCode = ErrorCode.PARAM_INCORRECT;<br>            message = exception.getMessage();<br>        &#125;<br>        <span class="hljs-comment">// ...处理其他自定义异常</span><br><br>        <span class="hljs-comment">// 设置响应类型为JSON</span><br>        response.setContentType(MediaType.APPLICATION_JSON_UTF8_VALUE);<br><br>        <span class="hljs-comment">// 向客户端输出错误信息</span><br>        <span class="hljs-keyword">try</span> (PrintWriter writer = response.getWriter()) &#123;<br>            writer.write(ResultUtil.resultWithMessage(errorCode, message));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.<span class="hljs-keyword">error</span>(<span class="hljs-string">&quot;响应输出失败！原因如下：&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">// 返回一个空的ModelAndView表示已手动处理响应</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个类中，<code>resolveException</code> 方法根据捕获到的异常类型，对错误信息进行定制，并将定制的错误消息以JSON格式写入HTTP响应。</p><p>这种方式有助于实现统一的错误处理逻辑，使得API的错误响应更加一致和标准化。</p><h3 id="6、返回统一接口ResultUtil"><a href="#6、返回统一接口ResultUtil" class="headerlink" title="6、返回统一接口ResultUtil"></a>6、返回统一接口ResultUtil</h3><figure class="highlight wren"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><code class="hljs wren"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工具类用于构建统一的API响应格式。</span><br><span class="hljs-comment"> * 提供了一系列方法来生成标准化的JSON字符串响应，</span><br><span class="hljs-comment"> * 包括成功或错误的状态代码、消息和数据。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-variable">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ResultUtil</span> &#123;<br>    <span class="hljs-comment">// 常量定义</span><br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">CODE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;code&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;success&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">ERROR</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;error&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">DATA</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-variable">MESSAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;message&quot;</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_TWO</span> <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;<br>    <span class="hljs-variable">final</span> <span class="hljs-keyword">static</span> int <span class="hljs-variable">NUM_THREE</span> <span class="hljs-operator">=</span> <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成包含状态码和数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">result</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">code</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含数据的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成只包含消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_TWO</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成同时包含数据和消息的响应。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> code 状态码</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">code</span>, <span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-title class_">Map</span><span class="hljs-operator">&lt;</span><span class="hljs-title class_">Object</span>, <span class="hljs-title class_">Object</span><span class="hljs-operator">&gt;</span> <span class="hljs-variable">map</span> <span class="hljs-operator">=</span> <span class="hljs-variable">new</span> <span class="hljs-title class_">HashMap</span><span class="hljs-operator">&lt;</span><span class="hljs-operator">&gt;</span>(<span class="hljs-variable">NUM_THREE</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">CODE</span>, <span class="hljs-variable">code</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">DATA</span>, <span class="hljs-variable">data</span>);<br>        <span class="hljs-variable">map</span>.<span class="hljs-property">put</span>(<span class="hljs-variable">MESSAGE</span>, <span class="hljs-variable">message</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">JsonUtils</span>.<span class="hljs-property">objectToJson</span>(<span class="hljs-variable">map</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作成功的响应，同时包含数据和消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">successWithDataAndMessage</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>, <span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithDataAndMessage</span>(<span class="hljs-variable">SUCCESS</span>, <span class="hljs-variable">data</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithMessage</span>(<span class="hljs-params">String</span> <span class="hljs-params">message</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithMessage</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">message</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成表示操作失败的响应，只包含数据。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> data 数据</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> JSON字符串格式的响应</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-variable">public</span> <span class="hljs-keyword">static</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">errorWithData</span>(<span class="hljs-params">Object</span> <span class="hljs-params">data</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">resultWithData</span>(<span class="hljs-variable">ERROR</span>, <span class="hljs-variable">data</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>ResultUtil</code> 是一个工具类，用于创建和格式化API响应。它提供了一系列静态方法来生成标准化的JSON字符串响应。这些方法允许包含各种类型的信息，如状态码、数据、消息等。</p><blockquote><p>类的作用</p></blockquote><ol><li><strong>统一API响应格式</strong>:<ul><li><code>ResultUtil</code> 类用于生成具有一致格式的API响应。这有助于前端开发者理解和处理后端发送的数据。</li></ul></li><li><strong>灵活的响应构建</strong>:<ul><li>提供了多种方法来构建响应，可以只包含数据、只包含消息或同时包含数据和消息。</li></ul></li></ol><blockquote><p>方法说明</p></blockquote><ul><li><code>result(Object code, Object data)</code>: 生成包含指定代码和数据的响应。</li><li><code>resultWithData(Object code, Object data)</code>: 生成只包含数据的响应。</li><li><code>resultWithMessage(Object code, String message)</code>: 生成只包含消息的响应。</li><li><code>resultWithDataAndMessage(Object code, Object data, String message)</code>: 生成同时包含数据和消息的响应。</li><li><code>successWithData(Object data)</code>: 生成表示操作成功的响应，只包含数据。</li><li><code>successWithMessage(String message)</code>: 生成表示操作成功的响应，只包含消息。</li><li><code>successWithDataAndMessage(Object data, String message)</code>: 生成表示操作成功的响应，包含数据和消息。</li><li><code>errorWithMessage(String message)</code>: 生成表示操作失败的响应，只包含消息。</li><li><code>errorWithData(Object data)</code>: 生成表示操作失败的响应，只包含数据。</li></ul><blockquote><p>使用示例</p></blockquote><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs abnf">// 返回成功响应，只包含数据<br>String response <span class="hljs-operator">=</span> ResultUtil.successWithData(someData)<span class="hljs-comment">;</span><br><br>// 返回失败响应，只包含错误消息<br>String errorResponse <span class="hljs-operator">=</span> ResultUtil.errorWithMessage(<span class="hljs-string">&quot;An error occurred&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>这个类在实际的API开发中非常有用，它可以简化响应的创建过程，并确保API的返回格式统一和标准化。</p><p>对于维护API的一致性和可用性非常重要。</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_RabbitMQ_基础使用</title>
    <link href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><strong>“消息队列(Message Queue)”是在消息的传输过程中保存消息的容器</strong>。</p><p>MQ 的核心作用：削峰、解耦、异步</p><h3 id="1、RabbitMQ是什么"><a href="#1、RabbitMQ是什么" class="headerlink" title="1、RabbitMQ是什么"></a>1、RabbitMQ是什么</h3><p>建议直接去官网看一下相关概念： <a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></p><blockquote><p>RabbitMQ的特点</p></blockquote><p>RabbitMQ是一款使用Erlang语言开发的，实现AMQP(高级消息队列协议)的开源消息中间件。</p><p>特点</p><ul><li>可靠性。支持持久化，传输确认，发布确认等保证了MQ的可靠性。</li><li>灵活的分发消息策略。这应该是RabbitMQ的一大特点。在消息进入MQ前由Exchange(交换机)进行路由消息。分发消息策略有：简单模式、工作队列模式、发布订阅模式、路由模式、通配符模式。</li><li>支持集群。多台RabbitMQ服务器可以组成一个集群，形成一个逻辑Broker。</li><li>多种协议。RabbitMQ支持多种消息队列协议，比如 STOMP、MQTT 等等。</li><li>支持多种语言客户端。RabbitMQ几乎支持所有常用编程语言，包括 Java、.NET、Ruby 等等。</li><li>可视化管理界面。RabbitMQ提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker。</li><li>插件机制。RabbitMQ提供了许多插件，可以通过插件进行扩展，也可以编写自己的插件。</li></ul><blockquote><p>安装和使用</p></blockquote><ul><li><ol><li>安装 erlang 环境</li></ol></li><li><ol start="2"><li>安装RabbitMQ服务端</li></ol></li></ul><blockquote><p>RabbitMQ的组成部分</p></blockquote><ul><li>Broker：消息队列服务进程。此进程包括两个部分：Exchange和Queue。<ul><li>Exchange：消息队列交换机。<strong>按一定的规则将消息路由转发到某个队列</strong>。</li><li>Queue：消息队列，存储消息的队列。</li></ul></li><li>Producer：消息生产者。生产方客户端将消息同交换机路由发送到队列中。</li><li>Consumer：消息消费者。消费队列中存储的消息。</li></ul><p>大概流程：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121056722.png" alt="image.png"></p><ul><li>消息生产者连接到RabbitMQ Broker，创建connection，开启channel。</li><li>生产者声明交换机类型、名称、是否持久化等。</li><li>生产者发送消息，并指定消息是否持久化等属性和 routing key。</li><li>exchange收到消息之后，<strong>根据routing key路由到跟当前交换机绑定的相匹配的队列</strong>里面。</li><li>消费者监听接收到消息之后开始业务处理</li></ul><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">生产者</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消息</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">交换机</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">路由</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">队列</span> <span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">消费</span><span class="hljs-title">]</span><span class="hljs-literal">--</span>&gt; <span class="hljs-comment">消费者</span><br>    <span class="hljs-comment">\                                         /</span><br>     <span class="hljs-comment">\</span><span class="hljs-literal">--</span><span class="hljs-title">[</span><span class="hljs-comment">通道 Channel</span><span class="hljs-title">]</span><span class="hljs-literal">-----------------------</span><span class="hljs-comment">/</span><br></code></pre></td></tr></table></figure><p>通道的概念：</p><ul><li><strong>定义</strong>：通道是建立在实际的 TCP 连接内的一个轻量级连接。它是执行大多数操作（如消息发布或消息接收）的路径。</li><li><strong>作用</strong>：通道是多路复用连接中的一个独立路径，允许多个通道共享一个 TCP 连接，而不必为每个通道建立物理连接。这提高了资源利用率和通信效率</li><li>生产者使用通道来发送消息到交换机，而消费者使用通道从队列中接收消息。通道作为消息传输的通道，连接了生产者、交换机和消费者。</li></ul><p>通道是作为消息传递的载体贯穿整个过程。</p><h3 id="2、RabbitMQ-的工作流程"><a href="#2、RabbitMQ-的工作流程" class="headerlink" title="2、RabbitMQ 的工作流程"></a>2、RabbitMQ 的工作流程</h3><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><ul><li>建立连接</li><li>生产者<ul><li>声明交换机类型、名称、是否持久化等</li><li>发送消息</li></ul></li><li>交换机<ul><li>交换机接收消息，进行消息路由</li></ul></li><li>消费者<ul><li>订阅消息（监听队列）</li><li>接收消息，业务处理</li></ul></li></ul><blockquote><ol><li>消息生产者与 RabbitMQ Broker 建立连接</li></ol></blockquote><ul><li><strong>建立连接（Connection）</strong>：消息生产者（Producer）首先与 RabbitMQ Broker 建立连接。这个连接是一个比较重的操作，通常是长连接，并在多个消息发送过程中复用。</li><li><strong>开启通道（Channel）</strong>：一旦连接建立，生产者开启一个或多个通道（Channel）。通道是轻量级的，用于执行实际的消息发送和接收操作。在 RabbitMQ 中，所有的消息传输都是通过通道完成的。</li></ul><blockquote><ol start="2"><li>生产者声明交换机</li></ol></blockquote><ul><li><strong>声明交换机（Exchange）</strong>：生产者需要声明一个交换机，并指定它的类型（如 direct, topic, fanout, headers）和名称。生产者还可以设置交换机的其他属性，如是否持久化。持久化的交换机可以在 Broker 重启后依然存在。</li></ul><blockquote><ol start="3"><li>生产者发送消息</li></ol></blockquote><ul><li><strong>发送消息</strong>：生产者向指定的交换机发送消息。发送时，生产者还可以指定消息的各种属性，如是否持久化消息体，设置消息优先级等。</li><li><strong>指定 Routing Key</strong>：发送消息时，生产者需要指定一个 <code>routing key</code>。这个 <code>routing key</code> 用于决定消息如何路由到队列。</li></ul><blockquote><ol start="4"><li>交换机处理消息</li></ol></blockquote><ul><li><strong>接收消息</strong>：交换机接收到生产者发送的消息后，开始根据交换机类型和 <code>routing key</code> 进行消息路由。</li><li><strong>路由到队列</strong>：交换机根据 <code>routing key</code> 和交换机类型将消息路由到一个或多个绑定的队列中。例如，在 direct 类型的交换机中，消息会路由到 <code>routing key</code> 完全匹配的队列。</li></ul><blockquote><ol start="5"><li>消费者处理消息</li></ol></blockquote><ul><li><strong>监听队列</strong>：消费者（Consumer）监听一个或多个队列，等待消息的到来。</li><li><strong>接收消息</strong>：一旦有消息到达队列，消费者就会接收到这个消息。</li><li><strong>业务处理</strong>：消费者获取消息后，开始进行相应的业务处理。</li></ul><blockquote><p>总结</p></blockquote><p>在整个过程中，RabbitMQ 通过交换机和队列的机制提供了强大的消息路由能力。</p><p>交换机决定了消息如何根据 <code>routing key</code> 被路由到不同的队列，而消费者从队列中获取消息进行处理。这种机制支持了高度的解耦和灵活的消息处理策略，适用于各种复杂的消息处理场景。</p><h4 id="交换机类型"><a href="#交换机类型" class="headerlink" title="交换机类型"></a>交换机类型</h4><p>RabbitMQ 中最常用的几种交换机类型及其区别：</p><blockquote><ol><li>Direct Exchange（直接交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到那些 <code>binding key</code> 与消息的 <code>routing key</code> 完全匹配的队列。</li><li><strong>用途</strong>：非常适合单播（unicast）或多播（multicast）路由场景，即一对一或一对多发送。</li></ul><blockquote><ol start="2"><li>Fanout Exchange（扇出交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：消息被路由到所有与该交换机绑定的队列，忽略 <code>routing key</code>。</li><li><strong>用途</strong>：非常适合广播消息，如日志系统，其中消息需要被发送到多个目的地。</li></ul><blockquote><ol start="3"><li>Topic Exchange（主题交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：可以根据模式匹配 <code>routing keys</code> 和 <code>binding keys</code>（模式中可以包含通配符）。<code>routing key</code> 为点分隔的一系列单词，<code>binding key</code> 中可以包含特殊字符 <code>*</code> 和 <code>#</code> 来进行模式匹配，其中 <code>*</code> 匹配一个单词，<code>#</code> 匹配零个或多个单词。</li><li><strong>用途</strong>：适用于同时需要单播和多播路由逻辑的复杂路由配置。</li></ul><blockquote><ol start="4"><li>Headers Exchange（头部交换机）</li></ol></blockquote><ul><li><strong>行为</strong>：基于消息头部（headers）中的属性进行匹配。不依赖 <code>routing key</code>。匹配规则可以是“所有”（<code>x-match=all</code>，即所有头部属性必须匹配）或“任何”（<code>x-match=any</code>，即任意头部属性匹配）。</li><li><strong>用途</strong>：适用于需要根据多个属性进行路由决策的高级路由策略。</li></ul><blockquote><p>总结</p></blockquote><p>选择哪种交换机类型主要取决于你的具体应用场景和消息路由需求。</p><p>直接交换机适合简单的单播路由，扇出交换机适合广播，主题交换机适合复杂的路由场景，而头部交换机适合基于多属性的路由决策。了解这些交换机的特点可以帮助你更好地设计消息路由策略，并充分利用 RabbitMQ 的强大功能。</p><p>RabbitMQ 的处理流程是围绕着连接、交换机、消息发送和消息接收这几个核心环节展开的。</p><h4 id="路由键（Routing-Key）的作用"><a href="#路由键（Routing-Key）的作用" class="headerlink" title="路由键（Routing Key）的作用"></a>路由键（Routing Key）的作用</h4><p>路由键是消息发布到 RabbitMQ 时<strong>附带的一个字符串标识</strong>，它的作用是帮助交换机决定如何路由消息。</p><p>这里的“路由”指的是决定消息应该被发送到哪一个或哪些队列。路由键的具体作用取决于交换机的类型：</p><ol><li><strong>Direct Exchange</strong>：交换机会将消息路由到那些 <code>binding key</code> 与 <code>routing key</code> 完全匹配的队列。</li><li><strong>Topic Exchange</strong>：可以进行模式匹配，交换机会根据 <code>routing key</code> 和队列的 <code>binding key</code>（可以包含通配符）进行匹配。</li><li><strong>Fanout Exchange</strong>：忽略路由键，消息会被发送到所有绑定到该交换机的队列。</li><li><strong>Headers Exchange</strong>：不依赖路由键，而是根据发送的消息头部中的键值对进行匹配。</li></ol><h4 id="交换机与消费者之间的协同"><a href="#交换机与消费者之间的协同" class="headerlink" title="交换机与消费者之间的协同"></a>交换机与消费者之间的协同</h4><p>交换机不直接与消费者通信来决定向哪个消费者发送消息。</p><p>相反，它依赖于队列和队列与消费者之间的关系来实现消息的分发。下面是它们是如何协同工作的：</p><ol><li><p><strong>队列绑定到交换机</strong>：队列通过 <code>binding key</code>（在 fanout 和 headers 交换机中，这个 <code>binding key</code> 不一定被使用）绑定到交换机。这个过程决定了哪些消息会被路由到特定的队列。</p></li><li><p><strong>消费者监听队列</strong>：消费者通过打开一个通道并订阅（或监听）一个或多个队列来接收消息。这意味着消费者告诉 RabbitMQ：“我对这个队列中的消息感兴趣，请将它们发送给我。”</p></li><li><p><strong>消息分发</strong>：当消息通过交换机被路由到队列后，RabbitMQ 会将队列中的消息发送给订阅该队列的消费者。这个分发过程可能是基于不同的策略，如轮询或公平调度等。</p></li></ol><h4 id="消费者的监听"><a href="#消费者的监听" class="headerlink" title="消费者的监听"></a>消费者的监听</h4><p>当我们说消费者“监听”一个队列时，实际上是指消费者开启了一个持续的、异步的过程，这个过程会等待、接收并处理来自队列的消息。</p><p>消费者通过通道向 RabbitMQ 注册其对特定队列的兴趣。一旦队列中有消息，RabbitMQ 就会将消息推送给消费者。消费者接收到消息后，会根据自己的逻辑进行处理。</p><p>消费者通过监听队列来接收消息，交换机本身并不决定消息发送给哪个消费者，这是由队列中的消息与消费者之间的关系决定的。<strong>消费者监听意味着它们准备好接收和处理从队列中来的消息。</strong></p><h3 id="3、RabbitMQ广播和直接模式示例"><a href="#3、RabbitMQ广播和直接模式示例" class="headerlink" title="3、RabbitMQ广播和直接模式示例"></a>3、RabbitMQ广播和直接模式示例</h3><p>项目参考： <a href="https://gitee.com/yidao620/springboot-bucket">https://gitee.com/yidao620/springboot-bucket</a></p><p>这个项目的最后更新时间是五年前， 这里建议单独打开一下 springboot-rabbitmq</p><p>本地的 maven 版本是 3.5.2 , springboot-rabbitmq 依赖中的 maven-compiler-plugin 改为了 3.6.1 后没有报错</p><p>在 SpringBoot 中，使用消息队列需要引入 amqp 的依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>yml 配置内容</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span>  <br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span>  <br>  <span class="hljs-attr">rabbitmq:</span>  <br>    <span class="hljs-attr">host:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>  <br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span>  <br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span>  <br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><h4 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h4><p>在这个项目中，定义了一个配置类 RabbitConfig</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><code class="hljs livescript">package com.xncoding.pos.config;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.*;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.support.converter.Jackson2JsonMessageConverter;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RabbitConfig</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @version 1.0</span><br><span class="hljs-comment"> * @since 2018/3/1</span><br><span class="hljs-comment"> */</span><br>@Configuration<br>public <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br>    @Resource<br>    private RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定制化 AMQP 模版。</span><br><span class="hljs-comment">     * 设置消息转换器、编码、消息确认和返回回调。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * @return the amqp template</span><br><span class="hljs-comment">     */</span><br>    @Bean<br>    public AmqpTemplate amqpTemplate() &#123;<br>        Logger log = LoggerFactory.getLogger(RabbitTemplate.<span class="hljs-keyword">class</span>);<br><br>        <span class="hljs-regexp">// 使用 Jackson 作为消息转换器，自动将消息转换为 JSON 格式</span><br><span class="hljs-regexp">        rabbitTemplate.setMessageConverter(new Jackson2JsonMessageConverter());</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 设置字符编码为 UTF-<span class="hljs-number">8</span><br>        rabbitTemplate.setEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br><br>        <span class="hljs-regexp">// 消息发送失败时返回到队列，需要在配置文件中设置 publisher-returns: true</span><br><span class="hljs-regexp">        rabbitTemplate.setMandatory(true);</span><br><span class="hljs-regexp"></span><br><span class="hljs-regexp">        //</span> 定义消息发送失败的回调<br>        rabbitTemplate.setReturnCallback<span class="hljs-function"><span class="hljs-params">((message, replyCode, replyText, exchange, routingKey) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-built_in">String</span> correlationId = message.getMessageProperties().getCorrelationIdString();</span></span><br><span class="hljs-params"><span class="hljs-function">            log.debug(<span class="hljs-string">&quot;消息：&#123;&#125; 发送失败, 应答码：&#123;&#125; 原因：&#123;&#125; 交换机: &#123;&#125;  路由键: &#123;&#125;&quot;</span>, correlationId, replyCode, replyText, exchange, routingKey);</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        // 定义消息发送到交换机确认回调，需要在配置文件中设置 <span class="hljs-title">publisher-confirms</span>: <span class="hljs-title">true</span></span><br><span class="hljs-function">        <span class="hljs-title">rabbitTemplate</span>.<span class="hljs-title">setConfirmCallback</span><span class="hljs-params">((correlationData, ack, cause) -&gt; &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">if</span> (ack) &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange成功,id: &#123;&#125;&quot;</span>, correlationData.getId());</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125; <span class="hljs-keyword">else</span> &#123;</span></span><br><span class="hljs-params"><span class="hljs-function">                log.debug(<span class="hljs-string">&quot;消息发送到exchange失败,原因: &#123;&#125;&quot;</span>, cause);</span></span><br><span class="hljs-params"><span class="hljs-function">            &#125;</span></span><br><span class="hljs-params"><span class="hljs-function">        &#125;)</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">rabbitTemplate</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Direct</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Direct</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Exchange</span> <span class="hljs-title">directExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Direct</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">directExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;directQueue&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">directQueue</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_QUEUE&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列绑定到交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>    <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">exchange</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">directBinding</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;directQueue&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 @Qualifier(<span class="hljs-string">&quot;directExchange&quot;</span>) Exchange exchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列绑定到交换机，使用路由键 &quot;<span class="hljs-title">DIRECT_ROUTING_KEY</span>&quot;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(exchange)</span>.<span class="hljs-title">with</span><span class="hljs-params">(<span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>)</span>.<span class="hljs-title">noargs</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    // <span class="hljs-title">Fanout</span> <span class="hljs-title">Exchange</span> 配置部分</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutExchange&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">FanoutExchange</span> <span class="hljs-title">fanoutExchange</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-params">(FanoutExchange)</span> <span class="hljs-title">ExchangeBuilder</span>.<span class="hljs-title">fanoutExchange</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>)</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-literal">true</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">A</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueA</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">A</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_A&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 声明队列 <span class="hljs-title">B</span>。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span><span class="hljs-params">(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>)</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Queue</span> <span class="hljs-title">fanoutQueueB</span><span class="hljs-params">()</span> &#123;</span><br><span class="hljs-function">        // 创建并返回一个持久化的队列 <span class="hljs-title">B</span></span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">QueueBuilder</span>.<span class="hljs-title">durable</span><span class="hljs-params">(<span class="hljs-string">&quot;FANOUT_QUEUE_B&quot;</span>)</span>.<span class="hljs-title">build</span><span class="hljs-params">()</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingA</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueA&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">A</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    /**</span><br><span class="hljs-function">     * 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机。</span><br><span class="hljs-function">     *</span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">queue</span>          <span class="hljs-title">the</span> <span class="hljs-title">queue</span></span><br><span class="hljs-function">     * @<span class="hljs-title">param</span> <span class="hljs-title">fanoutExchange</span> <span class="hljs-title">the</span> <span class="hljs-title">fanout</span> <span class="hljs-title">exchange</span></span><br><span class="hljs-function">     * @<span class="hljs-title">return</span> <span class="hljs-title">the</span> <span class="hljs-title">binding</span></span><br><span class="hljs-function">     */</span><br><span class="hljs-function">    @<span class="hljs-title">Bean</span></span><br><span class="hljs-function">    <span class="hljs-title">public</span> <span class="hljs-title">Binding</span> <span class="hljs-title">bindingB</span><span class="hljs-params">(@Qualifier(<span class="hljs-string">&quot;fanoutQueueB&quot;</span>) Queue queue,</span></span><br><span class="hljs-params"><span class="hljs-function">                            @Qualifier(<span class="hljs-string">&quot;fanoutExchange&quot;</span>) FanoutExchange fanoutExchange)</span> &#123;</span><br><span class="hljs-function">        // 将队列 <span class="hljs-title">B</span> 绑定到 <span class="hljs-title">Fanout</span> 交换机</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">BindingBuilder</span>.<span class="hljs-title">bind</span><span class="hljs-params">(queue)</span>.<span class="hljs-title">to</span><span class="hljs-params">(fanoutExchange)</span>;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>这个 <code>RabbitConfig</code> 配置类通过 <code>@Bean</code> 注解声明了多个 Spring Bean，用于设置 RabbitMQ 的不同组件。</p><p>它涵盖了消息模板的定制、交换机和队列的声明，以及队列与交换机的绑定。</p><p>这样的配置提供了灵活的方式来定义消息传递的行为，包括消息格式、路由策略和队列管理，适用于不同的消息处理需求。</p><p>通过这种方式，可以在 Spring 应用中轻松地使用 RabbitMQ 进行高效的消息通信。</p><hr><p>通过广播方式发送消息</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送广播模式的消息。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">broadcast</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> p</span>) &#123;<br>    <span class="hljs-comment">// 创建 CorrelationData 对象，带有一个唯一的标识符。</span><br>    <span class="hljs-comment">// 这个标识符用于消息确认过程中识别消息。</span><br>    <span class="hljs-title class_">CorrelationData</span> correlationData = <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(<span class="hljs-variable constant_">UUID</span>.<span class="hljs-title function_">randomUUID</span>().<span class="hljs-title function_">toString</span>());<br><br>    <span class="hljs-comment">// 使用 RabbitTemplate 将消息发送到指定的交换机。</span><br>    <span class="hljs-comment">// 参数1: 交换机名称 - 这里是 &quot;FANOUT_EXCHANGE&quot;。</span><br>    <span class="hljs-comment">// 参数2: 路由键 - 在 Fanout 交换机中，路由键会被忽略，所以这里传递一个空字符串。</span><br>    <span class="hljs-comment">// 参数3: 消息内容 - 这里是传入的参数 p。</span><br>    <span class="hljs-comment">// 参数4: CorrelationData - 包含消息的唯一标识符，用于消息跟踪和确认。</span><br>    rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>&#125;<br></code></pre></td></tr></table></figure><p>在前面的配置类中，是声明了 Fanout 交换机， 并且绑定两个队列在这个交换机上。</p><h4 id="生产者类"><a href="#生产者类" class="headerlink" title="生产者类"></a>生产者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.service;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.core.RabbitTemplate;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.support.CorrelationData;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-keyword">import</span> javax.annotation.Resource;<br><span class="hljs-keyword">import</span> java.util.UUID;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息发送服务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-built_in">this</span>.getClass());<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试广播模式.</span><br><span class="hljs-comment">     * 在广播模式下，消息会被发送到所有绑定到交换机的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">broadcast</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 FANOUT_EXCHANGE 交换机，路由键为空字符串</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;FANOUT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, p, correlationData);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试Direct模式.</span><br><span class="hljs-comment">     * 在Direct模式下，消息会被路由到具有指定路由键的队列。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p 要发送的消息内容</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">direct</span><span class="hljs-params">(String p)</span> &#123;<br>        <span class="hljs-comment">// 为每个消息创建一个带唯一标识符的 CorrelationData 对象</span><br>        <span class="hljs-type">CorrelationData</span> <span class="hljs-variable">correlationData</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CorrelationData</span>(UUID.randomUUID().toString());<br>        <span class="hljs-comment">// 将消息发送到 DIRECT_EXCHANGE 交换机，并指定路由键</span><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;DIRECT_EXCHANGE&quot;</span>, <span class="hljs-string">&quot;DIRECT_ROUTING_KEY&quot;</span>, p, correlationData);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="消费者类"><a href="#消费者类" class="headerlink" title="消费者类"></a>消费者类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xncoding.pos.mq;<br><br><span class="hljs-keyword">import</span> com.rabbitmq.client.Channel;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.amqp.core.Message;<br><span class="hljs-keyword">import</span> org.springframework.amqp.rabbit.annotation.RabbitListener;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.io.IOException;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息监听器</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(Receiver.class);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听一.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_A 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_A&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">on</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_A &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * FANOUT广播队列监听二.</span><br><span class="hljs-comment">     * 在 FANOUT_QUEUE_B 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;FANOUT_QUEUE_B&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">t</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;FANOUT_QUEUE_B &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * DIRECT模式.</span><br><span class="hljs-comment">     * 在 DIRECT_QUEUE 队列上监听消息。</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 接收到的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel 通信通道</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException 在消息确认过程中可能抛出的异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;DIRECT_QUEUE&quot;&#125;)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">message</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 确认消息已被正确接收</span><br>        channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-literal">true</span>);<br>        <span class="hljs-comment">// 记录接收到的消息</span><br>        log.debug(<span class="hljs-string">&quot;DIRECT &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.getBody()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>在生产者类（<code>SenderService</code>）中，两个方法分别演示了如何在广播（Fanout）和直接（Direct）模式下发送消息。</li><li>在消费者类（<code>Receiver</code>）中，每个方法都使用了 <code>@RabbitListener</code> 注解来监听特定的队列，并在接收到消息后执行相应的处理逻辑。</li></ul><p>这里由于你配置了接收的监听，因此当你发送的时候你就收到了这条消息，并且通过日志的方式打印了出来，如果需要比较明显一点的观察现象，可以加一个等待时间确保被消费。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">// 等待一段时间以确保消息被消费 </span><br>Thread.<span class="hljs-built_in">sleep</span>(<span class="hljs-number">1000</span>);<br></code></pre></td></tr></table></figure><h4 id="主题交换机（Topic-Exchange）的使用示例"><a href="#主题交换机（Topic-Exchange）的使用示例" class="headerlink" title="主题交换机（Topic Exchange）的使用示例"></a>主题交换机（Topic Exchange）的使用示例</h4><p>Topic Exchange 直接翻译的话叫做主题交换机，如果从用法上面翻译可能叫通配符交换机会更加贴切。</p><p>这种交换机是使用通配符去匹配，路由到对应的队列。通配符有两种：”* “ 、 “#”。需要注意的是通配符前面必须要加上”.”符号。</p><p><code>*</code> 符号：有且只匹配一个词。比如 <code>a.*</code>可以匹配到”a.b”、”a.c”，但是匹配不了”a.b.c”。<br><code>#</code> 符号：匹配一个或多个词。比如”rabbit.#”既可以匹配到”rabbit.a.b”、”rabbit.a”，也可以匹配到”rabbit.a.b.c”。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312121409207.png" alt="image.png"></p><blockquote><p>使用示例</p></blockquote><p>在前文的基础上，新增一些内容</p><p>配置类(更新配置类以包含一个主题交换机和两个队列，以及它们的绑定)</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RabbitConfig</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他配置 ...</span><br><br>    <span class="hljs-comment">// Topic Exchange 配置</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">TopicExchange</span> <span class="hljs-title function_">topicExchange</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TopicExchange</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueOneWord</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Queue</span> <span class="hljs-title function_">topicQueueMultipleWords</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Queue</span>(<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.*&quot; 只匹配一个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicOneWord</span>(<span class="hljs-params">Queue topicQueueOneWord, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueOneWord).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 绑定键 &quot;topic.#&quot; 匹配零个或多个单词</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">Binding</span> <span class="hljs-title function_">bindingTopicMultipleWords</span>(<span class="hljs-params">Queue topicQueueMultipleWords, TopicExchange topicExchange</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-title class_">BindingBuilder</span>.<span class="hljs-title function_">bind</span>(topicQueueMultipleWords).<span class="hljs-title function_">to</span>(topicExchange).<span class="hljs-title function_">with</span>(<span class="hljs-string">&quot;topic.#&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>生产者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SenderService</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">RabbitTemplate</span> rabbitTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送消息到主题交换机</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendToTopic</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> routingKey, <span class="hljs-built_in">String</span> message</span>) &#123;<br>        rabbitTemplate.<span class="hljs-title function_">convertAndSend</span>(<span class="hljs-string">&quot;TOPIC_EXCHANGE&quot;</span>, routingKey, message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>消费者类</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Receiver</span> &#123;<br><br>    <span class="hljs-comment">// ... 其他方法 ...</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final <span class="hljs-title class_">Logger</span> log = <span class="hljs-title class_">LoggerFactory</span>.<span class="hljs-title function_">getLogger</span>(<span class="hljs-title class_">Receiver</span>.<span class="hljs-property">class</span>);<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_ONE_WORD&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicOneWord</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_ONE_WORD: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br><br>    <span class="hljs-meta">@RabbitListener</span>(queues = &#123;<span class="hljs-string">&quot;TOPIC_QUEUE_MULTIPLE_WORDS&quot;</span>&#125;)<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">receiveFromTopicMultipleWords</span>(<span class="hljs-params">Message message</span>) &#123;<br>        log.<span class="hljs-title function_">debug</span>(<span class="hljs-string">&quot;Received in TOPIC_QUEUE_MULTIPLE_WORDS: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(message.<span class="hljs-title function_">getBody</span>()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试类(发送消息并验证它们被正确路由到对应的队列：)</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqTest</span> </span>&#123;<br><br>    <span class="hljs-comment">// ... 其他测试 ...</span><br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> SenderService senderService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testTopicExchange</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.*&quot;，应该只被 TOPIC_QUEUE_ONE_WORD 接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one&quot;</span>, <span class="hljs-string">&quot;Message for topic.one&quot;</span>);<br><br>        <span class="hljs-comment">// 发送消息，路由键匹配 &quot;topic.#&quot;，应该被两个队列接收</span><br>        senderService.sendToTopic(<span class="hljs-string">&quot;topic.one.two&quot;</span>, <span class="hljs-string">&quot;Message for topic.one.two&quot;</span>);<br><br>        <span class="hljs-comment">// 等待一段时间以确保消息被消费</span><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>第一个测试消息使用路由键 “topic.one”，它符合 <code>*</code> 的匹配规则（匹配一个单词），因此只有 “TOPIC_QUEUE_ONE_WORD” 队列接收到这个消息。</li><li>第二个测试消息使用路由键 “topic.one.two”，它符合 <code>#</code> 的匹配规则（匹配多个单词），因此两个队列都接收到这个消息。</li></ul><p>运行测试后，通过日志输出可以验证这些匹配规则是否按预期工作。</p><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>在 RabbitMQ中比较常用的三种模式是：直连(DirectExchange)，发布订阅(FanoutExchange)，通配符(TopicExchange)。</p><p>熟练运用这三种交换机类型，基本上可以解决大部分的业务场景。</p><p>通配符(TopicExchange)这种模式也可以达到直连(DirectExchange)和发布订阅(FanoutExchange)这两种的效果。</p><p>FanoutExchange不需要绑定routingKey，所以性能相对TopicExchange会好一些。</p><hr><p>参考</p><ul><li><a href="https://www.rabbitmq.com/documentation.html">https://www.rabbitmq.com/documentation.html</a></li><li><a href="https://developer.aliyun.com/article/769883">https://developer.aliyun.com/article/769883</a></li><li><a href="https://blog.csdn.net/CherryChenieth/article/details/124767155">https://blog.csdn.net/CherryChenieth/article/details/124767155</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_基础概念</title>
    <link href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>在面试的时候，当你的简历上面写了用过<code>MQ</code> ,那么面试官的面试这个时候便开始了：</p><ul><li><ol><li>你在系统里用过消息队列吗</li></ol></li><li><ol start="2"><li>你们在项目里是如何使用消息队列的。</li></ol></li><li><ol start="3"><li>为什么你们这里要使用消息队列呢，为什么不直接调用接口处理呢。</li></ol></li><li><ol start="4"><li>说说消息队列有哪些优点和缺点吧。</li></ol></li><li><ol start="5"><li>消息队列的选型，他们之间的区别。</li></ol></li><li><ol start="6"><li>如何保证消息不被重复消息，如何保证消费的时候是幂等，如何保证消息的可靠性，如何保证消息的顺序性。</li></ol></li><li><ol start="7"><li>如何解决消息队列的延时以及过期失效问题？消息队列满了以后该如何处理？有几百万消息持续堆积几小时，要怎么解决？</li></ol></li><li><ol start="8"><li>让你去设计一个MQ，该如何进行架构设计，说一下你的思路。</li></ol></li></ul><p>前几个问题的思考主要是围绕：为什么要使用消息队列；</p><p>陈述回答的时候需要从消息队列利弊、优缺点、风险点等方面考虑，在进行技术选型的时候，主要还是围绕使用场景来决定。</p><div style="box-shadow: 2px 2px 5px #888888; padding: 10px; border: 1px solid #3271ae;">    每一个 MQ 没有绝对的好坏，但是要看用在哪个场景可以扬长避短，利用其优势，规避其劣势。</div><h3 id="消息队列的核心使用场景"><a href="#消息队列的核心使用场景" class="headerlink" title="消息队列的核心使用场景"></a>消息队列的核心使用场景</h3><p>消息队列（MQ）的核心使用场景主要包括三个方面：解耦、异步处理和削峰。</p><blockquote><p>解耦</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，你在组织一个大型派对，你需要通知很多朋友。如果你直接一个个打电话，每当新朋友加入或某人退出，你都需要更新你的通知列表。这很麻烦，对吧？现在，假设你创建了一个在线活动页面，你只需要更新这个页面，而你的朋友们自己决定是否查看这个页面。这就大大简化了你的工作。</p><p><strong>技术解释</strong></p><p>在没有消息队列的情况下，系统 A 需要直接和多个系统（如 B、C、D、E）进行通信。这种紧密耦合的方式使得系统 A 需要不断更新与其他系统的交互逻辑。使用消息队列后，系统 A 只需将消息发布到队列，而其他系统根据需要从队列中取出消息。这种发布&#x2F;订阅模式（Pub&#x2F;Sub）使得系统 A 与其他系统解耦，简化了维护和扩展的复杂性。</p><blockquote><p>异步处理</p></blockquote><p><strong>类比解释</strong></p><p>假设你在一家餐厅点餐。如果厨师需要等待一个菜做完才开始做下一个，这将非常低效。但如果他们能同时处理多个订单，每道菜完成时就直接上菜，这样效率会更高。</p><p><strong>技术解释</strong></p><p>在同步处理模式中，系统 A 在完成所有操作（如更新多个数据库）之前不会响应用户请求，导致延迟。<br>而异步处理使用消息队列，系统 A 可以快速响应用户请求，将后续任务（如数据库更新）放入队列中，由其他系统或服务慢慢处理。这减少了用户的等待时间，提高了系统的响应能力。</p><blockquote><p>削峰</p></blockquote><p><strong>类比解释</strong></p><p>想象一下，一个公交车站在高峰时段面临大量乘客。如果每个人都立即上车，公交车会被迅速塞满。但如果有一个等候区，让乘客按顺序上车，这样既保持了公交车的正常运行，又避免了拥挤。</p><p><strong>技术解释</strong></p><p>在流量削峰场景中，消息队列充当缓冲区，帮助处理短时的高流量。当系统 A 在高峰时段面临大量请求时，这些请求首先被放入消息队列。<br>系统 A 根据自己的处理能力逐渐从队列中取出并处理这些请求。这样可以避免在高峰期对系统造成过大的压力，同时保证了系统的稳定性和可用性。</p><p>上面提及到的削峰、解耦、异步就是<strong>在特殊场景下其对应的好处</strong>，而缺点对应的是系统的复杂性变高，可用性降低，以及还有一致性问题。</p><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><p>技术选型可以参考看一下下面的内容</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><blockquote><p>Kafka</p></blockquote><p>优点</p><ol><li><strong>高吞吐量</strong>：Kafka 设计用于处理高吞吐量数据，适合大规模消息处理应用。</li><li><strong>分布式系统</strong>：它天生就是分布式的，易于扩展。</li><li><strong>持久性和可靠性</strong>：Kafka 可以持久化消息到磁盘，因此对消息不会因为系统故障而丢失。</li><li><strong>高效</strong>：Kafka 使用顺序磁盘I&#x2F;O，提供高性能与数据吞吐。</li></ol><p>缺点</p><ol><li><strong>复杂性</strong>：Kafka 的设置和管理相对复杂。</li><li><strong>消息积压</strong>：在高负载下，消息延迟可能会增加。</li><li><strong>不支持优先级队列</strong>。</li></ol><blockquote><p>ActiveMQ</p></blockquote><p>优点</p><ol><li><strong>支持多种传输协议</strong>：如 OpenWire, STOMP, MQTT 等。</li><li><strong>易于使用和配置</strong>：相比 Kafka，ActiveMQ 配置和管理较为简单。</li><li><strong>JMS 支持</strong>：完全支持 JMS API 和 J2EE 集成。</li></ol><p>缺点</p><ol><li><strong>较低的吞吐量</strong>：相比 Kafka，ActiveMQ 的吞吐量较低。</li><li><strong>可扩展性问题</strong>：在非常大的数据负载下，扩展性可能是一个问题。</li></ol><blockquote><p>RabbitMQ</p></blockquote><p>优点</p><ol><li><strong>灵活的路由</strong>：支持复杂的路由。</li><li><strong>多种消息协议</strong>：支持 AMQP, MQTT, STOMP 等。</li><li><strong>管理界面友好</strong>：提供易于使用的管理界面。</li></ol><p>缺点</p><ol><li><strong>性能问题</strong>：在高吞吐量时，性能可能会受限。</li><li><strong>持久化开销</strong>：消息持久化可能会导致性能问题。</li></ol><blockquote><p>RocketMQ</p></blockquote><p>优点</p><ol><li><strong>高性能和低延迟</strong>：在分布式系统中表现出色。</li><li><strong>丰富的功能</strong>：提供了大量的特性，如消息顺序、事务消息等。</li><li><strong>可靠性和扩展性</strong>：保证了消息的可靠传输，同时支持水平和垂直扩展。</li></ol><p>缺点</p><ol><li><strong>社区和生态</strong>：相比 Kafka，RocketMQ 的社区和生态相对较小。</li><li><strong>复杂性</strong>：配置和管理稍微复杂。</li></ol><blockquote><p>技术选型考虑因素</p></blockquote><ol><li><strong>吞吐量需求</strong>：如果你的系统需要处理大量的数据，Kafka 或 RocketMQ 可能是更好的选择。</li><li><strong>系统复杂性</strong>：如果你需要一个易于设置和管理的系统，ActiveMQ 或 RabbitMQ 可能更合适。</li><li><strong>功能需求</strong>：根据你需要的特定功能（如消息排序、事务处理等）选择相应的系统。</li><li><strong>社区支持和生态系统</strong>：强大的社区可以提供更好的支持和更多的资源。</li><li><strong>可靠性和持久性</strong>：如果这些是你的主要关注点，Kafka 和 RocketMQ 是不错的选择</li></ol><p>选择建议：</p><ul><li><strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；</li><li><strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</li><li>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，Kafka 是业内标准，社区活跃度很高，几乎是全世界该领域的事实性规范。</li><li>ActiveMQ，最近逐年使用减少，没经过大规模吞吐量场景的验证，社区不是很活跃。</li></ul><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html">https://javaguide.cn/high-performance/message-queue/message-queue.html</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview">https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day02</title>
    <link href="/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/"/>
    <url>/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/</url>
    
    <content type="html"><![CDATA[<h3 id="Part01-我们应该去了解什么东西呢"><a href="#Part01-我们应该去了解什么东西呢" class="headerlink" title="Part01: 我们应该去了解什么东西呢"></a>Part01: 我们应该去了解什么东西呢</h3><p>这部分内容主要讲述一下基础的博客管理是怎么做的，如果需要做一个基础的博客系统需要怎么做，考虑哪些方面。</p><p>up 主 CodeSheep  在视频对于项目学习的一些建议，记录一下 <a href="https://www.bilibili.com/video/BV1y4411p74E/">https://www.bilibili.com/video/BV1y4411p74E/</a></p><ul><li><ol><li>运行项目并跑起来</li></ol></li><li><ol start="2"><li>阅读项目源码并调试（可以结合某个运行的功能入手，一个组件一个组件弄熟、看报错、看日志、看打印变量）</li></ol></li><li><ol start="3"><li>记录文档，从业务逻辑出发（逻辑很重要，你先学习这个，前端页面实现和二次改造想法先放后面，先去了解，再去摸索）</li></ol></li></ul><p>视频中推荐过这个项目（一个单体项目），有空也可以学习一下： <a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></p><p>在后台管理界面中，有一个很明显的模块是：博客管理</p><p>博客管理（界面）</p><ul><li>博客管理</li><li>分类管理</li><li>收藏管理</li><li>标签管理</li><li>推荐管理</li><li>专题管理</li></ul><h3 id="Part02-蘑菇博客中博客管理是如何实现的。"><a href="#Part02-蘑菇博客中博客管理是如何实现的。" class="headerlink" title="Part02: 蘑菇博客中博客管理是如何实现的。"></a>Part02: 蘑菇博客中博客管理是如何实现的。</h3><p>先了解这个问题，我们需要先回到技术栈的使用，知道他使用的是什么技术栈，才能对后面有更好的了解。</p><p>具体内容看一下 <a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></p><p>这里就不一一列举，需要知道的一个是项目中使用的 Java 持久层框架 是 MyBatis-Plus。</p><p>通过这个框架，你可以实现 <strong>代码生成器</strong>、<strong>自动 CRUD（Create, Read, Update, Delete）</strong> 等操作。</p><h4 id="博客管理"><a href="#博客管理" class="headerlink" title="博客管理"></a>博客管理</h4><blockquote><p>查找</p></blockquote><p>查询并分页获取博客列表</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据条件获取博客列表，并进行分页。</span><br><span class="hljs-comment"> * 使用MyBatis-Plus的QueryWrapper来构建查询条件。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * @param blogVO 包含查询条件的VO对象</span><br><span class="hljs-comment"> * @return 分页后的博客列表</span><br><span class="hljs-comment"> */</span><br>@Override<br>public IPage&lt;Blog&gt; getPageList(BlogVO blogVO) &#123;<br>    <span class="hljs-comment">// 创建查询包装器</span><br>    QueryWrapper&lt;Blog&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br><br>    <span class="hljs-comment">// 构建搜索条件</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isNotEmpty(blogVO.getKeyword()) &amp;&amp; !StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getKeyword().<span class="hljs-built_in">trim</span>())) &#123;<br>        queryWrapper.like(SQLConf.TITLE, blogVO.getKeyword().<span class="hljs-built_in">trim</span>());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getTagUid())) &#123;<br>        queryWrapper.like(SQLConf.TAG_UID, blogVO.getTagUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getBlogSortUid())) &#123;<br>        queryWrapper.like(SQLConf.BLOG_SORT_UID, blogVO.getBlogSortUid());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getLevelKeyword())) &#123;<br>        queryWrapper.eq(SQLConf.LEVEL, blogVO.getLevelKeyword());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsPublish())) &#123;<br>        queryWrapper.eq(SQLConf.IS_PUBLISH, blogVO.getIsPublish());<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getIsOriginal())) &#123;<br>        queryWrapper.eq(SQLConf.IS_ORIGINAL, blogVO.getIsOriginal());<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!StringUtils.<span class="hljs-built_in">isEmpty</span>(blogVO.getType())) &#123;<br>        queryWrapper.eq(SQLConf.TYPE, blogVO.getType());<br>    &#125;<br><br>    <span class="hljs-comment">// 设置分页参数</span><br>    Page&lt;Blog&gt; page = <span class="hljs-keyword">new</span> Page&lt;&gt;();<br>    page.setCurrent(blogVO.getCurrentPage());<br>    page.setSize(blogVO.getPageSize());<br>    queryWrapper.eq(SQLConf.STATUS, EStatus.ENABLE);<br><br>    <span class="hljs-comment">// 设置排序方式</span><br>    <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByAscColumn())) &#123;<br>        <span class="hljs-comment">// 将驼峰命名转换成下划线命名</span><br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByAscColumn())).toString();<br>        queryWrapper.orderByAsc(column);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(StringUtils.isNotEmpty(blogVO.getOrderByDescColumn())) &#123;<br>        String column = StringUtils.underLine(<span class="hljs-keyword">new</span> StringBuffer(blogVO.getOrderByDescColumn())).toString();<br>        queryWrapper.orderByDesc(column);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 默认排序</span><br>        <span class="hljs-keyword">if</span> (blogVO.getUseSort() == <span class="hljs-number">0</span>) &#123;<br>            queryWrapper.orderByDesc(SQLConf.CREATE_TIME);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            queryWrapper.orderByDesc(SQLConf.<span class="hljs-built_in">SORT</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 执行分页查询</span><br>    IPage&lt;Blog&gt; pageList = blogService.page(page, queryWrapper);<br>    List&lt;Blog&gt; list = pageList.getRecords();<br><br>    <span class="hljs-comment">// 若结果为空，直接返回</span><br>    <span class="hljs-keyword">if</span> (list.size() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> pageList;<br>    &#125;<br><br>    <span class="hljs-comment">// 处理查询结果，例如添加分类、标签等额外信息</span><br>    <span class="hljs-comment">// ... 省略了额外信息处理的代码 ...</span><br><br>    <span class="hljs-comment">// 返回处理后的分页结果</span><br>    pageList.setRecords(list);<br>    <span class="hljs-keyword">return</span> pageList;<br>&#125;<br></code></pre></td></tr></table></figure><p>处理查询结果</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs pf">// ...省略方法的其它部分...<br><br>List<span class="hljs-variable">&lt;Blog&gt;</span> list = pageList.getRecords();<br><br>// 若查询结果为空，直接返回<br>if (list.isEmpty()) &#123;<br>    return pageList;<br>&#125;<br><br>// 初始化存储分类UID和标签UID的集合<br>List<span class="hljs-variable">&lt;String&gt;</span> sortUids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br>List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>Uids = new ArrayList<span class="hljs-variable">&lt;&gt;</span>();<br><br>// 遍历查询结果，收集分类UID和标签UID<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    if (StringUtils.isNotEmpty(blog.getB<span class="hljs-keyword">log</span>SortUid())) &#123;<br>        sortUids.add(blog.getB<span class="hljs-keyword">log</span>SortUid());<br>    &#125;<br>    if (StringUtils.isNotEmpty(blog.getTagUid())) &#123;<br>        <span class="hljs-keyword">tag</span>Uids.addAll(StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION));<br>    &#125;<br>&#125;<br><br>// 根据分类UIDs和标签UIDs获取对应的分类和标签对象<br>Collection<span class="hljs-variable">&lt;BlogSort&gt;</span> sortList = blogSortService.listByIds(sortUids);<br>Collection<span class="hljs-variable">&lt;Tag&gt;</span> <span class="hljs-keyword">tag</span>List = <span class="hljs-keyword">tag</span>Service.listByIds(<span class="hljs-keyword">tag</span>Uids);<br><br>// 将分类和标签对象转换为Map，便于快速查找<br>Map<span class="hljs-variable">&lt;String, BlogSort&gt;</span> sortMap = sortList.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(B<span class="hljs-keyword">log</span>Sort::getUid, Function.identity()));<br>Map<span class="hljs-variable">&lt;String, Tag&gt;</span> <span class="hljs-keyword">tag</span>Map = <span class="hljs-keyword">tag</span>List.stream()<br>    .collect(Collectors.<span class="hljs-keyword">to</span>Map(Tag::getUid, Function.identity()));<br><br>// 遍历查询结果，设置每个博客的分类和标签<br><span class="hljs-keyword">for</span> (B<span class="hljs-keyword">log</span> blog : list) &#123;<br>    blog.<span class="hljs-built_in">set</span>B<span class="hljs-keyword">log</span>Sort(sortMap.get(blog.getB<span class="hljs-keyword">log</span>SortUid()));<br>    List<span class="hljs-variable">&lt;String&gt;</span> <span class="hljs-keyword">tag</span>UidList = StringUtils.changeStringToString(blog.getTagUid(), SysConf.FILE_SEGMENTATION);<br>    List<span class="hljs-variable">&lt;Tag&gt;</span> blogTags = <span class="hljs-keyword">tag</span>UidList.stream()<br>        .map(<span class="hljs-keyword">tag</span>Map::get)<br>        .collect(Collectors.<span class="hljs-keyword">to</span>List());<br>    blog.<span class="hljs-built_in">set</span>TagList(blogTags);<br>&#125;<br><br>// 更新处理后的查询结果<br>pageList.<span class="hljs-built_in">set</span>Records(list);<br><br>// ...省略方法的其余部分...<br></code></pre></td></tr></table></figure><ol><li>首先检查查询结果列表是否为空，如果为空则直接返回。</li><li>遍历博客列表，从每个博客对象中提取分类和标签的UID。</li><li>使用收集的UIDs从服务层获取相应的分类和标签对象。</li><li>将分类和标签对象转换成Map，方便后续根据UID快速查找。</li><li>再次遍历博客列表，为每个博客设置对应的分类和标签列表。</li><li>最后，将更新后的博客列表设置回分页结果对象中。</li></ol><p>这个过程允许在返回博客列表之前丰富每个博客对象的信息，如添加分类和标签数据。以便提供更详细的信息给前端显示。</p><blockquote><p>添加博客</p></blockquote><p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>业务场景和技术选型</title>
    <link href="/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    <url>/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="业务场景和技术选型需要考虑的因素"><a href="#业务场景和技术选型需要考虑的因素" class="headerlink" title="业务场景和技术选型需要考虑的因素"></a>业务场景和技术选型需要考虑的因素</h3><h3 id="成长和思考"><a href="#成长和思考" class="headerlink" title="成长和思考"></a>成长和思考</h3><h4 id="1、当小A-接到需求后的反应-🏌️"><a href="#1、当小A-接到需求后的反应-🏌️" class="headerlink" title="1、当小A 接到需求后的反应 🏌️"></a>1、当小A 接到需求后的反应 🏌️</h4><p>对于一个需求来说，我们应该站在一个评审的态度去看待他。</p><p>接到产品经理的需求后，我们应该从有利于业务的角度出发思考，对这个需求进行删、改、增。</p><p>同时最重要的一个地方是，你需要有自己的一个思考和自己的实践，并去落实他和推动一些东西，让你的思考能够落地并看到成效。</p><p>有自己的思考和整体业务的理解，将有助于你整体的一个职业生涯，对于你目前所做的事情，也许在未来某个地方，能够结合你当时的一个背景，做出有点酷并很有用的东西。</p><h4 id="2、提高某件事情的效率-🦖"><a href="#2、提高某件事情的效率-🦖" class="headerlink" title="2、提高某件事情的效率  🦖"></a>2、提高某件事情的效率  🦖</h4><p>对于项目中的现成代码，我们应该去理性思考，</p><ul><li>第一，这些代码为什么这么写呢，写的逻辑是什么，有什么好处呢。</li><li>第二，这些代码能够优化吗，哪些地方存在瓶颈呢，如何优化。优化的解决方案有哪些，我们应该怎么处理。</li><li>第三，保持持续学习，了解程序实现的底层逻辑，对于计算机操作系统、数据结构、组成原理等能够有比较好的认识和理解。</li><li>第四，对于 ToC  的项目，我们应该考虑一下服务 QPS 能支撑多少，心里对于流量阈值有一个清楚认知，针对这个阈值如何提高优化，性能是否符合预期，是一个需要考虑很多方面和内容的问题。</li><li>第五，对于生产环境和测试环境的区别，是非常大的，生产环境遇到的复杂性问题，我们需要随时养成关注线上服务运行的一个情况；一些基础的内容，比如请求峰值的时候 CPU、内存的消耗、网络端口消耗等都是我们需要去关注的一些点，并在实践中养成这个习惯。</li><li>第六，了解整个项目整体业务，不要给自己的工作设定边界。</li><li>第七，归纳总结复盘。</li></ul><p>关于第二点，在 JavaGuide 网站文章中一句话写的很好，借鉴引用一下：</p><div style="background-color: #3498db; color: white; padding: 10px;">   主动思考一下现有工作中哪些地方效率有改进的空间，想到了就主动去改进它！</div><h4 id="3、学习的时候一些坑不要去碰-🤕"><a href="#3、学习的时候一些坑不要去碰-🤕" class="headerlink" title="3、学习的时候一些坑不要去碰 🤕"></a>3、学习的时候一些坑不要去碰 🤕</h4><ul><li>多去看官方文档，多去看实际的源码，尽量少的去看一下垃圾博客</li><li>关注细节</li><li>及时反馈</li><li>规范，以及规范（代码，注释，接口，方法名称，文档，技术名称，日志，测试）</li><li>多实际去写代码（不要一说就会，一写就废）</li><li>重要的变更和接口内容一定要写文档</li><li>理解需求后，再开始写代码</li><li>多思考，有自己的理解后再去询问一些东西（积极沟通）</li><li>生产环境不要动</li></ul><h3 id="未来就业方向选择"><a href="#未来就业方向选择" class="headerlink" title="未来就业方向选择"></a>未来就业方向选择</h3><p>在目前这种趋势的未来中，对于顶层设计的要求从业人员其实是越来越高的，需求量也要减少（已经有很多现成的解决方案），未来的就业市场需要的反而是中低层人员，而随着GPT等人工智能的发展，技术人员的可替代性其实是很强的。</p><div style="background: linear-gradient(to right, #6dd5fa, #ff758c); color: white; padding: 15px;">  义无反顾的抓住每一个管理岗机会。</div><ul><li>驾驭管理<ul><li>模仿周围优秀管理者</li><li>找机会锻炼 展示能力</li></ul></li><li>顶层架构<ul><li>大量研读吸收  架构设计方案</li></ul></li></ul><p>推荐书籍：《软件平台管理架构设计与技术管理之道》</p>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>project</tag>
      
      <tag>thinking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker入门_Docker的基本使用</title>
    <link href="/2023/12/08/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/08/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、安装-Docker操作-centos系列安装"><a href="#1、安装-Docker操作-centos系列安装" class="headerlink" title="1、安装 Docker操作 (centos系列安装)"></a>1、安装 Docker操作 (centos系列安装)</h3><p>安装操作</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs vim">yum install -<span class="hljs-keyword">y</span> yum-utils<br><br>yum-config-manager --<span class="hljs-built_in">add</span>-repo http://mirrors.aliyun.<span class="hljs-keyword">com</span>/docker-<span class="hljs-keyword">ce</span>/linux/centos/docker-<span class="hljs-keyword">ce</span>.repo<br><br><br>yum install docker-<span class="hljs-keyword">ce</span> docker-<span class="hljs-keyword">ce</span>-cli containerd.io<br></code></pre></td></tr></table></figure><p>启动docer并设置开机自启</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl start docker<br><br><span class="hljs-params">system</span>ctl enable docker<br></code></pre></td></tr></table></figure><p>docker配置加速度</p><p>修改 &#x2F;etc&#x2F;docker&#x2F;daemon.json 文件并添加上 registry-mirrors 键值；注册阿里云，可获取自己的加速器</p><p>容器镜像服务 →  容器加速器</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs prolog">&#123;. <br>    <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p>docker安装验证</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">docker <span class="hljs-comment">--version</span><br></code></pre></td></tr></table></figure><h3 id="2、docker-compose安装"><a href="#2、docker-compose安装" class="headerlink" title="2、docker-compose安装"></a>2、docker-compose安装</h3><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来配置应用程序需要的所有服务。</p><p>使用一个命令，就可以从 YML 文件配置中创建并启动所有服务</p><blockquote><p>安装操作</p></blockquote><p>先需要下载一下二进制文件</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/docker/</span>compose<span class="hljs-regexp">/releases/</span>download<span class="hljs-regexp">/v2.5.0/</span>docker-compose-linux-x86_64<br></code></pre></td></tr></table></figure><p>放入&#x2F;usr&#x2F;local&#x2F;bin&#x2F; 路径下并重新命名添加可执行权限</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">mv</span> docker-compose-linux-x86_64 docker-compose<br><span class="hljs-built_in">chmod</span> +x docker-compose<br></code></pre></td></tr></table></figure><p>这个也可以推荐看一下</p><p>将脚本下载，阿里云的下载速度较快，推荐适用</p><p><a href="https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/">https://mirrors.aliyun.com/docker-toolbox/linux/compose/1.21.2/</a></p><p>把脚本放在&#x2F;usr&#x2F;local&#x2F;bin&#x2F;下.名字为docker-compose ,加执行权限 ，docker-compose命令就有了</p><h3 id="3、docker-安装-redis-操作"><a href="#3、docker-安装-redis-操作" class="headerlink" title="3、docker 安装 redis 操作"></a>3、docker 安装 redis 操作</h3><p>安装 Redis 使用 Docker 是一个非常简单且快捷的过程。以下是通过 Docker 安装和运行 Redis 的基本步骤：</p><ol><li><p><strong>拉取 Redis 镜像</strong>： 首先，你需要从 Docker Hub 拉取最新的 Redis 镜像。打开命令行界面，然后输入以下命令：</p><p> <code>docker pull redis</code></p><p> 这个命令会从 Docker Hub 下载最新的 Redis 镜像。</p></li><li><p><strong>运行 Redis 容器</strong>： 接着，使用以下命令来启动一个 Redis 容器：</p><p> <code>docker run --name redis -d redis</code></p><p> 这里，<code>--name redis</code> 设置容器的名称为 <code>some-redis</code>。你可以根据需要更改这个名称。<code>-d</code> 参数表示容器将在后台运行。</p></li><li><p><strong>暴露和映射端口</strong>（可选）： 如果你打算从宿主机外部访问 Redis，你需要映射端口。Redis 默认端口是 <code>6379</code>，所以你可以这样映射端口：</p><p> <code>docker run --name redis -d -p 6379:6379 redis</code></p><p> <code>-p 6379:6379</code> 表示将容器的 6379 端口映射到宿主机的 6379 端口。</p></li><li><p><strong>访问 Redis</strong>： 一旦 Redis 容器在运行，你可以通过 Redis 客户端或任何支持 Redis 的程序访问它。如果你只是在本地机器上运行和访问 Redis，你可以通过 <code>localhost:6379</code> 来访问它。</p></li><li><p><strong>使用 Redis CLI 进行交互</strong>（可选）： 如果你想要通过 Redis 命令行界面与 Redis 容器交互，可以使用以下命令进入 Redis 容器：</p><p> <code>docker exec -it some-redis redis-cli</code></p></li></ol><p>小结：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">docker pull redis<br>docker <span class="hljs-keyword">run</span><span class="language-bash"> --name redis -d -p 6379:6379 redis</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=6379/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_45868731/article/details/131743699">https://blog.csdn.net/qq_45868731/article/details/131743699</a></li><li><a href="https://blog.csdn.net/ninimino/article/details/113388745">https://blog.csdn.net/ninimino/article/details/113388745</a></li><li><a href="https://blog.csdn.net/weixin_45821811/article/details/116211724">https://blog.csdn.net/weixin_45821811/article/details/116211724</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_进阶内容</title>
    <link href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是线程模型？"><a href="#1、什么是线程模型？" class="headerlink" title="1、什么是线程模型？"></a>1、什么是线程模型？</h3><blockquote><p>先回顾一下线程和进程的区分</p></blockquote><ul><li>进程：<ul><li>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul></li><li>线程<ul><li>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><blockquote><p>什么是线程模型</p></blockquote><p>并发编程在计算机中如何实现的，在 Java 开发领域中，JVM线程对不同操作系统上的原生线程进行了高级抽象，使开发者大多数情况下可以不用关注下层细节，而只要专注上层开发。</p><p>JVM线程与操作系统线程之间存在着某种映射关系，这两种<strong>不同维度的线程之间的规范和协议</strong>，就是线程模型。</p><blockquote><p>用户线程和内核线程</p></blockquote><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><blockquote><p>线程模型类型</p></blockquote><p>JVM线程模型有三种模型：一对一、多对一、多对多。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161619698.png" alt="image.png"></p><p><strong>一对一</strong></p><p>在Jva线程（用户线程）与操作系统线程(KLT)之间建立一对一的关系，简单粗暴，但好用。</p><ul><li>优点：<ul><li>每个线程都是独立的调度单元，直接利用操作系统内核提供的调度功能。</li></ul></li><li>缺点：<ul><li>用户线程的阻塞唤醒，会直接映射到内核线程上，容易<strong>引起频繁切换，降低性</strong>能。但是一些语言引入了CAS来避免一部分的内核调用，比如Java 引入了AQS这种函数级别的锁，<strong>减少使用内核级别的锁</strong>，就能提升性能。</li></ul></li></ul><p>目前大部分主流 JVM 上都是采用的这种线程模型。</p><p><strong>多对一模型</strong></p><ul><li>优点<ul><li>用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快：</li></ul></li><li>缺点<ul><li>如果其中一个用户线程阻塞，其他用户线程也无法执行</li><li>这种模型下，内核并不知道用户态有哪些线程，调度和优先级等不完整。</li></ul></li></ul><p><strong>多对多模型</strong></p><ul><li>优点：兼具前两者的优点</li><li>缺点：实现复杂</li></ul><p>目前主流语言中，Java 使用的是 一对一线程模型；Go 语言使用的是 多对多线程模型；Python 的 gevent 使用的多对一线程模型。</p><h3 id="2、悲观锁机制"><a href="#2、悲观锁机制" class="headerlink" title="2、悲观锁机制"></a>2、悲观锁机制</h3><p>在了解悲观锁机制前，我们先来了解一下什么是锁。</p><h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>在并发环境下，会出现多个线程对同一个资源进行争抢的情况，假设A线程对资源正在进行修改，此时<br>B线程此时又对资源进行了修改，这就可能会导致数据不一致的问题。</p><p>为了解决这个问题，引入了锁机制，<strong>通过一种抽象的“锁”来对资源进行锁定</strong>，当一个线程持有“锁”的时候，其他线程必须等待“锁”，本质上是在临界资源上对线程进行一种串行化。</p><h4 id="Java语言的锁机制"><a href="#Java语言的锁机制" class="headerlink" title="Java语言的锁机制"></a>Java语言的锁机制</h4><blockquote><p>Java 虚拟机的内存结构</p></blockquote><p>在了解 Java语言锁机制之前，我们先对简单了解一下 Java 虚拟机的内存结构。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116222015.png" alt="image.png"></p><p>JVM 运行时内存结构主要包含了五个部分：</p><ul><li>程序计数器(PC寄存器)、</li><li>JVM栈、</li><li>Native方法栈、</li><li>堆、</li><li>方法区。</li></ul><p>上图中，红色区域是各个线程私有的。这个区域中的数据，不会出现线程竞争的关系。</p><p>而蓝色区域中的数据被所有线程共享，其中Jva堆中存放的是大量对象，方法区中<strong>存放类信息、常量、静态变<br>量</strong>等数据。</p><p>当多个线程在竞争其中的一些数据时，可能会发生难以预料的异常情况。在程序开发中，锁的主要应用范围就是在数据共享区域。</p><p>在代码层面，Jvva 主要采用了两种实现方式：</p><ul><li>1.基于Object的悲观锁。</li><li>2.基于CAS的乐观锁。</li></ul><p>本章主要讲解基于Object的悲观锁。</p><blockquote><p>悲观锁机制</p></blockquote><p>悲观锁总是假设最坏的情况，认为共享资源<strong>每次被访问的时候就会出现问题</strong>(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。</p><p>也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><blockquote><p>基于Object的悲观锁</p></blockquote><p>在Java中，每个Object,也就是每个对象都拥有一把锁，这把锁存放在对象头中，记录了当前对象被哪个线程占用。</p><blockquote><p>对象和对象头的结构</p></blockquote><p><strong>Java 对象</strong></p><p>Java对象分为三个部分：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充字节</li></ul><p>其中对齐填充字节是为了满足“Java对象大小是8字节的倍数”这一条件而设计的，为对象对齐填充了一些无用字节。</p><p>实例数据是在初始化对象时设定的属性和状态等内容。</p><p><strong>对象头</strong></p><p>对象头存放了一些对象本身的运行时信息。对象头包含了两部分：</p><ul><li>Mark Word</li><li>Class Pointer</li></ul><p>相较于实例数据，对象头属于一些额外的存储开销，它被设计得极小（一般为232bt或264bt) 来提升效率。</p><p>Class Pointer是一个指针，指向当前对象类型所在方法区中的Class信息；</p><p>Mark Word 存储了<strong>很多当前对象的运行时状态信息</strong>，比如 HashCode.、锁状态标志、指向锁记录的指针、偏向线程 ID、锁标志位等等。</p><p>可以通过下面这张表对 Mark Word有一个更直观的认识：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116223405.png" alt="image.png"></p><p>“锁”的信息存储在对象头的Mark Word中。Mark Word 的最后两位，代表锁标志位，分别对应“无锁”、“偏向锁”、“轻量级锁”、“重量级锁”四种状态。</p><p>在Java中，启用对象锁的方式是使用<code>synchronized</code>关键字。</p><h4 id="对象锁的四种状态"><a href="#对象锁的四种状态" class="headerlink" title="对象锁的四种状态"></a>对象锁的四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p><p>锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><h3 id="3、乐观锁机制"><a href="#3、乐观锁机制" class="headerlink" title="3、乐观锁机制"></a>3、乐观锁机制</h3><p>在多个线程对于同一个资源进行访问的访问，互斥锁的方式是悲观的，在线程访问的时候，互斥锁会锁定资源，<strong>只供一个线程调用，而阻塞其他线程</strong>，让其他线程等待。</p><p>在一些情况下，同步代码块执行的耗时远远小于线程切换的耗时，这种情况下使用互斥锁对性能是不太划算的。在这种场景下，直接在用户态对线程的切换进行管理，效率更高。实际操作的时候是通过每次使用同步原语对共享资源进行锁定，让线程反复“乐观”地去尝试获取共享资源，如果发现空闲，那么使用，如果被占用，那么继续“乐观”地重试。</p><blockquote><p>乐观锁和悲观锁<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231207231904.png" alt="image.png"></p></blockquote><blockquote><p>CAS</p></blockquote><p>在 Java 中，实现这种同步原语的算法是 CAS (Compare And Swap)。</p><p>简单翻译是：比较然后交换</p><p>CAS操作包含三个操作数：内存位置（要更新的变量）、预期原值和新值。</p><p><strong>工作原理</strong></p><ol><li><strong>检查和更新</strong>：<ul><li>CAS首先检查<strong>目标内存位置的当前值</strong>是否与预期原值相同。如果相同，它会将该内存位置的值更新为新值。</li><li>如果目标值已被其他线程改变（不等于预期原值），CAS操作失败。</li></ul></li><li><strong>无锁操作</strong>：<ul><li>CAS提供了一种无需锁定的方式来实现并发控制，减少了锁的开销和复杂性。</li></ul></li></ol><div style="border: 1px solid #999; border-radius: 5px; padding: 10px;">    CAS操作是原子性的。</div><h3 id="4、悲观锁和乐观锁"><a href="#4、悲观锁和乐观锁" class="headerlink" title="4、悲观锁和乐观锁"></a>4、悲观锁和乐观锁</h3><h4 id="悲观锁示例"><a href="#悲观锁示例" class="headerlink" title="悲观锁示例"></a>悲观锁示例</h4><p>在Java中，悲观锁通常是通过<code>synchronized</code>关键字或<code>ReentrantLock</code>类实现的。</p><p><code>synchronized</code> 使用示例：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> PessimisticLockExample &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">count</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> increment() &#123;<br>        <span class="hljs-keyword">count</span>++;  <span class="hljs-comment">// 仅当持有对象锁时，才能执行此操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">int</span> getCount() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">count</span>;  <span class="hljs-comment">// 同样，需要持有对象锁才能执行</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，我们用<code>synchronized</code>关键字锁定了整个方法。</p><p>当一个线程进入<code>increment</code>或<code>getCount</code>方法时，它必须先获得这个对象的锁。在这段时间内，其他任何试图进入这些同步方法的线程都会被阻塞。</p><h4 id="乐观锁示例"><a href="#乐观锁示例" class="headerlink" title="乐观锁示例"></a>乐观锁示例</h4><p>乐观锁通常是通过CAS（比较并交换）操作实现的。</p><p>在Java中，<code>AtomicInteger</code>类提供了一种使用乐观锁的方式。以下是一个使用<code>AtomicInteger</code>实现乐观锁的示例：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">import</span> java.util.concurrent.atomic.AtomicInteger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">OptimisticLockExample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AtomicInteger count = <span class="hljs-keyword">new</span> <span class="hljs-type">AtomicInteger</span>(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">public</span> void increment() &#123;<br>        int currentValue;<br>        int <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            currentValue = count.<span class="hljs-keyword">get</span>(); <span class="hljs-comment">// 获取当前值</span><br>            <span class="hljs-keyword">new</span><span class="hljs-type">Value</span> = currentValue + <span class="hljs-number">1</span>; <span class="hljs-comment">// 计算新值</span><br>        &#125; <span class="hljs-keyword">while</span> (!count.compareAndSet(currentValue, <span class="hljs-keyword">new</span><span class="hljs-type">Value</span>)); <span class="hljs-comment">// CAS操作</span><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int getCount() &#123;<br>        <span class="hljs-keyword">return</span> count.<span class="hljs-keyword">get</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>AtomicInteger</code>的<code>compareAndSet</code>方法实现了CAS操作。</p><p>它会比较<code>count</code>的当前值和<code>currentValue</code>。如果相同，它会更新<code>count</code>为<code>newValue</code>。这个过程是无锁的，即使在并发环境下也不会阻塞其他线程。如果<code>count</code>的值在此期间被其他线程修改，<code>compareAndSet</code>会返回<code>false</code>，循环继续，直到更新成功。</p><blockquote><p>对比</p></blockquote><ul><li><strong>悲观锁</strong>（<code>synchronized</code>，<code>ReentrantLock</code>）适用于写操作多的场景，因为它防止了多个线程同时写入，减少了冲突。</li><li><strong>乐观锁</strong>（如<code>AtomicInteger</code>的CAS操作）适用于读操作多的场景，它不会阻塞线程，但在写操作频繁的情况下可能会导致高重试成本。</li></ul><h3 id="5、ReentrantLock"><a href="#5、ReentrantLock" class="headerlink" title="5、ReentrantLock"></a>5、ReentrantLock</h3><h4 id="ReentrantLock-的基础使用"><a href="#ReentrantLock-的基础使用" class="headerlink" title="ReentrantLock 的基础使用"></a>ReentrantLock 的基础使用</h4><p>在并发编程中，悲观锁是一种策略，它假设最坏的情况：即在多个线程尝试同时访问共享资源时，会发生冲突。因此，悲观锁在访问任何共享资源之前会先锁定它，以防止其他线程的访问，直到它完成操作并释放锁。</p><blockquote><p>ReentrantLock（可重入锁）</p></blockquote><p><code>ReentrantLock</code> 是一个可重入的互斥锁，它提供了比 <code>synchronized</code> 关键字更高级的功能，如可中断的锁获取操作、公平锁策略、锁绑定多个条件等。</p><blockquote><p>基于 AQS 的实现</p></blockquote><ul><li>AQS 提供了一种管理锁状态的框架，并处理了线程的排队和阻塞。在 <code>ReentrantLock</code> 的实现中，AQS 负责维护一个表示锁状态的变量和一个由等待锁的线程组成的队列。</li><li>当一个线程尝试获取 <code>ReentrantLock</code> 时，AQS 会检查锁的状态，然后要么授予锁（如果当前未被其他线程持有），要么将尝试获取锁的线程放入等待队列。</li></ul><blockquote><p>悲观锁的特性</p></blockquote><ul><li><code>ReentrantLock</code> 作为一种悲观锁，是基于这样的假设：如果不采取措施，多个线程同时修改同一个资源会导致问题。因此，它在修改资源之前先加锁，防止其他线程同时进行写操作。</li><li>这与乐观锁的策略不同，乐观锁允许多个线程进入临界区，但在实际修改数据时检查是否存在冲突。</li></ul><p>示例</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs csharp">import java.util.concurrent.locks.ReentrantLock;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLockExample</span> &#123;<br>    <span class="hljs-keyword">private</span> final ReentrantLock <span class="hljs-keyword">lock</span> = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-keyword">private</span> <span class="hljs-built_in">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">increment</span>()</span> &#123;<br>        <span class="hljs-keyword">lock</span>.<span class="hljs-keyword">lock</span>();  <span class="hljs-comment">// 获取锁</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            count++;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">lock</span>.unlock();  <span class="hljs-comment">// 释放锁</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">getCount</span>()</span> &#123;<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，我们在修改 <code>count</code> 变量之前获取了锁，并在操作完成后释放了锁。</p><p>这确保了即使多个线程尝试同时调用 <code>increment</code> 方法，<code>count</code> 的增加也是线程安全的。</p><h4 id="ReentrantLock-的实现原理"><a href="#ReentrantLock-的实现原理" class="headerlink" title="ReentrantLock 的实现原理"></a>ReentrantLock 的实现原理</h4><p><code>ReentrantLock</code> 是 Java 并发包中的一个重要组件，基于 AQS 实现。</p><p>基本原理</p><ol><li><strong>可重入性</strong>：<ul><li><code>ReentrantLock</code> 是一个可重入锁。这意味着同一个线程可以多次获取同一个锁而不会发生死锁。这是通过为每个锁维护一个持有计数和一个指向当前持有锁的线程的引用来实现的。</li></ul></li><li><strong>基于 AQS</strong>：<ul><li><code>ReentrantLock</code> 的实现依赖于 AQS。AQS 使用一个整型的 volatile 变量来表示同步状态，并使用一个 FIFO 队列来管理那些等待获取锁的线程。</li></ul></li><li><strong>锁的状态</strong>：<ul><li>在 <code>ReentrantLock</code> 中，锁的状态是由 AQS 的同步状态变量来表示的。状态为 0 表示锁是可用的，状态为 1 表示锁被一个线程持有，大于 1 表示同一个线程重入了这个锁。</li></ul></li><li><strong>获取锁</strong>：<ul><li>当一个线程尝试获取锁时，如果同步状态为 0，AQS 会尝试通过 CAS（比较并交换）操作将状态设置为 1，从而获取锁。</li><li>如果锁已经被其他线程持有（同步状态非 0），那么尝试获取锁的线程会被加入到 AQS 维护的等待队列中。</li></ul></li><li><strong>释放锁</strong>：<ul><li>当线程完成任务后，它会调用 <code>unlock</code> 方法来释放锁。这将减少 AQS 同步状态的计数。当计数降到 0 时，锁被完全释放，等待队列中的下一个线程将有机会获取锁。</li></ul></li></ol><p>公平性和非公平性</p><ul><li><strong>公平锁</strong>：在公平模式下，<code>ReentrantLock</code> 会按照线程在等待队列中的等待顺序来获取锁。这意味着首先进入等待队列的线程将先获得锁。</li><li><strong>非公平锁</strong>：在非公平模式下，当锁可用时，任何请求它的线程都有机会获取锁。这可能不会遵守等待队列中的顺序。</li></ul><p>性能考量</p><ul><li><strong>选择公平性</strong>：公平锁通常会有较低的性能，因为它严格按照等待队列来分配锁，但它可以减少线程饥饿的情况。</li><li><strong>选择非公平性</strong>：非公平锁可能会有更好的性能，但可能导致线程饥饿，因为某些线程可能会长时间等待而不得不频繁地重新调度。</li></ul><p><code>ReentrantLock</code> 提供了一种灵活的锁定机制，通过 AQS 实现了可重入性和可选的公平性。</p><p>它允许更细粒度的锁控制，从而在高度竞争的环境中提供比内置 <code>synchronized</code> 更高的性能和更强的功能。</p><h4 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h4><h5 id="ReentrantLock-类结构"><a href="#ReentrantLock-类结构" class="headerlink" title="ReentrantLock 类结构"></a>ReentrantLock 类结构</h5><p><code>ReentrantLock</code> 本身是一个相对简单的类，它依赖于内部类 <code>Sync</code> 的实现，而 <code>Sync</code> 是 <code>AbstractQueuedSynchronizer</code> 的子类。</p><p>在 <code>ReentrantLock</code> 中，有两个主要的内部类：<code>FairSync</code> 和 <code>NonfairSync</code>，分别对应公平锁和非公平锁的实现。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-title">implements</span> <span class="hljs-title">Lock</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Sync</span> sync;<br><br>    <span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-comment">// ... 实现细节</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 非公平锁实现</span><br>    &#125;<br><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>        <span class="hljs-comment">// ... 公平锁实现</span><br>    &#125;<br><br>    <span class="hljs-comment">// 构造函数等其他方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="Sync-类"><a href="#Sync-类" class="headerlink" title="Sync 类"></a>Sync 类</h5><p><code>Sync</code> 类是 <code>AbstractQueuedSynchronizer</code> 的一个扩展，提供了大部分与锁状态管理相关的功能。</p><p>它使用 AQS 的状态变量来表示锁的持有次数，以及持有锁的线程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">abstract</span> static <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean isHeldExclusively() &#123;<br>        <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == <span class="hljs-type">Thread</span>.currentThread();<br>    &#125;<br><br>    <span class="hljs-keyword">final</span> void lock() &#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 其他方法，包括 tryAcquire, tryRelease 等</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="公平锁和非公平锁的实现"><a href="#公平锁和非公平锁的实现" class="headerlink" title="公平锁和非公平锁的实现"></a>公平锁和非公平锁的实现</h5><p><code>FairSync</code> 和 <code>NonfairSync</code> 类重写了 <code>tryAcquire</code> 方法以提供不同的锁获取策略。</p><ul><li><strong>非公平锁</strong>（<code>NonfairSync</code>）：在尝试获取锁时，会立即尝试改变状态，而不检查等待队列。</li><li><strong>公平锁</strong>（<code>FairSync</code>）：在尝试获取锁之前，会检查等待队列，以确保队列中的线程先获得服务。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现非公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br><br>static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> boolean tryAcquire(int acquires) &#123;<br>        <span class="hljs-comment">// 实现公平的锁获取逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="AbstractQueuedSynchronizer（AQS）"><a href="#AbstractQueuedSynchronizer（AQS）" class="headerlink" title="AbstractQueuedSynchronizer（AQS）"></a>AbstractQueuedSynchronizer（AQS）</h5><p>AQS 是实现锁和其他同步器的框架。它使用一个 int 类型的 volatile 变量来表示同步状态，并使用一个队列来管理那些未能成功获取同步状态的线程。</p><ul><li><strong>状态管理</strong>：AQS 提供了一系列方法来操作其状态变量，如 <code>getState()</code>, <code>setState(int)</code> 和 <code>compareAndSetState(int, int)</code>。</li><li><strong>队列管理</strong>：AQS 维护了一个等待队列，当线程尝试获取资源失败时，它会被加入到这个队列中。</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span> <span class="hljs-title">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> head;<br>    <span class="hljs-keyword">private</span> transient volatile <span class="hljs-type">Node</span> tail;<br>    <span class="hljs-keyword">private</span> volatile int state;<br><br>    <span class="hljs-comment">// 内部类 Node，队列节点的定义</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-comment">// Node 的结构和方法</span><br>    &#125;<br><br>    <span class="hljs-comment">// 状态管理和队列操作的方法</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="锁的获取与释放"><a href="#锁的获取与释放" class="headerlink" title="锁的获取与释放"></a>锁的获取与释放</h5><ul><li><strong>获取锁</strong>：当 <code>ReentrantLock</code> 的 <code>lock()</code> 方法被调用时，实际上是调用了 <code>Sync</code> 类的 <code>acquire</code> 方法，该方法又会调用 <code>tryAcquire</code> 方法。<code>tryAcquire</code> 的具体实现取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>。</li><li><strong>释放锁</strong>：<code>unlock()</code> 方法调用 <code>Sync</code> 类的 <code>release</code> 方法，进而调用<code>tryRelease</code> 方法。这个方法会更新同步状态，并在状态变为 0 时（即锁被完全释放时），唤醒等待队列中的线程.</li></ul><h5 id="获取锁的过程"><a href="#获取锁的过程" class="headerlink" title="获取锁的过程"></a>获取锁的过程</h5><ol><li>当一个线程调用 <code>lock()</code> 方法时，它实际上调用的是 <code>Sync</code> 类中的 <code>acquire(int)</code> 方法。</li><li><code>acquire(int)</code> 方法会调用重写的 <code>tryAcquire(int)</code> 方法（取决于是 <code>FairSync</code> 还是 <code>NonfairSync</code>）。<ul><li>在 <code>NonfairSync</code> 中，它会立即尝试获取锁，不管其他线程是否在等待。</li><li>在 <code>FairSync</code> 中，它会先检查队列，以确保没有其他线程在等待时间更长。</li></ul></li></ol><h5 id="释放锁的过程"><a href="#释放锁的过程" class="headerlink" title="释放锁的过程"></a>释放锁的过程</h5><ol><li>当线程调用 <code>unlock()</code> 方法时，实际上是调用 <code>Sync</code> 类的 <code>release(int)</code> 方法。</li><li><code>release(int)</code> 方法内部会调用 <code>tryRelease(int)</code> 方法，该方法检查当前线程是否是锁的持有者，并尝试将同步状态设置回 0。</li><li>如果同步状态成功设置回 0，表示锁已经被释放，等待队列中的其他线程可能会被唤醒并尝试获取锁。</li></ol><h5 id="AQS-中的等待队列"><a href="#AQS-中的等待队列" class="headerlink" title="AQS 中的等待队列"></a>AQS 中的等待队列</h5><p>AQS 使用一个内部的 FIFO 队列来管理那些无法获取到锁的线程。</p><p>每个节点代表一个线程。当一个线程无法获取到锁时，它会被包装成一个节点加入到队列的末尾。当锁被释放时，队列头部的节点会被唤醒并尝试再次获取锁。</p><h5 id="CAS-在-AQS-中的使用"><a href="#CAS-在-AQS-中的使用" class="headerlink" title="CAS 在 AQS 中的使用"></a>CAS 在 AQS 中的使用</h5><p>AQS 使用 CAS 操作来安全地修改同步状态。这是一种无锁的原子操作，可以保证即使在多个线程同时尝试修改状态时，同步状态的更新也是一致的。</p><blockquote><p>总结</p></blockquote><p><code>ReentrantLock</code> 的实现依赖于 AQS 的强大功能，提供了一种灵活且高效的方式来处理并发编程中的同步问题。</p><p>通过将锁的具体实现细节委托给 AQS，<code>ReentrantLock</code> 不仅提供了基本的锁功能，还支持如公平性&#x2F;非公平性选择、条件变量、以及锁的可重入性等高级特性。</p><hr><p>参考:</p><ul><li><a href="https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866">https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866</a></li><li><a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></li><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.bilibili.com/video/BV1z44y1X7BJ">https://www.bilibili.com/video/BV1z44y1X7BJ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_SpringMVC</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是SpringMVC"><a href="#1、什么是SpringMVC" class="headerlink" title="1、什么是SpringMVC"></a>1、什么是SpringMVC</h3><p>SpringMVC是Spring框架中的一个模块，用于构建Web应用程序，采用了经典的MVC设计模式。</p><p>MVC英文是Model View Controller，是模型(model)－视图(view)－控制器(controller)的缩写，一种软件设计规范。本质上也是一种解耦。核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><ol><li><strong>模型（Model）：</strong><ul><li>模型代表应用程序的业务逻辑和数据。在SpringMVC中，模型通常是一个POJO（Plain Old Java Object）类，负责封装业务数据。</li><li>模型对象存储应用程序的状态，与数据库进行交互，执行业务逻辑等。</li></ul></li><li><strong>视图（View）：</strong><ul><li>视图负责渲染模型数据并展示给用户。在SpringMVC中，视图通常是JSP（JavaServer Pages）或Thymeleaf等模板引擎。</li><li>视图负责将模型的数据以用户友好的方式呈现，与用户进行交互。</li></ul></li><li><strong>控制器（Controller）：</strong><ul><li>控制器接收用户的请求并决定调用哪个业务逻辑处理方法。在SpringMVC中，控制器通常是一个类，使用注解来标识处理请求的方法。</li><li>控制器处理请求后，调用适当的业务逻辑，获取或更新模型数据，然后选择合适的视图来渲染响应。</li></ul></li><li><strong>前端控制器（Front Controller）：</strong><ul><li>SpringMVC 使用DispatcherServlet作为前端控制器，它是Servlet的一个子类，负责拦截所有进入应用的请求。</li><li>DispatcherServlet将请求分发给相应的处理器（Controller），并将模型数据传递给合适的视图进行渲染。</li></ul></li><li><strong>处理器映射器和视图解析器：</strong><ul><li>处理器映射器负责将请求映射到合适的控制器，根据请求URL找到对应的处理器。</li><li>视图解析器负责将逻辑视图名解析为实际的视图对象，决定使用哪个视图来呈现模型数据。</li></ul></li></ol><h3 id="2、SpringMVC的核心组件"><a href="#2、SpringMVC的核心组件" class="headerlink" title="2、SpringMVC的核心组件"></a>2、SpringMVC的核心组件</h3><ul><li><strong><code>DispatcherServlet</code><strong>：</strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li><strong><code>HandlerMapping</code><strong>：</strong>处理器映射器</strong>，根据 URL 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><strong><code>HandlerAdapter</code><strong>：</strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li><strong><code>Handler</code><strong>：</strong>请求处理器</strong>，处理实际请求的处理器。</li><li><strong><code>ViewResolver</code><strong>：</strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 &#x2F; 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h3 id="3、SpringMVC的工作原理"><a href="#3、SpringMVC的工作原理" class="headerlink" title="3、SpringMVC的工作原理"></a>3、SpringMVC的工作原理</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312061453227.png" alt="image.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>客户端（浏览器）发送请求， <code>DispatcherServlet</code>拦截请求。</li><li><code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code> 。<code>HandlerMapping</code> 根据 URL 去匹配查找能处理的 <code>Handler</code>（也就是我们平常说的 <code>Controller</code> 控制器） ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li><code>DispatcherServlet</code> 调用 <code>HandlerAdapter</code>适配器执行 <code>Handler</code> 。</li><li><code>Handler</code> 完成对用户请求的处理后，会返回一个 <code>ModelAndView</code> 对象给<code>DispatcherServlet</code>，<code>ModelAndView</code> 顾名思义，包含了数据模型以及相应的视图的信息。<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li><li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li><li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code>（视图渲染）。</li><li>把 <code>View</code> 返回给请求者（浏览器）</li></ol><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html">https://www.pdai.tech/md/spring/spring-x-framework-springmvc.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-mvc</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_AOP</title>
    <link href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/"/>
    <url>/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是AOP"><a href="#1、什么是AOP" class="headerlink" title="1、什么是AOP"></a>1、什么是AOP</h3><p>AOP（Aspect-Oriented Programming:面向切面编程）是一种编程范式，通过在代码中横向插入关注点（如日志、事务），实现对应用程序模块化、可维护性和可重用性的提升。</p><p>AOP 切面编程涉及到的一些专业术语：</p><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>目标(Target)</td><td>被通知的对象</td></tr><tr><td>代理(Proxy)</td><td>向目标对象应用通知之后创建的代理对象</td></tr><tr><td>连接点(JoinPoint)</td><td>目标对象的所属类中，定义的所有方法均为连接点</td></tr><tr><td>切入点(Pointcut)</td><td>被切面拦截 &#x2F; 增强的连接点（切入点一定是连接点，连接点不一定是切入点）</td></tr><tr><td>通知(Advice)</td><td>增强的逻辑 &#x2F; 代码，也即拦截到目标对象的连接点之后要做的事情</td></tr><tr><td>切面(Aspect)</td><td>切入点(Pointcut)+通知(Advice)</td></tr><tr><td>Weaving(织入)</td><td>将通知应用到目标对象，进而生成代理对象的过程动作</td></tr></tbody></table><h3 id="2、Spring-AOP-的实现"><a href="#2、Spring-AOP-的实现" class="headerlink" title="2、Spring AOP 的实现"></a>2、Spring AOP 的实现</h3><p>Spring AOP基于动态代理实现，</p><ul><li>对于实现了接口的对象，使用JDK Proxy创建代理对象；</li><li>对于未实现接口的对象，使用Cglib生成被代理对象的子类。</li></ul><p>Spring AOP还集成了AspectJ，AspectJ是Java生态系统中最完整的AOP框架，拥有更多功能，特别在切面较多的情况下，选择AspectJ相比Spring AOP更为高效。</p><p>to be contined…..</p><hr><p>参考</p><ul><li><a href="https://www.pdai.tech/md/spring/spring-x-framework-aop.html">https://www.pdai.tech/md/spring/spring-x-framework-aop.html</a></li><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html#spring-aop</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Stream</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/</url>
    
    <content type="html"><![CDATA[<p>Stream 组件是用于封装消息队列来使用的，Bus这个组件一般会结合 Stream 使用；</p><p>看一般性文档解释，主要是围绕 Bus 可以做到配置的动态刷新、事件的传递。具体使用的时候可以看一下相关内容。</p><p>下面内容是引用 ChatGpt 的内容，分别是 Stream 和 Bus 的基本使用。</p><h3 id="1、Spring-Cloud-Stream的使用"><a href="#1、Spring-Cloud-Stream的使用" class="headerlink" title="1、Spring Cloud Stream的使用"></a>1、Spring Cloud Stream的使用</h3><p>Spring Cloud Stream 是一个用于构建消息驱动微服务架构的框架，它基于Spring Boot和Spring Integration，提供了一种简单的方式来实现各个微服务组件之间的消息通信。</p><p>以下是Spring Cloud Stream的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的 <code>pom.xml</code> 文件中，添加 Spring Cloud Stream 的依赖：</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-stream-</span><span class="hljs-template-variable">&#123;binder&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span></span><br></code></pre></td></tr></table></figure><p><code>&#123;binder&#125;</code> 可以是不同的消息中间件的名称，比如 RabbitMQ、Kafka 等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在 <code>application.properties</code> 或 <code>application.yml</code> 文件中配置消息中间件的连接信息，以 RabbitMQ 为例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">stream:</span><br>      <span class="hljs-attr">bindings:</span><br>        <span class="hljs-attr">output:</span><br>          <span class="hljs-attr">destination:</span> <span class="hljs-string">my-output-topic</span><br>          <span class="hljs-attr">binder:</span> <span class="hljs-string">rabbit</span> <span class="hljs-comment"># RabbitMQ的binder</span><br>      <span class="hljs-attr">rabbit:</span><br>        <span class="hljs-attr">bindings:</span><br>          <span class="hljs-attr">output:</span><br>            <span class="hljs-attr">exchangeType:</span> <span class="hljs-string">topic</span><br>            <span class="hljs-attr">routingKeyExpression:</span> <span class="hljs-string">&#x27;my-output-topic&#x27;</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>发送消息</li></ol></blockquote><p>在应用程序中使用 <code>Source</code> 接口定义消息发送的输出通道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.annotation.Output;<br><span class="hljs-keyword">import</span> org.springframework.messaging.MessageChannel;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MySource</span> &#123;<br><br>    <span class="hljs-type">String</span> <span class="hljs-variable">OUTPUT</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;output&quot;</span>;<br><br>    <span class="hljs-meta">@Output(OUTPUT)</span><br>    MessageChannel <span class="hljs-title function_">output</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在需要发送消息的地方注入 <code>MySource</code>，并使用 <code>output()</code> 方法发送消息：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">beans</span>.<span class="hljs-property">factory</span>.<span class="hljs-property">annotation</span>.<span class="hljs-property">Autowired</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">Message</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">messaging</span>.<span class="hljs-property">support</span>.<span class="hljs-property">MessageBuilder</span>;<br><span class="hljs-keyword">import</span> org.<span class="hljs-property">springframework</span>.<span class="hljs-property">stereotype</span>.<span class="hljs-property">Service</span>;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageSenderService</span> &#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">MySource</span> mySource;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">sendMessage</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> payload</span>) &#123;<br>        <span class="hljs-title class_">Message</span>&lt;<span class="hljs-title class_">String</span>&gt; message = <span class="hljs-title class_">MessageBuilder</span>.<span class="hljs-title function_">withPayload</span>(payload).<span class="hljs-title function_">build</span>();<br>        mySource.<span class="hljs-title function_">output</span>().<span class="hljs-title function_">send</span>(message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="4"><li>接收消息</li></ol></blockquote><p>在应用程序中使用 <code>@StreamListener</code> 注解定义消息接收的输入通道：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.stream.<span class="hljs-keyword">annotation</span>.StreamListener;<br><span class="hljs-keyword">import</span> org.springframework.messaging.handler.<span class="hljs-keyword">annotation</span>.Payload;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageReceiverService</span> &#123;<br><br>    <span class="hljs-meta">@StreamListener(MySource.INPUT)</span><br>    <span class="hljs-keyword">public</span> void receiveMessage(<span class="hljs-meta">@Payload</span> String payload) &#123;<br>        System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;Received message: &quot;</span> + payload);<br>        <span class="hljs-comment">// 处理接收到的消息</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ol start="5"><li>运行时绑定</li></ol></blockquote><p>Spring Cloud Stream 会在运行时将消息通道绑定到消息中间件上，使得消息的发送和接收可以与底层的消息中间件解耦。根据配置的 <code>&#123;binder&#125;</code> 不同，可以支持 RabbitMQ、Kafka、ActiveMQ 等多种消息中间件。</p><p>通过以上步骤，你就可以使用 Spring Cloud Stream 在微服务中实现消息的发送和接收，从而构建消息驱动的微服务架构。</p><h3 id="2、SpringCloud-Bus-的使用"><a href="#2、SpringCloud-Bus-的使用" class="headerlink" title="2、SpringCloud Bus 的使用"></a>2、SpringCloud Bus 的使用</h3><p>Spring Cloud Bus是一个用于在分布式系统中传播事件的工具，它建立在Spring Cloud Stream之上。它允许微服务架构中的组件之间进行消息推送，实现配置的动态刷新、事件的传递等功能。</p><p>以下是Spring Cloud Bus的基本使用步骤：</p><blockquote><ol><li>引入依赖</li></ol></blockquote><p>在项目的<code>pom.xml</code>文件中添加Spring Cloud Bus的依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-bus-amqp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上述示例中使用了AMQP（Advanced Message Queuing Protocol）作为消息传递的中间件，你也可以选择其他消息中间件，如Kafka等。</p><blockquote><ol start="2"><li>配置消息中间件</li></ol></blockquote><p>在<code>application.properties</code>或<code>application.yml</code>中配置消息中间件的连接信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">rabbitmq:</span><br>    <span class="hljs-attr">host:</span> <span class="hljs-string">localhost</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">5672</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">guest</span><br></code></pre></td></tr></table></figure><blockquote><ol start="3"><li>配置Bus</li></ol></blockquote><p>在微服务的<code>application.properties</code>或<code>application.yml</code>中，添加以下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">bus:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>4.发送消息</p></blockquote><p>在任意微服务中，可以使用Spring Cloud Bus发送消息来触发事件。可以使用HTTP POST请求向<code>/actuator/bus-refresh</code>端点发送刷新请求：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">curl -X POST http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">8080</span><span class="hljs-regexp">/actuator/</span>bus-refresh<br></code></pre></td></tr></table></figure><p>这样就会触发Spring Cloud Bus发送一个刷新事件，然后各个微服务都会接收到这个事件，从而触发配置的刷新操作。</p><blockquote><ol start="5"><li>接收消息</li></ol></blockquote><p>在微服务中，可以使用<code>@RefreshScope</code>注解标记一个类，使得该类中的配置在接收到刷新事件时能够重新加载：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;my.property&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String myProperty;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/property&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getProperty() &#123;<br>        <span class="hljs-keyword">return</span> myProperty;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述示例中，<code>@RefreshScope</code>注解使得<code>MyController</code>类中的配置在接收到刷新事件时会重新加载。</p><p>通过这些步骤，你就可以使用Spring Cloud Bus实现在分布式系统中传播事件，例如动态刷新配置、传递消息等。</p><p>to be contined…..</p>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Seata</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是分布式事务"><a href="#1、什么是分布式事务" class="headerlink" title="1、什么是分布式事务"></a>1、什么是分布式事务</h3><p>首先理解一下，为什么会用到分布式事务。</p><p>在分布式服务中，服务A中通过feign来调用服务B的方法，但是服务B的方法并不归属于服务A的事务体系中，因此如果此时服务B报错，并不会导致已经执行了的服务A的操作回退。</p><p>想要让服务A回退，那么就要让服务B纳入到服务A的事务体系中，也就是两者是同一个事务ID。这就是我们的分布式事务，它<strong>可以跨越服务来实现事务</strong>。</p><p>想要实现分布式事务，我们有多种方式，可以通过像redis这样的中间件来实现。</p><p>但也可以用到我们今天介绍的seata组件来实现。甚至发展至今，一般我们谈到分布式事务，基本上seata已经成了我们的不二选择。</p><h3 id="2、Seata-是什么"><a href="#2、Seata-是什么" class="headerlink" title="2、Seata 是什么"></a>2、Seata 是什么</h3><p>Seata 是一款分布式事务解决方案，为微服务架构提供了强一致性的分布式事务支持。提供了全局事务管理和本地事务协调的功能，可以用于确保多个微服务之间的事务操作的一致性；提供了 AT、TCC、SAGA和XA等几种事务模式。</p><p>常见的两种分布式事务模型：AT 模型（基于 TCC，Try-Confirm-Cancel）和 TCC 模型（基于两阶段提交）。</p><blockquote><p>AT模型</p></blockquote><p>默认使用的是AT模式</p><ol><li>在业务表所在的数据库中创建一个名为undo_log的表，用于记录回滚SQL，即与执行SQL相反的SQL（例如，执行insert则对应delete）。</li><li>当业务表执行操作时，Seata会解析执行的SQL，生成回滚SQL并存储到undo_log表中。</li><li>在本地事务提交前，向Seata服务端注册分支，申请业务表中对应数据行的全局锁，阻止其他事务对该数据进行更新操作。</li><li>本地事务提交时，业务数据的更新和生成的undo log一起提交。</li><li>将本地事务执行结果报告给Seata服务端，多个服务的本地事务使用相同的事务ID和分支ID记录在Seata服务端。</li><li>如果某个本地事务发生错误，Seata服务端发起对应分支的回滚请求。</li><li>同时开启本地事务，通过事务ID和分支ID查询undo_log表，执行回滚SQL，并将执行结果报告给Seata服务端。</li><li>如果没有错误发生，Seata服务端会在对应分支上发起请求，异步批量删除undo_log表中的记录。</li></ol><p>总体来说，Seata服务端记录了所有本地事务，同时在每个库中记录了undo log。</p><p>当发生错误时，通过事务ID和分支ID找到同一组的所有本地事务，利用记录的undo log统一回退数据。</p><h3 id="3、使用-Seata-的基本步骤"><a href="#3、使用-Seata-的基本步骤" class="headerlink" title="3、使用 Seata 的基本步骤"></a>3、使用 Seata 的基本步骤</h3><p>seata分为服务端（TC）和客户端（TM,RM）,</p><p>客户端通过引入jar包来使用。服务端需要我们单独安装。</p><ul><li>TC(Transaction Coordinator)：事务协调器，维护全局事务的运行状态，协调和落实全局事务的回滚提交</li><li>TM(Transaction Manager)：控制全局事务的边界，负责开启一个全局事务，并最终发起全局事务提交或回滚的决议</li><li>RM(Resource Manager)：控制分支（本地）事务，负责分支注册、状态汇报，并接受TC的指令，驱动本地事务的提交和回滚</li></ul><h4 id="1-部署-Seata-服务器"><a href="#1-部署-Seata-服务器" class="headerlink" title="1. 部署 Seata 服务器"></a>1. 部署 Seata 服务器</h4><p>服务端下载地址： <a href="https://github.com/seata/seata/releases">https://github.com/seata/seata/releases</a></p><p>部署过程：略</p><h4 id="2-seata客户端配置"><a href="#2-seata客户端配置" class="headerlink" title="2. seata客户端配置"></a>2. seata客户端配置</h4><p>在微服务的项目中，添加 Seata 的依赖。如果使用 Maven，可以在项目的 <code>pom.xml</code> 文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.seata<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>seata-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span> <span class="hljs-comment">&lt;!-- 请根据实际情况选择版本 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><p>在微服务的配置文件中，配置 Seata 客户端。通常需要指定 Seata 服务器的地址等信息。以下是一个示例配置：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">seata:</span><br>  application-id: my-app<br>  tx-service-group: my-tx-group<br><span class="hljs-symbol">  enabled:</span> true<br><span class="hljs-symbol">  config:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  registry:</span><br><span class="hljs-symbol">    type:</span> nacos<br><span class="hljs-symbol">    nacos:</span><br><span class="hljs-symbol">      serverAddr:</span> nacos-server:<span class="hljs-number">8848</span><br><span class="hljs-symbol">      groupId:</span> SEATA_GROUP<br><span class="hljs-symbol">      namespace:</span> <span class="hljs-string">&quot;&quot;</span><br><span class="hljs-symbol">  service:</span><br><span class="hljs-symbol">    vgroup:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br><span class="hljs-symbol">    group:</span> <span class="hljs-string">&quot;my-tx-group&quot;</span><br></code></pre></td></tr></table></figure><h4 id="添加事务注解"><a href="#添加事务注解" class="headerlink" title="添加事务注解"></a>添加事务注解</h4><p>使用 @GlobalTransactional 注解</p><p>在需要分布式事务的方法上，使用 <code>@GlobalTransactional</code> 注解标记。这个注解表示这个方法需要参与全局事务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.seata.spring.annotation.GlobalTransactional;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Service;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> &#123;<br><br>    <span class="hljs-meta">@GlobalTransactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">businessMethod</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/github_38592071/article/details/131136986">https://blog.csdn.net/github_38592071/article/details/131136986</a></li><li><a href="https://juejin.cn/post/7087551217781620749">https://juejin.cn/post/7087551217781620749</a></li><li><a href="https://seata.io/zh-cn/docs/overview/what-is-seata.html">https://seata.io/zh-cn/docs/overview/what-is-seata.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_OpenFeign</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/</url>
    
    <content type="html"><![CDATA[<h3 id="1、服务调用"><a href="#1、服务调用" class="headerlink" title="1、服务调用"></a>1、服务调用</h3><h4 id="服务注册、服务发现、服务调用"><a href="#服务注册、服务发现、服务调用" class="headerlink" title="服务注册、服务发现、服务调用"></a>服务注册、服务发现、服务调用</h4><p>在Spring Cloud Alibaba生态系统中，服务调用的核心组件是 <strong>Nacos Discovery</strong> 和 <strong>Feign</strong>。</p><blockquote><p>Nacos Discovery</p></blockquote><p>Nacos是一个开源的服务发现和配置管理平台，它提供了服务注册与发现的功能，可以让微服务应用在注册到Nacos注册中心后，方便地发现其他服务，并实现服务之间的调用。通过Nacos Discovery，服务之间的关系和位置信息能够得到维护，实现了服务注册和服务发现。</p><blockquote><p>Feign</p></blockquote><p>Feign是一个声明式的Web服务客户端，它简化了服务调用的过程。通过在接口上添加注解，Feign能够自动构造HTTP请求并将其发送到服务提供方。在Spring Cloud Alibaba中，Feign与Nacos Discovery集成，可以使用Feign来发起服务调用，而Nacos Discovery则用于服务的注册和发现。</p><h4 id="微服务间的调用方式"><a href="#微服务间的调用方式" class="headerlink" title="微服务间的调用方式"></a>微服务间的调用方式</h4><blockquote><p>微服务调用</p></blockquote><p>微服务之间的通信方式常见的方式有两种：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">RPC</span> 代表：dubbo  <br>HTTP 代表：SpringCloud<br></code></pre></td></tr></table></figure><p>在微服务架构中，最常见的场景就是微服务间的相互调用。</p><p>在 SpringCloud 中，默认是使用 HTTP  来进行微服务的通信，微服务间的相互调用方式主要有<code>RestTemplate</code>、<code>Feign</code> 、和<code>OpenFeign</code></p><blockquote><p>RestTemplate</p></blockquote><p>RestTemplate 是从 Spring3.0 开始支持的一个 http 请求工具，这个请求工具是 Spring 自带的</p><p>RestTemplate 提供了常见的 REST 请求方法模板，如 GET、POST、PUT、DELETE 请求以及一些通用的请求执行方法 exchange 和 execute 方法</p><blockquote><p>Feign</p></blockquote><p>Feign 是 Spring Cloud 组件中的一个<code>声明式</code>的<code>轻量级 RESTful 的 HTTP 服务客户端</code></p><p>Feign 内置了 Ribbon，用来做<code>客户端负载均衡</code>，去调用服务注册中心的服务；</p><blockquote><p>OpenFeign</p></blockquote><p>OpenFeign 是 Spring Cloud 在 Feign 的基础上支持 SpringMVC 的注解，如 @RequesMapping 等等。</p><p>OpenFeign 的 @FeignClient 可以解析 SpringMVC 的 @RequestMapping 注解下的接口，并通过动态代理的方式产生实现类，实现类中做负载均衡并调用其他服务</p><blockquote><p>OpenFeign 和 Feign 组件的区别和关联</p></blockquote><p>OpenFeign 是 Feign 的增强版，它是 Spring Cloud 对 Feign 进行了扩展和优化的结果。虽然两者有关联，但在一些功能和使用上存在一些区别。</p><p><strong>Feign:</strong></p><ul><li>Feign 是一个声明式的Web服务客户端，用于简化服务调用的过程。</li><li>它基于接口定义，通过添加注解，可以轻松地发起HTTP请求。</li><li>在原始的 Spring Cloud 中，Feign 的默认实现不支持 Spring MVC 注解，因此使用起来有一些限制。</li></ul><p><strong>OpenFeign:</strong></p><ul><li>OpenFeign 是对 Feign 的增强，它引入了对 Spring MVC 注解的支持，使得 Feign 在使用上更加灵活。</li><li>OpenFeign 提供了更丰富的功能，例如继承性、支持 Spring Cloud Contract、支持多部分请求和响应等。</li><li>OpenFeign 可以通过 <code>@FeignClient</code> 注解的 <code>contextId</code> 属性来实现多个 Feign 客户端实例之间的隔离。</li></ul><p>在Spring Cloud项目中，如果你使用 <code>@FeignClient</code> 注解，实际上默认是使用的 OpenFeign。</p><p>Spring Cloud 在 Hoxton.RELEASE 版本之后<strong>默认使用 OpenFeign，而不是原始的 Feign。</strong></p><p>关于使用 <code>@FeignClient</code> 注解创建 Feign 客户端的例子：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>@FeignClient</code> 注解指定了服务的名称和URL，<code>ExampleFeignClient</code> 接口定义了服务调用的契约。通过添加 <code>@GetMapping</code> 注解，实现了对服务提供者的 <code>/hello</code> 接口的调用。</p><p>总体而言，OpenFeign 是对 Feign 的增强版本，提供了更多的功能和更好的灵活性，而在 Spring Cloud 中，我们常常通过 <code>@FeignClient</code> 注解来使用 OpenFeign。</p><h3 id="2、OpenFeign-的使用"><a href="#2、OpenFeign-的使用" class="headerlink" title="2、OpenFeign 的使用"></a>2、OpenFeign 的使用</h3><h4 id="FeignClient的基本使用方法"><a href="#FeignClient的基本使用方法" class="headerlink" title="@FeignClient的基本使用方法"></a><code>@FeignClient</code>的基本使用方法</h4><p><code>@FeignClient</code> 是 Spring Cloud 中用于声明式REST客户端的注解。通过使用该注解，可以定义一个接口，而不需要实现该接口，Spring Cloud会在运行时自动生成该接口的实现类，用于发起服务间的HTTP请求。</p><p>以下是<code>@FeignClient</code>的基本使用方法：</p><blockquote><p><strong>简单使用：</strong></p></blockquote><p>在一个接口上添加 <code>@FeignClient</code> 注解，并指定要调用的服务名称</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.cloud.openfeign.FeignClient;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><br><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在上述例子中，<code>ExampleFeignClient</code> 接口用于调用名为 “example-service” 的微服务，其中 <code>@GetMapping(&quot;/hello&quot;)</code> 定义了调用服务的路径。</p><blockquote><p>指定 URL</p></blockquote><p>可以通过 <code>url</code> 属性指定服务的URL，而不是通过服务名称进行调用。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, url = <span class="hljs-string">&quot;http://example.com&quot;</span>)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，服务的URL被硬编码为 “<a href="http://example.com"./">http://example.com&quot;。</a></p><blockquote><p><strong>指定Fallback</strong></p></blockquote><p>可以通过 <code>fallback</code> 属性指定一个实现了 <code>ExampleFeignClient</code> 接口的类，作为调用失败时的降级处理。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-meta">@FeignClient</span>(name = <span class="hljs-string">&quot;example-service&quot;</span>, fallback = ExampleFeignClientFallback.class)<br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">interface</span> <span class="hljs-title">ExampleFeignClient</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping</span>(<span class="hljs-string">&quot;/hello&quot;</span>)<br>    <span class="hljs-keyword">String</span> hello();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">ExampleFeignClientFallback</span> <span class="hljs-keyword"><span class="hljs-keyword">implements</span> <span class="hljs-type">ExampleFeignClient</span></span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">String</span> hello() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Fallback Hello&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，当调用服务失败时，会执行 <code>ExampleFeignClientFallback</code> 中的逻辑。</p><blockquote><p><strong>指定Decoder和Encoder</strong></p></blockquote><p>可以通过 <code>decoder</code> 和 <code>encoder</code> 属性指定自定义的解码器和编码器。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@FeignClient(name = <span class="hljs-string">&quot;example-service&quot;</span>, decoder = MyDecoder.class, encoder = MyEncoder.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">ExampleFeignClient</span> &#123;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/hello&quot;</span>)</span><br>    String hello();<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个例子中，<code>MyDecoder</code> 和 <code>MyEncoder</code> 分别是自定义的解码器和编码器。</p><p>这些是 <code>@FeignClient</code> 注解的基本用法，通过灵活使用这些属性，可以实现更多定制化的服务调用配置。</p><p>to be continued….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/IT__learning/article/details/116349843">https://blog.csdn.net/IT__learning/article/details/116349843</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Gateway</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/</url>
    
    <content type="html"><![CDATA[<h3 id="1、微服务网关是什么"><a href="#1、微服务网关是什么" class="headerlink" title="1、微服务网关是什么"></a>1、微服务网关是什么</h3><p>微服务网关是一个位于微服务架构前端的服务，作为客户端和后端微服务之间的中介。它的作用是集中处理和管理微服务系统的一些共享的非业务功能，提供统一的入口，同时可以进行路由、转发、过滤、监控等操作。</p><blockquote><p>Gateway 的基本功能</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041349886.png" alt="image.png"></p><ol><li><p><strong>路由转发：</strong></p><ul><li>网关负责接收客户端的请求，根据配置的路由规则将请求转发到不同的微服务。这有助于实现前后端的解耦，使得微服务可以独立演进。</li></ul></li><li><p><strong>流量控制：</strong></p><ul><li>网关可以对请求进行流量控制，限制每个微服务的访问频率，防止某个微服务被过度请求而影响整体系统的稳定性。</li></ul></li><li><p><strong>熔断保护：</strong></p><ul><li>网关可以实现熔断保护，当某个微服务出现故障或超时时，网关可以快速拦截请求，避免请求堆积导致整个系统的崩溃。Sentinel是一种专注于流量控制、熔断降级、系统自适应保护的开源框架，它提供了更丰富的熔断保护功能，因此有些项目选择引入Sentinel来增强熔断保护能力。</li></ul></li><li><p><strong>日志监控：</strong></p><ul><li>网关通常会记录请求和响应的日志信息，这有助于进行系统的监控和故障排查。业务日志和链路追踪也是重要的监控手段。</li></ul></li><li><p><strong>安全认证：</strong></p><ul><li>网关可以提供安全认证机制，确保只有经过认证和授权的用户才能访问微服务。这可以通过集成框架（如Spring Security）或使用专门的认证服务来实现。</li></ul></li></ol><blockquote><p>关于 Gateway 的熔断保护功能的说明</p></blockquote><p>Spring Cloud Gateway自身具备基本的熔断保护机制，可以在配置中设置断路器的一些参数，但相对简单。对于一些更复杂的熔断、限流、降级等场景，可能需要引入专门的框架如Sentinel。</p><p>在实际使用中，可以根据具体的需求来选择是否引入Sentinel。如果项目对熔断保护等功能的需求相对简单，Gateway的基本熔断保护足够使用。如果需要更复杂的流量控制和熔断降级策略，引入Sentinel可能会更为合适。</p><blockquote><p>服务网关和流量网关的区别</p></blockquote><p>对于 Nginx 和 Gateway 的两者区别：</p><p>流量网关（如Nignx)提供全局性的、与后端业务应用无关的策略，例如 HTTPS证书卸载、Web防火墙、全局流量监控等。</p><p>微服务网关（如Spring Cloud Gateway）是指与业务紧耦合的、提供单个业务域级别的策略，如服务治理、身份认证等。</p><p>流量网关负责南北向流量调度及安全防护，微服务网关负责东西向流量调度及服务治理。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202312041354467.png" alt="image.png|400"></p><h3 id="2、Gateway-的搭建和使用"><a href="#2、Gateway-的搭建和使用" class="headerlink" title="2、Gateway 的搭建和使用"></a>2、Gateway 的搭建和使用</h3><blockquote><p>网关的搭建</p></blockquote><p>略</p><blockquote><p>Spring Cloud Gateway 的配置项</p></blockquote><p>Spring Cloud Gateway的核心概念包括路由（Route）、断言（Predicate）和过滤器（Filter）。</p><p>这些概念共同构成了Gateway的基础，用于定义请求的路由规则、请求的匹配条件和请求的处理流程。</p><blockquote><p>路由</p></blockquote><p>路由定义了请求应该被定向到哪个目标服务。每个路由都包含一个唯一的ID、目标URI、一组断言和过滤器。通过配置多个路由，可以实现对请求的动态路由和负载均衡。</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br></code></pre></td></tr></table></figure><p>上述配置表示将以<code>/example/**</code>路径开头的请求转发到<code>http://example.com</code>，并在转发时去掉路径的第一个段（StripPrefix&#x3D;1）。</p><blockquote><p>断言</p></blockquote><p>断言定义了请求匹配的条件，当条件满足时，对应的路由规则生效。断言可以基于请求的路径、方法、头部信息等进行匹配。</p><blockquote><p>过滤器</p></blockquote><p>过滤器是处理请求和响应的逻辑的组件，它们可以修改请求和响应，实现一些额外的功能，如添加头信息、修改请求体、进行认证等</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">spring</span><span class="hljs-punctuation">:</span><br>  <span class="hljs-attribute">cloud</span><span class="hljs-punctuation">:</span><br>    <span class="hljs-attribute">gateway</span><span class="hljs-punctuation">:</span><br>      <span class="hljs-attribute">routes</span><span class="hljs-punctuation">:</span><br>        <span class="hljs-bullet">-</span> <span class="hljs-string">id: example</span><br>          <span class="hljs-attribute">uri</span><span class="hljs-punctuation">:</span> <span class="hljs-string">http://example.com</span><br>          <span class="hljs-attribute">predicates</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">Path=/example/**</span><br>          <span class="hljs-attribute">filters</span><span class="hljs-punctuation">:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">StripPrefix=1</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">AddRequestHeader=X-Header=foo</span><br></code></pre></td></tr></table></figure><p>上述配置中的过滤器<code>AddRequestHeader=X-Header=foo</code>表示在转发请求前，向请求头中添加一个名为<code>X-Header</code>的头，其值为<code>foo</code>。</p><blockquote><p>Gateway集成 nacos 注册中心实现服务发现</p></blockquote><p>略</p><blockquote><p>Gateway 整合 Apollo 实现动态路由配置</p></blockquote><p>略</p><blockquote><p>自定义全局异常处理器</p></blockquote><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yao583224426/article/details/122216804">https://blog.csdn.net/yao583224426/article/details/122216804</a></li><li><a href="https://cloud.tencent.com/developer/article/2135737">https://cloud.tencent.com/developer/article/2135737</a></li><li><a href="https://spring.io/projects/spring-cloud-gateway">https://spring.io/projects/spring-cloud-gateway</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Sentinel</title>
    <link href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/"/>
    <url>/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/</url>
    
    <content type="html"><![CDATA[<p>使用类似于 Sleuth，在对应服务添加依赖和注解配置后，Sentinel 能够对服务做一个服务流量监听，进行熔断降级、系统负载等操作。</p><p><strong>Sentinel控制台的下载</strong></p><p>下载地址： <a href="https://github.com/alibaba/Sentinel/releases/tag/1.8.3">https://github.com/alibaba/Sentinel/releases/tag/1.8.3</a></p><p>注意的一些内容</p><ul><li>注解使用（服务程序中使用）</li><li>流控规则</li><li>熔断规则</li><li>系统规则</li></ul><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106899215">https://blog.csdn.net/qq_36903261/article/details/106899215</a></li><li><a href="https://blog.csdn.net/qq_38374397/article/details/125603109">https://blog.csdn.net/qq_38374397/article/details/125603109</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RabbitMQ的安装与使用</title>
    <link href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、windows下rabbitMQ-的安装"><a href="#1、windows下rabbitMQ-的安装" class="headerlink" title="1、windows下rabbitMQ 的安装"></a>1、windows下rabbitMQ 的安装</h3><p>RabbitMQ服务端代码是使用并发式语言Erlang编写的，安装Rabbit MQ的前提是需要安装一下Erlang</p><p>Erlang 下载地址： <a href="https://www.erlang.org/downloads">https://www.erlang.org/downloads</a></p><p>环境变量配置</p><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs haml">ERLANG_HOME<br><span class="hljs-tag">%<span class="hljs-selector-tag">ERLANG_HOME</span></span>%\bin<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203233950.png" alt="image.png"></p><p>打开 cmd 输入 erl -version 出现版本号即安装成功</p><blockquote><p>RabbitMQ</p></blockquote><p>rabbitmq 下载地址： <a href="https://www.rabbitmq.com/download.html">https://www.rabbitmq.com/download.html</a></p><p>下载进行安装操作。</p><p>CMD 进入终端 进入到安装目录 执行 rabbitmq-plugins enable rabbitmq_management 命令安装管理页面的插件，</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203234341.png" alt="image.png"></p><p>启动rabbitMQ服务：rabbitmq-service.bat start</p><p>双击 rabbitmq-service.bat 即完成安装。（关闭的话手动在服务列表进行关闭一下）</p><p>登陆： <a href="http://127.0.0.1:15672/">http://127.0.0.1:15672/</a></p><p>初始的默认用户及密码都是 <code>guest</code> ， 输入后即可登录</p><h3 id="2、centos-系统下-rabbitMQ-的安装"><a href="#2、centos-系统下-rabbitMQ-的安装" class="headerlink" title="2、centos 系统下 rabbitMQ 的安装"></a>2、centos 系统下 rabbitMQ 的安装</h3><h4 id="RabbitMQ-服务安装"><a href="#RabbitMQ-服务安装" class="headerlink" title="RabbitMQ 服务安装"></a>RabbitMQ 服务安装</h4><p>略</p><h4 id="Docker容器方式安装RabbitMQ"><a href="#Docker容器方式安装RabbitMQ" class="headerlink" title="Docker容器方式安装RabbitMQ"></a>Docker容器方式安装RabbitMQ</h4><p>1、拉取镜像（默认安装最新版本）</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">docker pull rabbitmq<br></code></pre></td></tr></table></figure><p>2、启动RabbitMQ容器</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> run -d --hostname myRabbitMQ --name rabbit -p <span class="hljs-number">5672</span>:<span class="hljs-number">5672</span> -p <span class="hljs-number">15672</span>:<span class="hljs-number">15672</span> rabbitmq<br></code></pre></td></tr></table></figure><p>这个命令的组成部分解释如下：</p><ul><li><code>docker run</code>：启动一个新的容器。</li><li><code>-d</code>：以守护进程模式运行容器，即容器在后台运行。</li><li><code>--hostname myRabbitMQ</code>：为容器设置主机名（<code>myRabbitMQ</code>）。你可以根据需要更改这个值。</li><li><code>--name rabbit</code>：设置容器的名称（<code>rabbit</code>）。这也可以根据你的命名约定来更改。</li><li><code>-p 5672:5672</code>：将容器内部的 5672 端口映射到宿主机的 5672 端口。5672 端口是 RabbitMQ 的默认AMQP端口。</li><li><code>-p 15672:15672</code>：将容器内的 15672 端口映射到宿主机的 15672 端口。15672 端口是 RabbitMQ 管理界面（Management Console）的默认端口。</li><li><code>rabbitmq</code>：指定要使用的 Docker 镜像。</li></ul><p>在 Docker 命令中使用 <code>-p</code> 参数来映射端口时，格式为 <code>-p &lt;宿主机端口&gt;:&lt;容器端口&gt;</code>。</p><p>开放一下端口</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=5672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=15672/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --reload      <span class="hljs-comment"># 重启防火墙</span></span><br></code></pre></td></tr></table></figure><p>访问控制台界面</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">http:</span><span class="hljs-comment">//linuxip:15672</span><br></code></pre></td></tr></table></figure><p>用户名和密码默认都是guest</p><p>3、开启 Web 界面管控台插件</p><p>对于 Docker 容器中的 RabbitMQ</p><p>如果你是通过 Docker 容器运行 RabbitMQ，并且想要启用管理控制台，通常最简单的方式是直接使用带有管理插件的 RabbitMQ 镜像。例如：</p><p><code>docker run -d --hostname myRabbitMQ --name some-rabbit -p 5672:5672 -p 15672:15672 rabbitmq:3-management</code></p><p>在这个命令中，<code>rabbitmq:3-management</code> 镜像已经包含了管理插件。如果你已经运行了一个不包含管理插件的 RabbitMQ 容器，你可以按照以下步骤启用管理插件：</p><ol><li><p>找出你的 RabbitMQ 容器的 ID 或名称：</p><p> <code>docker ps</code></p></li><li><p>进入容器：</p><p> <code>docker exec -it [容器ID或名称] bash</code></p></li><li><p>在容器内部，运行以下命令来启用管理插件：</p><p> <code>rabbitmq-plugins enable rabbitmq_management</code></p></li><li><p>退出容器：</p><p> <code>exit</code></p></li><li><p>重启 RabbitMQ 容器以应用更改。</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">docker</span> restart<span class="hljs-meta"> [容器名称或ID]</span><br></code></pre></td></tr></table></figure><p>一旦完成，你就可以通过<code>http://linuxip:15672</code></p><p>访问 RabbitMQ 的管理界面。确保你已经将 15672 端口映射到了宿主机上。</p><hr><p>参考： </p><ul><li><a href="https://blog.csdn.net/u011709538/article/details/131396367">https://blog.csdn.net/u011709538/article/details/131396367</a></li><li><a href="https://zhuanlan.zhihu.com/p/609676322?utm_id=0">https://zhuanlan.zhihu.com/p/609676322?utm_id=0</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>MQ</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端依赖常见报错解决方案</title>
    <link href="/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2023/12/03/%E5%89%8D%E7%AB%AF%E4%BE%9D%E8%B5%96%E5%B8%B8%E8%A7%81%E6%8A%A5%E9%94%99%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<blockquote><p>问题1： npm错误——npm ERR! code ERESOLVE 解决方法</p></blockquote><figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">npm ERR! code ERESOLVE<br>npm ERR! ERESOLVE unable to resolve dependency tree<br>npm ERR!<br>npm ERR! While resolving: vol.vue3@<span class="hljs-number">0.1</span>.<span class="hljs-number">0</span><br>npm ERR! Found: vue@<span class="hljs-number">3.2</span>.<span class="hljs-number">20</span><br>npm ERR! node_modules/vue<br>npm ERR!   vue@<span class="hljs-string">&quot;^3.0.0&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Could not resolve dependency:<br>npm ERR! peer vue@<span class="hljs-string">&quot;^2.5.17&quot;</span> from element-ui@<span class="hljs-number">2.15</span>.<span class="hljs-number">6</span><br>npm ERR! node_modules/element-ui<br>npm ERR!   element-ui@<span class="hljs-string">&quot;*&quot;</span> from the root project<br>npm ERR!<br>npm ERR! Fix the upstream dependency conflict, or retry<br>npm ERR! this command with --force, or --legacy-peer-deps<br>npm ERR! to accept an incorrect (and potentially broken) dependency resolution.<br>npm ERR!<br>npm ERR! See C:\Users\Administrator\AppData\Local\npm-cache\eresolve-report.txt for a full report.<br> <br>npm ERR! A complete log of this run can be found in:<br>npm ERR!     C:\Users\Administrator\AppData\Local\npm-cache\_logs\<span class="hljs-number">2021</span>-<span class="hljs-number">10</span>-<span class="hljs-number">11</span>T06_27_44_908Z-debug.log<br></code></pre></td></tr></table></figure><p>在安装组件的时候出现以上问题，npm版本问题报错</p><p>解决方法：</p><p>在命令后面加上</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-comment">--legacy-peer-deps</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python环境安装</title>
    <link href="/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/"/>
    <url>/2023/12/03/Python%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h3 id="1、python-3-9-版本安装"><a href="#1、python-3-9-版本安装" class="headerlink" title="1、python 3.9 版本安装"></a>1、python 3.9 版本安装</h3><p>下载地址： <a href="https://www.python.org/downloads/release/python-396/">https://www.python.org/downloads/release/python-396/</a></p><p>参考： <a href="https://blog.csdn.net/qq_53280175/article/details/121107748">https://blog.csdn.net/qq_53280175/article/details/121107748</a></p><p>下载链接： <a href="https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe">https://www.python.org/ftp/python/3.9.6/python-3.9.6-amd64.exe</a></p><p>这里下载的是 win 64 位安装版</p><p>安装的时候勾选一下  Add Python 3.9 to PATH</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214357.png" alt="image.png"></p><p>选择自定义安装</p><p>查看是否安装成功，cmd 窗口输入一下 <code>python</code> 看一下</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231203214605.png" alt="image.png"></p><h3 id="2、降级python为2-0-版本"><a href="#2、降级python为2-0-版本" class="headerlink" title="2、降级python为2.0 版本"></a>2、降级python为2.0 版本</h3><p>由于版本前端项目 node-sass 安装失败，部分建议是降级 Python 为 2.x 版本，这里记录一下实际操作。</p><p>找了一个 2.7.2 版本：<a href="https://www.python.org/downloads/release/python-273/">https://www.python.org/downloads/release/python-273/</a></p><p>仍然选择安装版本</p><p>安装完成后加一下 Path 环境变量（删除之前的）</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">xxx\Pytho<span class="hljs-symbol">n27</span><br></code></pre></td></tr></table></figure><p>输入 <code>Python -V</code> 验证释放安装成功</p><p>实际操作在这一步输入后，没反映，<strong>使用完整路径运行 Python</strong> 却又是正常的</p><figure class="highlight moonscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs moonscript"><span class="hljs-name">D</span>:\<span class="hljs-number">02</span>_Soft\xxxxx\Python27\python.exe -V<br></code></pre></td></tr></table></figure><p>实际的一个操作，<strong>需要设置path优先级，把python的路径放置顶部</strong></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>linux系统下 java环境变量的配置</title>
    <link href="/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="linux系统下-java环境变量的配置"><a href="#linux系统下-java环境变量的配置" class="headerlink" title="linux系统下 java环境变量的配置"></a>linux系统下 java环境变量的配置</h3><p>输入<code>echo $JAVA_HOME</code>结果为空，说明没有配置java环境变量</p><p>查看yum安装的jdk在哪个目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">ls</span> -l /etc/alternatives/java<br></code></pre></td></tr></table></figure><p>默认安装路径是在 <code>/usr/lib/jvm</code></p><p>配置环境变量  <code>vim /etc/profile</code></p><p>追加内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">export</span> <span class="hljs-attribute">JAVA_HOME</span>=/usr/local/lib/java/jdk1.8.0_231 <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">JRE_HOME</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/jre  <br><span class="hljs-built_in">export</span> <span class="hljs-attribute">CLASSPATH</span>=.:$&#123;JAVA_HOME&#125;/lib:<span class="hljs-variable">$&#123;JRE_HOME&#125;</span>/lib  <br><span class="hljs-built_in">export</span>  <span class="hljs-attribute">PATH</span>=<span class="hljs-variable">$&#123;JAVA_HOME&#125;</span>/bin:$PATH<br></code></pre></td></tr></table></figure><p>刷新环境变量配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><blockquote><p>卸载重装</p></blockquote><p>卸载参考（Linux上卸载JDK）： <a href="https://blog.csdn.net/weixin_44990104/article/details/117589372">https://blog.csdn.net/weixin_44990104/article/details/117589372</a></p><p>linux安装jdk8详细步骤，参考： <a href="https://blog.csdn.net/qq_33794744/article/details/107838128">https://blog.csdn.net/qq_33794744/article/details/107838128</a></p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>jdk</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7 安装 nacos 操作</title>
    <link href="/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="centos7-安装-nacos-操作"><a href="#centos7-安装-nacos-操作" class="headerlink" title="centos7 安装 nacos 操作"></a>centos7 安装 nacos 操作</h3><p>前提需要：项目运行环境需要安装 nacos </p><p>在 centos 中进行安装nacos，这里演示安装版本是 1.3.2，</p><p>下载地址： <a href="https://github.com/alibaba/nacos/releases/tag/1.3.2">https://github.com/alibaba/nacos/releases/tag/1.3.2</a></p><p>nacos 运行需要先安装一下 JDK 环境，注意一下</p><p>可以自己点击下载   <code>nacos-server-1.3.2.tar.gz</code></p><p>或者在 Linux系统中下载命令：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">wget</span> https://github.com/alibaba/nacos/releases/download/<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>/nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>下载完压缩包之后，上传指服务器任意目录，进行解压</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">tar</span> -zxvf nacos-server-<span class="hljs-number">1</span>.<span class="hljs-number">3</span>.<span class="hljs-number">2</span>.tar.gz<br></code></pre></td></tr></table></figure><p>解压后会生成 nacos 文件夹，进入到 nacos 目录，输入命令启动(以单机的形式启动)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">bin/startup.sh -m standalone<br></code></pre></td></tr></table></figure><p>如果需要持久化 配置到mysql，则调整nacos的配置</p><p>如果你的服务器开了防火墙，则需要开放相应的端口</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli"><span class="hljs-comment">#开放端口</span><br>firewall-cmd <span class="hljs-params">--zone=public</span> <span class="hljs-params">--add-port=8848/tcp</span> <span class="hljs-params">--permanent</span> <br><span class="hljs-comment"># 重启防火墙 </span><br>firewall-cmd <span class="hljs-params">--reload</span><br><span class="hljs-comment"># 查看开放的端口列表 </span><br>firewall-cmd <span class="hljs-params">--list-port</span><br></code></pre></td></tr></table></figure><p>nacos默认的启动端口是 8848，访问 <code>http://ip:端口/nacos</code> 即可看到登录页面.默认的用户名密码是 <code>nacos/naocs</code>，登录即可使用</p>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nacos</tag>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>内网穿透工具Neutrino-Proxy</title>
    <link href="/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/"/>
    <url>/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/</url>
    
    <content type="html"><![CDATA[<p>一款简单易用的内网穿透使用工具</p><p>官网： <a href="https://neutrino-proxy.dromara.org/">https://neutrino-proxy.dromara.org/</a></p><p>项目地址： <a href="https://gitee.com/dromara/neutrino-proxy/releases">https://gitee.com/dromara/neutrino-proxy/releases</a></p><p>部署方式有三种，这里通过原生部署的方式进行启动</p><p>原生部署的方式需要下载zip包，进行解压，然后启动 exe 文件。部分exe程序同一目录下有Pom.xml配置文件，可进行修改对应配置。</p><p>服务器下载<code>neutrino-proxy-server-ubuntu-20.04-native.zip</code>文件，</p><p>客户端下载<code>neutrino-proxy-client-windows-2022-native.zip</code></p><blockquote><p>部署服务器端</p></blockquote><p>默认先采用原生配置h2数据库，实际使用中，个人使用的是h2数据库（这种数据库的缺点是数据放在内存中，如果需要持久化放到本地，建议修改配置为 mysql 数据库）</p><p>实际操作：</p><p>1、将下载文件复制到服务器的某个目录下，进行解压操作：</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs axapta">unzip  neutrino-proxy-<span class="hljs-keyword">server</span>-ubuntu<span class="hljs-number">-20.04</span>-native.zip<br><br><span class="hljs-meta">#启动服务端可执行程序</span><br>./neutrino-proxy-<span class="hljs-keyword">server</span><br></code></pre></td></tr></table></figure><ul><li>服务端部署成功后，访问http:&#x2F;&#x2F;{服务端IP}:8888打开后台管理页面。使用默认的管理员帐号登录：admin&#x2F;123456</li><li>打开代理配置&gt;License管理页面，系统已经自动为管理员初始化了一条License记录，复制该LicenseKey备用，后续客户端配置需要。</li></ul><p>2、将 exe 程序后台运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">nohup</span> ./neutrino-proxy-server &amp;<br></code></pre></td></tr></table></figure><p><code>nohup</code> 命令用于忽略挂断信号（SIGHUP），并且 <code>&amp;</code> 符号用于将程序放到后台运行。</p><p><code>nohup.out</code> 文件通常会生成在你运行 <code>nohup</code> 命令的当前工作目录（current working directory）。如果你没有指定具体的输出文件路径，<code>nohup</code> 默认将输出重定向到 <code>nohup.out</code> 文件</p><p>关闭后台程序</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment">#查看进程号PID</span><br>ps aux | <span class="hljs-keyword">grep</span> neutrino-proxy-server<br><span class="hljs-comment">#杀死进程</span><br><span class="hljs-keyword">kill</span> &lt;PID&gt;<br></code></pre></td></tr></table></figure><p>后台运行的时候发现使用 xshell 直接启动程序会随着关闭 ssh 连接而中断运行，这里是采用 screen + nohup 的方式运行程序。</p><p>上面这种方式在关闭 ssh 连接后，会话中的进程就直接关闭了。尝试一下 screen 的使用</p><p><code>screen</code> 是一个终端复用工具，它允许你在一个终端窗口中创建多个虚拟终端，并在这些虚拟终端中运行不同的程序。通过使用 <code>screen</code>，你可以在一个会话中保持你的程序在后台运行，即使你关闭了SSH连接也不会影响这些程序的执行</p><p>安装</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">sudo yum <span class="hljs-keyword">install</span> screen<br></code></pre></td></tr></table></figure><ol><li><p><strong>启动一个新的 <code>screen</code> 会话：</strong></p><p> <code>screen</code></p><p> 这将创建一个新的 <code>screen</code> 会话，并将你切换到该会话中。</p></li><li><p><strong>在 <code>screen</code> 会话中运行你的程序：</strong></p><p> 在 <code>screen</code> 会话中，你可以运行你的程序，比如：</p><p> <code>./your_program.exe</code></p><p> 如果你需要在程序后台运行，你可以使用 <code>Ctrl + A</code> 然后按下 <code>d</code> 键，这会将 <code>screen</code> 会话放入后台，但会话中的程序仍在运行。</p></li><li><p><strong>列出 <code>screen</code> 会话：</strong></p><p> <code>screen -ls</code></p><p> 这将显示当前所有的 <code>screen</code> 会话。</p></li><li><p><strong>重新连接到 <code>screen</code> 会话：</strong></p><p> 如果你关闭了终端或断开了SSH连接，你可以重新连接到之前创建的 <code>screen</code> 会话：</p><p> <code>screen -r</code></p><p> 如果有多个会话，你可能需要指定要连接的会话ID，例如：</p><p> <code>screen -r &lt;session_id&gt;</code></p></li><li><p><strong>退出 <code>screen</code> 会话：</strong></p><p> 在 <code>screen</code> 会话中，你可以使用 <code>exit</code> 或者 <code>Ctrl + D</code> 来退出。</p></li></ol><p>这是 <code>screen</code> 的基本用法。</p><blockquote><p>部署客户端</p></blockquote><p>需要下载后修改一下配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">neutrino:</span><br>  <span class="hljs-attr">proxy:</span><br>    <span class="hljs-attr">tunnel:</span><br>      <span class="hljs-comment"># ssl证书密钥（使用jjar包内自带的证书，则此处无需修改）</span><br>      <span class="hljs-attr">key-store-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-comment"># ssl证书管理密钥（使用jjar包内自带的证书，则此处无需修改。自定义证书，则此处配置对应的路径）</span><br>      <span class="hljs-attr">jks-path:</span> <span class="hljs-string">classpath:/test.jks</span><br>      <span class="hljs-comment"># 代理服务端IP</span><br>      <span class="hljs-attr">server-ip:</span> <span class="hljs-string">xxxx</span><br>      <span class="hljs-comment"># 代理服务端IP, 若是非ssl端口，则ssl-enable需要配置为false</span><br>      <span class="hljs-attr">server-port:</span> <span class="hljs-number">9002</span><br>      <span class="hljs-comment"># 是否启用ssl</span><br>      <span class="hljs-attr">ssl-enable:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># licenseKey，客户端凭证。此处需要配置刚刚从管理后台复制的LicenseKey</span><br>      <span class="hljs-attr">license-key:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>这里有一个注意的地方就是 9002 这个端口，需要我们去看一下服务器端的配置文件对应的端口，它默认是 9002 ，需要在防火墙端口开启一下，<strong>或者改一下这个端口配置</strong></p><p>server-port  →  服务端端口(对应服务端app.yml中的tunnel.port、tunnel.ssl-port)</p><p>然后复制一下客户端凭证即可</p><p>如果出现问题，建议先删掉文件重新解压，再配置一遍，重新启动。</p><p>Linux 客户端配置同理。（注意是一个客户端对应一个凭证）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">unzip</span>  neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native.zip<br><span class="hljs-attribute">cd</span> neutrino-proxy-client-ubuntu-<span class="hljs-number">20</span>.<span class="hljs-number">04</span>-native<br><br><span class="hljs-attribute">screen</span><br><br><span class="hljs-attribute">nohup</span> ./neutrino-proxy-client &amp;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Zipkin</title>
    <link href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/"/>
    <url>/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Sleuth"><a href="#1、什么是-Sleuth" class="headerlink" title="1、什么是 Sleuth"></a>1、什么是 Sleuth</h3><p>Sleuth是Spring Cloud的组件之一，它为Spring Cloud实现了一种分布式追踪解决方案。</p><p>一般是和 zipkin 或者其他基于日志的追踪系统一起使用的。</p><p>简单理解：sleuth 是链路追踪器，将链路信息放到日志中，zipkin 是链路分析器，将链路日志进行可视化分析和聚合检索。</p><h3 id="2、Zipkin是什么"><a href="#2、Zipkin是什么" class="headerlink" title="2、Zipkin是什么"></a>2、Zipkin是什么</h3><p>Zipkin是一个分布式追踪系统。它有助于收集对服务架构中的延迟问题进行故障排除所需的计时数据。功能包括收集和查找这些数据。</p><p>Zipkin is a distributed tracing system. It helps gather timing data needed to troubleshoot latency problems in service architectures. Features include both the collection and lookup of this data.</p><p>在微服务架构中，随着业务的不断扩张，服务之间互相调用会越来越复杂。而Zipkin能收集服务中的一些数据，我们能够通过明显的可视化效果去查看链路中的情况（支持日志聚合，进行可视化展示和全文检索）。</p><p><strong>分布式链路追踪（Distributed Tracing）</strong>： 将一次分布式请求还原成调用链路，进行日志记录，性能监控并将一次分布式请求的调用情况集中展示。比如各个服务节点上的耗时、请求具体到达哪台机器上、每个服务节点的请求状态等等。</p><p>常用的链路追踪技术还有好几种，有兴趣可以去了解一下。</p><ul><li><a href="https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/">https://skywalking.apache.org/zh/2020-04-19-skywalking-quick-start/</a></li><li><a href="https://logging.apache.org/log4j/2.x/">https://logging.apache.org/log4j/2.x/</a></li><li><a href="https://github.com/pinpoint-apm/pinpoint">https://github.com/pinpoint-apm/pinpoint</a></li></ul><hr><h3 id="3、Sleuth入门"><a href="#3、Sleuth入门" class="headerlink" title="3、Sleuth入门"></a>3、Sleuth入门</h3><blockquote><p>Sleuth 术语</p></blockquote><ul><li>Trace (一条完整链路–包含很多span(微服务接口))<ul><li>由一组Trace Id（贯穿整个链路）相同的Span串联形成一个树状结构。为了实现请求跟踪，当请求到达分布式系统的入口端点时，只需要服务跟踪框架为该请求创建一个唯一的标识（即TraceId），同时在分布式系统内部流转的时候，框架始终保持传递该唯一值，直到整个请求的返回。那么我们就可以使用该唯一标识将所有的请求串联起来，形成一条完整的请求链路。</li></ul></li><li>Span<ul><li>代表了一组基本的工作单元。为了统计各处理单元的延迟，当请求到达各个服务组件的时候，也通过一个唯一标识（SpanId）来标记它的开始、具体过程和结束。通过SpanId的开始和结束时间戳，就能统计该span的调用时间，除此之外，我们还可以获取如事件的名称。请求信息等元数据。</li></ul></li><li>Annotation<ul><li>用它记录一段时间内的事件，内部使用的重要注释：<ul><li>cs（Client Send）客户端发出请求，开始一个请求的生命</li><li>sr（Server Received）服务端接受到请求开始进行处理， sr－cs &#x3D; 网络延迟（服务调用的时间）</li><li>ss（Server Send）服务端处理完毕准备发送到客户端，ss - sr &#x3D; 服务器上的请求处理时间</li><li>cr（Client Reveived）客户端接受到服务端的响应，请求结束。 cr - sr &#x3D; 请求的总时间</li></ul></li></ul></li></ul><blockquote><p>Sleuth 使用</p></blockquote><p>在pom.xml文件添加Sleuth依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!--sleuth依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-sleuth<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>项目整合 sleuth 后，在日志输出会多一些链路信息。</p><p>我们在启动这个微服务后，调用其中某个请求，可以在控制台观察到sleuth的日志输出</p><h3 id="4、链路解决方案-Sleuth-Zipkin"><a href="#4、链路解决方案-Sleuth-Zipkin" class="headerlink" title="4、链路解决方案 Sleuth + Zipkin"></a>4、链路解决方案 <strong>Sleuth</strong> + <strong>Zipkin</strong></h3><p>使用 Zipkin 需要下载一下他的服务端： <a href="https://zipkin.io/pages/quickstart.html">https://zipkin.io/pages/quickstart.html</a></p><p>官方文档里面有介绍他对应的下载和启动方式。</p><p>通过浏览器访问 <a href="http://localhost:9411/">http://localhost:9411</a>访问</p><p>Zipkin 跟 Nacos 类似，需要启动他的服务端程序，并在微服务模块中添加客户端相关的配置。</p><blockquote><p><strong>Sleuth</strong> + <strong>Zipkin</strong> 集成</p></blockquote><p>这里是选用 ZipKin客户端和Sleuth 进行集成。</p><p>依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-zipkin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#配置zipkin</span><br>  <span class="hljs-attr">zipkin:</span><br>    <span class="hljs-attr">base-url:</span> <span class="hljs-string">http://192.168.31.60:9411</span><br>    <span class="hljs-attr">discovery-client-enabled:</span> <span class="hljs-literal">false</span>  <span class="hljs-comment"># 不要让nacos把zipkin注册进去（可以不写）</span><br>  <span class="hljs-attr">sleuth:</span><br>    <span class="hljs-attr">sampler:</span><br>      <span class="hljs-attr">probability:</span> <span class="hljs-number">1.0</span><br></code></pre></td></tr></table></figure><p>启动后，便可以在 Zipkin 观察该服务下的请求链路。</p><blockquote><p>持久化操作</p></blockquote><p>Zipkin 默认是将数据保存到内存，生产环境一般是选择持久化到本地。</p><p><strong>Zipkin</strong> 提供可插拔数据存储方式，下面这些都支持：In-Memory、MySql、Cassandra 以及 Elasticsearch。</p><blockquote><p>使用mysql实现数据持久化操作</p></blockquote><p>略，待更新</p><p>to be contined….</p><hr><p>参考：</p><ul><li><a href="https://zipkin.io/pages/quickstart">https://zipkin.io/pages/quickstart</a></li><li><a href="https://blog.csdn.net/qq_40587263/article/details/117338097">https://blog.csdn.net/qq_40587263/article/details/117338097</a></li><li><a href="https://zhuanlan.zhihu.com/p/71024024">https://zhuanlan.zhihu.com/p/71024024</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB_基本操作</title>
    <link href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>mongodb 的数据库中的一种，是面向文档存储的数据库；</p><p>他的概念和关系型数据有些区别。</p><p>跟 MySQL 类似，他能够执行 CRUD，事务，索引 等操作。</p><p>在技术选型的时候，对于高并发、海量数据读写、高可用、搞可扩展有需求，数据量大，写入频率，价值较低，对事务性要求不高的时候，可以考虑使用 MongoDB来实现数据的存储。</p><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301336438.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/efew212efe/article/details/124524863">https://blog.csdn.net/efew212efe/article/details/124524863</a></li><li><a href="https://www.mongodb.com/docs/manual/">https://www.mongodb.com/docs/manual/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows常用操作</title>
    <link href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>windows_查看端口被占用情况、结束进程</p></blockquote><p>查看指定端口占用情况（端口引号有没有都可以，此处以5040为例）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -aon<span class="hljs-string">|findstr 5040</span><br></code></pre></td></tr></table></figure><p>根据PID查看相应的进程或程序(也可以任务管理器查看)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist<span class="hljs-string">|findstr 5340</span><br></code></pre></td></tr></table></figure><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /f /t /im 进程名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用操作</title>
    <link href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h4><ul><li>wq：保存当前文件并退出</li><li>wqa：保存所有文件并退出</li><li>q!： 不保存，强制退出</li><li>qa!： 有多个文件被打开，同时退出</li></ul><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89042423">https://zhuanlan.zhihu.com/p/89042423</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7系统_常用操作</title>
    <link href="/2023/11/28/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/28/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><blockquote><p>查看防火墙状态</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">firewall-cmd <span class="hljs-comment">--state</span><br></code></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl stop firewalld   <span class="hljs-comment"># 关闭防火墙</span><br><span class="hljs-params">system</span>ctl start firewalld  <span class="hljs-comment"># 启动防火墙</span><br>firewall-cmd --reload      <span class="hljs-comment"># 重启防火墙</span><br><span class="hljs-params">system</span>ctl disable firewalld  <span class="hljs-comment"># 禁用防火墙</span><br></code></pre></td></tr></table></figure><blockquote><p>开放防火墙端口</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --query-port=80/tcp   <span class="hljs-comment">#端口开放情况</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --list-ports  <span class="hljs-comment">#查看开放的端口</span></span><br><br><span class="hljs-comment">#开放端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8080/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8083-8085/tcp</span><br><br><span class="hljs-comment">#关闭端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --remove-port=8083-8085/tcp</span><br></code></pre></td></tr></table></figure><p>端口开放后建议重启一下防火墙</p>]]></content>
    
    
    <categories>
      
      <category>操作系统</category>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_基础内容</title>
    <link href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Spring 概念</li><li>常用模块</li><li>IOC</li><li>AOP</li><li>Spring 事务</li><li>Spring MVC</li></ul><blockquote><p>什么是Spring</p></blockquote><p>Spring 是一个轻量级的开源Java开发框架，旨在提高开发人员的开发效率以及系统的可维护性。</p><p>一般来说，我们常说的 Spring 框架指的是 Spring Framework, 他是多模块的一个集合，这些模块能够比较方便的帮助我们来进行开发。</p><p>Spring 有很多特性，也支持很多功能，了解Spring 框架，我们一般会从它支持的 IOC 和 AOP 这两个核心功能来最开始认识它。</p><p><strong>目前Spring 最大的一个优势是它构建了一个非常不错的Java生态，你能够在这里面找到不同需求需要的处理方案。</strong></p><p>Spring 的官网： <a href="https://spring.io/">https://spring.io/</a></p><p>Github地址： <a href="https://github.com/spring-projects/spring-framework">https://github.com/spring-projects/spring-framework</a></p><p>Spring 的具体模块可以放后面了解，主要模块了解下。</p><p>Spring 5.x 主要模块</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212051.png" alt="image.png"><br>各个模块的依赖关系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231201212107.png" alt="image.png"></p><blockquote><p>Core Container</p></blockquote><p>其中主要模块中，Core Container  是 Spring 框架的核心模块，也是基础模块，它提供了 IOC 的依赖注入功能，Spring 的<strong>其他模块实现的功能也是在依赖该模块的基础上进行实现的</strong>。</p><p>Core Container 的子模块：</p><ul><li><strong>spring-core</strong>：Spring 框架基本的核心工具类。</li><li><strong>spring-beans</strong>：提供对 bean 的创建、配置和管理等功能的支持。</li><li><strong>spring-context</strong>：提供对国际化、事件传播、资源加载等功能的支持。</li><li><strong>spring-expression</strong>：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用</li></ul><blockquote><p>AOP</p></blockquote><ul><li><strong>spring-aspects</strong>：该模块为与 AspectJ 的集成提供支持。</li><li><strong>spring-aop</strong>：提供了面向切面的编程实现。</li><li><strong>spring-instrument</strong>：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。(这个模块的使用场景非常有限)</li></ul><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://www.pdai.tech/md/spring/spring.html">https://www.pdai.tech/md/spring/spring.html</a></li><li><a href="https://blog.csdn.net/Mixzi/article/details/123980213">https://blog.csdn.net/Mixzi/article/details/123980213</a></li><li><a href="https://www.moguit.cn/info/794">https://www.moguit.cn/info/794</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容</title>
    <link href="/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>关系型数据库</li><li>数据类型</li><li>MySQL基础架构</li><li>存储引擎</li><li>MySQL索引</li><li>数据库事务</li><li>多版本并发控制</li><li>MySQL锁</li><li>MySQL日志</li><li>性能优化</li><li>主从复制，读写分离，分库分表</li></ul><p>MySQL是一种关系型数据库管理系统（RDBMS)，用于持久化存储数据。</p><h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul><li>字段类型<ul><li>数值类型<ul><li>整型<ul><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>INT</li><li>BIGINT</li></ul></li><li>浮点型<ul><li>FLOAT<br>DOUBLE</li></ul></li><li>定点型<ul><li>DECIMAL</li></ul></li></ul></li><li>字符串类型<ul><li>常用<ul><li>CHAR</li><li>VARCHAR</li></ul></li><li>TEXT 类<ul><li>TINYTEXT</li><li>TEXT</li><li>MEDIUMTEXT</li><li>LONGTEXT</li></ul></li><li>BLOB类<ul><li>TINYBLOB</li><li>BLOB</li><li>MEDIUMBLOB</li><li>LONGBLOB</li></ul></li></ul></li><li>日期时间类型<ul><li>常用<ul><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li>TIMESATMP</li></ul></li></ul></li></ul></li></ul><h4 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h4><p>MySQL的基础架构主要由以下几个关键组件构成：</p><ol><li><strong>连接器（Connection Management）：</strong><ul><li>负责身份认证和权限相关的工作，管理用户的连接请求，处理用户登录MySQL的过程。</li></ul></li><li><strong>查询缓存（Query Cache）：</strong><ul><li>在执行查询语句之前，MySQL会先检查查询缓存，如果之前执行过相同的查询，就可以直接返回缓存中的结果。然而，由于MySQL 8.0版本后移除了查询缓存，因为该功能在实际应用中并不太实用。</li></ul></li><li><strong>分析器（Parser）：</strong><ul><li>当查询缓存未命中时，SQL语句会经过分析器。分析器的主要任务是解析SQL语句，确定其意图，并检查语法的正确性。</li></ul></li><li><strong>优化器（Optimizer）：</strong><ul><li>优化器根据MySQL的统计信息和规则，选择执行SQL查询的最优执行计划，以提高查询性能。</li></ul></li><li><strong>执行器（Execution Engine）：</strong><ul><li>执行器负责执行经过优化后的查询计划，通过存储引擎访问实际的数据，并将结果返回给用户。<br> <strong>权限判断（Access Control）：</strong><ul><li>在执行语句之前，MySQL会进行权限判断，确保用户具有执行该语句所需的权限。如果用户没有足够的权限，将会报错。</li></ul></li></ul></li><li><strong>插件式存储引擎（Pluggable Storage Engines）：</strong><ul><li>MySQL支持多种存储引擎，如InnoDB、MyISAM、Memory等。这些存储引擎负责实际的数据存储和读取，通过插件式架构，用户可以根据需求选择合适的存储引擎。<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301556607.png" alt="image.png"></li></ul></li></ol><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>MySQL 当前默认的存储引擎是 InnoDB。</p><p>在 MySQL的存储引擎中，只有 InnoDB 是事务性存储引擎（只有他支持事务） </p><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>索引是在<strong>存储引擎层实现</strong>的，而不是在服务器层实现的，不同存储引擎具有不同的索引类型和实现。</p><blockquote><p>索引类型</p></blockquote><p>MySQL支持多种索引类型，其中最常见的是B树索引和哈希索引。</p><p>大多数情况下，使用B树索引是最合适的选择，它适用于各种不同查询类型。</p><blockquote><p>索引的创建和注意事项</p></blockquote><p>实际操作的时候我们一般会通过分析查询执行计划来优化查询，确保MySQL使用比较正确的索引。</p><p>尽管一般添加索引会优化数据的查询性能，但过多或者不必要的索引有时候会导致写操作的性能下降。因此索引的添加是需要权衡一定利弊的。</p><p>除了在创建索引时权衡读写性能，还需要定期进行索引的性能分析和优化。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>事务的特性：要么全部执行成功，要么全部执行失败</p><blockquote><p>事务的ACID属性</p></blockquote><ul><li><strong>原子性（Atomicity）：</strong> 事务是一个原子操作单元，要么全部执行，要么全部回滚，不存在部分执行的情况。</li><li><strong>一致性（Consistency）：</strong> 事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不破坏数据库的完整性约束。</li><li><strong>隔离性（Isolation）：</strong> 事务的执行是相互隔离的，一个事务的修改在另一个事务看来是不可见的，防止并发引起的问题。</li><li><strong>持久性（Durability）：</strong> 一旦事务被提交，其修改将永久保存在数据库中，即使系统发生故障也不会丢失。</li></ul><blockquote><p>事务控制语句</p></blockquote><p>事务的开始、提交和回滚：</p><ul><li><code>BEGIN</code> 或 <code>START TRANSACTION</code>：开始一个新的事务。</li><li><code>COMMIT</code>：提交事务，将更改永久保存到数据库。</li><li><code>ROLLBACK</code>：回滚事务，撤销自上一次<code>COMMIT</code>或<code>ROLLBACK</code>以来的所有更改。</li></ul><blockquote><p>事务的隔离级别</p></blockquote><p>MySQL支持多个事务隔离级别，包括读未提交、读已提交、可重复读和串行化。</p><h4 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h4><p>略</p><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_8-2-mysql">https://www.pdai.tech/md/interview/x-interview.html#_8-2-mysql</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows旧电脑重装CentOs7系统制作为个人服务器</title>
    <link href="/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>如果需要将一台 winodws 电脑重装为 centos 系统，需要分为下面几步</p><ul><li>1、先对 windows 进行磁盘格式化操作</li><li>2、通过 iso 文件进行对某个U盘刻录操作</li><li>3、电脑通过这个U盘进行安装 centos 系统</li><li>4、基本配置与使用</li></ul><p>具体操作见如下内容：</p><h3 id="1、格式化windows-的盘符"><a href="#1、格式化windows-的盘符" class="headerlink" title="1、格式化windows 的盘符"></a>1、格式化windows 的盘符</h3><p>重新安装 centos 系统前，需要在 window 系统下先进入PE环境，将原来装有Windows系统的盘符使用分区工具格式化为FAT32格式.</p><blockquote><p>制作U盘启动盘</p></blockquote><p>使用老毛桃U盘启动工具制作U盘启动盘:  <a href="http://lmt.psydrj.com/udisk.html">http://lmt.psydrj.com/udisk.html</a></p><p>模式选择USB—HDD，格式选择“NTFS”；制作完成后，可以选择模拟启动测试，若能够进入老毛桃winpe主菜单，即表示老毛桃U盘启动盘制作成功。【这里主要是要用到他的第四个 DiskGenius 工具】</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126214740.png" alt="image.png"></p><p>重新启动电脑，进入bios</p><p>界面会让你选择一个 boot device ，你这里根据英文选择一下 U 盘启动（界面是显示的U盘名称）</p><p>然后会进入到上面图片的内容（选择  DiskGenius ）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126220736.png" alt="image.png"></p><p>选择快速分区，选择分区类型FAT32，选择 1 个分区，</p><h3 id="2、重装-centos-系统"><a href="#2、重装-centos-系统" class="headerlink" title="2、重装 centos 系统"></a>2、重装 centos 系统</h3><p>下载好 centos7 的镜像文件： </p><ul><li><a href="https://man.linuxde.net/download/CentOS_7_4">https://man.linuxde.net/download/CentOS_7_4</a></li><li><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></li></ul><h4 id="刻录操作"><a href="#刻录操作" class="headerlink" title="刻录操作"></a>刻录操作</h4><p>下载 UltraISO 软碟通 </p><p>格式化之前的U盘，格式化为 FAT32 文件系统（或者准备第二个U盘）</p><p>选择写入硬盘映像</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222516.png" alt="image.png"></p><p>写入方式默认（USB-HDD+），单击便携启动，单击写入新的驱动器引导扇区，单击Syslinux。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222715.png" alt="image.png"></p><p>完毕后，单击下方写入，等待进度条满写入完毕。</p><blockquote><p>记：中间遇到一次 提示格式化重新操作</p></blockquote><p>UltraISO的软件提示其实是准确的，但却是程序员思维下科学素养级别的提示。这里的建议格式化U盘后再试，意思是建议你删除所有分区后重试</p><p>解决处理：</p><ul><li>1、下载 DiskGenius 格式化所有分区 </li><li>2、用win+R打开cmd，输入“diskpart”    输入“list disk”查看所有磁盘   依据大小选中对应磁盘“select disk x”    输入“clean”删除所有分区</li></ul><p>第一种方式的下载地址： <a href="https://xiazai.zol.com.cn/detail/33/327603.shtml">https://xiazai.zol.com.cn/detail/33/327603.shtml</a></p><p>格式化转换盘符为FAT32格式</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126234720.png" alt="image.png|500"></p><p>实际操作的时候显示设备写入错误 55</p><p>也试了一下网上说的通过管理员运行，或者上面说的格式化操作，都不行；最后通过买了一个新的 U 盘解决。</p><blockquote><p>通过 balenaEtcher 进行刻录操作</p></blockquote><p>下载地址：</p><ul><li><a href="https://www.ssdtop.com/balenaetcher.html">https://www.ssdtop.com/balenaetcher.html</a></li><li><a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></li></ul><p>下载  balenaEtcher 进行刻录操作，还是失败</p><p>猜测大概是U盘有问题，或者换一台电脑进行操作；这里选择重新购买一个新的 U 盘进行操作</p><p>Later…</p><p>新 U盘 通过 DiskGenius 格式化U盘分区，再通过 UltraISO 成功进行了刻录操作。</p><hr><h4 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h4><p>将 U 盘 插入需要重装的电脑并开机。如果已经设置完毕以USB为第一启动项，则不用再次进入bios界面。</p><p>没有的话再进入一次，通过 USB 启动。</p><blockquote><p>安装操作</p></blockquote><ul><li>1、选择Install CentOS 7</li><li>2、按回车键</li><li>3、成功进入CentOS系统图形化的安装界面后，进行初始化</li></ul><p>初始化配置</p><ul><li>①中文（语言）</li><li>②软件选择：GNOME桌面</li><li>③安装位置：选择磁盘，手动分区（选择“我要配置分区”）<ul><li>&#x2F;boot     也可以不添加     1G</li><li>&#x2F;swap   交互分区             2G</li><li>&#x2F;            根目录，分配剩下所有空间</li></ul></li></ul><blockquote><p>初始化配置</p></blockquote><p>②软件选择</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234606.png" alt="image.png"></p><p>③添加新挂载点 &#x2F;boot</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234855.png" alt="image.png"></p><p><strong>设置好后点击完成，选择接受更改</strong></p><blockquote><p>网络与主机名</p></blockquote><p>网络与主机名：<strong>打开网络，自己设置一个主机名，然后点击完成</strong></p><blockquote><p>用户设置</p></blockquote><p>开始安装</p><ul><li><strong>点击设置root密码</strong></li><li>等待过程中可以 <strong>创建一个普通用户</strong></li></ul><blockquote><p>重启电脑后配置内容</p></blockquote><p>重启电脑</p><p><strong>重启后进入初始设置界面，接受许可，然后点击完成配置</strong>  → 完成配置</p><p><strong>等待，然后来到登录页面，我们选择未列出，然后输入root和root的密码，然后点击登录。</strong></p><p><strong>来到桌面，我们选择语言为中文</strong></p><p><strong>关闭位置服务</strong></p><p>跳过在线账号</p><hr><h3 id="3、使用-windows-访问同一个局域网下的-linux-系统"><a href="#3、使用-windows-访问同一个局域网下的-linux-系统" class="headerlink" title="3、使用 windows 访问同一个局域网下的 linux 系统"></a>3、使用 windows 访问同一个局域网下的 linux 系统</h3><p>设置完成后，连接同一个wife</p><p>在 windows 中使用 xshell&#x2F;termius 工具访问即可</p><h3 id="4、内网穿透的使用"><a href="#4、内网穿透的使用" class="headerlink" title="4、内网穿透的使用"></a>4、内网穿透的使用</h3><p>略</p><p>暂未有这个需求，后续考虑使用。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/m0_59302403/article/details/132119884">https://blog.csdn.net/m0_59302403/article/details/132119884</a></li><li><a href="https://blog.csdn.net/weixin_42292697/article/details/110285529">https://blog.csdn.net/weixin_42292697/article/details/110285529</a></li><li><a href="https://www.bilibili.com/video/BV1c3411T7Td">https://www.bilibili.com/video/BV1c3411T7Td</a></li><li><a href="https://blog.csdn.net/m0_51545690/article/details/123238360">https://blog.csdn.net/m0_51545690/article/details/123238360</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Records</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人在线网盘_ZFile</title>
    <link href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/"/>
    <url>/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/</url>
    
    <content type="html"><![CDATA[<p>看到有一个还不错的项目，有时候需要将文件放置在云端，这里学习使用一下这个工具。（支持预览操作）</p><p>项目地址： <a href="https://github.com/zfile-dev/zfile">https://github.com/zfile-dev/zfile</a></p><p>部署文档地址： <a href="https://docs.zfile.vip/">https://docs.zfile.vip/</a></p><h3 id="1、项目运行"><a href="#1、项目运行" class="headerlink" title="1、项目运行"></a>1、项目运行</h3><p>下载项目后，需要系统里面有 JDK8 的环境</p><blockquote><p>Centos 系统运行</p></blockquote><blockquote><p>安装 JDK8</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk unzip<br></code></pre></td></tr></table></figure><blockquote><p>下载并解压</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ZFILE_INSTALL_PATH=~/zfile                        <span class="hljs-comment"># 声明安装到的路径</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ZFILE_INSTALL_PATH</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>   <span class="hljs-comment"># 创建文件夹并进入</span><br>wget --no-check-certificate https://c.jun6.net/ZFILE/zfile-release.war          <span class="hljs-comment"># 下载 zfile 最新版</span><br>unzip zfile-release.war &amp;&amp; <span class="hljs-built_in">rm</span> -rf zfile-release.war      <span class="hljs-comment"># 解压并删除压缩包</span><br><span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>/bin/*.sh                    <span class="hljs-comment"># 授权启动停止脚本</span><br></code></pre></td></tr></table></figure><p>ZFile 提供了一个 在线下载路径，也可以本地下载后自定义设备某些内容后，打包为 war ，放置在 linux 系统上运行。</p><p>如需修改配置文件，配置文件路径为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>WEB-INF<span class="hljs-regexp">/classes/</span>application.properties<br></code></pre></td></tr></table></figure><hr><p>安装说明</p><p>下面命令中第一行表示默认安装到用户目录下: <code>~/zfile</code> 下。</p><p>对于 <code>root</code> 用户, <code>~</code> &#x3D; <code>/root</code>, <code>~/zfile</code> 表示在 <code>/root/zfile</code> 路径下。</p><p>对于其他用户, <code>~</code> &#x3D; <code>/home/用户名</code> 表示在 <code>/home/用户名/</code> 路径下。如对于 <code>oracle</code> 用户, <code>~/zfile</code> 则表示安装在 <code>/home/oracle/zfile</code> 下。</p><p>如需更改安装路径, 请自行修改，如 <code>export ZFILE_INSTALL_PATH=/data/zfile</code>，表示安装在 <code>/data/zfile</code> 路径下。</p><hr><h3 id="2、启动项目"><a href="#2、启动项目" class="headerlink" title="2、启动项目"></a>2、启动项目</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br></code></pre></td></tr></table></figure><hr><p>启动后浏览器访问 <strong><code>http://ip:8080</code></strong> 即可，如启动后无法访问，请检查 <strong><code>端口是否冲突</code></strong> 或 <code>防火墙/安全组是否开启</code>。</p><p>简单检查方式为在服务器执行 <code>curl http://127.0.0.1:8080</code></p><ul><li>如返回 <code>curl: (7) Failed connect to 127.0.0.1:8080; Connection refused</code> 表示未启动成功。</li><li>如返回 <code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt;……</code> 等字样表示启动成功，如启动成功但通过服务器 IP 无法访问，那一般就是防火墙&#x2F;安全组未放行端口问题。</li></ul><hr><p>更新程序前务必停止程序再进行操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br>~<span class="hljs-regexp">/zfile/</span>bin/stop.sh        <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch_基础内容</title>
    <link href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><code>Elasticsearch</code>是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本  身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p><p>ES也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得  简单。</p><blockquote><p>Elasticsearch比传统关系型数据库如下：</p></blockquote><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Relational</span> <span class="hljs-variable constant_">DB</span> ‐&gt; <span class="hljs-title class_">Databases</span> ‐&gt; <span class="hljs-title class_">Tables</span> ‐&gt; <span class="hljs-title class_">Rows</span> ‐&gt; <span class="hljs-title class_">Columns</span>  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Elasticsearch</span> ‐&gt; <span class="hljs-title class_">Indices</span> ‐&gt; <span class="hljs-title class_">Types</span> ‐&gt; <span class="hljs-title class_">Documents</span> ‐&gt; <span class="hljs-title class_">Fields</span></span><br></code></pre></td></tr></table></figure><p>to be contined…..</p><p>参考</p><ul><li><a href="https://elasticsearch.bookhub.tech/getting_started/">https://elasticsearch.bookhub.tech/getting_started/</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li><a href="https://www.cnblogs.com/coderxz/p/13268417.html">https://www.cnblogs.com/coderxz/p/13268417.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/516698885">https://zhuanlan.zhihu.com/p/516698885</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
      <category>Elasticsearch</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习_基础内容</title>
    <link href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Vue 基础</li><li>Vue 语法</li><li>组件化开发</li><li>路由</li><li>webpack</li><li>脚手架</li></ul><hr><p>参考</p><ul><li><a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li><li><a href="https://blog.csdn.net/fmk1023/article/details/111381876">https://blog.csdn.net/fmk1023/article/details/111381876</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven工具_基础使用</title>
    <link href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Maven-下载与安装"><a href="#1、Maven-下载与安装" class="headerlink" title="1、Maven 下载与安装"></a>1、Maven 下载与安装</h3><p>略</p><h3 id="2、Maven配置文件修改"><a href="#2、Maven配置文件修改" class="headerlink" title="2、Maven配置文件修改"></a>2、Maven配置文件修改</h3><blockquote><p>maven 配置文件内容</p></blockquote><p>设置本地仓库路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置本地仓库路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\maven\localRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置阿里云私服（或换成自己公司搭建的私服）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在mirrors标签里添加mirror标签，并指定阿里云私服下载依赖会快点 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置 maven 默认jdk版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在已有的profiles标签中添加profile标签，限定maven项目默认的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- 让增加的 profile生效 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置华为云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.huaweicloud.com/repository/maven/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>阿里云:   <a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个论点，配置的时候注意一下：<strong>一个仓库只能对应一个镜像，当有多个镜像的mirrorOf指定了同一个仓库，maven只会从第一个匹配的仓库中进行查找</strong></p><h3 id="3、IDEA-配置-maven"><a href="#3、IDEA-配置-maven" class="headerlink" title="3、IDEA 配置 maven"></a>3、IDEA 配置 maven</h3><blockquote><p>IDEA 配置 maven</p></blockquote><p>快捷查找框中输入maven，查找与maven相关的设置，然后点击maven</p><p>修改maven的路径（使用本地的Maven），以及修改settings文件的位置和本地仓库的位置</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242131645.png" alt="image.png"></p><p>IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，进行勾选</p><p>他的意思是： mvn(directory):  位于项目的顶级目录中，文件 maven.config、jvm.config和extensions.xml 包含运行Maven的项目特定配置。这个目录应该是项目的一部分，需要被版本管理工具管理</p><blockquote><p>推荐配置：设置maven在不联网的情况下使用本地插件</p></blockquote><p>一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。（根据骨架创建项目速度会加快）</p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242133069.png" alt="image.png"></p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><h3 id="4、IDEA导入项目后maven-常见报错"><a href="#4、IDEA导入项目后maven-常见报错" class="headerlink" title="4、IDEA导入项目后maven 常见报错"></a>4、IDEA导入项目后maven 常见报错</h3><p>方法一：改一下 maven 配置文件，修改 mirror 仓库位置，重新导入项目，重新加载 maven 依赖</p><p>方法二：IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，不进行勾选试一下</p><p>方法三：去一下仓库地址，查看是否是否有该版本依赖，如果没有，改一下版本，或者手动下载，手动导入到本地仓库中</p><blockquote><p>报错1：解决Maven ‘parent.relativePath‘ of POM</p></blockquote><p>错误分析  </p><p>子模块的parent写的不是父模块，而是继承了springboot</p><p>解决方法  </p><p>在该<code>&lt;parent&gt;</code>标签中加上<code>&lt;relativePath /&gt;</code></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>   /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>报错2：对于类似于xxx-maven-plugin的插件报红</p></blockquote><p>类似于这样的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>    <br></code></pre></td></tr></table></figure><p>报红就直接用不了了</p><p>我们可以通过添加依赖的方式解决（原来的插件就是上面的代码<strong>不要删</strong>）:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>wagon-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yang_yzl11/article/details/120764764">https://blog.csdn.net/yang_yzl11/article/details/120764764</a></li><li><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">https://blog.csdn.net/qq_42057154/article/details/106114515</a></li><li><a href="https://www.cnblogs.com/SherlockLynn/p/15079467.html">https://www.cnblogs.com/SherlockLynn/p/15079467.html</a></li><li><a href="https://blog.csdn.net/qq_38217990/article/details/129257106">https://blog.csdn.net/qq_38217990/article/details/129257106</a></li><li><a href="https://zhuanlan.zhihu.com/p/653017610">https://zhuanlan.zhihu.com/p/653017610</a></li><li><a href="https://blog.csdn.net/qq_39505065/article/details/111559890">https://blog.csdn.net/qq_39505065/article/details/111559890</a></li><li><a href="https://blog.csdn.net/m0_46682011/article/details/120626933">https://blog.csdn.net/m0_46682011/article/details/120626933</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Nacos</title>
    <link href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/"/>
    <url>/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Nacos-是什么"><a href="#1、Nacos-是什么" class="headerlink" title="1、Nacos 是什么"></a>1、Nacos 是什么</h3><p>Nacos 是一个构建云原生应用的动态服务发现、配置管理和服务管理平台；致力于帮助发现、配置和管理微服务。</p><h3 id="2、下载与运行"><a href="#2、下载与运行" class="headerlink" title="2、下载与运行"></a>2、下载与运行</h3><p>下载地址： <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>windows版本使用<code>nacos-server-x.x.x.zip</code>包即可</p><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154048.png" alt="image.png"><br>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154144.png" alt="image.png"></p><blockquote><p>启动命令(Windows)</p></blockquote><p>启动非常简单，进入bin目录</p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><blockquote><p>访问</p></blockquote><p>在浏览器输入地址： <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> </p><p>默认的账号和密码都是nacos</p><blockquote><p>Namespace+Group+DataID三者的关系</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250024118.png" alt="image.png|400"></p><blockquote><p>多环境配置</p></blockquote><p>略</p><h3 id="3、Nacos-的基本使用"><a href="#3、Nacos-的基本使用" class="headerlink" title="3、Nacos 的基本使用"></a>3、Nacos 的基本使用</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>在 spring-cloud-alibaba-service 的主启动类上，使用 @EnableDiscoveryClient 注解开启 Nacos 服务发现功能</p><p>你访问该服务下的某个请求链接，再查看 nacos “服务管理”下的“服务列表”，会发现已经注册上了。</p><p>一般在消费端会引入 spring-cloud-loadbalancer 进行调用服务提供者提供的服务</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p><strong>动态获取配置内容</strong></p></blockquote><p>在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config ，可实现配置的获取与动态刷新</p><p>示例 </p><p>bootstrap.yml 文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span> <span class="hljs-comment">#端口号</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span> <span class="hljs-comment">#服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活 dev 的配置</span><br></code></pre></td></tr></table></figure><p>在 icu.luoqi.nacos.controller 包下，创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;<br><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;config.info&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String ConfigInfo;<br>    <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/config/info&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getConfigInfo()&#123;<br>        <span class="hljs-keyword">return</span> ConfigInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p><p>启动 Nacos Server，并在 Nacos Server 控制台的“配置管理”下的“配置列表”中，点击“+”按钮，新建如下配置</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Data ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">       config-client-dev.yaml</span><br><br><span class="hljs-attribute">Group</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         DEFAULT_GROUP</span><br><br><span class="hljs-attribute">配置格式</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      YAML</span><br><br><span class="hljs-attribute">配置内容</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      config:</span><br>                   <span class="hljs-attribute">info</span><span class="hljs-punctuation">:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>&#123;prefix&#125;-<span class="hljs-symbol">$</span>&#123;spring.profiles.active&#125;.<span class="hljs-symbol">$</span>&#123;<span class="hljs-keyword">file</span>-extension&#125;<br></code></pre></td></tr></table></figure><p>启动该服务，并使用浏览器访问“<a href="http://localhost:3377/config/info%E2%80%9D%EF%BC%8C">http://localhost:3377/config/info”，</a></p><p>在这种情况下，能够实现不重启后台服务，当你手动修改 nacos 的配置时，能够动态获取到配置内容。</p><blockquote><p>Nacos Config配置集的三种方式和加载顺序</p></blockquote><ul><li>通过 spring.cloud.nacos.config.shared-configs 配置项，支持多个共享 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.extension-configs 配置项，支持多个拓展 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.name 配置项，支持一个 Nacos 配置集。</li></ul><p>当三种方式共同使用时，它们的优先级关系是：A &lt; B &lt; C。另外，A 和 B 的命名带有“共享”或是“拓展”，没有任何含义，只是优先级不同</p><h3 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h3><p>命名空间id用于唯一标识命名空间， 新建命名空间时候，如果不填写命名空间id，则系统会自动生成命名空间id，生成规则为UUID方式。</p><p>但在spring 项目中集成nacos 的时候，配置文件中填写的namespace就是命名空间的id</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260000905.png" alt="image.png"></p><p>因此尽量保持nacos的命名空间名称和id 一致</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260002165.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106835279">https://blog.csdn.net/qq_36903261/article/details/106835279</a></li><li><a href="https://m.biancheng.net/springcloud/nacos.html">https://m.biancheng.net/springcloud/nacos.html</a></li><li><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></li><li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></li><li><a href="https://blog.csdn.net/weixin_45397785/article/details/128076533">https://blog.csdn.net/weixin_45397785/article/details/128076533</a></li><li><a href="https://blog.csdn.net/ysj1241267542/article/details/112562611">https://blog.csdn.net/ysj1241267542/article/details/112562611</a></li><li><a href="https://blog.csdn.net/u010520146/article/details/118703413">https://blog.csdn.net/u010520146/article/details/118703413</a></li><li><a href="https://blog.csdn.net/wangwei021933/article/details/129590430">https://blog.csdn.net/wangwei021933/article/details/129590430</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_实现在百度中搜索到自己的博客</title>
    <link href="/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1、注册一个百度站长账号</p></blockquote><p>地址： <a href="https://ziyuan.baidu.com/?castk=LTE=">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><p>验证网站所有权： <a href="https://ziyuan.baidu.com/site/index">https://ziyuan.baidu.com/site/index</a></p><p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Vercel</code>的地址，然后点击下一步。</p><p>站点领域： 信息技术</p><p>验证：选择第二种验证方式  →  HTML 验证</p><p><strong>本博客使用的是 fluid 主题</strong>，</p><p>进入博客目录下 <code>scripts</code> 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容（content 见百度具体验证内容)：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab">hexo.extend.filter.register(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(injects)</span> &#123;</span><br>  injects.head.raw(<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;&lt;meta name=&quot;</span>baidu-site-verification<span class="hljs-string">&quot; content=&quot;</span>xxxxxxxxxxxxxxx<span class="hljs-string">&quot; /&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在博客 <code>_config.yml</code> 文件加一句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_site_verification:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了。</p><p>点击验证按钮，如果没问题则已成功。</p><blockquote><p>2、站点地图功能</p></blockquote><p>需要生成一个站点地图</p><p>先确认一下 <code>_config.yml</code> 配置里面的 URL 值，如果不是改为自己的域名地址。</p><p>博客目录执行命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save        <span class="hljs-comment">#安装sitemap插件</span><br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save  <span class="hljs-comment">#安装baidu-sitemap插件</span><br><br>  <br>hexo g  <span class="hljs-comment">#生成网站静态文件到public文件夹</span><br></code></pre></td></tr></table></figure><blockquote><p>查看根目录下的public目录，会生成两个文件，“sitemap.xml ”和 “baidusitemap.xml”</p></blockquote><p>其中“sitemap.xml”文件是搜索引擎通用的文件，</p><p>“baidusitemap.xml”是百度专用的sitemap文件，</p><blockquote><p>3、提交sitemap到百度资源搜索平台</p></blockquote><p>选择资源提交，点击普通收录，选择sitemap， <a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a></p><p>填写网站地址，例：“域名&#x2F;baidusitemap.xml”，点击提交，过一段时间后博客就可以在百度中搜素到。</p><p>个人使用的时候这一步显示提交上限是 0 ；只能使用他手动提交的方式，而且只能是访问链接。</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/Passerby_Wang/article/details/124704475">https://blog.csdn.net/Passerby_Wang/article/details/124704475</a></li><li><a href="https://py-wang.blog.csdn.net/article/details/121202486">https://py-wang.blog.csdn.net/article/details/121202486</a></li><li><a href="https://cloud.tencent.com/developer/article/2317858">https://cloud.tencent.com/developer/article/2317858</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81</a></li><li><a href="https://zhuanlan.zhihu.com/p/150999914">https://zhuanlan.zhihu.com/p/150999914</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vercel的开箱使用_同步Hexo静态博客</title>
    <link href="/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>官网： <a href="https://vercel.com/">https://vercel.com/</a></p><p>部署无脑式导入 Github 原项目，然后进行 deploy 就行。命令可以自定义设置，一般是 hexo -s 之类的。(Vercels是支持你推送代码到Github的时候你在Vercel的项目也是会进行自动更新的)</p><p>点击部署的时候项目配置添加自定义域名操作：</p><p>Setting →  Domains →  选择添加解析域名</p><p>官网文档参考的解析域名地址</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240050203.png" alt="image.png"></p><p>实际操作记录：</p><p>个人使用的是阿里云的域名解析，在对应域名下添加了这一条记录<br>（对应 的记录值是 <code>cname.vercel-dns.com</code> ，记录类型需要是 CNAME）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240052961.png" alt="image.png"></p><p>domain 选择编辑对应的域名地址: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">varcel. + 你的阿里云域名<br></code></pre></td></tr></table></figure><p>最后部署访问成功。</p><hr><p>参考</p><ul><li><a href="https://juejin.cn/post/7143067114025254919">https://juejin.cn/post/7143067114025254919</a></li><li><a href="https://zhuanlan.zhihu.com/p/646818470">https://zhuanlan.zhihu.com/p/646818470</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>蘑菇博客项目_Day01</title>
    <link href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/"/>
    <url>/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/</url>
    
    <content type="html"><![CDATA[<h3 id="1、项目下载"><a href="#1、项目下载" class="headerlink" title="1、项目下载"></a>1、项目下载</h3><p>项目下载地址： <a href="https://gitee.com/moxi159753/mogu_blog_v2">https://gitee.com/moxi159753/mogu_blog_v2</a></p><h3 id="2、项目后端启动"><a href="#2、项目后端启动" class="headerlink" title="2、项目后端启动"></a>2、项目后端启动</h3><p>后端项目启动：</p><p>相关环境需要先启动和运行</p><p><code>nacos</code>，<code>nginx</code>，<code>rabbitmq</code>， <code>redis</code>，<code>mysql</code>，</p><p>模块启动：</p><p><code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p><blockquote><p>配置 Nacos</p></blockquote><p>模块启动前先配置一下 nacos </p><p>mogu 的启动方式是将数据放在了 mysql 数据库中，因此我们需要先执行它项目中的 nacos_config.sql 脚本</p><p>创建一个数据库 nacos_config，将配置导入到mysql中</p><p>解压nacos 到另外一个文件夹，然后进入 conf目录，打开 application.properties文件</p><p>在文件的末尾添加mysql的配置信息，注意mysql的账号和密码</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment"># mysql配置</span><br><span class="hljs-attr">spring.datasource.platform</span>=mysql<br><span class="hljs-attr">db.num</span>=<span class="hljs-number">1</span><br><span class="hljs-attr">db.url.0</span>=jdbc:mysql://<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">3306</span>/nacos_config?characterEncoding=utf8&amp;connectTimeout=<span class="hljs-number">1000</span>&amp;socketTimeout=<span class="hljs-number">3000</span>&amp;autoReconnect=<span class="hljs-literal">true</span>&amp;serverTimezone=UTC<br><span class="hljs-attr">db.user</span>=root<br><span class="hljs-attr">db.password</span>=root<br></code></pre></td></tr></table></figure><p>到nacos下的 bin 目录，启动服务</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><p>访问： <a href="http://127.0.0.1:8848/nacos/#/login">http://127.0.0.1:8848/nacos/#/login</a></p><p>启动模块前先将 dev 命名空间下的 配置文件对应的 redis, zipkin,mysql,rabbitmq的配置文件改一下</p><p>启动一下 相应服务</p><blockquote><p>执行一下数据库SQL 脚本</p></blockquote><blockquote><p>修改一下 Nacos 配置文件</p></blockquote><blockquote><p>依次启动服务：<code>mogu-gateway</code>，<code>mogu-sms</code>，<code>mogu-picture</code>， <code>mogu-web</code>, <code>mogu-admin</code></p></blockquote><p>如果显示 zipkin 连接失败，尝试修改一下配置，添加一下 serviceName</p><p>Spring Cloud Sleuth配置中设置服务名称的示例：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">spring:</span><br><span class="hljs-symbol">  sleuth:</span><br><span class="hljs-symbol">    sampler:</span><br><span class="hljs-symbol">      probability:</span> <span class="hljs-number">1.0</span><br><span class="hljs-symbol">    zipkin:</span><br><span class="hljs-symbol">      baseUrl:</span> http:<span class="hljs-comment">//192.168.31.79:9411</span><br><span class="hljs-symbol">      serviceName:</span> your-service-name<br></code></pre></td></tr></table></figure><p>后端启动成功后，能够查看到对应的Swagger接口文档</p><blockquote><p>nacos版本：swagger-ui使用的是3.X，访问的页面是 <a href="http://localhost:8601/swagger-ui/index.html">http://localhost:8601/swagger-ui/index.html</a><br>sms 服务里面有短信和邮箱的配置，也注意改一下</p></blockquote><hr><h3 id="3、前端项目启动"><a href="#3、前端项目启动" class="headerlink" title="3、前端项目启动"></a>3、前端项目启动</h3><blockquote><p>vue_mogu_admin</p></blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># 指定node-sass的国内镜像源</span><br>npm i node-sass <span class="hljs-attribute">--sass_binary_site</span>=https://npm.taobao.org/mirrors/node-sass<br><br><span class="hljs-comment"># 使用淘宝镜像源进行依赖安装，解决国内下载缓慢的问题(出现警告可以忽略)</span><br>npm install <span class="hljs-attribute">--registry</span>=https://registry.npm.taobao.org<br><br><span class="hljs-comment"># 启动项目</span><br>npm <span class="hljs-built_in">run</span> dev<br><br><span class="hljs-comment">#打包项目（在部署的时候才需要使用）</span><br>npm <span class="hljs-built_in">run</span> build<br></code></pre></td></tr></table></figure><p>启动项目成功后，会跳转到：localhost:9528 ，</p><p>默认账号密码： admin, mogu2018 </p><p>实际在运行项目的时候，第一步有些问题，做了以下操作：</p><ul><li><ol><li>更新了一下依赖版本：”html-webpack-plugin”: “3.2.0”,</li></ol></li><li><ol start="2"><li>将windows 下的 3.x 的python 版本降级安装为 2.x 版本，且不超过 2.7</li></ol></li><li><ol start="3"><li>安装了 Visual C++ Build Tools for Visual Studio 2015</li></ol></li></ul><p>关于第三步，下载地址：<a href="https://my.visualstudio.com/Downloads?q=C++%20build">Downloads &amp; Keys - Visual Studio Subscriptions</a></p><p>在类型处选择DVD，然后下载下来，解压缩后运行其中的exe文件</p><blockquote><p>vue_mogu_web</p></blockquote><p>与上面一致，访问界面：localhost:9527</p><p>实际操作，有一些更改</p><ul><li><ol><li>由于依赖中 “node-sass”: “^4.14.1”, 需要和 node 版本对应，这里切换 Node 14 版本（使用NVM)</li></ol></li><li><ol start="2"><li>再次执行上面相同的运行命令</li></ol></li><li><ol start="3"><li>遇到运行命令可以尝试先删除node_module 文件夹再执行，或者执行 <code>npm cache clean --force</code> 再试一下。</li></ol></li></ul><p>至此，项目是能够完整运行并在浏览器上面访问。</p><hr><p>参考</p><ul><li><a href="https://gitee.com/moxi159753/mogu_blog_v2.git">https://gitee.com/moxi159753/mogu_blog_v2.git</a></li><li><a href="https://moxi159753.gitee.io/mogu_blog_doc/#/README">https://moxi159753.gitee.io/mogu_blog_doc/#/README</a></li><li><a href="https://blog.csdn.net/colleges/article/details/123769410">https://blog.csdn.net/colleges/article/details/123769410</a></li><li><a href="https://www.jb51.net/article/281818.htm">https://www.jb51.net/article/281818.htm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Eureka</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Eureka-是什么"><a href="#1、Eureka-是什么" class="headerlink" title="1、Eureka 是什么"></a>1、Eureka 是什么</h3><p>Eureka 是一个Netflix 开源的服务发现组件，包括 Server 和 Client 两部分。在 Spring Cloud 子项目 Spring Cloud Netflix 中。</p><blockquote><p>服务注册与发现</p></blockquote><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。</p><p>而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。</p><p>这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。</p><p>RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何 rpc 远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址）)</p><p>Eureka 系统架构（右图是Dubbo的架构）<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222335266.png" alt="image.png"></p><blockquote><p>Eureka Server 与 Eureka Client</p></blockquote><p>Eureka Server 提供服务注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>Eureka Client通过注册中心进行访问， Eureka Client 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h3 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h3><blockquote><p>服务端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--热部署工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向注册中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#为false表示自己是注册中心</span><br>    <span class="hljs-attr">service-url:</span>    <span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableEurekaServer</span> <span class="hljs-comment">//启动服务发现，接受注册</span><br><span class="hljs-variable">@SpringBootApplication</span><br>public class EurekaServer_7001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目，访问 <a href="http://localhost:7001/">http://localhost:7001/</a></p><blockquote><p>客户端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept-8001</span>   <span class="hljs-comment"># 修改eureka上的默认描述信息</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># true,可以显示服务的IP地址</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br>public class DeptProvider_8001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(DeptProvider_8001.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106551120">https://blog.csdn.net/qq_36903261/article/details/106551120</a></li><li><a href="https://blog.csdn.net/qq_45078781/article/details/118671285">https://blog.csdn.net/qq_45078781/article/details/118671285</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/142941185">https://zhuanlan.zhihu.com/p/142941185</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>通过RestTemplate进行远程调用</title>
    <link href="/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/"/>
    <url>/2023/11/22/%E9%80%9A%E8%BF%87RestTemplate%E8%BF%9B%E8%A1%8C%E8%BF%9C%E7%A8%8B%E8%B0%83%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>RestTemplate 是从 Spring3.0 开始支持的一个 HTTP 请求工具，它提供了常见的REST请求方案的模版。对于远程请求进行了一定封装，从而通过建议配置可以实现远程调用。</p><p>他底层用的是 JDK 的 HTTP 请求</p><ol><li>添加依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置类</li></ol><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">package</span> com.example.demo.config;<br><br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.http.client.ClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.http.client.SimpleClientHttpRequestFactory;<br><span class="hljs-keyword">import</span> org.springframework.web.client.RestTemplate;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RestTemplate配置类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-title class_"><span class="hljs-keyword">class</span> <span class="hljs-title">RestTemplateConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> RestTemplate restTemplate(ClientHttpRequestFactory factory)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-type">RestTemplate</span>(factory);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> ClientHttpRequestFactory simpleClientHttpRequestFactory()&#123;<br>        SimpleClientHttpRequestFactory factory = <span class="hljs-keyword">new</span> <span class="hljs-type">SimpleClientHttpRequestFactory</span>();<br>        factory.setReadTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        factory.setConnectTimeout(<span class="hljs-number">5000</span>);<span class="hljs-comment">//单位为ms</span><br>        <span class="hljs-keyword">return</span> factory;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>示例调用操作</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderController</span> &#123;<br><br>    <span class="hljs-keyword">public</span> static <span class="hljs-keyword">final</span> String PAYMENT_URL = <span class="hljs-string">&quot;http://localhost:8001&quot;</span>;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-comment">//因为浏览器只支持get请求，为了方便这里就用get</span><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/create&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; create(Payment payment)&#123;<br>        log.info(<span class="hljs-string">&quot;********插入的数据：&quot;</span> + payment);<br>        <span class="hljs-comment">//postForObject分别有三个参数：请求地址，请求参数，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.postForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/create&quot;</span>, payment, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/consumer/payment/get/&#123;id&#125;&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> CommonResult&lt;Payment&gt; getPayment(<span class="hljs-meta">@PathVariable(<span class="hljs-string">&quot;id&quot;</span>)</span> <span class="hljs-built_in">Long</span> id)&#123;<br>        log.info(<span class="hljs-string">&quot;********查询的id：&quot;</span> + id);<br>        <span class="hljs-comment">//getForObject两个参数：请求地址，返回的对象类型</span><br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(PAYMENT_URL + <span class="hljs-string">&quot;/payment/get/&quot;</span> + id, CommonResult.<span class="hljs-keyword">class</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined… </p><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44073321/article/details/102804615">https://blog.csdn.net/weixin_44073321/article/details/102804615</a></li><li><a href="https://blog.csdn.net/weixin_43702146/article/details/116567707">https://blog.csdn.net/weixin_43702146/article/details/116567707</a></li><li><a href="https://blog.csdn.net/dqxiaoxiao/article/details/114375873">https://blog.csdn.net/dqxiaoxiao/article/details/114375873</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>CodeProgram</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见工程报错问题</title>
    <link href="/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_基础概念</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SpringCloud是什么"><a href="#1、SpringCloud是什么" class="headerlink" title="1、SpringCloud是什么"></a>1、SpringCloud是什么</h3><p>SpringCloud 提供了一整套的分布式系统解决方案，通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。</p><p>SpringCloud 包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等。</p><p>Spring Cloud 包含很多子项目，国内主要是采用 Netflix 和 Alibaba 两个标准实现，前者由于不再维护，目前一般采用Spring Cloud Alibaba 这一套微服务解决方案。</p><blockquote><p>了解组件</p></blockquote><p>Spring Cloud Netflix 第一代</p><p>针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。</p><ul><li><code>Netflix Eureka</code>：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。</li><li><code>Netflix Ribbon</code>：客户端负载均衡的服务调用组件。</li><li><code>Netflix Hystrix</code>：容错管理工具，实现断路器模式，通过控制服务的节点，从而对延迟和故障提供更强大的容错能力。</li><li><code>Netflix Feign</code>：基于 Ribbon 和 Hystrix 的声明式服务调用组件。</li><li><code>Netflix Zuul</code>：微服务网关，提供动态路由，访问过滤等服务。</li><li><code>Netflix Archaius</code>：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li></ul><p>Spring Cloud Alibaba 第二代</p><p><strong>阿里开源组件</strong></p><ul><li><code>Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><p><strong>阿里商业化组件</strong></p><ul><li><code>Alibaba Cloud ACM</code>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><code>Alibaba Cloud OSS</code>：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><code>Alibaba Cloud SchedulerX</code>：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><code>Alibaba Cloud SMS</code>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><blockquote><p>关于Cloud各种组件的停更升级替换</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221942122.png" alt="image.png"></p><blockquote><p>SpringCloud 版本介绍</p></blockquote><p>略</p><h3 id="2、创建cloud聚合父工程"><a href="#2、创建cloud聚合父工程" class="headerlink" title="2、创建cloud聚合父工程"></a>2、创建cloud聚合父工程</h3><h4 id="初始化工程及配置"><a href="#初始化工程及配置" class="headerlink" title="初始化工程及配置"></a>初始化工程及配置</h4><ol><li>New Project</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221957842.png" alt="image.png"></p><ol start="2"><li>聚合总父工程名字</li><li>Maven选版本</li><li>开启自动导入</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221958787.png" alt="image.png"></p><ol start="5"><li>字符编码</li></ol><p>Settings → Editor →  File Encodings</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222220247.png" alt="image.png"></p><ol start="6"><li>注解生效激活</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222222672.png" alt="image.png"></p><ol start="7"><li>java编译版本选8</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222223525.png" alt="image.png"></p><ol start="8"><li>File Type过滤</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222225655.png" alt="image.png"></p><p>这里File Type 配置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*.idea</span><br><span class="hljs-comment">*.iml</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222226068.png" alt="image.png"></p><h4 id="父工程-pom-配置"><a href="#父工程-pom-配置" class="headerlink" title="父工程 pom 配置"></a>父工程 pom 配置</h4><p>父工程 Pom 文件参考配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.luoqi.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2023<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--统一管理jar包版本--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud alibaba--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mysql--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- druid--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;druid.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mybatis.spring.boot.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--junit--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;junit.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--log4j--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log4j.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><ul><li><ol><li>新建模块</li></ol></li><li><ol start="2"><li>pom文件对应依赖</li></ol></li><li><ol start="3"><li>yml 配置文件</li></ol></li><li><ol start="4"><li>启动类以及其他业务类</li></ol></li></ul><hr><p>参考</p><ul><li><a href="https://gitee.com/lixiaogou/cloud2020">https://gitee.com/lixiaogou/cloud2020</a></li><li><a href="https://blog.csdn.net/qq_36903261/article/details/106507150">https://blog.csdn.net/qq_36903261/article/details/106507150</a></li><li><a href="https://github.com/angenin/cloud2020">https://github.com/angenin/cloud2020</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/110249846">https://zhuanlan.zhihu.com/p/110249846</a></li></ul><p>引用</p><ul><li><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></li><li><a href="https://www.springcloud.cc/">https://www.springcloud.cc/</a></li><li><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapters1_极限与连续</title>
    <link href="/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/"/>
    <url>/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、映射与函数"><a href="#1、映射与函数" class="headerlink" title="1、映射与函数"></a>1、映射与函数</h3><p>学习极限前，先了解一些基础概念，对于函数整个内容有一个认识。</p><h4 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210437941.png" alt="image.png"></p><p>定义：定义域内<strong>任何</strong>元素，都在值域中有<strong>唯一</strong>的元素与之对应。</p><p>函数概念有两个基本要素：定义域、对应法则。</p><p>理解：函数是研究关系的，是在研究两个变量之间的关系。具体来说，函数是研究因变量是怎么随着自变量的变化而变化的。</p><blockquote><p>举例</p></blockquote><p>举个例子，在速度为40km&#x2F;h的匀速运动过程中，路程随时间的变化而变化：</p><ul><li>时间是1时，路程是40；</li><li>时间是2时，路程就是80。</li></ul><p>路程&#x3D;40 * 时间。路程就叫做时间的函数。</p><p>但不是有关系就是函数，不是因变量随自变量变化就是函数。还得满足一个重要的条件：对于自变量的每一个取值，因变量都有唯一的值与它对应！</p><p>例如，上述匀速运动过程中，时间每取一个值，对应计算出路程也是一个值。</p><p>反例：|y|&#x3D;x，在这个式子里，y也随x的变化而变化，但x&#x3D;1时，y&#x3D;1或—1，有两个值了。那y就不是x的函数了。</p><p>所以，函数是两个变量之间的特殊关系</p><h4 id="几个常见函数"><a href="#几个常见函数" class="headerlink" title="几个常见函数"></a>几个常见函数</h4><ul><li>绝对值函数</li><li>符号函数</li><li>取整函数</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210449362.png" alt="image.png"></p><h4 id="函数的特性"><a href="#函数的特性" class="headerlink" title="函数的特性"></a>函数的特性</h4><ul><li>有界性</li><li>单调性</li><li>奇偶性</li><li>周期性</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210452693.png" alt="image.png"></p><h4 id="反函数与复合函数"><a href="#反函数与复合函数" class="headerlink" title="反函数与复合函数"></a>反函数与复合函数</h4><blockquote><p>反函数</p></blockquote><p>定义：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210455686.png" alt="image.png"></p><blockquote><p>复合函数</p></blockquote><p>复合条件：内层函数值域与外层函数定义域的交集非空</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210456045.png" alt="image.png"></p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>函数的运算（加减乘除）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210457870.png" alt="image.png"></p><p>其中函数相除的时候 g(x) 不等于 0 </p><p>相关定理：任何一个函数(定义域对称)都可以找到一个奇函数和一个偶函数，使得这个函数等于偶函数加奇函数</p><blockquote><p>例题（证明题）</p></blockquote><p>以函数的运算证明:任给f(x)的定义域为(-L,L),证明必存在(-L,L)上的偶函数g(x)以及奇函数h(x),使得f(x)&#x3D;g(x)+h(x)</p><p>解析：</p><p>根据前面函数特征中的奇偶性，可以得知 奇函数 h( -x ) &#x3D; -h(x) ; 偶函数 g(-x) &#x3D; g(x)</p><p>先假设存在这样的奇偶函数，</p><p>to be improve….</p><p>解答：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210502430.png" alt="image.png"></p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><p>定义：由常数和基本初等函数经过有限次的加、减、乘、 除和复合所得到且能用一个解析式表示的函数,称为初等函数</p><blockquote><p>基本初等函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210504661.png" alt="image.png"></p><blockquote><p>关于反三角函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210505070.png" alt="image.png"></p><blockquote><p>内容小结</p></blockquote><ul><li>函数的定义及函数的二要素<ul><li>定义域</li><li>对应法则</li></ul></li><li>函数的特性<ul><li>有界性，单调性，奇偶性，周期性</li></ul></li><li>复合函数与反函数</li><li>基本初等函数与初等函数</li></ul><h3 id="2、数列的极限"><a href="#2、数列的极限" class="headerlink" title="2、数列的极限"></a>2、数列的极限</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210548604.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>用定义证明下列极限</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210550053.png" alt="image.png"></p><h4 id="收敛函数的性质"><a href="#收敛函数的性质" class="headerlink" title="收敛函数的性质"></a>收敛函数的性质</h4><p>收敛函数的性质</p><ul><li>唯一性<ul><li>收敛数列的极限唯一</li></ul></li><li>有界性<ul><li>收敛数列必有界</li></ul></li><li>保号性</li><li>任一子数列收敛于同一极限</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210553054.png" alt="image.png"></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210554140.png" alt="image.png"></p><p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/563178651">https://zhuanlan.zhihu.com/p/563178651</a></li><li><a href="https://www.zhihu.com/question/457091692/answer/2763695044">https://www.zhihu.com/question/457091692/answer/2763695044</a></li><li><a href="https://zhuanlan.zhihu.com/p/31206539">https://zhuanlan.zhihu.com/p/31206539</a></li><li>《武忠详高数零基础》</li></ul>]]></content>
    
    
    <categories>
      
      <category>Exam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx_基础概念</title>
    <link href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、启动Nginx"><a href="#1、启动Nginx" class="headerlink" title="1、启动Nginx"></a>1、启动Nginx</h3><blockquote><p>Windows 下启动 nginx</p></blockquote><p>在下载 nginx 后，在nginx安装目录的绝对路径的框框内输入 <code>cmd</code></p><p>直接输入 <code>nginx</code> 或者 <code>start nginx</code>，然后回车，就可以启动nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nginx<br><br><span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>在浏览器地址栏输入 <code>localhost:80</code>，然后再回车, 查看是否有 nginx 访问主页，如果有，则启动成功。</p><p>一般访问问题是端口占用，可以改一下 nginx 访问端口，或者杀掉对应进程。</p><p>关闭nginx的命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nginx -s stop<br></code></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44251179/article/details/129700793">https://blog.csdn.net/weixin_44251179/article/details/129700793</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify使用教程</title>
    <link href="/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、快速开始"><a href="#1、快速开始" class="headerlink" title="1、快速开始"></a>1、快速开始</h3><p>全局安装 <code>docsify-cli</code> 工具，可以方便地创建及在本地预览生成的文档。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i docsify-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><blockquote><p>初始化项目</p></blockquote><p>如果想在项目的 <code>./docs</code> 目录里写文档，直接通过 <code>init</code> 初始化项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docsify init ./docs<br></code></pre></td></tr></table></figure><blockquote><p>开始写文档</p></blockquote><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新文档内容，当然也可以添加更多页面。</p><blockquote><p>本地预览</p></blockquote><p>通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。</p><p>默认访问地址 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docsify serve docs</span><br></code></pre></td></tr></table></figure><h3 id="2、多页文档设置"><a href="#2、多页文档设置" class="headerlink" title="2、多页文档设置"></a>2、多页文档设置</h3><p>在 docsify 中，你访问的文档 URL 路径地址和你的文档文件夹结构是一个映射关系（实现多级路由）；</p><p>比如你在 doc 文件夹中创建<code>guide.md</code>、<code>zh-cn/READEME.md</code>、<code>zh-cn/guide.md</code>，结构如下所示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos">.<br>├── README.<span class="hljs-built_in">md</span><br>├── guide.<span class="hljs-built_in">md</span><br>├── index.html<br>└── zh-cn<br>    ├── README.<span class="hljs-built_in">md</span><br>    └── guide.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>此时我们访问如下url即可以访问到对应的页面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">README.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span><br>guide.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/gui</span>de<br><span class="hljs-regexp">/zh-cn/</span>README.md  =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/<br><span class="hljs-regexp">/zh-cn/gui</span>de.md   =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/guide<br><br></code></pre></td></tr></table></figure><h3 id="3、定制化配置"><a href="#3、定制化配置" class="headerlink" title="3、定制化配置"></a>3、定制化配置</h3><h4 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h4><p>需要先在 docs&#x2F;index.html 中修改一下配置，开启侧边栏的选项添加<code>loadSiderbar: true</code></p><p>这样设置后就会加载 Docsify 目录下的 _ sidebar.md 文件,  进行加载而渲染成我们定制的侧边栏</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span><br>loadSidebar: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311201949003.png" alt="image.png"></p><p>我们在 docs 目录下创建一个 <code>_sidebar.md</code> 文件，里面可以对侧边栏进行配置，比如这里配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>这里使用的是 MarkDown 中的超链接语法，后面的路径对应着上述多页文档的路由路径</p><p>我们还可以指定页面的标题，比如这里指定首页的标题为home 【后面添加双引号进行别名】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/ &quot;home&quot;) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><h4 id="侧边栏嵌套设置"><a href="#侧边栏嵌套设置" class="headerlink" title="侧边栏嵌套设置"></a>侧边栏嵌套设置</h4><p>在对应子目录 docs&#x2F;zh-cn 下创建一个 <code>_sidebar.md</code> 文件，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/zh-cn/_sidebar.md --&gt;</span><br><br>* [zh-ch首页](/zh-cn) <br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>_ sidebar.md 的加载逻辑是从每层目录下获取文件，如果当前目录不存在该文件则回退到上一级目录。<br>例如当前路径为 &#x2F;zh-cn 则从 &#x2F;zh-cn&#x2F;_ sidebar.md 获取文件，如果不存在则从 &#x2F;_ sidebar.md 获取，</p><p>我们也可以在 index.html 中如下配置表示默认都走根路径下的 <code>_sidebar.md</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="开启目录功能"><a href="#开启目录功能" class="headerlink" title="开启目录功能"></a>开启目录功能</h4><p>自定义侧边栏同时也可以开启目录功能。设置 <code>subMaxLevel</code> 配置项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">    <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="目录折叠功能"><a href="#目录折叠功能" class="headerlink" title="目录折叠功能"></a>目录折叠功能</h4><p>需要引入一下 docsify-sidebar-collapse 样式 , 具体配置可以看一下下面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Description&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 文件夹样式 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar-folder.min.css&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 箭头样式 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar.min.css&quot; /&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span></span><br><span class="language-javascript">  <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">  <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Docsify v4 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 侧边栏目录折叠 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>添加导航栏有两种方式，一是直接到 index.html 中添加，二是和侧边栏类似，通过 md 文件的形式来添加。</p><blockquote><p><strong>通过md文件来添加</strong></p></blockquote><p>首先在 index.html 中配置 <code>loadNavbar</code>，默认加载的文件为 <code>_navbar.md</code> </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启导航栏,加载_navbar.md </span><br>loadNavbar: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套列表</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;!-- _navbar<span class="hljs-selector-class">.md</span> --&gt;<br><br>* 入门<br>  * <span class="hljs-selector-attr">[快速开始]</span>(zh-cn/quickstart.md)<br>  * <span class="hljs-selector-attr">[多页文档]</span>(zh-cn/more-pages.md)<br>  * <span class="hljs-selector-attr">[定制导航栏]</span>(zh-cn/custom-navbar.md)<br>  * <span class="hljs-selector-attr">[封面]</span>(zh-cn/cover.md)<br><br><br>* 配置<br>  * <span class="hljs-selector-attr">[配置项]</span>(zh-cn/configuration.md)<br>  * <span class="hljs-selector-attr">[主题]</span>(zh-cn/themes.md)<br>  * <span class="hljs-selector-attr">[使用插件]</span>(zh-cn/plugins.md)<br>  * <span class="hljs-selector-attr">[Markdown 配置]</span>(zh-cn/markdown.md)<br>  * <span class="hljs-selector-attr">[代码高亮]</span>(zh-cn/language-highlight.md)<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311202158957.png" alt="image.png"></p><h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p>在 index.html 中设置 <code>coverpage</code> 参数开启封面功能</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启封面,加载_coverpage.md</span><br>coverpage: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p>在文档根目录创建 <code>_coverpage.md</code> 文件，用于配置封面内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docsify <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span></span>3.5<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span></span></span><br><br><span class="hljs-quote">&gt; 一个神奇的文档网站生成器。</span><br><br><span class="hljs-bullet">-</span> 简单、轻便 (压缩后 ~21kB)<br><span class="hljs-bullet">-</span> 无需生成 html 文件<br><span class="hljs-bullet">-</span> 众多主题<br><br>[<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com/docsifyjs/docsify/</span>)<br></code></pre></td></tr></table></figure><p>目前的背景是随机生成的渐变色，可以自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 网站图标 --&gt;</span><br>![logo](_media/icon.jpg)<br><br># docsify <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br>&gt; 一个神奇的文档网站生成器。<br><br>- 简单、轻便 (压缩后 ~21kB)<br>- 无需生成 html 文件<br>- 众多主题<br><br>[GitHub](https://github.com/docsifyjs/docsify/)<br><br><span class="hljs-comment">&lt;!-- 背景图片 --&gt;</span><br>![](_media/玩家.png)<br><br><span class="hljs-comment">&lt;!-- 背景色 --&gt;</span><br>![color](#f0f0f0)<br></code></pre></td></tr></table></figure><p>通常封面和首页是同时出现的，你可以将封面独立出来</p><p>配置（只在访问主页时加载封面）：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">window</span>.<span class="hljs-variable">$docsify</span> = &#123;<br>  onlyCover:<span class="hljs-built_in"> false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>见： <a href="https://docsify.js.org/#/zh-cn/themes">https://docsify.js.org/#/zh-cn/themes</a></p><h3 id="4、基于nginx-docsify搭建"><a href="#4、基于nginx-docsify搭建" class="headerlink" title="4、基于nginx + docsify搭建"></a>4、基于nginx + docsify搭建</h3><p>nginx 配置文件中，在 <code>http</code> 块内添加一个新的 <code>server</code> 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /docs &#123;<br><span class="hljs-built_in">alias</span> D:/shareDocs/docs; <span class="hljs-comment"># 修改为你的 Docsify 项目绝对路径</span><br>index index.html;<br>try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://docsify.js.org/#/zh-cn/quickstart">https://docsify.js.org/#/zh-cn/quickstart</a></li><li><a href="https://www.cnblogs.com/Can-daydayup/p/15413267.html">https://www.cnblogs.com/Can-daydayup/p/15413267.html</a></li><li><a href="https://ysgstudyhards.github.io/Docsify-Guide/#/README">https://ysgstudyhards.github.io/Docsify-Guide/#/README</a></li><li><a href="https://blog.csdn.net/qq_45173404/article/details/122683872">https://blog.csdn.net/qq_45173404/article/details/122683872</a></li><li><a href="https://developer.aliyun.com/article/1266542">https://developer.aliyun.com/article/1266542</a></li><li><a href="https://clotliu.com/archives/docsify-advanced">https://clotliu.com/archives/docsify-advanced</a></li><li><a href="https://www.cnblogs.com/yangstar/articles/16690435.html">https://www.cnblogs.com/yangstar/articles/16690435.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>StatusPage</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL_基础概念</title>
    <link href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、NoSQL-是什么"><a href="#1、NoSQL-是什么" class="headerlink" title="1、NoSQL 是什么"></a>1、NoSQL 是什么</h3><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><h4 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h4><table><thead><tr><th></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td>发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td>例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td>ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td>性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td>扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td>用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td>查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h4 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h4><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231119123254.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/nosql.html">https://javaguide.cn/database/nosql.html</a></li><li><a href="https://www.ibm.com/cn-zh/topics/nosql-databases">https://www.ibm.com/cn-zh/topics/nosql-databases</a></li><li><a href="https://zhuanlan.zhihu.com/p/345342966">https://zhuanlan.zhihu.com/p/345342966</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>NoSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插件实现Obsidian实时同步</title>
    <link href="/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、插件下载和服务安装"><a href="#1、插件下载和服务安装" class="headerlink" title="1、插件下载和服务安装"></a>1、插件下载和服务安装</h3><p>使用插件： Self-hosted LiveSync</p><p>在服务器上面安装 docker 后，</p><p>创建一个文件 <code>local.ini</code></p><p>复制以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[couchdb]</span><br><span class="hljs-attr">single_node</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd_auth]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">authentication_redirect</span> = /_utils/session.html<br><br><span class="hljs-section">[httpd]</span><br><span class="hljs-attr">WWW-Authenticate</span> = Basic realm=<span class="hljs-string">&quot;couchdb&quot;</span><br><span class="hljs-attr">enable_cors</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[cors]</span><br><span class="hljs-attr">origins</span> = app://obsidian.md,capacitor://localhost,http://localhost<br><span class="hljs-attr">credentials</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">headers</span> = accept, authorization, content-type, origin, referer<br><span class="hljs-attr">methods</span> = GET, PUT, POST, HEAD, DELETE<br><span class="hljs-attr">max_age</span> = <span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>将该文件移动到 <code>/opt/couchdb</code>目录下</p><p>运行下面命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d --restart always -e <span class="hljs-attribute">COUCHDB_USER</span>=luo -e <span class="hljs-attribute">COUCHDB_PASSWORD</span>=luo123 -v /opt/couchdb/local.ini:/opt/couchdb/etc/local.ini -p 6900:5984 couchdb<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>COUCHDB_USER</code> 后面的是你的用户名</li><li><code>COUCHDB_PASSWORD</code> 后面的是你的密码</li><li><code>/opt/couchdb/local.ini</code> 是配置文件的路径</li><li><code>/opt/couchdb/db</code> 是数据库的路径</li><li><code>-p 6900:5984</code> 前面的 6900 是暴露在外的端口。</li></ul><p>检查是否运行成功</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo docker <span class="hljs-keyword">ps</span> |<span class="hljs-keyword">grep</span> couchdb<br></code></pre></td></tr></table></figure><h3 id="2、插件配置"><a href="#2、插件配置" class="headerlink" title="2、插件配置"></a>2、插件配置</h3><p>打开Obsidian的设置-第三方插件，在插件市场安装<code>Self-hosted LiveSync</code></p><blockquote><p>客户端配置</p></blockquote><p>安装并启用后打开插件的设置界面，填写箭头内容，URI 为刚刚的<code>http://IP+端口（6900）</code>，例如：<code>http://127.0.0.1:6900</code>，</p><p>Username 和 Password 为前面的参数设置的内容，</p><p>Database name 可以自己取，注意不要填大写字母，完成后点击test 按钮</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230051.png" alt="image.png"></p><p>右上角出现 <code>Connect to 数据库名</code>，则为连接成功</p><p>如果你之前配置连接过，并存放过数据，你连接后会将对应的数据库中的文件同步到你目前的工作空间中；也可以理解他的数据是存放在了服务器中的数据库，设备连接该服务后的同步操作，本质上都是在操作更新服务器上面的数据库文件内容，然后更新对应映射内容到设备的Obsidian文件中。</p><p>完成后点击下面的check ，将所有提示错误的选择fix，然后再次点击check ，直到没有错误</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230528.png" alt="image.png"></p><p>划到最下方，选择端对端加密（End to End Encryption），在输入框中设置密码，点击启用</p><p><strong>如果仅想要同步文章无需开启端对端加密</strong></p><p>在Sync Setting 选项卡中，选择LiveSync（实时同步），点击Apply启用</p><p>建议启用 <code>Use Trash for deleted files</code>（删除文件到回收站）</p><p>建议启用 <code>Miscellaneous</code> 选项卡中的 <code>Show staus inside editor</code> （会在编辑器右上角显示状态）</p><blockquote><p>复制配置到其他设备</p></blockquote><p>在插件Setup wizard 选项卡中，点击 <code>Copy Setup URI</code>，弹出的对话框设置密码，即可复制当前的配置信息</p><p>复制后打开自己需要同步的设备点击Open setup URI 粘贴复制的内容，输入设置的密码，点击第一个</p><hr><p>参考</p><ul><li><a href="https://sspai.com/post/82161#">https://sspai.com/post/82161#</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装和下载</title>
    <link href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Node-js-下载安装"><a href="#1、Node-js-下载安装" class="headerlink" title="1、Node.js 下载安装"></a>1、Node.js 下载安装</h3><p>官网下载： <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>安装后，验证一下是否安装成功</p><p>打开 cmd, 输入node -v，npm -v，出现如下界面安装成功</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117221300.png" alt="image.png"></p><h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><blockquote><p>环境变量配置</p></blockquote><p>新增<strong>用户变量</strong>  <code>NODE_PATH</code>，变量值设置为 <code>xxx\nodejs</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224932.png" alt="image.png"></p><p>编辑<strong>用户变量</strong>中的【Path】</p><p>修改 变量名 <code>Path</code></p><p>将默认的 C 盘下【 <code>AppData\Roaming\npm</code> 】修改成 <code>%NODE_PATH%</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224741.png" alt="image.png"></p><p>设置完后也打开 cmd, 输入一下  node -v，npm -v  看是否OK。</p><blockquote><p>配置npm的全局模块的存放路径以及cache的路径</p></blockquote><p>找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】</p><p>使用管理员身份打开cmd窗口，执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;xxx\Node.js\node_global&quot;</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;xxx\Node.js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>新增系统Path变量</p></blockquote><p>在【系统变量】中选择【Path】点击【编辑】添加你刚才配置的两个路径。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117225456.png" alt="image.png"></p><h3 id="3、安装淘宝镜像"><a href="#3、安装淘宝镜像" class="headerlink" title="3、安装淘宝镜像"></a>3、安装淘宝镜像</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>查看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><h3 id="4、NVM-安装"><a href="#4、NVM-安装" class="headerlink" title="4、NVM 安装"></a>4、NVM 安装</h3><p>下载地址： <a href="https://github.com/coreybutler/nvm-windows/releases">https://github.com/coreybutler/nvm-windows/releases</a></p><p>NVM 是一个 node 版本管理工具，这里主要是由于前端项目中有时候需要的版本不同，需要切换</p><ul><li><ol><li>下载 nvm-setup.zip 文件</li></ol></li><li><ol start="2"><li>卸载电脑安装的 node ，在程序与功能上卸载 node ，同时删除之前的环境变量</li></ol></li><li>3.解压文件后，有一个 nvm-setup.exe ，点击安装</li><li>4.安装你需要的版本</li><li>5.可能需要重新启动一下你的电脑</li></ul><p>常用命令</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nvm ls               // 查看已安装<span class="hljs-keyword">node</span><span class="hljs-title">版本</span><br><span class="hljs-title">nvm</span> install vXX      // 安装对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> uninstall vXX    // 卸载对应vXX版本的<span class="hljs-keyword">node</span><br><span class="hljs-title">nvm</span> use xxx          // 选择使用XXX版本<br></code></pre></td></tr></table></figure><p>实际操作</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#安装并切换版本到 14.21.3，安装需要一点时间</span><br><span class="hljs-attribute">nvm</span> install <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br><span class="hljs-attribute">nvm</span> use <span class="hljs-number">14</span>.<span class="hljs-number">21</span>.<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/m0_62617719/article/details/130423504">https://blog.csdn.net/m0_62617719/article/details/130423504</a></li><li><a href="https://blog.csdn.net/JingYan_Chan/article/details/125405423">https://blog.csdn.net/JingYan_Chan/article/details/125405423</a></li><li><a href="https://blog.csdn.net/MyronCham/article/details/119561972">https://blog.csdn.net/MyronCham/article/details/119561972</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
      <category>Node</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dokcer入门_基础概念</title>
    <link href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Docker"><a href="#1、什么是-Docker" class="headerlink" title="1、什么是 Docker"></a>1、什么是 Docker</h3><blockquote><p>理解虚拟化技术</p></blockquote><p>人们为了提高系统及硬件资源的利用率而引入了<strong>虚拟化技术</strong>。虚拟化是一种<strong>资源管理技术</strong>，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。</p><p>虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。</p><p>从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。</p><blockquote><p>基于软件的虚拟化</p></blockquote><p>软件虚拟化是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p><p>对软件虚拟化进行细分，又可以分为以下几类：</p><ul><li>完全虚拟化</li><li>硬件辅助虚拟化</li><li>部分虚拟化</li><li>平行虚拟化</li><li>操作系统层虚拟化</li></ul><p>Docker容器技术就是属于操作系统层虚拟化的范畴。</p><p>虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。</p><blockquote><p>虚拟机和Docker</p></blockquote><p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源。</p><p>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p><blockquote><p>虚拟机和 Docker 的对比<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171252304.png" alt="image.png"></p></blockquote><blockquote><p>图解物理机,虚拟机与容器</p></blockquote><p>物理机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456074.png" alt="image.png"></p><p>虚拟机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456887.png" alt="image.png"><br>容器</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171457700.png" alt="image.png"></p><p>虚拟机和Docker容器各自有自己的应用场景，<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。</p><p>而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p><h3 id="2、Docker-基本概念"><a href="#2、Docker-基本概念" class="headerlink" title="2、Docker 基本概念"></a>2、Docker 基本概念</h3><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><blockquote><p><strong>Docker Registry 公开服务和私有 Docker Registry</strong></p></blockquote><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" title="https://hub.docker.com/">https://hub.docker.com/open in new window</a> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171534204.png" alt="image.png"></p><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ docker <span class="hljs-keyword">search</span> mysql<br><span class="hljs-type">NAME</span>                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>mysql                             MySQL <span class="hljs-keyword">is</span> a widely used, <span class="hljs-keyword">open</span>-source relation…   <span class="hljs-number">8763</span>                [OK]<br>mariadb                           MariaDB <span class="hljs-keyword">is</span> a community-developed fork <span class="hljs-keyword">of</span> MyS…   <span class="hljs-number">3073</span>                [OK]<br>mysql/mysql-<span class="hljs-keyword">server</span>                Optimized MySQL <span class="hljs-keyword">Server</span> Docker images. <span class="hljs-keyword">Create</span>…   <span class="hljs-number">650</span>                                     [OK]<br></code></pre></td></tr></table></figure><p>在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" title="阿里云镜像库">阿里云镜像库</a>。</p><p>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。</p><p>Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="3、基本命令"><a href="#3、基本命令" class="headerlink" title="3、基本命令"></a>3、基本命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker <span class="hljs-keyword">version</span> <span class="hljs-comment"># 查看docker版本</span><br>docker images <span class="hljs-comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span><br>docker container <span class="hljs-keyword">ls</span> <span class="hljs-comment"># 查看所有容器</span><br>docker ps <span class="hljs-comment">#查看正在运行的容器</span><br>docker image prune <span class="hljs-comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span><br></code></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search mysql <span class="hljs-comment"># 查看mysql相关镜像</span><br>docker pull mysql:5.7 <span class="hljs-comment"># 拉取mysql镜像</span><br>docker image <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 查看所有已下载镜像</span><br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID 删除）。</p><p>通过我们前面讲的<code>docker ps</code>命令即可查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br>c4cd691d9f80        mysql:5.7           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   7 weeks ago         Up 12 days          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql<br></code></pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code>暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  ~ docker images<br>REPOSITORY              <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>mysql                   <span class="hljs-number">5.7</span>                 f6509bac4980        <span class="hljs-number">3</span> months ago        <span class="hljs-number">373M</span>B<br></code></pre></td></tr></table></figure><p>通过 IMAGE ID 或者 REPOSITORY 名字即可删除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi f6509bac4980 <span class="hljs-comment">#  或者 docker rmi mysql</span><br></code></pre></td></tr></table></figure><h3 id="4、Build-Ship-and-Run"><a href="#4、Build-Ship-and-Run" class="headerlink" title="4、Build Ship and Run"></a>4、Build Ship and Run</h3><p>搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。</p><ul><li><strong>Build（构建镜像）</strong>：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong>Run （运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p>Docker 运行过程是会去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p><p>Docker 也被称为码头工人或码头装卸工，这和 Docker 的中文翻译<strong>搬运工人</strong>如出一辙。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171603190.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html">https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-03-basic2.html">https://www.pdai.tech/md/devops/docker/docker-03-basic2.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>Java8</p><hr><p>参考</p><ul><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7">https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7</a></li><li><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">https://javaguide.cn/java/new-features/java8-common-new-features.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JDK8</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM入门_基础概念</title>
    <link href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-JVM"><a href="#1、什么是-JVM" class="headerlink" title="1、什么是 JVM"></a>1、什么是 JVM</h3><p>JVM 全称是 Java Virtual Machine，中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。</p><p>JVM 充当着一个翻译官的角色，能够将我们编写出的Java程序，翻译给系统“听”，告诉它我们的程序需要做什么操作。</p><p>Java的代码需要经过编译器，生成.Class文件后，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。</p><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机，这里也是以 HotSpot 虚拟机展开，对JVM 基础概念进行阐述。</p><h3 id="2、类加载机制"><a href="#2、类加载机制" class="headerlink" title="2、类加载机制"></a>2、类加载机制</h3><p>上文提到，Java的代码经过编译器，生成.Class文件后，JVM才能识别并运行。</p><blockquote><p>类加载过程</p></blockquote><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>整个类加载的过程中，包括<strong>加载、验证、准备、解析、初始化</strong>五个阶段。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意<strong>这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>类的加载: 查找并加载类的二进制数据</li><li>连接<ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</li><li>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li>卸载： 结束生命周期</li></ul><blockquote><p>类加载的层次</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116234810.png" alt="image.png"></p><ul><li><strong>启动类加载器</strong>: Bootstrap ClassLoader，<ul><li>负责加载存放在<code>JDK\jre\lib</code> (JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.* 开头的类均被Bootstrap ClassLoader加载)。</li><li>启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><strong>扩展类加载器</strong>: Extension ClassLoader，<ul><li>该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库(如javax.* 开头的类)，</li><li>开发者可以直接使用扩展类加载器。</li></ul></li><li><strong>应用程序类加载器</strong>: Application ClassLoader，<ul><li>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，</li><li>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><strong>自定义类加载器</strong>: <ul><li>因为JVM自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:<ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul></li></ul><blockquote><p>Class.forName()和ClassLoader.loadClass()区别?</p></blockquote><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li></ul><h3 id="3、JVM的结构体系"><a href="#3、JVM的结构体系" class="headerlink" title="3、JVM的结构体系"></a>3、JVM的结构体系</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116235359.png" alt="image.png"></p><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><blockquote><p>运行时数据区根据线程是否私有或者共享进行区分</p></blockquote><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><p>直接内存（Java7的永久代或JDK8的元空间、代码缓存）</p><blockquote><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p></blockquote><p>1.8之前版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000248.png" alt="image.png|600"></p><p>JVM1.8之后版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000319.png" alt="image.png|600"></p><p>1.8之前的版本，线程共享为两个区域：堆与方法区；其中方法区只是JVM虚拟机规范的一部分，不是实际的实现；</p><p>直接内存：是JVM以外的本地内存；</p><p><strong>版本区别介绍</strong></p><ul><li>区别一（方法区）<ul><li>1.8版本之后，使用元数据区实现了方法区，之前是使用永久代来实现方法区，大小是启动时固定好的；</li><li>元空间不在虚拟机中，而是使用本地内存，并且大小可以自动增长，减少了OOM（内存溢出）的几率；</li></ul></li><li>区别二（堆区）<ul><li>Java7之后运行时常量池从方法区移到了这里，为Java8移出永久代做好准备；</li></ul></li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>to be continued ….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98">https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98</a></li><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></li><li><a href="https://blog.csdn.net/fllow_wind/article/details/117027924">https://blog.csdn.net/fllow_wind/article/details/117027924</a></li><li><a href="https://zhuanlan.zhihu.com/p/25713880">https://zhuanlan.zhihu.com/p/25713880</a></li><li><a href="https://blog.csdn.net/xianyun1992/article/details/126555575">https://blog.csdn.net/xianyun1992/article/details/126555575</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>JVM</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_基础概念</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li></ul><p>并行和并发的区别</p><ul><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行</p><p>同步和异步的区别</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p><h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" alt="image.png"></p><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" alt="image.png"></p><p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p><p>Java线程具有五中基本状态</p><ul><li>新建状态（New）<ul><li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li></ul></li><li>就绪状态（Runnable）<ul><li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li><li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li></ul></li><li>运行状态（Running）<ul><li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li><li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li></ul></li><li>阻塞状态（Blocked）<ul><li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li><li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul><li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li><li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡状态（Dead）<ul><li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul><blockquote><p>Java多线程的就绪、运行和死亡状态</p></blockquote><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p><p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p><p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p><p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p><h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p><ol><li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>Runnable接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure><ul><li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li><li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li><li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li></ul><blockquote><p>写法简化（Java 8)</p></blockquote><ul><li><strong>方式一：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote><p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p></blockquote><table><thead><tr><th>名称</th><th>描述</th><th>注意事项</th></tr></thead><tbody><tr><td>​<code>start()</code>​</td><td>启动一个新线程，<br />在新的线程运行 run 方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td></tr><tr><td>​<code>run()</code>​</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td></tr><tr><td>​<code>join()</code>​</td><td>等待线程运行结束</td><td></td></tr><tr><td>​<code>join(long n)</code>​</td><td>等待线程运行结束，<br />最多等待 n 毫秒</td><td></td></tr><tr><td>​<code>getId()</code>​</td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>​<code>getName()</code>​</td><td>获取线程名</td><td></td></tr><tr><td>​<code>setName(String name)</code>​</td><td>修改线程名</td><td></td></tr><tr><td>​<code>getPriority()</code>​</td><td>获取线程优先级</td><td></td></tr><tr><td>​<code>setPriority(int priority)</code>​</td><td>修改线程优先级</td><td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td></tr><tr><td>​<code>getState()</code>​</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td></tr><tr><td>​<code>interrupt()</code>​</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td></tr><tr><td><font color=Coral>interrupted()</font></td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>​<code>isInterrupted()</code>​</td><td>判断当前线程是否被打断</td><td>不会清除打断标记</td></tr><tr><td>​<code>isAlive()</code>​</td><td>判断当前线程是否存活</td><td></td></tr><tr><td>​<code>isDaemon()</code>​</td><td>判断当前线程是否是守护线程</td><td></td></tr><tr><td>​<code>setDaemon(boolean on)</code>​</td><td>设置当前线程为守护线程</td><td></td></tr><tr><td><font color=Coral>currentThread()</font></td><td>获取当前正在执行的线程</td><td></td></tr><tr><td><font color=Coral>sleep(long n)</font></td><td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td><td></td></tr><tr><td><font color=Coral>yield()</font></td><td>提示线程调度器让出当前线程<br />对 CPU 的使用</td><td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td></tr></tbody></table><h3 id="6、Synchronized-和-Lock-的使用"><a href="#6、Synchronized-和-Lock-的使用" class="headerlink" title="6、Synchronized 和 Lock 的使用"></a>6、Synchronized 和 Lock 的使用</h3><p>并发编程中，锁是经常需要用到的。这里讲述一下 Synchronized 和 Lock 的使用。</p><p>Synchronized 是 Java 并发编程 中很重要的关键字，另外一个很重要的是 volatile。</p><p>Syncronized 的目的是一次<strong>只允许一个线程进入由他修饰的代码段</strong>，从而允许他们进行自我保护。</p><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要<strong>手动加锁和手动解锁</strong>，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><blockquote><p>在方法上使用 Synchronized</p></blockquote><p>方法声明时使用，放在范围操作符之后,返回类型声明之前。即一次只能有一个线程进入该方法，其他线程要想在此时调用该方法，只能排队等候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numIncrease</span><span class="hljs-params">()</span>&#123;<br>  number++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在某个代码段使用 Synchronized</p></blockquote><p>可以在某个代码块上使用 Synchronized 关键字，表示只能有一个线程进入某个代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numDecrease</span><span class="hljs-params">(Object num)</span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (num)&#123;<br>    number++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Synchronized 锁住整个对象</p></blockquote><p>synchronized后面括号里是一对象，此时线程获得的是对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，相关方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用方法</p><ul><li>lock()<ul><li>用来获取锁。如果锁被其他线程获取，则进行等待。</li><li>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁</li></ul></li><li>tryLock()<ul><li>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，</li><li>这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li></ul></li><li>tryLock(long time, TimeUnit unit)<ul><li>和tryLock()方法是类似</li><li>在拿不到锁时<strong>会等待一定的时间</strong>，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li></ul></li><li>lockInterruptibly()<ul><li>去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即<strong>中断线程的等待状态</strong>。</li><li>当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用 threadB.interrupt() 方法能够中断线程B的等待过程。</li><li>由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在try块中或者在调用lockInterruptibly() 的方法外声明抛出 InterruptedException。</li></ul></li></ul><blockquote><p>代码示例：</p></blockquote><p>lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>tryLock()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Lock</span> lock = ...;<br><span class="hljs-keyword">if</span>(lock.<span class="hljs-title function_">tryLock</span>()) &#123;<br>     <span class="hljs-keyword">try</span>&#123;<br>         <span class="hljs-comment">//处理任务</span><br>     &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-title class_">Exception</span> ex)&#123;<br>         <br>     &#125;<span class="hljs-keyword">finally</span>&#123;<br>         lock.<span class="hljs-title function_">unlock</span>();   <span class="hljs-comment">//释放锁</span><br>     &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不能获取锁，则直接做其他事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>    lock.<span class="hljs-title function_">lockInterruptibly</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//.....</span><br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        lock.<span class="hljs-title function_">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将<strong>释放锁的操作放在finally块中进行</strong>，以保证锁一定被被释放，防止死锁的发生。</p><blockquote><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能<strong>中断阻塞过程中的线程</strong>。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，<strong>只有进行等待的情况下，是可以响应中断的</strong>。<br>而<strong>用synchronized修饰的话</strong>，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li><li><a href="https://cloud.tencent.com/developer/article/1497476">https://cloud.tencent.com/developer/article/1497476</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>Thread</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_HashMap学习</title>
    <link href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>HashMap 主要用来存放键值对，基于哈希表的 Map 接口实现，是常用的 Java 集合之一。</p><p>HashMap是非线程安全的，效率较高。</p><p>它可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><strong>底层数据结构</strong>：</p><ul><li>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li><li>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>扩充机制</strong>：<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><blockquote><p>HashMap的常用方法</p></blockquote><p>1、put(K key, V value)： 将键（key）&#x2F;值（value）映射存放到Map集合中。</p><p>2、get(Object key)： 返回指定键所映射的值，没有该key对应的值则返回 null。</p><p>3、size()： 返回Map集合中数据数量。</p><p>4、clear()： 清空Map集合。</p><p>5、isEmpty()： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。</p><p>6、remove(Object key)： 删除Map集合中键为key的数据并返回其所对应value值。</p><p>7、values()： 返回Map集合中所有value组成的以Collection数据类型格式数据。</p><p>8、containsKey(Object key)： 判断集合中是否包含指定键，包含返回 true，否则返回false。</p><p>9、containsValue(Object value)： 判断集合中是否包含指定值，包含返回 true，否则返回false。</p><p>10、keySet()： 返回Map集合中所有key组成的Set集合。</p><p>11、entrySet()： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。</p><blockquote><p>HashMap 常用方法测试</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sas">package map;<br><br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.<span class="hljs-keyword">Set</span>;<br><br>public class HashMapDemo &#123;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>        // 键不能重复，值可以重复<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;san&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王2&quot;</span>);// 老王被覆盖<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;lao&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------直接输出hashmap:-------&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历HashMap</span><br><span class="hljs-comment">         */</span><br>        // 1.获取Map中的所有键<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span>+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 2.获取Map中所有值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);<br>        Collection&lt;String&gt; values = map.values();<br>        for (String value : values) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(value+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 3.得到<span class="hljs-keyword">key</span>的值的同时得到<span class="hljs-keyword">key</span>所对应的值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys2 = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys2) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span> + <span class="hljs-string">&quot;：&quot;</span> + map.get(<span class="hljs-keyword">key</span>)+<span class="hljs-string">&quot;   &quot;</span>);<br><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="hljs-comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="hljs-comment">         */</span><br>        // 当我调用<span class="hljs-meta">put</span>(<span class="hljs-keyword">key</span>,value)方法的时候，首先会把<span class="hljs-keyword">key</span>和value封装到<br>        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取<br>        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来<br>        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了<br>        <span class="hljs-keyword">Set</span>&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();<br>        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;<br>            System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HashMap其他常用方法</span><br><span class="hljs-comment">         */</span><br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.size()：&quot;</span>+map.size());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;san&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.remove()：&quot;</span>+map);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;李四&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四2&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.replace(si, 李四2):&quot;</span>+map);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用（ <strong>链表散列</strong>）。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115224010.png" alt="image.png"></p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<strong>如果相同的话，直接覆盖</strong>，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。</p><p>使用 hash 方法（扰动函数）是为了防止一些实现比较差的 hashCode() 方法 ，使用扰动函数之后可以减少碰撞。</p><p>所谓 <strong>“拉链法”</strong> 是：将链表和数组相结合。也就是说创建一个链表数组，<strong>数组中每一格就是一个链表</strong>。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><strong>hash 方法</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能稍差一点，因为毕竟扰动了 4 次。</p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。</p><p>这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。</p><p>否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115223309.png" alt="image.png"></p><h4 id="HashMap-的类属性"><a href="#HashMap-的类属性" class="headerlink" title="HashMap 的类属性"></a>HashMap 的类属性</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span> &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">362498820763181265</span>L;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    transient Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    transient <span class="hljs-built_in">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    transient <span class="hljs-built_in">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-built_in">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的字段</p><ul><li>loadFactor   负载因子</li><li>threshold   阈值（HashMap 实际能存储的大小）</li><li>DEFAULT_INITIAL_CAPACITY  默认初始容量</li><li>MAXIMUM_CAPACITY  最大容量</li><li>size   HashMap实际存储的元素个数</li><li>modCount     HashMap的结构被修改的次数，用于迭代器</li></ul><blockquote><p>loadFactor 负载因子</p></blockquote><p>loadFactor 负载因子 是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor 的默认值为 0.75f</strong> ，是官方给出的一个比较好的临界值。</p><p>HashMap 给定的默认容量为 16，负载因子为 0.75。<br>Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 , 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><blockquote><p>threshold   阈值</p></blockquote><p><strong>threshold &#x3D; capacity * loadFactor</strong>，阈值(容量 * 负载因子) </p><p>当实际大小超过阈值时，就要考虑对数组的扩增。阈值是衡量数组是否需要扩增的一个标准。</p><h4 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br>static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">K,V</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-type">K,V</span>&gt; &#123;<br>       <span class="hljs-keyword">final</span> int hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       <br>       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String toString() &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int hashCode() &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br><span class="hljs-comment">//相当于把原来的值给覆盖掉，但是返回被覆盖掉的值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V newValue) &#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean equals(Object o) &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 父</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;           <span class="hljs-comment">// 判断颜色</span><br>        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; root() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、HashMap-源码分析"><a href="#3、HashMap-源码分析" class="headerlink" title="3、HashMap 源码分析"></a>3、HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> threshold;<br>   <br>   <span class="hljs-comment">// 默认构造函数。</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    &#125;<br><br>    <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>        <span class="hljs-comment">//指定负载因子</span><br>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在 resize 中再赋值给 newCap 进行table初始化</span><br>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面第二个构造函数中调用了 putMapEntries 方法，下面进行分析：</p><p><strong>putMapEntries 方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> s = m.size();  <br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size  </span><br>            <span class="hljs-comment">//如果未初始化，s 为 m 的实际元素个数；ft=s/loadFactor =&gt; s=ft*loadFactor；其中 ft 指的是要添加 s 个元素所需要的最小的容量</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0</span>F;  <br>            <span class="hljs-comment">//与最大容量作比较，如果小于则 t 为 ft，否则为 MAXIMUM_CAPACITY</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?  <br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);  <br>            <span class="hljs-comment">//根据上面的构造函数，可以得知此时 table 未初始化，threshold 实际上是存放的初始化容量</span><br>            <span class="hljs-comment">//如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。（注意这里不是初始化阈值）</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)  <br>                threshold = tableSizeFor(t);  <br>        &#125;  <br>        <span class="hljs-comment">// 如果已经初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)  <br>            resize();  <br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容    </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet()) &#123;  <br>            K key = e.getKey();  <br>            V value = e.getValue();  <br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor 方法：返回一个最接近 cap 的2的幂次方大小数值</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;  <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;  <br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法是 put 方法调用的一个方法，并没有提供给用户使用。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>putVal 方法 图解</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115230931.png" alt="image.png"></p><p>putVal 方法添加元素分析：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，<ul><li>如果 key 相同就直接覆盖，</li><li>如果 key 不相同，就判断 p 是否是一个树节点，<ul><li>如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</li><li>如果不是就遍历链表插入(插入的是链表尾部)。</li></ul></li></ul></li></ul><blockquote><p>putVal 方法</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对比 JDK1.7 put 方法的代码</strong></p></blockquote><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value)<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    <span class="hljs-title function_">inflateTable</span>(threshold);<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123; <span class="hljs-comment">// 先遍历</span><br>        <span class="hljs-built_in">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">public V get(Object key) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(<span class="hljs-built_in">hash</span>(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br>final Node&lt;K,V&gt; getNode(int <span class="hljs-built_in">hash</span>, Object key) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; int n; K k;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = <span class="hljs-literal">tab</span>[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span>.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">first</span>;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = <span class="hljs-built_in">first</span>.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(<span class="hljs-built_in">hash</span>, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">https://javaguide.cn/java/collection/hashmap-source-code.html</a></li><li><a href="https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507">https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507</a></li><li><a href="https://blog.csdn.net/rain67/article/details/124043769">https://blog.csdn.net/rain67/article/details/124043769</a></li><li><a href="https://segmentfault.com/a/1190000039302830">https://segmentfault.com/a/1190000039302830</a></li><li><a href="https://blog.csdn.net/weixin_47257050/article/details/118926555">https://blog.csdn.net/weixin_47257050/article/details/118926555</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 集合</strong></p><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li><li><a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">Java集合_HashMap学习</a></li></ul><p> <strong>Java多线程</strong></p><ul><li><a href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java并发编程_基础概念">Java并发编程_基础概念</a></li><li><a href="/2023/12/08/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java并发编程_进阶内容">Java并发编程_进阶内容</a></li></ul><p><strong>Java 8</strong> </p><ul><li><a href="/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java8新特性">Java8新特性</a></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><a href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="JVM入门_基础概念">JVM入门_基础概念</a></li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><p>MySQL</p><ul><li><a href="/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="MySQL学习_基础内容">MySQL学习_基础内容</a></li></ul><p>NOSQL</p><ul><li><a href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="NoSQL_基础概念">NoSQL_基础概念</a></li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul><li><a href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Spring学习_基础内容">Spring学习_基础内容</a></li><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_AOP/" title="Spring学习_AOP">Spring学习_AOP</a></li><li><a href="/2023/12/05/Spring%E5%AD%A6%E4%B9%A0_SpringMVC/" title="Spring学习_SpringMVC">Spring学习_SpringMVC</a></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p><strong>Redis</strong></p><ul><li><a href="/2023/12/08/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Redis入门_基础概念">Redis入门_基础概念</a></li></ul><p><strong>MQ</strong></p><ul><li><a href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="消息队列_基础概念">消息队列_基础概念</a></li><li><a href="/2023/12/13/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="消息队列_进阶内容">消息队列_进阶内容</a></li></ul><p>RabbitMQ</p><ul><li><a href="/2023/12/11/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="消息队列_RabbitMQ_基础使用">消息队列_RabbitMQ_基础使用</a></li><li><a href="/2023/12/03/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_RabbitMQ%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/" title="RabbitMQ的安装与使用">RabbitMQ的安装与使用</a></li></ul><p>Elasticsearch</p><ul><li><a href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Elasticsearch_基础内容">Elasticsearch_基础内容</a></li></ul><p>MongoDB</p><ul><li><a href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/" title="MongoDB_基本操作">MongoDB_基本操作</a></li></ul><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><ul><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="SpringCloud_组件基本使用_基础概念">SpringCloud_组件基本使用_基础概念</a></li><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/" title="SpringCloud_组件基本使用_Eureka">SpringCloud_组件基本使用_Eureka</a></li><li><a href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/" title="SpringCloud_组件基本使用_Nacos">SpringCloud_组件基本使用_Nacos</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_OpenFeign/" title="SpringCloud_组件基本使用_OpenFeign">SpringCloud_组件基本使用_OpenFeign</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Gateway/" title="SpringCloud_组件基本使用_Gateway">SpringCloud_组件基本使用_Gateway</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Seata/" title="SpringCloud_组件基本使用_Seata">SpringCloud_组件基本使用_Seata</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Stream/" title="SpringCloud_组件基本使用_Stream">SpringCloud_组件基本使用_Stream</a></li><li><a href="/2023/12/04/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sentinel/" title="SpringCloud_组件基本使用_Sentinel">SpringCloud_组件基本使用_Sentinel</a></li><li><a href="/2023/12/01/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Sleuth+Zipkin/" title="SpringCloud_组件基本使用_Zipkin">SpringCloud_组件基本使用_Zipkin</a></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Dokcer入门_基础概念">Dokcer入门_基础概念</a></li><li><a href="/2023/12/08/Docker%E5%85%A5%E9%97%A8_Docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/" title="Docker入门_Docker的基本使用">Docker入门_Docker的基本使用</a></li></ul><h3 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h3><p>Vue</p><ul><li><a href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Vue学习_基础内容">Vue学习_基础内容</a></li></ul><p>Node</p><ul><li><a href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="node安装和下载">node安装和下载</a></li></ul><p>Nginx</p><ul><li><a href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Nginx_基础概念">Nginx_基础概念</a></li></ul><h3 id="项目学习"><a href="#项目学习" class="headerlink" title="项目学习"></a>项目学习</h3><p>使用工具</p><ul><li><a href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/" title="个人在线网盘_ZFile">个人在线网盘_ZFile</a></li><li><a href="/2023/12/01/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%B7%A5%E5%85%B7Neutrino-Proxy/" title="内网穿透工具Neutrino-Proxy">内网穿透工具Neutrino-Proxy</a></li></ul><p>蘑菇博客</p><ul><li><a href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day01/" title="蘑菇博客项目_Day01">蘑菇博客项目_Day01</a></li><li><a href="/2023/12/11/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day02/" title="蘑菇博客项目_Day02">蘑菇博客项目_Day02</a></li><li><a href="/2023/12/12/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day03/" title="蘑菇博客项目_Day03">蘑菇博客项目_Day03</a></li><li><a href="/2023/12/13/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE_Day04/" title="蘑菇博客项目_Day04">蘑菇博客项目_Day04</a></li></ul><h3 id="技术选型"><a href="#技术选型" class="headerlink" title="技术选型"></a>技术选型</h3><ul><li><a href="/2023/12/11/%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E5%92%8C%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/" title="业务场景和技术选型">业务场景和技术选型</a></li></ul><h3 id="运维工具和项目构建"><a href="#运维工具和项目构建" class="headerlink" title="运维工具和项目构建"></a>运维工具和项目构建</h3><p><strong>Maven</strong></p><ul><li><a href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/" title="Maven工具_基础使用">Maven工具_基础使用</a></li></ul><p><strong>Linux</strong></p><ul><li><a href="/2023/12/03/linux%E7%B3%BB%E7%BB%9F%E4%B8%8BJava%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84%E9%85%8D%E7%BD%AE/" title="linux系统下 java环境变量的配置">linux系统下 java环境变量的配置</a></li><li><a href="/2023/11/28/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="centos7系统_常用操作">centos7系统_常用操作</a></li><li><a href="/2023/12/03/centos7%E5%AE%89%E8%A3%85nacos%E6%93%8D%E4%BD%9C/" title="centos7 安装 nacos 操作">centos7 安装 nacos 操作</a></li><li><a href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="vim常用操作">vim常用操作</a></li></ul><p>Windows</p><ul><li><a href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/" title="windows常用操作">windows常用操作</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>ArrayList 是 List 的主要实现类，内部基于动态数组实现，支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。</p><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。</p><p><code>ArrayList</code>创建时不需要指定大小，下面是常用方法示例代码：</p><p>ArrayList</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h3 id="2、ArrayList-扩容机制"><a href="#2、ArrayList-扩容机制" class="headerlink" title="2、ArrayList 扩容机制"></a>2、ArrayList 扩容机制</h3><p>以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><h3 id="3、相关内容"><a href="#3、相关内容" class="headerlink" title="3、相关内容"></a>3、相关内容</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>HashMap保证key的不重复性，对于重复的key，HashMap会根据参数onlyIfAbsent的设置和原value是否为空两个条件来<strong>判断是否替换新value</strong>，</p><p>但要注意的是，对于HashSet，这个value只是个空的Object类的对象，没有任何实际作用，HashSet中的元素实际上是存储在key上的。针对重复的key，<strong>HashMap只有对于value的处理，并不会替换key</strong>，因此在HashSet中加入相同元素不会覆盖。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><p><strong>总结</strong>：结果向HashSet中加入相同元素不会进行覆盖。因为HashSet底层使用HashMap实现，元素存在HashMap的key中。在HashMap中，多次put相同的key，只会覆盖value，而不存在key的情况。</p><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢"><a href="#4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢" class="headerlink" title="4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢"></a>4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢</h4><p>为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？</p><p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p><p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会<strong>显著提高效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20231114</title>
    <link href="/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
    <url>/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><ul><li><input disabled="" type="checkbox"> Java集合、Java多线程、MySQL数据库、Spring 进行复习</li><li><input disabled="" type="checkbox"> Redis、MQ </li><li><input disabled="" type="checkbox"> 微服务 SpringCloud Alibaba 学习</li><li><input checked="" disabled="" type="checkbox"> <del>学成在线项目进行（放弃）</del></li><li><input disabled="" type="checkbox"> 项目：蘑菇博客的学习（个人一直趋向学习这个项目，趁这段时间有空，学习一下）</li><li><input disabled="" type="checkbox"> 考研数学</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_基础概念</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="1、成员关系"><a href="#1、成员关系" class="headerlink" title="1、成员关系"></a>1、成员关系</h4><p>Java 集合相关的成员关系图<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" alt="image.png"></p><ul><li>Collection<ul><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li></ul></li><li>List<ul><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li><li>LinkedList</li></ul></li><li>Queue<ul><li>Deque<ul><li>ArrayDeque</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>Hashtable</li><li>SortedMap<ul><li>TreeMap</li></ul></li></ul></li></ul><p>通过下面表格可说明之间部分的区别和联系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123120.png" alt="image.png"><br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123036.png" alt="image.png"></p><h4 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection接口：最基本的集合接口，所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List接口：有序的Collection，用某种特定的插入顺序来维护元素顺序；用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141634443.png" alt="image.png"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map接口：由一系列键值对组成的集合，提供了key到Value的映射。同时它没有继承Collection；它保证了key与value之间的一一对应关系，一个key对应一个value，它不能存在相同的key值，value值可以相同。</p><p>实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><ul><li>HashMap（JDK1.8及以上）<ul><li>基于哈希表的Map接口的非同步实现</li><li>允许使用 null 值和 null 键</li><li>数据结构可以看成数组+链表+红黑树</li><li>采用了Fail-  Fast机制</li></ul></li><li>Hashtable<ul><li>基于哈希表的Map接口的同步实现, 使用synchronized实现线程安全</li><li>不允许使用null值和null键</li><li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li></ul></li><li>ConcurrentHashMap（JDK1.7版本）<ul><li>采用数组+分段锁的方式实现</li><li>数据结构：Segment 数组 + HashEntry 数组 + 链表</li></ul></li><li>ConcurrentHashMap（JDK1.8版本）<ul><li>数据结构：Node 数组 + 链表 &#x2F; 红黑树。</li><li>当冲突链表达到一定长度时，链表会转换成红黑树。</li></ul></li><li>TreeMap<ul><li>实现了SortedMap接口，键以某种排序规则排序</li><li>内部以red-black（红-黑）树数据结构实现</li></ul></li><li>LinkedHashMap<ul><li>继承于HashMap</li><li>非同步，允许使用null值和null键</li><li>底层使用哈希表和双向链表来保存所有元素</li></ul></li><li>WeakHashMap<ul><li>支持null值和null键，fast-fail机制，不允许重复</li><li>key只保留对实际对象的弱引用，当key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。</li></ul></li><li>IdentifyHashMap<ul><li>在IdentityHashMap中，当且仅当两个key严格相等（key1&#x3D;&#x3D; key2）时，IdentityHashMap才认为两个key相等；相对于普通HashMap而言，只要key1和key2通过equals()方法返回true，且它们的hashCode值相等即可。</li></ul></li><li>EnumMap<ul><li>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显示或隐式的指定它对应的枚举类。</li></ul></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 接口：不包括重复元素的Collection，同样允许 null的存在但是仅有一个</p><p>实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><ul><li>HashSet<ul><li>基于HashMap实现，API 对 HashMap的行为进行了封装</li><li>允许使用null元素</li></ul></li><li>LinkedHashSet<ul><li>继承于 HashSet、又基于LinkedHashMap来实现</li><li>底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上与HashSet相同</li></ul></li><li>TreeSet<ul><li>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。</li><li>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的  <code>Comparator</code> 进行排序</li></ul></li><li>EnumSet<ul><li>枚举的专用Set。所有的元素都是枚举类型</li></ul></li></ul><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列，主要分为两大类，</p><p>一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。</p><p>另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html">https://javaguide.cn/java/collection/java-collection-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
      <category>集合</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h3><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍<br>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p><h3 id="常用的一些命令"><a href="#常用的一些命令" class="headerlink" title="常用的一些命令"></a>常用的一些命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看用户名 ：git config <span class="hljs-keyword">user</span>.name<br><br>查看密码： git config <span class="hljs-keyword">user</span>.<span class="hljs-keyword">password</span><br><br>查看邮箱：git config <span class="hljs-keyword">user</span>.email<br><br>查看配置信息： $ git config <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门_基本操作</title>
    <link href="/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1、将某个目录文件上传到-Github-某个仓库"><a href="#1、将某个目录文件上传到-Github-某个仓库" class="headerlink" title="1、将某个目录文件上传到 Github 某个仓库"></a>1、将某个目录文件上传到 Github 某个仓库</h3><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p><blockquote><p>Git的工作流程核心</p></blockquote><ul><li>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</li><li>1、<strong>搬砖</strong>：在工作目录中添加、修改代码。</li><li>2、<strong>暂存</strong>（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>3、<strong>提交</strong>（git commit）：将暂存区域的文件提交到Git仓库。</li><li>4、<strong>推送</strong>（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>5、<strong>获取更新</strong>（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250040140.png" alt="image.png"></p><ul><li><code>git commit -a</code>指令省略了<code>add</code>到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是<code>git pull</code>多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、 <code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code>是专门用来撤销修改、回退版本的指令，替代上面<code>checkout</code>的撤销功能。</li></ul><hr><p>参考</p><ul><li><a href="https://www.cnblogs.com/anding/p/16987769.html">https://www.cnblogs.com/anding/p/16987769.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
