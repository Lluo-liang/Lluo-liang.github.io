<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MongoDB_基本操作</title>
    <link href="/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/MongoDB_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>mongodb 的数据库中的一种，是面向文档存储的数据库；</p><p>他的概念和关系型数据有些区别。</p><p>跟 MySQL 类似，他能够执行 CRUD，事务，索引 等操作。</p><p>在技术选型的时候，对于高并发、海量数据读写、高可用、搞可扩展有需求，数据量大，写入频率，价值较低，对事务性要求不高的时候，可以考虑使用 MongoDB来实现数据的存储。</p><h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301336438.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/efew212efe/article/details/124524863">https://blog.csdn.net/efew212efe/article/details/124524863</a></li><li><a href="https://www.mongodb.com/docs/manual/">https://www.mongodb.com/docs/manual/</a></li><li><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">https://www.runoob.com/mongodb/mongodb-tutorial.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mongodb</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows常用操作</title>
    <link href="/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/30/windows%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>windows_查看端口被占用情况、结束进程</p></blockquote><p>查看指定端口占用情况（端口引号有没有都可以，此处以5040为例）</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">netstat -aon<span class="hljs-string">|findstr 5040</span><br></code></pre></td></tr></table></figure><p>根据PID查看相应的进程或程序(也可以任务管理器查看)</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">tasklist<span class="hljs-string">|findstr 5340</span><br></code></pre></td></tr></table></figure><p>结束进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">taskkill /f /t /im 进程名<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vim常用操作</title>
    <link href="/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/29/vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="退出编辑器"><a href="#退出编辑器" class="headerlink" title="退出编辑器"></a>退出编辑器</h4><ul><li>wq：保存当前文件并退出</li><li>wqa：保存所有文件并退出</li><li>q!： 不保存，强制退出</li><li>qa!： 有多个文件被打开，同时退出</li></ul><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/89042423">https://zhuanlan.zhihu.com/p/89042423</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
      <tag>vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>centos7系统_常用操作</title>
    <link href="/2023/11/28/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/28/centos7%E7%B3%BB%E7%BB%9F_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h3><blockquote><p>查看防火墙状态</p></blockquote><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">firewall-cmd <span class="hljs-comment">--state</span><br></code></pre></td></tr></table></figure><p>常用操作</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-params">system</span>ctl stop firewalld   <span class="hljs-comment"># 关闭防火墙</span><br><span class="hljs-params">system</span>ctl start firewalld  <span class="hljs-comment"># 启动防火墙</span><br>firewall-cmd --reload      <span class="hljs-comment"># 重启防火墙</span><br><span class="hljs-params">system</span>ctl disable firewalld  <span class="hljs-comment"># 禁用防火墙</span><br></code></pre></td></tr></table></figure><blockquote><p>开放防火墙端口</p></blockquote><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile">firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --query-port=80/tcp   <span class="hljs-comment">#端口开放情况</span></span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --list-ports  <span class="hljs-comment">#查看开放的端口</span></span><br><br><span class="hljs-comment">#开放端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8080/tcp</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --add-port=8083-8085/tcp</span><br><br><span class="hljs-comment">#关闭端口</span><br>firewall-<span class="hljs-keyword">cmd</span><span class="language-bash"> --permanent --remove-port=8083-8085/tcp</span><br></code></pre></td></tr></table></figure><p>端口开放后建议重启一下防火墙</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring学习_基础内容</title>
    <link href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Spring 概念</li><li>常用模块</li><li>IOC</li><li>AOP</li><li>Spring 事务</li><li>Spring MVC</li></ul><hr><p>参考</p><ul><li><a href="https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html">https://javaguide.cn/system-design/framework/spring/spring-knowledge-and-questions-summary.html</a></li><li><a href="https://www.pdai.tech/md/spring/spring.html">https://www.pdai.tech/md/spring/spring.html</a></li><li><a href="https://blog.csdn.net/Mixzi/article/details/123980213">https://blog.csdn.net/Mixzi/article/details/123980213</a></li><li><a href="https://www.moguit.cn/info/794">https://www.moguit.cn/info/794</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL学习_基础内容</title>
    <link href="/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>关系型数据库</li><li>数据类型</li><li>MySQL基础架构</li><li>存储引擎</li><li>MySQL索引</li><li>数据库事务</li><li>多版本并发控制</li><li>MySQL锁</li><li>MySQL日志</li><li>性能优化</li><li>主从复制，读写分离，分库分表</li></ul><p>MySQL是一种关系型数据库管理系统（RDBMS)，用于持久化存储数据。</p><h4 id="字段类型"><a href="#字段类型" class="headerlink" title="字段类型"></a>字段类型</h4><ul><li>字段类型<ul><li>数值类型<ul><li>整型<ul><li>TINYINT</li><li>SMALLINT</li><li>MEDIUMINT</li><li>INT</li><li>BIGINT</li></ul></li><li>浮点型<ul><li>FLOAT<br>DOUBLE</li></ul></li><li>定点型<ul><li>DECIMAL</li></ul></li></ul></li><li>字符串类型<ul><li>常用<ul><li>CHAR</li><li>VARCHAR</li></ul></li><li>TEXT 类<ul><li>TINYTEXT</li><li>TEXT</li><li>MEDIUMTEXT</li><li>LONGTEXT</li></ul></li><li>BLOB类<ul><li>TINYBLOB</li><li>BLOB</li><li>MEDIUMBLOB</li><li>LONGBLOB</li></ul></li></ul></li><li>日期时间类型<ul><li>常用<ul><li>YEAR</li><li>TIME</li><li>DATE</li><li>DATETIME</li><li>TIMESATMP</li></ul></li></ul></li></ul></li></ul><h4 id="MySQL基础架构"><a href="#MySQL基础架构" class="headerlink" title="MySQL基础架构"></a>MySQL基础架构</h4><p>MySQL的基础架构主要由以下几个关键组件构成：</p><ol><li><strong>连接器（Connection Management）：</strong><ul><li>负责身份认证和权限相关的工作，管理用户的连接请求，处理用户登录MySQL的过程。</li></ul></li><li><strong>查询缓存（Query Cache）：</strong><ul><li>在执行查询语句之前，MySQL会先检查查询缓存，如果之前执行过相同的查询，就可以直接返回缓存中的结果。然而，由于MySQL 8.0版本后移除了查询缓存，因为该功能在实际应用中并不太实用。</li></ul></li><li><strong>分析器（Parser）：</strong><ul><li>当查询缓存未命中时，SQL语句会经过分析器。分析器的主要任务是解析SQL语句，确定其意图，并检查语法的正确性。</li></ul></li><li><strong>优化器（Optimizer）：</strong><ul><li>优化器根据MySQL的统计信息和规则，选择执行SQL查询的最优执行计划，以提高查询性能。</li></ul></li><li><strong>执行器（Execution Engine）：</strong><ul><li>执行器负责执行经过优化后的查询计划，通过存储引擎访问实际的数据，并将结果返回给用户。<br> <strong>权限判断（Access Control）：</strong><ul><li>在执行语句之前，MySQL会进行权限判断，确保用户具有执行该语句所需的权限。如果用户没有足够的权限，将会报错。</li></ul></li></ul></li><li><strong>插件式存储引擎（Pluggable Storage Engines）：</strong><ul><li>MySQL支持多种存储引擎，如InnoDB、MyISAM、Memory等。这些存储引擎负责实际的数据存储和读取，通过插件式架构，用户可以根据需求选择合适的存储引擎。<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311301556607.png" alt="image.png"></li></ul></li></ol><h4 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h4><p>MySQL 当前默认的存储引擎是 InnoDB。</p><p>在 MySQL的存储引擎中，只有 InnoDB 是事务性存储引擎（只有他支持事务） </p><h4 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h4><p>索引是在<strong>存储引擎层实现</strong>的，而不是在服务器层实现的，不同存储引擎具有不同的索引类型和实现。</p><blockquote><p>索引类型</p></blockquote><p>MySQL支持多种索引类型，其中最常见的是B树索引和哈希索引。</p><p>大多数情况下，使用B树索引是最合适的选择，它适用于各种不同查询类型。</p><blockquote><p>索引的创建和注意事项</p></blockquote><p>实际操作的时候我们一般会通过分析查询执行计划来优化查询，确保MySQL使用比较正确的索引。</p><p>尽管一般添加索引会优化数据的查询性能，但过多或者不必要的索引有时候会导致写操作的性能下降。因此索引的添加是需要权衡一定利弊的。</p><p>除了在创建索引时权衡读写性能，还需要定期进行索引的性能分析和优化。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>事务的特性：要么全部执行成功，要么全部执行失败</p><blockquote><p>事务的ACID属性</p></blockquote><ul><li><strong>原子性（Atomicity）：</strong> 事务是一个原子操作单元，要么全部执行，要么全部回滚，不存在部分执行的情况。</li><li><strong>一致性（Consistency）：</strong> 事务的执行将数据库从一个一致的状态转移到另一个一致的状态，不破坏数据库的完整性约束。</li><li><strong>隔离性（Isolation）：</strong> 事务的执行是相互隔离的，一个事务的修改在另一个事务看来是不可见的，防止并发引起的问题。</li><li><strong>持久性（Durability）：</strong> 一旦事务被提交，其修改将永久保存在数据库中，即使系统发生故障也不会丢失。</li></ul><blockquote><p>事务控制语句</p></blockquote><p>事务的开始、提交和回滚：</p><ul><li><code>BEGIN</code> 或 <code>START TRANSACTION</code>：开始一个新的事务。</li><li><code>COMMIT</code>：提交事务，将更改永久保存到数据库。</li><li><code>ROLLBACK</code>：回滚事务，撤销自上一次<code>COMMIT</code>或<code>ROLLBACK</code>以来的所有更改。</li></ul><blockquote><p>事务的隔离级别</p></blockquote><p>MySQL支持多个事务隔离级别，包括读未提交、读已提交、可重复读和串行化。</p><h4 id="多版本并发控制"><a href="#多版本并发控制" class="headerlink" title="多版本并发控制"></a>多版本并发控制</h4><p>略</p><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_8-2-mysql">https://www.pdai.tech/md/interview/x-interview.html#_8-2-mysql</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>windows旧电脑重装CentOs7系统制作为个人服务器</title>
    <link href="/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>/2023/11/26/%E6%97%A7%E7%94%B5%E8%84%91%E6%94%B9%E9%80%A0%E4%B8%BA%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>如果需要将一台 winodws 电脑重装为 centos 系统，需要分为下面几步</p><ul><li>1、先对 windows 进行磁盘格式化操作</li><li>2、通过 iso 文件进行对某个U盘刻录操作</li><li>3、电脑通过这个U盘进行安装 centos 系统</li><li>4、基本配置与使用</li></ul><p>具体操作见如下内容：</p><h3 id="1、格式化windows-的盘符"><a href="#1、格式化windows-的盘符" class="headerlink" title="1、格式化windows 的盘符"></a>1、格式化windows 的盘符</h3><p>重新安装 centos 系统前，需要在 window 系统下先进入PE环境，将原来装有Windows系统的盘符使用分区工具格式化为FAT32格式.</p><blockquote><p>制作U盘启动盘</p></blockquote><p>使用老毛桃U盘启动工具制作U盘启动盘:  <a href="http://lmt.psydrj.com/udisk.html">http://lmt.psydrj.com/udisk.html</a></p><p>模式选择USB—HDD，格式选择“NTFS”；制作完成后，可以选择模拟启动测试，若能够进入老毛桃winpe主菜单，即表示老毛桃U盘启动盘制作成功。【这里主要是要用到他的第四个 DiskGenius 工具】</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126214740.png" alt="image.png"></p><p>重新启动电脑，进入bios</p><p>界面会让你选择一个 boot device ，你这里根据英文选择一下 U 盘启动（界面是显示的U盘名称）</p><p>然后会进入到上面图片的内容（选择  DiskGenius ）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126220736.png" alt="image.png"></p><p>选择快速分区，选择分区类型FAT32，选择 1 个分区，</p><h3 id="2、重装-centos-系统"><a href="#2、重装-centos-系统" class="headerlink" title="2、重装 centos 系统"></a>2、重装 centos 系统</h3><p>下载好 centos7 的镜像文件： </p><ul><li><a href="https://man.linuxde.net/download/CentOS_7_4">https://man.linuxde.net/download/CentOS_7_4</a></li><li><a href="http://mirrors.aliyun.com/centos/7/isos/x86_64/">http://mirrors.aliyun.com/centos/7/isos/x86_64/</a></li></ul><h4 id="刻录操作"><a href="#刻录操作" class="headerlink" title="刻录操作"></a>刻录操作</h4><p>下载 UltraISO 软碟通 </p><p>格式化之前的U盘，格式化为 FAT32 文件系统（或者准备第二个U盘）</p><p>选择写入硬盘映像</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222516.png" alt="image.png"></p><p>写入方式默认（USB-HDD+），单击便携启动，单击写入新的驱动器引导扇区，单击Syslinux。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126222715.png" alt="image.png"></p><p>完毕后，单击下方写入，等待进度条满写入完毕。</p><blockquote><p>记：中间遇到一次 提示格式化重新操作</p></blockquote><p>UltraISO的软件提示其实是准确的，但却是程序员思维下科学素养级别的提示。这里的建议格式化U盘后再试，意思是建议你删除所有分区后重试</p><p>解决处理：</p><ul><li>1、下载 DiskGenius 格式化所有分区 </li><li>2、用win+R打开cmd，输入“diskpart”    输入“list disk”查看所有磁盘   依据大小选中对应磁盘“select disk x”    输入“clean”删除所有分区</li></ul><p>第一种方式的下载地址： <a href="https://xiazai.zol.com.cn/detail/33/327603.shtml">https://xiazai.zol.com.cn/detail/33/327603.shtml</a></p><p>格式化转换盘符为FAT32格式</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231126234720.png" alt="image.png|500"></p><p>实际操作的时候显示设备写入错误 55</p><p>也试了一下网上说的通过管理员运行，或者上面说的格式化操作，都不行；最后通过买了一个新的 U 盘解决。</p><blockquote><p>通过 balenaEtcher 进行刻录操作</p></blockquote><p>下载地址：</p><ul><li><a href="https://www.ssdtop.com/balenaetcher.html">https://www.ssdtop.com/balenaetcher.html</a></li><li><a href="https://github.com/balena-io/etcher/releases">https://github.com/balena-io/etcher/releases</a></li></ul><p>下载  balenaEtcher 进行刻录操作，还是失败</p><p>猜测大概是U盘有问题，或者换一台电脑进行操作；这里选择重新购买一个新的 U 盘进行操作</p><p>Later…</p><p>新 U盘 通过 DiskGenius 格式化U盘分区，再通过 UltraISO 成功进行了刻录操作。</p><hr><h4 id="重装系统"><a href="#重装系统" class="headerlink" title="重装系统"></a>重装系统</h4><p>将 U 盘 插入需要重装的电脑并开机。如果已经设置完毕以USB为第一启动项，则不用再次进入bios界面。</p><p>没有的话再进入一次，通过 USB 启动。</p><blockquote><p>安装操作</p></blockquote><ul><li>1、选择Install CentOS 7</li><li>2、按回车键</li><li>3、成功进入CentOS系统图形化的安装界面后，进行初始化</li></ul><p>初始化配置</p><ul><li>①中文（语言）</li><li>②软件选择：GNOME桌面</li><li>③安装位置：选择磁盘，手动分区（选择“我要配置分区”）<ul><li>&#x2F;boot     也可以不添加     1G</li><li>&#x2F;swap   交互分区             2G</li><li>&#x2F;            根目录，分配剩下所有空间</li></ul></li></ul><blockquote><p>初始化配置</p></blockquote><p>②软件选择</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234606.png" alt="image.png"></p><p>③添加新挂载点 &#x2F;boot</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231127234855.png" alt="image.png"></p><p><strong>设置好后点击完成，选择接受更改</strong></p><blockquote><p>网络与主机名</p></blockquote><p>网络与主机名：<strong>打开网络，自己设置一个主机名，然后点击完成</strong></p><blockquote><p>用户设置</p></blockquote><p>开始安装</p><ul><li><strong>点击设置root密码</strong></li><li>等待过程中可以 <strong>创建一个普通用户</strong></li></ul><blockquote><p>重启电脑后配置内容</p></blockquote><p>重启电脑</p><p><strong>重启后进入初始设置界面，接受许可，然后点击完成配置</strong>  → 完成配置</p><p><strong>等待，然后来到登录页面，我们选择未列出，然后输入root和root的密码，然后点击登录。</strong></p><p><strong>来到桌面，我们选择语言为中文</strong></p><p><strong>关闭位置服务</strong></p><p>跳过在线账号</p><hr><h3 id="3、使用-windows-访问同一个局域网下的-linux-系统"><a href="#3、使用-windows-访问同一个局域网下的-linux-系统" class="headerlink" title="3、使用 windows 访问同一个局域网下的 linux 系统"></a>3、使用 windows 访问同一个局域网下的 linux 系统</h3><p>设置完成后，连接同一个wife</p><p>在 windows 中使用 xshell&#x2F;termius 工具访问即可</p><h3 id="4、内网穿透的使用"><a href="#4、内网穿透的使用" class="headerlink" title="4、内网穿透的使用"></a>4、内网穿透的使用</h3><p>略</p><p>暂未有这个需求，后续考虑使用。</p><hr><p>参考：</p><ul><li><a href="https://blog.csdn.net/m0_59302403/article/details/132119884">https://blog.csdn.net/m0_59302403/article/details/132119884</a></li><li><a href="https://blog.csdn.net/weixin_42292697/article/details/110285529">https://blog.csdn.net/weixin_42292697/article/details/110285529</a></li><li><a href="https://www.bilibili.com/video/BV1c3411T7Td">https://www.bilibili.com/video/BV1c3411T7Td</a></li><li><a href="https://blog.csdn.net/m0_51545690/article/details/123238360">https://blog.csdn.net/m0_51545690/article/details/123238360</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>computer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>个人在线网盘_ZFile</title>
    <link href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/"/>
    <url>/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/</url>
    
    <content type="html"><![CDATA[<p>看到有一个还不错的项目，有时候需要将文件放置在云端，这里学习使用一下这个工具。（支持预览操作）</p><p>项目地址： <a href="https://github.com/zfile-dev/zfile">https://github.com/zfile-dev/zfile</a></p><p>部署文档地址： <a href="https://docs.zfile.vip/">https://docs.zfile.vip/</a></p><h3 id="1、项目运行"><a href="#1、项目运行" class="headerlink" title="1、项目运行"></a>1、项目运行</h3><p>下载项目后，需要系统里面有 JDK8 的环境</p><blockquote><p>Centos 系统运行</p></blockquote><blockquote><p>安装 JDK8</p></blockquote><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">yum</span> install -y java-<span class="hljs-number">1</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>-openjdk unzip<br></code></pre></td></tr></table></figure><blockquote><p>下载并解压</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">export</span> ZFILE_INSTALL_PATH=~/zfile                        <span class="hljs-comment"># 声明安装到的路径</span><br><span class="hljs-built_in">mkdir</span> -p <span class="hljs-variable">$ZFILE_INSTALL_PATH</span> &amp;&amp; <span class="hljs-built_in">cd</span> <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>   <span class="hljs-comment"># 创建文件夹并进入</span><br>wget --no-check-certificate https://c.jun6.net/ZFILE/zfile-release.war          <span class="hljs-comment"># 下载 zfile 最新版</span><br>unzip zfile-release.war &amp;&amp; <span class="hljs-built_in">rm</span> -rf zfile-release.war      <span class="hljs-comment"># 解压并删除压缩包</span><br><span class="hljs-built_in">chmod</span> +x <span class="hljs-variable">$ZFILE_INSTALL_PATH</span>/bin/*.sh                    <span class="hljs-comment"># 授权启动停止脚本</span><br></code></pre></td></tr></table></figure><p>ZFile 提供了一个 在线下载路径，也可以本地下载后自定义设备某些内容后，打包为 war ，放置在 linux 系统上运行。</p><p>如需修改配置文件，配置文件路径为：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>WEB-INF<span class="hljs-regexp">/classes/</span>application.properties<br></code></pre></td></tr></table></figure><hr><p>安装说明</p><p>下面命令中第一行表示默认安装到用户目录下: <code>~/zfile</code> 下。</p><p>对于 <code>root</code> 用户, <code>~</code> &#x3D; <code>/root</code>, <code>~/zfile</code> 表示在 <code>/root/zfile</code> 路径下。</p><p>对于其他用户, <code>~</code> &#x3D; <code>/home/用户名</code> 表示在 <code>/home/用户名/</code> 路径下。如对于 <code>oracle</code> 用户, <code>~/zfile</code> 则表示安装在 <code>/home/oracle/zfile</code> 下。</p><p>如需更改安装路径, 请自行修改，如 <code>export ZFILE_INSTALL_PATH=/data/zfile</code>，表示安装在 <code>/data/zfile</code> 路径下。</p><hr><h3 id="2、启动项目"><a href="#2、启动项目" class="headerlink" title="2、启动项目"></a>2、启动项目</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br></code></pre></td></tr></table></figure><hr><p>启动后浏览器访问 <strong><code>http://ip:8080</code></strong> 即可，如启动后无法访问，请检查 <strong><code>端口是否冲突</code></strong> 或 **<code>防火墙/安全组是否开启</code>**。</p><p>简单检查方式为在服务器执行 <code>curl http://127.0.0.1:8080</code></p><ul><li>如返回 <code>curl: (7) Failed connect to 127.0.0.1:8080; Connection refused</code> 表示未启动成功。</li><li>如返回 <code>&lt;!DOCTYPE html&gt; &lt;html lang=&quot;zh-CN&quot;&gt;……</code> 等字样表示启动成功，如启动成功但通过服务器 IP 无法访问，那一般就是防火墙&#x2F;安全组未放行端口问题。</li></ul><hr><p>更新程序前务必停止程序再进行操作</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk">~<span class="hljs-regexp">/zfile/</span>bin/start.sh       <span class="hljs-comment"># 启动</span><br>~<span class="hljs-regexp">/zfile/</span>bin/stop.sh        <span class="hljs-comment"># 停止</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>project</category>
      
      <category>github</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Elasticsearch_基础内容</title>
    <link href="/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Elasticsearch_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p><code>Elasticsearch</code>是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本  身扩展性很好，可以扩展到上百台服务器，处理PB级别的数据。</p><p>ES也使用Java开发并使用Lucene作为其核心来实 现所有索引和搜索的功能，它的目的是通过简单的RESTful API来隐藏Lucene的复杂性，从而让全文搜索变得  简单。</p><blockquote><p>Elasticsearch比传统关系型数据库如下：</p></blockquote><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Relational</span> <span class="hljs-variable constant_">DB</span> ‐&gt; <span class="hljs-title class_">Databases</span> ‐&gt; <span class="hljs-title class_">Tables</span> ‐&gt; <span class="hljs-title class_">Rows</span> ‐&gt; <span class="hljs-title class_">Columns</span>  </span><br><span class="hljs-meta prompt_">&gt;</span> <span class="language-javascript"><span class="hljs-title class_">Elasticsearch</span> ‐&gt; <span class="hljs-title class_">Indices</span> ‐&gt; <span class="hljs-title class_">Types</span> ‐&gt; <span class="hljs-title class_">Documents</span> ‐&gt; <span class="hljs-title class_">Fields</span></span><br></code></pre></td></tr></table></figure><p>to be contined…..</p><p>参考</p><ul><li><a href="https://elasticsearch.bookhub.tech/getting_started/">https://elasticsearch.bookhub.tech/getting_started/</a></li><li><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html">https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html</a></li><li><a href="https://www.cnblogs.com/coderxz/p/13268417.html">https://www.cnblogs.com/coderxz/p/13268417.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/516698885">https://zhuanlan.zhihu.com/p/516698885</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>elasticsearch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue学习_基础内容</title>
    <link href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<blockquote><p>大纲</p></blockquote><ul><li>Vue 基础</li><li>Vue 语法</li><li>组件化开发</li><li>路由</li><li>webpack</li><li>脚手架</li></ul><hr><p>参考</p><ul><li><a href="https://cn.vuejs.org/">https://cn.vuejs.org/</a></li><li><a href="https://blog.csdn.net/fmk1023/article/details/111381876">https://blog.csdn.net/fmk1023/article/details/111381876</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Maven工具_基础使用</title>
    <link href="/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"/>
    <url>/2023/11/24/Maven%E5%B7%A5%E5%85%B7_%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Maven-下载与安装"><a href="#1、Maven-下载与安装" class="headerlink" title="1、Maven 下载与安装"></a>1、Maven 下载与安装</h3><p>略</p><h3 id="2、Maven配置文件修改"><a href="#2、Maven配置文件修改" class="headerlink" title="2、Maven配置文件修改"></a>2、Maven配置文件修改</h3><blockquote><p>maven 配置文件内容</p></blockquote><p>设置本地仓库路径</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--设置本地仓库路径--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\maven\localRepository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置阿里云私服（或换成自己公司搭建的私服）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在mirrors标签里添加mirror标签，并指定阿里云私服下载依赖会快点 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置 maven 默认jdk版本</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 在已有的profiles标签中添加profile标签，限定maven项目默认的jdk版本 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span>    <br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br> <br><span class="hljs-comment">&lt;!-- 让增加的 profile生效 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>myjdk<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置华为云</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>huaweicloud<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.huaweicloud.com/repository/maven/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>阿里云:   <a href="https://developer.aliyun.com/mvn/guide">https://developer.aliyun.com/mvn/guide</a></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>aliyunmaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>阿里云公共仓库<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://maven.aliyun.com/repository/public<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>下面这个论点，配置的时候注意一下：<strong>一个仓库只能对应一个镜像，当有多个镜像的mirrorOf指定了同一个仓库，maven只会从第一个匹配的仓库中进行查找</strong></p><h3 id="3、IDEA-配置-maven"><a href="#3、IDEA-配置-maven" class="headerlink" title="3、IDEA 配置 maven"></a>3、IDEA 配置 maven</h3><blockquote><p>IDEA 配置 maven</p></blockquote><p>快捷查找框中输入maven，查找与maven相关的设置，然后点击maven</p><p>修改maven的路径（使用本地的Maven），以及修改settings文件的位置和本地仓库的位置</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242131645.png" alt="image.png"></p><p>IDEA  有的版本下面有一个   use settings from .mvn&#x2F;maven.config  选项，进行勾选</p><p>他的意思是： mvn(directory):  位于项目的顶级目录中，文件 maven.config、jvm.config和extensions.xml 包含运行Maven的项目特定配置。这个目录应该是项目的一部分，需要被版本管理工具管理</p><blockquote><p>推荐配置：设置maven在不联网的情况下使用本地插件</p></blockquote><p>一般使用maven为我们提供好的骨架时，是需要联网的，配置这个，可以在没有网路的情况下，我们可以正常创建工程，并从之前已经使用过的工程中找到相应的骨架。（根据骨架创建项目速度会加快）</p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311242133069.png" alt="image.png"></p><p>输入内容：<code>-DarchetypeCatalog=internal</code></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/yang_yzl11/article/details/120764764">https://blog.csdn.net/yang_yzl11/article/details/120764764</a></li><li><a href="https://blog.csdn.net/qq_42057154/article/details/106114515">https://blog.csdn.net/qq_42057154/article/details/106114515</a></li><li><a href="https://www.cnblogs.com/SherlockLynn/p/15079467.html">https://www.cnblogs.com/SherlockLynn/p/15079467.html</a></li><li><a href="https://blog.csdn.net/qq_38217990/article/details/129257106">https://blog.csdn.net/qq_38217990/article/details/129257106</a></li><li><a href="https://zhuanlan.zhihu.com/p/653017610">https://zhuanlan.zhihu.com/p/653017610</a></li><li><a href="https://blog.csdn.net/qq_39505065/article/details/111559890">https://blog.csdn.net/qq_39505065/article/details/111559890</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Nacos</title>
    <link href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/"/>
    <url>/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Nacos-是什么"><a href="#1、Nacos-是什么" class="headerlink" title="1、Nacos 是什么"></a>1、Nacos 是什么</h3><p>Nacos 是一个构建云原生应用的动态服务发现、配置管理和服务管理平台；致力于帮助发现、配置和管理微服务。</p><h3 id="2、下载与运行"><a href="#2、下载与运行" class="headerlink" title="2、下载与运行"></a>2、下载与运行</h3><p>下载地址： <a href="https://github.com/alibaba/nacos/releases">https://github.com/alibaba/nacos/releases</a></p><p>windows版本使用<code>nacos-server-x.x.x.zip</code>包即可</p><p>将这个包解压到任意非中文目录下，如图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154048.png" alt="image.png"><br>目录说明：</p><ul><li>bin：启动脚本</li><li>conf：配置文件</li></ul><p>Nacos的默认端口是8848，如果电脑上的其它进程占用了8848端口，先尝试关闭该进程。</p><p><strong>如果无法关闭占用8848端口的进程</strong>，也可以进入nacos的conf目录，修改配置文件中的端口<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231124154144.png" alt="image.png"></p><blockquote><p>启动命令(Windows)</p></blockquote><p>启动非常简单，进入bin目录</p><p>启动命令(standalone代表着单机模式运行，非集群模式):</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dos">startup.<span class="hljs-built_in">cmd</span> -m standalone<br></code></pre></td></tr></table></figure><blockquote><p>访问</p></blockquote><p>在浏览器输入地址： <a href="http://127.0.0.1:8848/nacos">http://127.0.0.1:8848/nacos</a> </p><p>默认的账号和密码都是nacos</p><blockquote><p>Namespace+Group+DataID三者的关系</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250024118.png" alt="image.png|400"></p><blockquote><p>多环境配置</p></blockquote><p>略</p><h3 id="3、Nacos-的基本使用"><a href="#3、Nacos-的基本使用" class="headerlink" title="3、Nacos 的基本使用"></a>3、Nacos 的基本使用</h3><h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><p>在 spring-cloud-alibaba-service 的主启动类上，使用 @EnableDiscoveryClient 注解开启 Nacos 服务发现功能</p><p>你访问该服务下的某个请求链接，再查看 nacos “服务管理”下的“服务列表”，会发现已经注册上了。</p><p>一般在消费端会引入 spring-cloud-loadbalancer 进行调用服务提供者提供的服务</p><h4 id="配置中心"><a href="#配置中心" class="headerlink" title="配置中心"></a>配置中心</h4><blockquote><p><strong>动态获取配置内容</strong></p></blockquote><p>在应用的 POM 文件中引入 spring-cloud-starter-alibaba-nacos-config ，可实现配置的获取与动态刷新</p><p>示例 </p><p>bootstrap.yml 文件配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">3377</span> <span class="hljs-comment">#端口号</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">config-client</span> <span class="hljs-comment">#服务名</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos服务注册中心地址</span><br>      <span class="hljs-attr">config:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><span class="hljs-string">:8848</span> <span class="hljs-comment">#Nacos作为配置中心地址</span><br>        <span class="hljs-attr">file-extension:</span> <span class="hljs-string">yaml</span> <span class="hljs-comment">#指定yaml格式的配置</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span> <span class="hljs-comment">#激活 dev 的配置</span><br></code></pre></td></tr></table></figure><p>在 icu.luoqi.nacos.controller 包下，创建一个名为 ConfigClientController 的 Controller 类，并在该类上使用 @RefreshScope 注解实现配置的自动更新，代码如下</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">import</span> org.springframework.beans.factory.<span class="hljs-keyword">annotation</span>.Value;<br><span class="hljs-keyword">import</span> org.springframework.cloud.context.config.<span class="hljs-keyword">annotation</span>.RefreshScope;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.GetMapping;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.RestController;<br><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RefreshScope</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConfigClientController</span> &#123;<br><br>    <span class="hljs-meta">@Value(<span class="hljs-string">&quot;<span class="hljs-subst">$&#123;config.info&#125;</span>&quot;</span>)</span><br>    <span class="hljs-keyword">private</span> String ConfigInfo;<br>    <br>    <span class="hljs-meta">@GetMapping(<span class="hljs-string">&quot;/config/info&quot;</span>)</span><br>    <span class="hljs-keyword">public</span> String getConfigInfo()&#123;<br>        <span class="hljs-keyword">return</span> ConfigInfo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>主启动类上，使用 @EnableDiscoveryClient 注解开启服务发现功能</p><p>启动 Nacos Server，并在 Nacos Server 控制台的“配置管理”下的“配置列表”中，点击“+”按钮，新建如下配置</p><figure class="highlight nestedtext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">Data ID</span><span class="hljs-punctuation">:</span> <span class="hljs-string">       config-client-dev.yaml</span><br><br><span class="hljs-attribute">Group</span><span class="hljs-punctuation">:</span> <span class="hljs-string">         DEFAULT_GROUP</span><br><br><span class="hljs-attribute">配置格式</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      YAML</span><br><br><span class="hljs-attribute">配置内容</span><span class="hljs-punctuation">:</span> <span class="hljs-string">      config:</span><br>                   <span class="hljs-attribute">info</span><span class="hljs-punctuation">:</span> <span class="hljs-string">xxxx</span><br></code></pre></td></tr></table></figure><p>在 Nacos Server 中，配置的 dataId（即 Data ID）的完整格式如下：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span>&#123;prefix&#125;-<span class="hljs-symbol">$</span>&#123;spring.profiles.active&#125;.<span class="hljs-symbol">$</span>&#123;<span class="hljs-keyword">file</span>-extension&#125;<br></code></pre></td></tr></table></figure><p>启动该服务，并使用浏览器访问“<a href="http://localhost:3377/config/info%E2%80%9D%EF%BC%8C">http://localhost:3377/config/info”，</a></p><p>在这种情况下，能够实现不重启后台服务，当你手动修改 nacos 的配置时，能够动态获取到配置内容。</p><blockquote><p>Nacos Config配置集的三种方式和加载顺序</p></blockquote><ul><li>通过 spring.cloud.nacos.config.shared-configs 配置项，支持多个共享 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.extension-configs 配置项，支持多个拓展 Nacos 配置集。</li><li>通过 spring.cloud.nacos.config.name 配置项，支持一个 Nacos 配置集。</li></ul><p>当三种方式共同使用时，它们的优先级关系是：A &lt; B &lt; C。另外，A 和 B 的命名带有“共享”或是“拓展”，没有任何含义，只是优先级不同</p><h3 id="4、注意事项"><a href="#4、注意事项" class="headerlink" title="4、注意事项"></a>4、注意事项</h3><p>命名空间id用于唯一标识命名空间， 新建命名空间时候，如果不填写命名空间id，则系统会自动生成命名空间id，生成规则为UUID方式。</p><p>但在spring 项目中集成nacos 的时候，配置文件中填写的namespace就是命名空间的id</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260000905.png" alt="image.png"></p><p>因此尽量保持nacos的命名空间名称和id 一致</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311260002165.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106835279">https://blog.csdn.net/qq_36903261/article/details/106835279</a></li><li><a href="https://m.biancheng.net/springcloud/nacos.html">https://m.biancheng.net/springcloud/nacos.html</a></li><li><a href="https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html">https://nacos.io/zh-cn/docs/v2/ecology/use-nacos-with-spring-cloud.html</a></li><li><a href="https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html">https://nacos.io/zh-cn/docs/quick-start-spring-cloud.html</a></li><li><a href="https://blog.csdn.net/weixin_45397785/article/details/128076533">https://blog.csdn.net/weixin_45397785/article/details/128076533</a></li><li><a href="https://blog.csdn.net/ysj1241267542/article/details/112562611">https://blog.csdn.net/ysj1241267542/article/details/112562611</a></li><li><a href="https://blog.csdn.net/u010520146/article/details/118703413">https://blog.csdn.net/u010520146/article/details/118703413</a></li><li><a href="https://blog.csdn.net/wangwei021933/article/details/129590430">https://blog.csdn.net/wangwei021933/article/details/129590430</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo_实现在百度中搜索到自己的博客</title>
    <link href="/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/24/hexo_%E5%AE%9E%E7%8E%B0%E5%9C%A8%E7%99%BE%E5%BA%A6%E4%B8%AD%E6%90%9C%E7%B4%A2%E5%88%B0%E8%87%AA%E5%B7%B1%E7%9A%84%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>1、注册一个百度站长账号</p></blockquote><p>地址： <a href="https://ziyuan.baidu.com/?castk=LTE=">https://ziyuan.baidu.com/?castk=LTE%3D</a></p><p>验证网站所有权： <a href="https://ziyuan.baidu.com/site/index">https://ziyuan.baidu.com/site/index</a></p><p>打开之后输入你的博客首页地址，可以是<code>Github Pages</code>或者<code>Vercel</code>的地址，然后点击下一步。</p><p>站点领域： 信息技术</p><p>验证：选择第二种验证方式  →  HTML 验证</p><p><strong>本博客使用的是 fluid 主题</strong>，</p><p>进入博客目录下 <code>scripts</code> 文件夹（如不存在则创建），在里面创建任意名称的 js 文件，在文件中写入如下内容（content 见百度具体验证内容)：</p><figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs scilab">hexo.extend.filter.register(<span class="hljs-string">&#x27;theme_inject&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(injects)</span> &#123;</span><br>  injects.head.raw(<span class="hljs-string">&#x27;home&#x27;</span>,<span class="hljs-string">&#x27;&lt;meta name=&quot;</span>baidu-site-verification<span class="hljs-string">&quot; content=&quot;</span>xxxxxxxxxxxxxxx<span class="hljs-string">&quot; /&gt;&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>在博客 <code>_config.yml</code> 文件加一句：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">baidu_site_verification:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>编译发布你的博客，在博客首页按<code>F12</code>，如果在<code>head</code>标签中看到了验证标签则成功了。</p><p>点击验证按钮，如果没问题则已成功。</p><blockquote><p>2、站点地图功能</p></blockquote><p>需要生成一个站点地图</p><p>先确认一下 <code>_config.yml</code> 配置里面的 URL 值，如果不是改为自己的域名地址。</p><p>博客目录执行命令</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span>hexo-generator-sitemap --save        <span class="hljs-comment">#安装sitemap插件</span><br>npm <span class="hljs-keyword">install </span>hexo-generator-<span class="hljs-keyword">baidu-sitemap </span>--save  <span class="hljs-comment">#安装baidu-sitemap插件</span><br><br>  <br>hexo g  <span class="hljs-comment">#生成网站静态文件到public文件夹</span><br></code></pre></td></tr></table></figure><blockquote><p>查看根目录下的public目录，会生成两个文件，“sitemap.xml ”和 “baidusitemap.xml”</p></blockquote><p>其中“sitemap.xml”文件是搜索引擎通用的文件，</p><p>“baidusitemap.xml”是百度专用的sitemap文件，</p><blockquote><p>3、提交sitemap到百度资源搜索平台</p></blockquote><p>选择资源提交，点击普通收录，选择sitemap， <a href="https://ziyuan.baidu.com/linksubmit/index">https://ziyuan.baidu.com/linksubmit/index</a></p><p>填写网站地址，例：“域名&#x2F;baidusitemap.xml”，点击提交，过一段时间后博客就可以在百度中搜素到。</p><p>个人使用的时候这一步显示提交上限是 0 ；只能使用他手动提交的方式，而且只能是访问链接。</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/Passerby_Wang/article/details/124704475">https://blog.csdn.net/Passerby_Wang/article/details/124704475</a></li><li><a href="https://py-wang.blog.csdn.net/article/details/121202486">https://py-wang.blog.csdn.net/article/details/121202486</a></li><li><a href="https://cloud.tencent.com/developer/article/2317858">https://cloud.tencent.com/developer/article/2317858</a></li><li><a href="https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81">https://fluid-dev.github.io/hexo-fluid-docs/advance/#fluid-%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81</a></li><li><a href="https://zhuanlan.zhihu.com/p/150999914">https://zhuanlan.zhihu.com/p/150999914</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>status pages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vercel的开箱使用_同步Hexo静态博客</title>
    <link href="/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/"/>
    <url>/2023/11/23/Vercel%E7%9A%84%E5%BC%80%E7%AE%B1%E4%BD%BF%E7%94%A8_%E5%90%8C%E6%AD%A5Hexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>官网： <a href="https://vercel.com/">https://vercel.com/</a></p><p>部署无脑式导入 Github 原项目，然后进行 deploy 就行。命令可以自定义设置，一般是 hexo -s 之类的。(Vercels是支持你推送代码到Github的时候你在Vercel的项目也是会进行自动更新的)</p><p>点击部署的时候项目配置添加自定义域名操作：</p><p>Setting →  Domains →  选择添加解析域名</p><p>官网文档参考的解析域名地址</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240050203.png" alt="image.png"></p><p>实际操作记录：</p><p>个人使用的是阿里云的域名解析，在对应域名下添加了这一条记录<br>（对应 的记录值是 <code>cname.vercel-dns.com</code> ，记录类型需要是 CNAME）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311240052961.png" alt="image.png"></p><p>domain 选择编辑对应的域名地址: </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">varcel. + 你的阿里云域名<br></code></pre></td></tr></table></figure><p>最后部署访问成功。</p><hr><p>参考</p><ul><li><a href="https://juejin.cn/post/7143067114025254919">https://juejin.cn/post/7143067114025254919</a></li><li><a href="https://zhuanlan.zhihu.com/p/646818470">https://zhuanlan.zhihu.com/p/646818470</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>status pages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_Eureka</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Eureka-是什么"><a href="#1、Eureka-是什么" class="headerlink" title="1、Eureka 是什么"></a>1、Eureka 是什么</h3><p>Eureka 是一个Netflix 开源的服务发现组件，包括 Server 和 Client 两部分。在 Spring Cloud 子项目 Spring Cloud Netflix 中。</p><blockquote><p>服务注册与发现</p></blockquote><p>Eureka采用了CS的设计架构，Eureka Server作为服务注册功能的服务器，它是服务注册中心。</p><p>而系统中的其他微服务，使用Eureka的客户端连接到Eureka Server并维持心跳连接。</p><p>这样系统的维护人员就可以通过Eureka Server来监控系统中各个微服务是否正常运行。</p><p>在服务注册与发现中，有一个注册中心。当服务器启动的时候，会把当前自己服务器的信息比如服务地址通讯地址等以别名方式注册到注册中心上。另一方（消费者服务提供者)，以该别名的方式去注册中心上获取到实际的服务通讯地址，然后再实现本地RPC调用。</p><p>RPC远程调用框架核心设计思想：在于注册中心，因为使用注册中心管理每个服务与服务之间的一个依赖关系（服务治理概念）。在任何 rpc 远程框架中，都会有一个注册中心（存放服务地址相关信息（接口地址）)</p><p>Eureka 系统架构（右图是Dubbo的架构）<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222335266.png" alt="image.png"></p><blockquote><p>Eureka Server 与 Eureka Client</p></blockquote><p>Eureka Server 提供服务注册服务，各个微服务节点通过配置启动后，会在 Eureka Server中进行注册，这样EurekaServer中的服务注册表中将会存储所有可用服务节点的信息，服务节点的信息可以在界面中直观看到。</p><p>Eureka Client通过注册中心进行访问， Eureka Client 是一个Java客户端，用于简化Eureka Server的交互，客户端同时也具备一个内置的、使用轮询(round-robin)负载算法的负载均衡器。</p><p>在应用启动后，将会向Eureka Server发送心跳（默认周期为30秒）。如果Eureka Server 在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除（默认90秒）</p><h3 id="2、基本使用"><a href="#2、基本使用" class="headerlink" title="2、基本使用"></a>2、基本使用</h3><blockquote><p>服务端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka-server<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--热部署工具--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">7001</span><br><br><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">localhost</span> <span class="hljs-comment">#Eureka服务端的实例名称</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">register-with-eureka:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#表示是否向注册中心注册自己</span><br>    <span class="hljs-attr">fetch-registry:</span> <span class="hljs-literal">false</span>   <span class="hljs-comment">#为false表示自己是注册中心</span><br>    <span class="hljs-attr">service-url:</span>    <span class="hljs-comment">#监控页面</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@EnableEurekaServer</span> <span class="hljs-comment">//启动服务发现，接受注册</span><br><span class="hljs-variable">@SpringBootApplication</span><br>public class EurekaServer_7001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(EurekaServer_7001.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>启动项目，访问 <a href="http://localhost:7001/">http://localhost:7001/</a></p><blockquote><p>客户端</p></blockquote><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-eureka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>application</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment">#Eureka配置</span><br><span class="hljs-attr">eureka:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">service-url:</span><br>      <span class="hljs-attr">defaultZone:</span> <span class="hljs-string">http://localhost:7001/eureka/</span><br>  <span class="hljs-attr">instance:</span><br>    <span class="hljs-attr">instance-id:</span> <span class="hljs-string">springcloud-provider-dept-8001</span>   <span class="hljs-comment"># 修改eureka上的默认描述信息</span><br>    <span class="hljs-attr">prefer-ip-address:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># true,可以显示服务的IP地址</span><br></code></pre></td></tr></table></figure><p>启动类</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@SpringBootApplication</span><br><span class="hljs-variable">@EnableEurekaClient</span><br>public class DeptProvider_8001 &#123;<br><br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">static</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(String[] args) &#123;<br>        <span class="hljs-selector-tag">SpringApplication</span><span class="hljs-selector-class">.run</span>(DeptProvider_8001.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>to be contined….</p><p>参考</p><ul><li><a href="https://blog.csdn.net/qq_36903261/article/details/106551120">https://blog.csdn.net/qq_36903261/article/details/106551120</a></li><li><a href="https://blog.csdn.net/qq_45078781/article/details/118671285">https://blog.csdn.net/qq_45078781/article/details/118671285</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/142941185">https://zhuanlan.zhihu.com/p/142941185</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常见工程报错问题</title>
    <link href="/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/22/%E5%B8%B8%E8%A7%81%E5%B7%A5%E7%A8%8B%E6%8A%A5%E9%94%99%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>to be contined….</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>project</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCloud_组件基本使用_基础概念</title>
    <link href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、SpringCloud是什么"><a href="#1、SpringCloud是什么" class="headerlink" title="1、SpringCloud是什么"></a>1、SpringCloud是什么</h3><p>SpringCloud 提供了一整套的分布式系统解决方案，通过 Spring Boot 风格的封装，屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、容易部署的分布式系统开发工具包。</p><p>SpringCloud 包含了：服务注册与发现、配置中心、服务网关、智能路由、负载均衡、断路器、监控跟踪、分布式消息队列等。</p><p>Spring Cloud 包含很多子项目，国内主要是采用 Netflix 和 Alibaba 两个标准实现，前者由于不再维护，目前一般采用Spring Cloud Alibaba 这一套微服务解决方案。</p><blockquote><p>了解组件</p></blockquote><p>Spring Cloud Netflix 第一代</p><p>针对多种 Netflix 组件提供的开发工具包，其中包括 Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius 等。</p><ul><li><code>Netflix Eureka</code>：一个基于 Rest 服务的服务治理组件，包括服务注册中心、服务注册与服务发现机制的实现，实现了云端负载均衡和中间层服务器的故障转移。</li><li><code>Netflix Ribbon</code>：客户端负载均衡的服务调用组件。</li><li><code>Netflix Hystrix</code>：容错管理工具，实现断路器模式，通过控制服务的节点，从而对延迟和故障提供更强大的容错能力。</li><li><code>Netflix Feign</code>：基于 Ribbon 和 Hystrix 的声明式服务调用组件。</li><li><code>Netflix Zuul</code>：微服务网关，提供动态路由，访问过滤等服务。</li><li><code>Netflix Archaius</code>：配置管理 API，包含一系列配置管理 API，提供动态类型化属性、线程安全配置操作、轮询框架、回调机制等功能。</li></ul><p>Spring Cloud Alibaba 第二代</p><p><strong>阿里开源组件</strong></p><ul><li><code>Nacos</code>：阿里巴巴开源产品，一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li><code>Sentinel</code>：面向分布式服务架构的轻量级流量控制产品，把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li><code>RocketMQ</code>：一款开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li><code>Dubbo</code>：Apache Dubbo™ 是一款高性能 Java RPC 框架，用于实现服务通信。</li><li><code>Seata</code>：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li></ul><p><strong>阿里商业化组件</strong></p><ul><li><code>Alibaba Cloud ACM</code>：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li><code>Alibaba Cloud OSS</code>：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的海量、安全、低成本、高可靠的云存储服务。您可以在任何应用、任何时间、任何地点存储和访问任意类型的数据。</li><li><code>Alibaba Cloud SchedulerX</code>：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准、高可靠、高可用的定时（基于 Cron 表达式）任务调度服务。</li><li><code>Alibaba Cloud SMS</code>：覆盖全球的短信服务，友好、高效、智能的互联化通讯能力，帮助企业迅速搭建客户触达通道。</li></ul><blockquote><p>关于Cloud各种组件的停更升级替换</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221942122.png" alt="image.png"></p><blockquote><p>SpringCloud 版本介绍</p></blockquote><p>略</p><h3 id="2、创建cloud聚合父工程"><a href="#2、创建cloud聚合父工程" class="headerlink" title="2、创建cloud聚合父工程"></a>2、创建cloud聚合父工程</h3><h4 id="初始化工程及配置"><a href="#初始化工程及配置" class="headerlink" title="初始化工程及配置"></a>初始化工程及配置</h4><ol><li>New Project</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221957842.png" alt="image.png"></p><ol start="2"><li>聚合总父工程名字</li><li>Maven选版本</li><li>开启自动导入</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311221958787.png" alt="image.png"></p><ol start="5"><li>字符编码</li></ol><p>Settings → Editor →  File Encodings</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222220247.png" alt="image.png"></p><ol start="6"><li>注解生效激活</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222222672.png" alt="image.png"></p><ol start="7"><li>java编译版本选8</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222223525.png" alt="image.png"></p><ol start="8"><li>File Type过滤</li></ol><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222225655.png" alt="image.png"></p><p>这里File Type 配置</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-comment">*.idea</span><br><span class="hljs-comment">*.iml</span><br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311222226068.png" alt="image.png"></p><h4 id="父工程-pom-配置"><a href="#父工程-pom-配置" class="headerlink" title="父工程 pom 配置"></a>父工程 pom 配置</h4><p>父工程 Pom 文件参考配置</p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.luoqi.springcloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cloud2023<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--统一管理jar包版本--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">junit.version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">junit.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">lombok.version</span>&gt;</span>1.18.10<span class="hljs-tag">&lt;/<span class="hljs-name">lombok.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mysql.version</span>&gt;</span>8.0.18<span class="hljs-tag">&lt;/<span class="hljs-name">mysql.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">druid.version</span>&gt;</span>1.1.20<span class="hljs-tag">&lt;/<span class="hljs-name">druid.version</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>1.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">mybatis.spring.boot.version</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-comment">&lt;!--子模块继承之后，提供作用：锁定版本+子module不用写groupId和version--&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring boot 2.2.2--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud Hoxton.SR1--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>Hoxton.SR1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--spring cloud alibaba--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mysql--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mysql.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!-- druid--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;druid.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--mybatis--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;mybatis.spring.boot.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--junit--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;junit.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-comment">&lt;!--log4j--&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;log4j.version&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span>  </span><br><span class="language-xml">  </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">fork</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">fork</span>&gt;</span>  </span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">addResources</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">addResources</span>&gt;</span>  </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span>  </span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span>  </span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span>  </span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span></span><br></code></pre></td></tr></table></figure><h4 id="创建子模块"><a href="#创建子模块" class="headerlink" title="创建子模块"></a>创建子模块</h4><ul><li><ol><li>新建模块</li></ol></li><li><ol start="2"><li>pom文件对应依赖</li></ol></li><li><ol start="3"><li>yml 配置文件</li></ol></li><li><ol start="4"><li>启动类以及其他业务类</li></ol></li></ul><hr><p>参考</p><ul><li><a href="https://gitee.com/lixiaogou/cloud2020">https://gitee.com/lixiaogou/cloud2020</a></li><li><a href="https://blog.csdn.net/qq_36903261/article/details/106507150">https://blog.csdn.net/qq_36903261/article/details/106507150</a></li><li><a href="https://github.com/angenin/cloud2020">https://github.com/angenin/cloud2020</a></li><li><a href="https://www.bilibili.com/video/BV18E411x7eT">https://www.bilibili.com/video/BV18E411x7eT</a></li><li><a href="https://zhuanlan.zhihu.com/p/110249846">https://zhuanlan.zhihu.com/p/110249846</a></li></ul><p>引用</p><ul><li><a href="https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md">https://www.bookstack.cn/read/spring-cloud-docs/docs-index.md</a></li><li><a href="https://www.springcloud.cc/">https://www.springcloud.cc/</a></li><li><a href="https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/">https://cloud.spring.io/spring-cloud-static/Hoxton.SR5/reference/htmlsingle/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>springcloud</tag>
      
      <tag>spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Chapters1_极限与连续</title>
    <link href="/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/"/>
    <url>/2023/11/21/Chapters1_%E6%9E%81%E9%99%90%E4%B8%8E%E8%BF%9E%E7%BB%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、映射与函数"><a href="#1、映射与函数" class="headerlink" title="1、映射与函数"></a>1、映射与函数</h3><p>学习极限前，先了解一些基础概念，对于函数整个内容有一个认识。</p><h4 id="函数的概念"><a href="#函数的概念" class="headerlink" title="函数的概念"></a>函数的概念</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210437941.png" alt="image.png"></p><p>定义：定义域内<strong>任何</strong>元素，都在值域中有<strong>唯一</strong>的元素与之对应。</p><p>函数概念有两个基本要素：定义域、对应法则。</p><p>理解：函数是研究关系的，是在研究两个变量之间的关系。具体来说，函数是研究因变量是怎么随着自变量的变化而变化的。</p><blockquote><p>举例</p></blockquote><p>举个例子，在速度为40km&#x2F;h的匀速运动过程中，路程随时间的变化而变化：</p><ul><li>时间是1时，路程是40；</li><li>时间是2时，路程就是80。</li></ul><p>路程&#x3D;40 * 时间。路程就叫做时间的函数。</p><p>但不是有关系就是函数，不是因变量随自变量变化就是函数。还得满足一个重要的条件：对于自变量的每一个取值，因变量都有唯一的值与它对应！</p><p>例如，上述匀速运动过程中，时间每取一个值，对应计算出路程也是一个值。</p><p>反例：|y|&#x3D;x，在这个式子里，y也随x的变化而变化，但x&#x3D;1时，y&#x3D;1或—1，有两个值了。那y就不是x的函数了。</p><p>所以，函数是两个变量之间的特殊关系</p><h4 id="几个常见函数"><a href="#几个常见函数" class="headerlink" title="几个常见函数"></a>几个常见函数</h4><ul><li>绝对值函数</li><li>符号函数</li><li>取整函数</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210449362.png" alt="image.png"></p><h4 id="函数的特性"><a href="#函数的特性" class="headerlink" title="函数的特性"></a>函数的特性</h4><ul><li>有界性</li><li>单调性</li><li>奇偶性</li><li>周期性</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210452693.png" alt="image.png"></p><h4 id="反函数与复合函数"><a href="#反函数与复合函数" class="headerlink" title="反函数与复合函数"></a>反函数与复合函数</h4><blockquote><p>反函数</p></blockquote><p>定义：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210455686.png" alt="image.png"></p><blockquote><p>复合函数</p></blockquote><p>复合条件：内层函数值域与外层函数定义域的交集非空</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210456045.png" alt="image.png"></p><h4 id="函数的运算"><a href="#函数的运算" class="headerlink" title="函数的运算"></a>函数的运算</h4><p>函数的运算（加减乘除）</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210457870.png" alt="image.png"></p><p>其中函数相除的时候 g(x) 不等于 0 </p><p>相关定理：任何一个函数(定义域对称)都可以找到一个奇函数和一个偶函数，使得这个函数等于偶函数加奇函数</p><blockquote><p>例题（证明题）</p></blockquote><p>以函数的运算证明:任给f(x)的定义域为(-L,L),证明必存在(-L,L)上的偶函数g(x)以及奇函数h(x),使得f(x)&#x3D;g(x)+h(x)</p><p>解析：</p><p>根据前面函数特征中的奇偶性，可以得知 奇函数 h( -x ) &#x3D; -h(x) ; 偶函数 g(-x) &#x3D; g(x)</p><p>先假设存在这样的奇偶函数，</p><p>to be improve….</p><p>解答：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210502430.png" alt="image.png"></p><h4 id="初等函数"><a href="#初等函数" class="headerlink" title="初等函数"></a>初等函数</h4><p>定义：由常数和基本初等函数经过有限次的加、减、乘、 除和复合所得到且能用一个解析式表示的函数,称为初等函数</p><blockquote><p>基本初等函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210504661.png" alt="image.png"></p><blockquote><p>关于反三角函数</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210505070.png" alt="image.png"></p><blockquote><p>内容小结</p></blockquote><ul><li>函数的定义及函数的二要素<ul><li>定义域</li><li>对应法则</li></ul></li><li>函数的特性<ul><li>有界性，单调性，奇偶性，周期性</li></ul></li><li>复合函数与反函数</li><li>基本初等函数与初等函数</li></ul><h3 id="2、数列的极限"><a href="#2、数列的极限" class="headerlink" title="2、数列的极限"></a>2、数列的极限</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210548604.png" alt="image.png"></p><blockquote><p>例题</p></blockquote><p>用定义证明下列极限</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210550053.png" alt="image.png"></p><h4 id="收敛函数的性质"><a href="#收敛函数的性质" class="headerlink" title="收敛函数的性质"></a>收敛函数的性质</h4><p>收敛函数的性质</p><ul><li>唯一性<ul><li>收敛数列的极限唯一</li></ul></li><li>有界性<ul><li>收敛数列必有界</li></ul></li><li>保号性</li><li>任一子数列收敛于同一极限</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210553054.png" alt="image.png"></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311210554140.png" alt="image.png"></p><p>to be contined…</p><hr><p>参考</p><ul><li><a href="https://zhuanlan.zhihu.com/p/563178651">https://zhuanlan.zhihu.com/p/563178651</a></li><li><a href="https://www.zhihu.com/question/457091692/answer/2763695044">https://www.zhihu.com/question/457091692/answer/2763695044</a></li><li><a href="https://zhuanlan.zhihu.com/p/31206539">https://zhuanlan.zhihu.com/p/31206539</a></li><li>《武忠详高数零基础》</li></ul>]]></content>
    
    
    <categories>
      
      <category>exam</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx_基础概念</title>
    <link href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、启动Nginx"><a href="#1、启动Nginx" class="headerlink" title="1、启动Nginx"></a>1、启动Nginx</h3><blockquote><p>Windows 下启动 nginx</p></blockquote><p>在下载 nginx 后，在nginx安装目录的绝对路径的框框内输入 <code>cmd</code></p><p>直接输入 <code>nginx</code> 或者 <code>start nginx</code>，然后回车，就可以启动nginx</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">nginx<br><br><span class="hljs-literal">start</span> nginx<br></code></pre></td></tr></table></figure><p>在浏览器地址栏输入 <code>localhost:80</code>，然后再回车, 查看是否有 nginx 访问主页，如果有，则启动成功。</p><p>一般访问问题是端口占用，可以改一下 nginx 访问端口，或者杀掉对应进程。</p><p>关闭nginx的命令：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">nginx -s stop<br></code></pre></td></tr></table></figure><p>重新加载</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nginx -s reload</span><br></code></pre></td></tr></table></figure><p>to be contined….</p><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/weixin_44251179/article/details/129700793">https://blog.csdn.net/weixin_44251179/article/details/129700793</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docsify使用教程</title>
    <link href="/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    <url>/2023/11/19/Docsify%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1、快速开始"><a href="#1、快速开始" class="headerlink" title="1、快速开始"></a>1、快速开始</h3><p>全局安装 <code>docsify-cli</code> 工具，可以方便地创建及在本地预览生成的文档。</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">npm i docsify-<span class="hljs-keyword">cli</span> -g<br></code></pre></td></tr></table></figure><blockquote><p>初始化项目</p></blockquote><p>如果想在项目的 <code>./docs</code> 目录里写文档，直接通过 <code>init</code> 初始化项目。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">docsify init ./docs<br></code></pre></td></tr></table></figure><blockquote><p>开始写文档</p></blockquote><p>初始化成功后，可以看到 <code>./docs</code> 目录下创建的几个文件</p><ul><li><code>index.html</code> 入口文件</li><li><code>README.md</code> 会做为主页内容渲染</li><li><code>.nojekyll</code> 用于阻止 GitHub Pages 忽略掉下划线开头的文件</li></ul><p>直接编辑 <code>docs/README.md</code> 就能更新文档内容，当然也可以添加更多页面。</p><blockquote><p>本地预览</p></blockquote><p>通过运行 <code>docsify serve</code> 启动一个本地服务器，可以方便地实时预览效果。</p><p>默认访问地址 <a href="http://localhost:3000/">http://localhost:3000</a> 。</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">docsify serve docs</span><br></code></pre></td></tr></table></figure><h3 id="2、多页文档设置"><a href="#2、多页文档设置" class="headerlink" title="2、多页文档设置"></a>2、多页文档设置</h3><p>在 docsify 中，你访问的文档 URL 路径地址和你的文档文件夹结构是一个映射关系（实现多级路由）；</p><p>比如你在 doc 文件夹中创建<code>guide.md</code>、<code>zh-cn/READEME.md</code>、<code>zh-cn/guide.md</code>，结构如下所示：</p><figure class="highlight dos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs dos">.<br>├── README.<span class="hljs-built_in">md</span><br>├── guide.<span class="hljs-built_in">md</span><br>├── index.html<br>└── zh-cn<br>    ├── README.<span class="hljs-built_in">md</span><br>    └── guide.<span class="hljs-built_in">md</span><br></code></pre></td></tr></table></figure><p>此时我们访问如下url即可以访问到对应的页面：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">README.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span><br>guide.md=&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/gui</span>de<br><span class="hljs-regexp">/zh-cn/</span>README.md  =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/<br><span class="hljs-regexp">/zh-cn/gui</span>de.md   =&gt; http:<span class="hljs-regexp">//</span>localhost:<span class="hljs-number">3000</span><span class="hljs-regexp">/#/</span>zh-cn/guide<br><br></code></pre></td></tr></table></figure><h3 id="3、定制化配置"><a href="#3、定制化配置" class="headerlink" title="3、定制化配置"></a>3、定制化配置</h3><h4 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h4><p>需要先在 docs&#x2F;index.html 中修改一下配置，开启侧边栏的选项添加<code>loadSiderbar: true</code></p><p>这样设置后就会加载 Docsify 目录下的 _ sidebar.md 文件,  进行加载而渲染成我们定制的侧边栏</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span><br>loadSidebar: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311201949003.png" alt="image.png"></p><p>我们在 docs 目录下创建一个 <code>_sidebar.md</code> 文件，里面可以对侧边栏进行配置，比如这里配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>这里使用的是 MarkDown 中的超链接语法，后面的路径对应着上述多页文档的路由路径</p><p>我们还可以指定页面的标题，比如这里指定首页的标题为home 【后面添加双引号进行别名】</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/_sidebar.md --&gt;</span><br><br>* [首页](/ &quot;home&quot;) <br>* [guide](/guide)<br>* [zh-cn](zh-cn/)<br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><h4 id="侧边栏嵌套设置"><a href="#侧边栏嵌套设置" class="headerlink" title="侧边栏嵌套设置"></a>侧边栏嵌套设置</h4><p>在对应子目录 docs&#x2F;zh-cn 下创建一个 <code>_sidebar.md</code> 文件，配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- docs/zh-cn/_sidebar.md --&gt;</span><br><br>* [zh-ch首页](/zh-cn) <br>* [zh-cn guide](zh-cn/guide)<br></code></pre></td></tr></table></figure><p>_ sidebar.md 的加载逻辑是从每层目录下获取文件，如果当前目录不存在该文件则回退到上一级目录。<br>例如当前路径为 &#x2F;zh-cn 则从 &#x2F;zh-cn&#x2F;_ sidebar.md 获取文件，如果不存在则从 &#x2F;_ sidebar.md 获取，</p><p>我们也可以在 index.html 中如下配置表示默认都走根路径下的 <code>_sidebar.md</code> 文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">      <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="开启目录功能"><a href="#开启目录功能" class="headerlink" title="开启目录功能"></a>开启目录功能</h4><p>自定义侧边栏同时也可以开启目录功能。设置 <code>subMaxLevel</code> 配置项</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- index.html --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">    <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">    <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span></span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify/lib/docsify.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="目录折叠功能"><a href="#目录折叠功能" class="headerlink" title="目录折叠功能"></a>目录折叠功能</h4><p>需要引入一下 docsify-sidebar-collapse 样式 , 具体配置可以看一下下面。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;X-UA-Compatible&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;IE=edge,chrome=1&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;description&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;Description&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4/lib/themes/vue.css&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 文件夹样式 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar-folder.min.css&quot;</span> /&gt;</span><br>  <span class="hljs-comment">&lt;!-- 箭头样式 --&gt;</span><br>  <span class="hljs-comment">&lt;!-- &lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/sidebar.min.css&quot; /&gt; --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">$docsify</span> = &#123;</span><br><span class="language-javascript">      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">      <span class="hljs-attr">repo</span>: <span class="hljs-string">&#x27;&#x27;</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启侧边栏定制,加载_sidebar.md </span></span><br><span class="language-javascript">  <span class="hljs-attr">loadSidebar</span>: <span class="hljs-literal">true</span>,</span><br><span class="language-javascript">  <span class="hljs-comment">// 开启目录,最大层级为2</span></span><br><span class="language-javascript">  <span class="hljs-attr">subMaxLevel</span>: <span class="hljs-number">2</span>,</span><br><span class="language-javascript">  <span class="hljs-attr">alias</span>: &#123;</span><br><span class="language-javascript">    <span class="hljs-string">&#x27;/.*/_sidebar.md&#x27;</span>: <span class="hljs-string">&#x27;/_sidebar.md&#x27;</span></span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- Docsify v4 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;//cdn.jsdelivr.net/npm/docsify@4&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- 侧边栏目录折叠 --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.jsdelivr.net/npm/docsify-sidebar-collapse/dist/docsify-sidebar-collapse.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="导航栏"><a href="#导航栏" class="headerlink" title="导航栏"></a>导航栏</h4><p>添加导航栏有两种方式，一是直接到 index.html 中添加，二是和侧边栏类似，通过 md 文件的形式来添加。</p><blockquote><p><strong>通过md文件来添加</strong></p></blockquote><p>首先在 index.html 中配置 <code>loadNavbar</code>，默认加载的文件为 <code>_navbar.md</code> </p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启导航栏,加载_navbar.md </span><br>loadNavbar: <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><blockquote><p>嵌套列表</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs scss">&lt;!-- _navbar<span class="hljs-selector-class">.md</span> --&gt;<br><br>* 入门<br>  * <span class="hljs-selector-attr">[快速开始]</span>(zh-cn/quickstart.md)<br>  * <span class="hljs-selector-attr">[多页文档]</span>(zh-cn/more-pages.md)<br>  * <span class="hljs-selector-attr">[定制导航栏]</span>(zh-cn/custom-navbar.md)<br>  * <span class="hljs-selector-attr">[封面]</span>(zh-cn/cover.md)<br><br><br>* 配置<br>  * <span class="hljs-selector-attr">[配置项]</span>(zh-cn/configuration.md)<br>  * <span class="hljs-selector-attr">[主题]</span>(zh-cn/themes.md)<br>  * <span class="hljs-selector-attr">[使用插件]</span>(zh-cn/plugins.md)<br>  * <span class="hljs-selector-attr">[Markdown 配置]</span>(zh-cn/markdown.md)<br>  * <span class="hljs-selector-attr">[代码高亮]</span>(zh-cn/language-highlight.md)<br></code></pre></td></tr></table></figure><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311202158957.png" alt="image.png"></p><h4 id="封面"><a href="#封面" class="headerlink" title="封面"></a>封面</h4><p>在 index.html 中设置 <code>coverpage</code> 参数开启封面功能</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 开启封面,加载_coverpage.md</span><br>coverpage: <span class="hljs-literal">true</span>,<br></code></pre></td></tr></table></figure><p>在文档根目录创建 <code>_coverpage.md</code> 文件，用于配置封面内容</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># docsify <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span></span>3.5<span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span></span></span><br><br><span class="hljs-quote">&gt; 一个神奇的文档网站生成器。</span><br><br><span class="hljs-bullet">-</span> 简单、轻便 (压缩后 ~21kB)<br><span class="hljs-bullet">-</span> 无需生成 html 文件<br><span class="hljs-bullet">-</span> 众多主题<br><br>[<span class="hljs-string">GitHub</span>](<span class="hljs-link">https://github.com/docsifyjs/docsify/</span>)<br></code></pre></td></tr></table></figure><p>目前的背景是随机生成的渐变色，可以自定义背景色或者背景图。在文档末尾用添加图片的 Markdown 语法设置背景。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 网站图标 --&gt;</span><br>![logo](_media/icon.jpg)<br><br># docsify <span class="hljs-tag">&lt;<span class="hljs-name">small</span>&gt;</span>3.5<span class="hljs-tag">&lt;/<span class="hljs-name">small</span>&gt;</span><br><br>&gt; 一个神奇的文档网站生成器。<br><br>- 简单、轻便 (压缩后 ~21kB)<br>- 无需生成 html 文件<br>- 众多主题<br><br>[GitHub](https://github.com/docsifyjs/docsify/)<br><br><span class="hljs-comment">&lt;!-- 背景图片 --&gt;</span><br>![](_media/玩家.png)<br><br><span class="hljs-comment">&lt;!-- 背景色 --&gt;</span><br>![color](#f0f0f0)<br></code></pre></td></tr></table></figure><p>通常封面和首页是同时出现的，你可以将封面独立出来</p><p>配置（只在访问主页时加载封面）：</p><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">window</span>.<span class="hljs-variable">$docsify</span> = &#123;<br>  onlyCover:<span class="hljs-built_in"> false</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><h4 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h4><p>见： <a href="https://docsify.js.org/#/zh-cn/themes">https://docsify.js.org/#/zh-cn/themes</a></p><h3 id="4、基于nginx-docsify搭建"><a href="#4、基于nginx-docsify搭建" class="headerlink" title="4、基于nginx + docsify搭建"></a>4、基于nginx + docsify搭建</h3><p>nginx 配置文件中，在 <code>http</code> 块内添加一个新的 <code>server</code> 配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">location /docs &#123;<br><span class="hljs-built_in">alias</span> D:/shareDocs/docs; <span class="hljs-comment"># 修改为你的 Docsify 项目绝对路径</span><br>index index.html;<br>try_files <span class="hljs-variable">$uri</span> <span class="hljs-variable">$uri</span>/ /index.html;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://docsify.js.org/#/zh-cn/quickstart">https://docsify.js.org/#/zh-cn/quickstart</a></li><li><a href="https://www.cnblogs.com/Can-daydayup/p/15413267.html">https://www.cnblogs.com/Can-daydayup/p/15413267.html</a></li><li><a href="https://ysgstudyhards.github.io/Docsify-Guide/#/README">https://ysgstudyhards.github.io/Docsify-Guide/#/README</a></li><li><a href="https://blog.csdn.net/qq_45173404/article/details/122683872">https://blog.csdn.net/qq_45173404/article/details/122683872</a></li><li><a href="https://developer.aliyun.com/article/1266542">https://developer.aliyun.com/article/1266542</a></li><li><a href="https://clotliu.com/archives/docsify-advanced">https://clotliu.com/archives/docsify-advanced</a></li><li><a href="https://www.cnblogs.com/yangstar/articles/16690435.html">https://www.cnblogs.com/yangstar/articles/16690435.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>status pages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>消息队列_基础概念</title>
    <link href="/2023/11/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、消息队列是什么"><a href="#1、消息队列是什么" class="headerlink" title="1、消息队列是什么"></a>1、消息队列是什么</h3><p>消息队列，一般我们会简称它为MQ(Message Queue)</p><p>消息队列是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用。</p><p>参与消息传递的双方称为 <strong>生产者</strong> 和 <strong>消费者</strong> ，生产者负责发送消息，消费者负责处理消息。</p><h3 id="2、为什么要使用消息队列"><a href="#2、为什么要使用消息队列" class="headerlink" title="2、为什么要使用消息队列"></a>2、为什么要使用消息队列</h3><p>一般会考虑消息队列的使用场景，比较核心的有 3 个：<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><h4 id="解耦"><a href="#解耦" class="headerlink" title="解耦"></a>解耦</h4><h4 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h4><h4 id="削峰"><a href="#削峰" class="headerlink" title="削峰"></a>削峰</h4><h4 id="使用消息队列会带来哪些问题"><a href="#使用消息队列会带来哪些问题" class="headerlink" title="使用消息队列会带来哪些问题"></a>使用消息队列会带来哪些问题</h4><p>这个主要是问消息队列的优缺点</p><p>优点就是<strong>在特殊场景下有其对应的好处</strong>，<strong>解耦</strong>、<strong>异步</strong>、<strong>削峰</strong>。</p><p>缺点有以下几个：</p><ul><li><strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li><strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li><strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了!</li></ul><h3 id="3、技术选型"><a href="#3、技术选型" class="headerlink" title="3、技术选型"></a>3、技术选型</h3><p>Kafka、ActiveMQ、RabbitMQ、RocketMQ 有什么优缺点？</p><table><thead><tr><th>特性</th><th>ActiveMQ</th><th>RabbitMQ</th><th>RocketMQ</th><th>Kafka</th></tr></thead><tbody><tr><td>单机吞吐量</td><td>万级，比 RocketMQ、Kafka 低一个数量级</td><td>同 ActiveMQ</td><td>10 万级，支撑高吞吐</td><td>10 万级，高吞吐，一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td>topic 数量对吞吐量的影响</td><td></td><td></td><td>topic 可以达到几百&#x2F;几千的级别，吞吐量会有较小幅度的下降，这是 RocketMQ 的一大优势，在同等机器下，可以支撑大量的 topic</td><td>topic 从几十到几百个时候，吞吐量会大幅度下降，在同等机器下，Kafka 尽量保证 topic 数量不要过多，如果要支撑大规模的 topic，需要增加更多的机器资源</td></tr><tr><td>时效性</td><td>ms 级</td><td>微秒级，这是 RabbitMQ 的一大特点，延迟最低</td><td>ms 级</td><td>延迟在 ms 级以内</td></tr><tr><td>可用性</td><td>高，基于主从架构实现高可用</td><td>同 ActiveMQ</td><td>非常高，分布式架构</td><td>非常高，分布式，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td>消息可靠性</td><td>有较低的概率丢失数据</td><td>基本不丢</td><td>经过参数优化配置，可以做到 0 丢失</td><td>同 RocketMQ</td></tr><tr><td>功能支持</td><td>MQ 领域的功能极其完备</td><td>基于 erlang 开发，并发能力很强，性能极好，延时很低</td><td>MQ 功能较为完善，还是分布式的，扩展性好</td><td>功能较为简单，主要支持简单的 MQ 功能，在大数据领域的实时计算以及日志采集被大规模使用</td></tr></tbody></table><p>使用建议：</p><p>一般的业务系统要引入 MQ，最早大家都用 ActiveMQ，但是现在确实大家用的不多了，没经过大规模吞吐量场景的验证，社区也不是很活跃，所以大家还是算了，不推荐用这个。</p><p>后来大家开始用 RabbitMQ，但是确实 erlang 语言阻止了大量的 Java 工程师去深入研究和掌控它，对公司而言，几乎处于不可控的状态，但是确实人家是开源的，比较稳定的支持，活跃度也高。</p><p>不过现在确实越来越多的公司会去用 RocketMQ，确实很不错，毕竟是阿里出品，但社区可能有突然黄掉的风险（目前 RocketMQ 已捐给 <a href="https://github.com/apache/rocketmq">Apache</a>，但 GitHub 上的活跃度其实不算高）对自己公司技术实力有绝对自信的，推荐用 RocketMQ，否则回去老老实实用 RabbitMQ 吧，人家有活跃的开源社区，绝对不会黄。</p><p>所以<strong>中小型公司</strong>，技术实力较为一般，技术挑战不是特别高，用 RabbitMQ 是不错的选择；<strong>大型公司</strong>，基础架构研发实力较强，用 RocketMQ 是很好的选择。</p><p>如果是<strong>大数据领域</strong>的实时计算、日志采集等场景，用 Kafka 是业内标准的，绝对没问题，社区活跃度很高，绝对不会黄，何况几乎是全世界这个领域的事实性规范。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/high-performance/message-queue/message-queue.html">https://javaguide.cn/high-performance/message-queue/message-queue.html</a></li><li><a href="https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview">https://doocs.github.io/advanced-java/#/docs/high-concurrency/mq-interview</a></li><li><a href="https://www.zhihu.com/question/628465730">https://www.zhihu.com/question/628465730</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NoSQL_基础概念</title>
    <link href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、NoSQL-是什么"><a href="#1、NoSQL-是什么" class="headerlink" title="1、NoSQL 是什么"></a>1、NoSQL 是什么</h3><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>NoSQL 数据库代表：HBase、Cassandra、MongoDB、Redis。</p><h4 id="SQL-和-NoSQL-有什么区别？"><a href="#SQL-和-NoSQL-有什么区别？" class="headerlink" title="SQL 和 NoSQL 有什么区别？"></a>SQL 和 NoSQL 有什么区别？</h4><table><thead><tr><th></th><th>SQL 数据库</th><th>NoSQL 数据库</th></tr></thead><tbody><tr><td>数据存储模型</td><td>结构化存储，具有固定行和列的表格</td><td>非结构化存储。文档：JSON 文档，键值：键值对，宽列：包含行和动态列的表，图：节点和边</td></tr><tr><td>发展历程</td><td>开发于 1970 年代，重点是减少数据重复</td><td>开发于 2000 年代后期，重点是提升可扩展性，减少大规模数据的存储成本</td></tr><tr><td>例子</td><td>Oracle、MySQL、Microsoft SQL Server、PostgreSQL</td><td>文档：MongoDB、CouchDB，键值：Redis、DynamoDB，宽列：Cassandra、 HBase，图表：Neo4j、 Amazon Neptune、Giraph</td></tr><tr><td>ACID 属性</td><td>提供原子性、一致性、隔离性和持久性 (ACID) 属性</td><td>通常不支持 ACID 事务，为了可扩展、高性能进行了权衡，少部分支持比如 MongoDB 。不过，MongoDB 对 ACID 事务 的支持和 MySQL 还是有所区别的。</td></tr><tr><td>性能</td><td>性能通常取决于磁盘子系统。要获得最佳性能，通常需要优化查询、索引和表结构。</td><td>性能通常由底层硬件集群大小、网络延迟以及调用应用程序来决定。</td></tr><tr><td>扩展</td><td>垂直（使用性能更强大的服务器进行扩展）、读写分离、分库分表</td><td>横向（增加服务器的方式横向扩展，通常是基于分片机制）</td></tr><tr><td>用途</td><td>普通企业级的项目的数据存储</td><td>用途广泛比如图数据库支持分析和遍历连接数据之间的关系、键值数据库可以处理大量数据扩展和极高的状态变化</td></tr><tr><td>查询语法</td><td>结构化查询语言 (SQL)</td><td>数据访问语法可能因数据库而异</td></tr></tbody></table><h4 id="NoSQL-数据库有哪些类型？"><a href="#NoSQL-数据库有哪些类型？" class="headerlink" title="NoSQL 数据库有哪些类型？"></a>NoSQL 数据库有哪些类型？</h4><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li><strong>键值</strong>：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li><strong>文档</strong>：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li><strong>图形</strong>：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li><strong>宽列</strong>：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231119123254.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/nosql.html">https://javaguide.cn/database/nosql.html</a></li><li><a href="https://www.ibm.com/cn-zh/topics/nosql-databases">https://www.ibm.com/cn-zh/topics/nosql-databases</a></li><li><a href="https://zhuanlan.zhihu.com/p/345342966">https://zhuanlan.zhihu.com/p/345342966</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis入门_基础概念</title>
    <link href="/2023/11/19/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/19/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Redis-是什么"><a href="#1、Redis-是什么" class="headerlink" title="1、Redis 是什么"></a>1、Redis 是什么</h3><p>Redis是一种支持key-value等多种数据结构的存储系统。可用于缓存，事件发布或订阅，高速队列等场景。支持网络，提供字符串，哈希，列表，队列，集合结构直接存取，基于内存，可持久化。</p><ul><li><strong>读写性能优异</strong><ul><li>Redis能读的速度是110000次&#x2F;s,写的速度是81000次&#x2F;s （测试条件见下一节）。</li></ul></li><li><strong>数据类型丰富</strong><ul><li>Redis支持二进制案例的 Strings, Lists, Hashes, Sets 及 Ordered Sets 数据类型操作。</li></ul></li><li><strong>原子性</strong><ul><li>Redis的所有操作都是原子性的，同时Redis还支持对几个操作全并后的原子性执行。</li></ul></li><li><strong>丰富的特性</strong><ul><li>Redis支持 publish&#x2F;subscribe, 通知, key 过期等特性。</li></ul></li><li><strong>持久化</strong><ul><li>Redis支持RDB, AOF等持久化方式</li></ul></li><li><strong>发布订阅</strong><ul><li>Redis支持发布&#x2F;订阅模式</li></ul></li><li><strong>分布式</strong><ul><li>Redis Cluster</li></ul></li></ul><h3 id="2、Redis-的常用数据类型"><a href="#2、Redis-的常用数据类型" class="headerlink" title="2、Redis 的常用数据类型"></a>2、Redis 的常用数据类型</h3><ul><li><strong>5种基础数据类型</strong>，分别是：String、List、Set、Zset、Hash。</li></ul><table><thead><tr><th>结构类型</th><th>结构存储的值</th><th>结构的读写能力</th></tr></thead><tbody><tr><td><strong>String字符串</strong></td><td>可以是字符串、整数或浮点数</td><td>对整个字符串或字符串的一部分进行操作；对整数或浮点数进行自增或自减操作；</td></tr><tr><td><strong>List列表</strong></td><td>一个链表，链表上的每个节点都包含一个字符串</td><td>对链表的两端进行push和pop操作，读取单个或多个元素；根据值查找或删除元素；</td></tr><tr><td><strong>Set集合</strong></td><td>包含字符串的无序集合</td><td>字符串的集合，包含基础的方法有看是否存在添加、获取、删除；还包含计算交集、并集、差集等</td></tr><tr><td><strong>Hash散列</strong></td><td>包含键值对的无序散列表</td><td>包含方法有添加、获取、删除单个元素</td></tr><tr><td><strong>Zset有序集合</strong></td><td>和散列一样，用于存储键值对</td><td>字符串成员与浮点数分数之间的有序映射；元素的排列顺序由分数的大小决定；包含方法有添加、获取、删除单个元素以及根据分值范围或成员来获取元素</td></tr></tbody></table><ul><li><strong>三种特殊的数据类型</strong> 分别是 HyperLogLogs（基数统计）， Bitmaps (位图) 和 geospatial （地理位置)</li></ul><h3 id="3、Redis-一般有哪些使用场景？"><a href="#3、Redis-一般有哪些使用场景？" class="headerlink" title="3、Redis 一般有哪些使用场景？"></a>3、Redis 一般有哪些使用场景？</h3><p>可以结合自己的项目讲讲，比如</p><ul><li><strong>热点数据的缓存</strong></li></ul><p>缓存是Redis最常见的应用场景，之所有这么使用，主要是因为Redis读写性能优异。而且逐渐有取代memcached，成为首选服务端缓存的组件。而且，Redis内部是支持事务的，在使用时候能有效保证数据的一致性。</p><ul><li><strong>限时业务的运用</strong></li></ul><p>redis中可以使用expire命令设置一个键的生存时间，到时间后redis会删除它。利用这一特性可以运用在限时的优惠活动信息、手机验证码等业务场景。</p><ul><li><strong>计数器相关问题</strong></li></ul><p>redis由于incrby命令可以实现原子性的递增，所以可以运用于高并发的秒杀活动、分布式序列号的生成、具体业务还体现在比如限制一个手机号发多少条短信、一个接口一分钟限制多少请求、一个接口一天限制调用多少次等等。</p><ul><li><strong>分布式锁</strong></li></ul><p>这个主要利用redis的setnx命令进行，setnx：”set if not exists”就是如果不存在则成功设置缓存同时返回1，否则返回0 ，这个特性在俞你奔远方的后台中有所运用，因为我们服务器是集群的，定时任务可能在两台机器上都会运行，所以在定时任务中首先 通过setnx设置一个lock，如果成功设置则执行，如果没有成功设置，则表明该定时任务已执行。 当然结合具体业务，我们可以给这个lock加一个过期时间，比如说30分钟执行一次的定时任务，那么这个过期时间设置为小于30分钟的一个时间就可以，这个与定时任务的周期以及定时任务执行消耗时间相关。</p><p>在分布式锁的场景中，主要用在比如秒杀系统等。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/database/redis/cache-basics.html">https://javaguide.cn/database/redis/cache-basics.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis">https://www.pdai.tech/md/interview/x-interview.html#_8-3-redis</a></li><li><a href="https://www.cnblogs.com/powertoolsteam/p/redis.html">https://www.cnblogs.com/powertoolsteam/p/redis.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>DataBase</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NoSQL</tag>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>插件实现Obsidian实时同步</title>
    <link href="/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/"/>
    <url>/2023/11/17/%E6%8F%92%E4%BB%B6%E5%AE%9E%E7%8E%B0Obsidian%E5%AE%9E%E6%97%B6%E5%90%8C%E6%AD%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、插件下载和服务安装"><a href="#1、插件下载和服务安装" class="headerlink" title="1、插件下载和服务安装"></a>1、插件下载和服务安装</h3><p>使用插件： Self-hosted LiveSync</p><p>在服务器上面安装 docker 后，</p><p>创建一个文件 <code>local.ini</code></p><p>复制以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[couchdb]</span><br><span class="hljs-attr">single_node</span>=<span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[chttpd_auth]</span><br><span class="hljs-attr">require_valid_user</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">authentication_redirect</span> = /_utils/session.html<br><br><span class="hljs-section">[httpd]</span><br><span class="hljs-attr">WWW-Authenticate</span> = Basic realm=<span class="hljs-string">&quot;couchdb&quot;</span><br><span class="hljs-attr">enable_cors</span> = <span class="hljs-literal">true</span><br><br><span class="hljs-section">[cors]</span><br><span class="hljs-attr">origins</span> = app://obsidian.md,capacitor://localhost,http://localhost<br><span class="hljs-attr">credentials</span> = <span class="hljs-literal">true</span><br><span class="hljs-attr">headers</span> = accept, authorization, content-type, origin, referer<br><span class="hljs-attr">methods</span> = GET, PUT, POST, HEAD, DELETE<br><span class="hljs-attr">max_age</span> = <span class="hljs-number">3600</span><br></code></pre></td></tr></table></figure><p>将该文件移动到 <code>/opt/couchdb</code>目录下</p><p>运行下面命令：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">docker <span class="hljs-built_in">run</span> -d --restart always -e <span class="hljs-attribute">COUCHDB_USER</span>=luo -e <span class="hljs-attribute">COUCHDB_PASSWORD</span>=luo123 -v /opt/couchdb/local.ini:/opt/couchdb/etc/local.ini -p 6900:5984 couchdb<br></code></pre></td></tr></table></figure><p>其中:</p><ul><li><code>COUCHDB_USER</code> 后面的是你的用户名</li><li><code>COUCHDB_PASSWORD</code> 后面的是你的密码</li><li><code>/opt/couchdb/local.ini</code> 是配置文件的路径</li><li><code>/opt/couchdb/db</code> 是数据库的路径</li><li><code>-p 6900:5984</code> 前面的 6900 是暴露在外的端口。</li></ul><p>检查是否运行成功</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">sudo docker <span class="hljs-keyword">ps</span> |<span class="hljs-keyword">grep</span> couchdb<br></code></pre></td></tr></table></figure><h3 id="2、插件配置"><a href="#2、插件配置" class="headerlink" title="2、插件配置"></a>2、插件配置</h3><p>打开Obsidian的设置-第三方插件，在插件市场安装<code>Self-hosted LiveSync</code></p><blockquote><p>客户端配置</p></blockquote><p>安装并启用后打开插件的设置界面，填写箭头内容，URI 为刚刚的<code>http://IP+端口（6900）</code>，例如：<code>http://127.0.0.1:6900</code>，</p><p>Username 和 Password 为前面的参数设置的内容，</p><p>Database name 可以自己取，注意不要填大写字母，完成后点击test 按钮</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230051.png" alt="image.png"></p><p>右上角出现 <code>Connect to 数据库名</code>，则为连接成功</p><p>如果你之前配置连接过，并存放过数据，你连接后会将对应的数据库中的文件同步到你目前的工作空间中；也可以理解他的数据是存放在了服务器中的数据库，设备连接该服务后的同步操作，本质上都是在操作更新服务器上面的数据库文件内容，然后更新对应映射内容到设备的Obsidian文件中。</p><p>完成后点击下面的check ，将所有提示错误的选择fix，然后再次点击check ，直到没有错误</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231118230528.png" alt="image.png"></p><p>划到最下方，选择端对端加密（End to End Encryption），在输入框中设置密码，点击启用</p><p><strong>如果仅想要同步文章无需开启端对端加密</strong></p><p>在Sync Setting 选项卡中，选择LiveSync（实时同步），点击Apply启用</p><p>建议启用 <code>Use Trash for deleted files</code>（删除文件到回收站）</p><p>建议启用 <code>Miscellaneous</code> 选项卡中的 <code>Show staus inside editor</code> （会在编辑器右上角显示状态）</p><blockquote><p>复制配置到其他设备</p></blockquote><p>在插件Setup wizard 选项卡中，点击 <code>Copy Setup URI</code>，弹出的对话框设置密码，即可复制当前的配置信息</p><p>复制后打开自己需要同步的设备点击Open setup URI 粘贴复制的内容，输入设置的密码，点击第一个</p><hr><p>参考</p><ul><li><a href="https://sspai.com/post/82161#">https://sspai.com/post/82161#</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>obsidian</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>node安装和下载</title>
    <link href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/"/>
    <url>/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1、Node-js-下载安装"><a href="#1、Node-js-下载安装" class="headerlink" title="1、Node.js 下载安装"></a>1、Node.js 下载安装</h3><p>官网下载： <a href="https://nodejs.org/en">https://nodejs.org/en</a></p><p>安装后，验证一下是否安装成功</p><p>打开 cmd, 输入node -v，npm -v，出现如下界面安装成功</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117221300.png" alt="image.png"></p><h3 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h3><blockquote><p>环境变量配置</p></blockquote><p>新增<strong>用户变量</strong>  <code>NODE_PATH</code>，变量值设置为 <code>xxx\nodejs</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224932.png" alt="image.png"></p><p>编辑<strong>用户变量</strong>中的【Path】</p><p>修改 变量名 <code>Path</code></p><p>将默认的 C 盘下【 <code>AppData\Roaming\npm</code> 】修改成 <code>%NODE_PATH%</code></p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117224741.png" alt="image.png"></p><p>设置完后也打开 cmd, 输入一下  node -v，npm -v  看是否OK。</p><blockquote><p>配置npm的全局模块的存放路径以及cache的路径</p></blockquote><p>找到安装的目录，在安装目录下新建两个文件夹【node_global】和【node_cache】</p><p>使用管理员身份打开cmd窗口，执行</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span><span class="hljs-built_in"> prefix </span><span class="hljs-string">&quot;xxx\Node.js\node_global&quot;</span><br><br>npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> cache <span class="hljs-string">&quot;xxx\Node.js\node_cache&quot;</span><br></code></pre></td></tr></table></figure><blockquote><p>新增系统Path变量</p></blockquote><p>在【系统变量】中选择【Path】点击【编辑】添加你刚才配置的两个路径。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117225456.png" alt="image.png"></p><h3 id="3、安装淘宝镜像"><a href="#3、安装淘宝镜像" class="headerlink" title="3、安装淘宝镜像"></a>3、安装淘宝镜像</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">npm config set registry https:<span class="hljs-comment">//registry.npm.taobao.org</span><br></code></pre></td></tr></table></figure><p>查看是否成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm config get registry<br></code></pre></td></tr></table></figure><hr><p>参考</p><ul><li><a href="https://blog.csdn.net/m0_62617719/article/details/130423504">https://blog.csdn.net/m0_62617719/article/details/130423504</a></li><li><a href="https://blog.csdn.net/JingYan_Chan/article/details/125405423">https://blog.csdn.net/JingYan_Chan/article/details/125405423</a></li><li><a href="https://blog.csdn.net/MyronCham/article/details/119561972">https://blog.csdn.net/MyronCham/article/details/119561972</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>web</tag>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dokcer入门_基础概念</title>
    <link href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-Docker"><a href="#1、什么是-Docker" class="headerlink" title="1、什么是 Docker"></a>1、什么是 Docker</h3><blockquote><p>理解虚拟化技术</p></blockquote><p>人们为了提高系统及硬件资源的利用率而引入了<strong>虚拟化技术</strong>。虚拟化是一种<strong>资源管理技术</strong>，它可以各种实体资源抽像后再分隔，从而打破实体结构的限制，最大程度的提高资源的利用率。</p><p>虚拟化的目的是为了在同一个主机上运行多个系统或应用，从而提高系统资源的利用率，并带来降低成本、方便管理和容错容灾等好处。</p><p>从实现形式来分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。</p><blockquote><p>基于软件的虚拟化</p></blockquote><p>软件虚拟化是利用软件技术，在现有的物理平台上实现对物理平台访问的截获和模拟。</p><p>对软件虚拟化进行细分，又可以分为以下几类：</p><ul><li>完全虚拟化</li><li>硬件辅助虚拟化</li><li>部分虚拟化</li><li>平行虚拟化</li><li>操作系统层虚拟化</li></ul><p>Docker容器技术就是属于操作系统层虚拟化的范畴。</p><p>虚拟化是通过软件的方式模拟实体服务器，其初衷是为了解决“一种应用占用一台服务器”模式所带来的服务器数量剧增的问题，从而降低数据中心复杂度，简化管理难度。</p><blockquote><p>虚拟机和Docker</p></blockquote><p>容器虚拟化的是操作系统而不是硬件，容器之间是共享同一套操作系统资源。</p><p>虚拟机技术是虚拟出一套硬件后，在其上运行一个完整操作系统。因此容器的隔离级别会稍低一些。</p><blockquote><p>虚拟机和 Docker 的对比<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171252304.png" alt="image.png"></p></blockquote><blockquote><p>图解物理机,虚拟机与容器</p></blockquote><p>物理机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456074.png" alt="image.png"></p><p>虚拟机</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171456887.png" alt="image.png"><br>容器</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171457700.png" alt="image.png"></p><p>虚拟机和Docker容器各自有自己的应用场景，<strong>虚拟机更擅长于彻底隔离整个运行环境</strong>。例如，云服务提供商通常采用虚拟机技术隔离不同的用户。</p><p>而 <strong>Docker 通常用于隔离不同的应用</strong> ，例如前端，后端以及数据库。</p><h3 id="2、Docker-基本概念"><a href="#2、Docker-基本概念" class="headerlink" title="2、Docker 基本概念"></a>2、Docker 基本概念</h3><p>Docker 包括三个基本概念:</p><ul><li><strong>镜像（Image）</strong>：Docker 镜像（Image），就相当于是一个 root 文件系统。比如官方镜像 ubuntu:16.04 就包含了完整的一套 Ubuntu16.04 最小系统的 root 文件系统。</li><li><strong>容器（Container）</strong>：镜像（Image）和容器（Container）的关系，就像是面向对象程序设计中的类和实例一样，<strong>镜像是静态的定义，容器是镜像运行时的实体</strong>。容器可以被创建、启动、停止、删除、暂停等。</li><li><strong>仓库（Repository）</strong>：仓库可看成一个代码控制中心，用来保存镜像。</li></ul><blockquote><p><strong>Docker Registry 公开服务和私有 Docker Registry</strong></p></blockquote><p><strong>Docker Registry 公开服务</strong> 是开放给用户使用、允许用户管理镜像的 Registry 服务。一般这类公开服务允许用户免费上传、下载公开的镜像，并可能提供收费服务供用户管理私有镜像。</p><p>最常使用的 Registry 公开服务是官方的 <strong>Docker Hub</strong> ，这也是默认的 Registry，并拥有大量的高质量的官方镜像，网址为：<a href="https://hub.docker.com/" title="https://hub.docker.com/">https://hub.docker.com/open in new window</a> 。官方是这样介绍 Docker Hub 的：</p><blockquote><p>Docker Hub 是 Docker 官方提供的一项服务，用于与您的团队查找和共享容器镜像。</p></blockquote><p>比如我们想要搜索自己想要的镜像：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171534204.png" alt="image.png"></p><p>在 Docker Hub 的搜索结果中，有几项关键的信息有助于我们选择合适的镜像：</p><ul><li><strong>OFFICIAL Image</strong>：代表镜像为 Docker 官方提供和维护，相对来说稳定性和安全性较高。</li><li><strong>Stars</strong>：和点赞差不多的意思，类似 GitHub 的 Star。</li><li><strong>Downloads</strong>：代表镜像被拉取的次数，基本上能够表示镜像被使用的频度。</li></ul><p>除了直接通过 Docker Hub 网站搜索镜像这种方式外，我们还可以通过 <code>docker search</code> 这个命令搜索 Docker Hub 中的镜像，搜索的结果是一致的。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">➜  ~ docker <span class="hljs-keyword">search</span> mysql<br><span class="hljs-type">NAME</span>                              DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED<br>mysql                             MySQL <span class="hljs-keyword">is</span> a widely used, <span class="hljs-keyword">open</span>-source relation…   <span class="hljs-number">8763</span>                [OK]<br>mariadb                           MariaDB <span class="hljs-keyword">is</span> a community-developed fork <span class="hljs-keyword">of</span> MyS…   <span class="hljs-number">3073</span>                [OK]<br>mysql/mysql-<span class="hljs-keyword">server</span>                Optimized MySQL <span class="hljs-keyword">Server</span> Docker images. <span class="hljs-keyword">Create</span>…   <span class="hljs-number">650</span>                                     [OK]<br></code></pre></td></tr></table></figure><p>在国内访问<strong>Docker Hub</strong> 可能会比较慢国内也有一些云服务商提供类似于 Docker Hub 的公开服务。比如 <a href="https://www.aliyun.com/product/containerservice?utm_content=se_1292836" title="阿里云镜像库">阿里云镜像库</a>。</p><p>除了使用公开服务外，用户还可以在 <strong>本地搭建私有 Docker Registry</strong> 。</p><p>Docker 官方提供了 Docker Registry 镜像，可以直接使用做为私有 Registry 服务。开源的 Docker Registry 镜像只提供了 Docker Registry API 的服务端实现，足以支持 docker 命令，不影响使用。但不包含图形界面，以及镜像维护、用户管理、访问控制等高级功能。</p><h3 id="3、基本命令"><a href="#3、基本命令" class="headerlink" title="3、基本命令"></a>3、基本命令</h3><h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">docker <span class="hljs-keyword">version</span> <span class="hljs-comment"># 查看docker版本</span><br>docker images <span class="hljs-comment"># 查看所有已下载镜像，等价于：docker image ls 命令</span><br>docker container <span class="hljs-keyword">ls</span> <span class="hljs-comment"># 查看所有容器</span><br>docker ps <span class="hljs-comment">#查看正在运行的容器</span><br>docker image prune <span class="hljs-comment"># 清理临时的、没有被使用的镜像文件。-a, --all: 删除所有没有用的镜像，而不仅仅是临时文件；</span><br></code></pre></td></tr></table></figure><h4 id="拉取镜像"><a href="#拉取镜像" class="headerlink" title="拉取镜像"></a>拉取镜像</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">docker search mysql <span class="hljs-comment"># 查看mysql相关镜像</span><br>docker pull mysql:5.7 <span class="hljs-comment"># 拉取mysql镜像</span><br>docker image <span class="hljs-built_in">ls</span> <span class="hljs-comment"># 查看所有已下载镜像</span><br></code></pre></td></tr></table></figure><h4 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h4><p>比如我们要删除我们下载的 mysql 镜像。</p><p>通过 <code>docker rmi [image]</code> （等价于<code>docker image rm [image]</code>）删除镜像之前首先要确保这个镜像没有被容器引用（可以通过标签名称或者镜像 ID 删除）。</p><p>通过我们前面讲的<code>docker ps</code>命令即可查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">➜  ~ docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                               NAMES<br>c4cd691d9f80        mysql:5.7           <span class="hljs-string">&quot;docker-entrypoint.s…&quot;</span>   7 weeks ago         Up 12 days          0.0.0.0:3306-&gt;3306/tcp, 33060/tcp   mysql<br></code></pre></td></tr></table></figure><p>可以看到 mysql 正在被 id 为 c4cd691d9f80 的容器引用，我们需要首先通过 <code>docker stop c4cd691d9f80</code> 或者 <code>docker stop mysql</code>暂停这个容器。</p><p>然后查看 mysql 镜像的 id</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs crmsh">➜  ~ docker images<br>REPOSITORY              <span class="hljs-keyword">TAG</span>                 <span class="hljs-title">IMAGE</span> ID            CREATED             SIZE<br>mysql                   <span class="hljs-number">5.7</span>                 f6509bac4980        <span class="hljs-number">3</span> months ago        <span class="hljs-number">373M</span>B<br></code></pre></td></tr></table></figure><p>通过 IMAGE ID 或者 REPOSITORY 名字即可删除</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">docker</span> rmi f6509bac4980 <span class="hljs-comment">#  或者 docker rmi mysql</span><br></code></pre></td></tr></table></figure><h3 id="4、Build-Ship-and-Run"><a href="#4、Build-Ship-and-Run" class="headerlink" title="4、Build Ship and Run"></a>4、Build Ship and Run</h3><p>搜索 Docker 官网，会发现如下的字样：<strong>“Docker - Build, Ship, and Run Any App, Anywhere”</strong>。</p><ul><li><strong>Build（构建镜像）</strong>：镜像就像是集装箱包括文件以及运行环境等等资源。</li><li><strong>Ship（运输镜像）</strong>：主机和仓库间运输，这里的仓库就像是超级码头一样。</li><li><strong>Run （运行镜像）</strong>：运行的镜像就是一个容器，容器就是运行程序的地方。</li></ul><p>Docker 运行过程是会去仓库把镜像拉到本地，然后用一条命令把镜像运行起来变成容器。</p><p>Docker 也被称为码头工人或码头装卸工，这和 Docker 的中文翻译<strong>搬运工人</strong>如出一辙。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311171603190.png" alt="image.png"></p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/tools/docker/docker-intro.html">https://javaguide.cn/tools/docker/docker-intro.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html">https://www.pdai.tech/md/devops/docker/docker-01-docker-vm.html</a></li><li><a href="https://www.pdai.tech/md/devops/docker/docker-03-basic2.html">https://www.pdai.tech/md/devops/docker/docker-03-basic2.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java8新特性</title>
    <link href="/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p>Java8</p><hr><p>参考</p><ul><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7">https://www.pdai.tech/md/interview/x-interview.html#_6-1-java-8-%E7%89%B9%E6%80%A7</a></li><li><a href="https://javaguide.cn/java/new-features/java8-common-new-features.html">https://javaguide.cn/java/new-features/java8-common-new-features.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM入门_基础概念</title>
    <link href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是-JVM"><a href="#1、什么是-JVM" class="headerlink" title="1、什么是 JVM"></a>1、什么是 JVM</h3><p>JVM 全称是 Java Virtual Machine，中文名称叫Java虚拟机，它是由软件技术模拟出计算机运行的一个虚拟的计算机。</p><p>JVM 充当着一个翻译官的角色，能够将我们编写出的Java程序，翻译给系统“听”，告诉它我们的程序需要做什么操作。</p><p>Java的代码需要经过编译器，生成.Class文件后，JVM才能识别并运行它，JVM针对每个操作系统开发其对应的解释器，所以只要其操作系统有对应版本的JVM，那么这份Java编译后的代码就能够运行起来，这就是Java能一次编译，到处运行的原因。</p><p>当前市面上使用范围最广的，是Sun&#x2F;OracleJDK或者OpenJDK中默认的 HotSpot 虚拟机，这里也是以 HotSpot 虚拟机展开，对JVM 基础概念进行阐述。</p><h3 id="2、类加载机制"><a href="#2、类加载机制" class="headerlink" title="2、类加载机制"></a>2、类加载机制</h3><p>上文提到，Java的代码经过编译器，生成.Class文件后，JVM才能识别并运行。</p><blockquote><p>类加载过程</p></blockquote><p><strong>Class 文件需要加载到虚拟机中之后才能运行和使用，那么虚拟机是如何加载这些 Class 文件呢？</strong></p><p>系统加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p>整个类加载的过程中，包括<strong>加载、验证、准备、解析、初始化</strong>五个阶段。<br>在这五个阶段中，加载、验证、准备和初始化这四个阶段发生的顺序是确定的，而解析阶段则不一定，它在某些情况下可以在初始化阶段之后开始，这是为了支持Java语言的运行时绑定(也成为动态绑定或晚期绑定)。另外注意<strong>这里的几个阶段是按顺序开始，而不是按顺序进行或完成</strong>，因为这些阶段通常都是互相交叉地混合进行的，通常在一个阶段执行的过程中调用或激活另一个阶段。</p><ul><li>类的加载: 查找并加载类的二进制数据</li><li>连接<ul><li>验证: 确保被加载的类的正确性</li><li>准备: 为类的静态变量分配内存，并将其初始化为默认值</li><li>解析: 把类中的符号引用转换为直接引用</li></ul></li><li>初始化：为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。</li><li>使用： 类访问方法区内的数据结构的接口， 对象是Heap区的数据</li><li>卸载： 结束生命周期</li></ul><blockquote><p>类加载的层次</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116234810.png" alt="image.png"></p><ul><li><strong>启动类加载器</strong>: Bootstrap ClassLoader，<ul><li>负责加载存放在<code>JDK\jre\lib</code> (JDK代表JDK的安装目录，下同)下，或被-Xbootclasspath参数指定的路径中的，并且能被虚拟机识别的类库(如rt.jar，所有的java.* 开头的类均被Bootstrap ClassLoader加载)。</li><li>启动类加载器是无法被Java程序直接引用的。</li></ul></li><li><strong>扩展类加载器</strong>: Extension ClassLoader，<ul><li>该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，它负责加载<code>JDK\jre\lib\ext</code>目录中，或者由 java.ext.dirs 系统变量指定的路径中的所有类库(如javax.* 开头的类)，</li><li>开发者可以直接使用扩展类加载器。</li></ul></li><li><strong>应用程序类加载器</strong>: Application ClassLoader，<ul><li>该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径(ClassPath)所指定的类，</li><li>开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li></ul></li><li><strong>自定义类加载器</strong>: <ul><li>因为JVM自带的 ClassLoader 只是懂得从本地文件系统加载标准的 java class 文件，因此如果编写了自己的ClassLoader，便可以做到如下几点:<ul><li>在执行非置信代码之前，自动验证数字签名。</li><li>动态地创建符合用户特定需要的定制化构建类。</li><li>从特定的场所取得java class，例如数据库中和网络中。</li></ul></li></ul></li></ul><blockquote><p>Class.forName()和ClassLoader.loadClass()区别?</p></blockquote><ul><li><code>Class.forName()</code>: 将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li><li><code>ClassLoader.loadClass()</code>: 只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li><li><code>Class.forName(name, initialize, loader)</code>带参函数也可控制是否加载static块。并且只有调用了newInstance()方法采用调用构造函数，创建类的对象</li></ul><h3 id="3、JVM的结构体系"><a href="#3、JVM的结构体系" class="headerlink" title="3、JVM的结构体系"></a>3、JVM的结构体系</h3><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116235359.png" alt="image.png"></p><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。</p><blockquote><p>运行时数据区根据线程是否私有或者共享进行区分</p></blockquote><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存 (非运行时数据区的一部分)</li></ul><p>Java 虚拟机规范对于运行时数据区域的规定是相当宽松的。以堆为例：堆可以是连续空间，也可以不连续。堆的大小可以固定，也可以在运行时按需扩展 。虚拟机实现者可以使用任何垃圾回收算法管理堆，甚至完全不进行垃圾收集也是可以的。</p><p>直接内存（Java7的永久代或JDK8的元空间、代码缓存）</p><blockquote><p>JDK 1.8 和之前的版本略有不同，我们这里以 JDK 1.7 和 JDK 1.8 这两个版本为例介绍。</p></blockquote><p>1.8之前版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000248.png" alt="image.png|600"></p><p>JVM1.8之后版本</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231117000319.png" alt="image.png|600"></p><p>1.8之前的版本，线程共享为两个区域：堆与方法区；其中方法区只是JVM虚拟机规范的一部分，不是实际的实现；</p><p>直接内存：是JVM以外的本地内存；</p><p><strong>版本区别介绍</strong></p><ul><li>区别一（方法区）<ul><li>1.8版本之后，使用元数据区实现了方法区，之前是使用永久代来实现方法区，大小是启动时固定好的；</li><li>元空间不在虚拟机中，而是使用本地内存，并且大小可以自动增长，减少了OOM（内存溢出）的几率；</li></ul></li><li>区别二（堆区）<ul><li>Java7之后运行时常量池从方法区移到了这里，为Java8移出永久代做好准备；</li></ul></li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</p><p>另外，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>to be continued ….</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/jvm/memory-area.html">https://javaguide.cn/java/jvm/memory-area.html</a></li><li><a href="https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98">https://www.pdai.tech/md/interview/x-interview.html#_5-jvm%E5%92%8C%E8%B0%83%E4%BC%98</a></li><li><a href="http://moxi159753.gitee.io/learningnotes/#/">http://moxi159753.gitee.io/learningnotes/#/</a></li><li><a href="https://www.bilibili.com/video/BV1iJ411d7jS">https://www.bilibili.com/video/BV1iJ411d7jS</a></li><li><a href="https://blog.csdn.net/fllow_wind/article/details/117027924">https://blog.csdn.net/fllow_wind/article/details/117027924</a></li><li><a href="https://zhuanlan.zhihu.com/p/25713880">https://zhuanlan.zhihu.com/p/25713880</a></li><li><a href="https://blog.csdn.net/xianyun1992/article/details/126555575">https://blog.csdn.net/xianyun1992/article/details/126555575</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_进阶内容</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是线程模型？"><a href="#1、什么是线程模型？" class="headerlink" title="1、什么是线程模型？"></a>1、什么是线程模型？</h3><blockquote><p>先回顾一下线程和进程的区分</p></blockquote><ul><li>进程：<ul><li>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul></li><li>线程<ul><li>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><blockquote><p>什么是线程模型</p></blockquote><p>并发编程在计算机中如何实现的，在 Java 开发领域中，JVM线程对不同操作系统上的原生线程进行了高级抽象，使开发者大多数情况下可以不用关注下层细节，而只要专注上层开发。</p><p>JVM线程与操作系统线程之间存在着某种映射关系，这两种<strong>不同维度的线程之间的规范和协议</strong>，就是线程模型。</p><blockquote><p>用户线程和内核线程</p></blockquote><ul><li>用户线程：由用户空间程序管理和调度的线程，运行在用户空间（专门给应用程序使用）。</li><li>内核线程：由操作系统内核管理和调度的线程，运行在内核空间（只有内核程序可以访问）。</li></ul><blockquote><p>线程模型类型</p></blockquote><p>JVM线程模型有三种模型：一对一、多对一、多对多。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161619698.png" alt="image.png"></p><p><strong>一对一</strong></p><p>在Jva线程（用户线程）与操作系统线程(KLT)之间建立一对一的关系，简单粗暴，但好用。</p><ul><li>优点：<ul><li>每个线程都是独立的调度单元，直接利用操作系统内核提供的调度功能。</li></ul></li><li>缺点：<ul><li>用户线程的阻塞唤醒，会直接映射到内核线程上，容易<strong>引起频繁切换，降低性</strong>能。但是一些语言引入了CAS来避免一部分的内核调用，比如Java 引入了AQS这种函数级别的锁，<strong>减少使用内核级别的锁</strong>，就能提升性能。</li></ul></li></ul><p>目前大部分主流 JVM 上都是采用的这种线程模型。</p><p><strong>多对一模型</strong></p><ul><li>优点<ul><li>用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快：</li></ul></li><li>缺点<ul><li>如果其中一个用户线程阻塞，其他用户线程也无法执行</li><li>这种模型下，内核并不知道用户态有哪些线程，调度和优先级等不完整。</li></ul></li></ul><p><strong>多对多模型</strong></p><ul><li>优点：兼具前两者的优点</li><li>缺点：实现复杂</li></ul><p>目前主流语言中，Java 使用的是 一对一线程模型；Go 语言使用的是 多对多线程模型；Python 的 gevent 使用的多对一线程模型。</p><h3 id="2、悲观锁机制"><a href="#2、悲观锁机制" class="headerlink" title="2、悲观锁机制"></a>2、悲观锁机制</h3><p>在了解悲观锁机制前，我们先来了解一下什么是锁。</p><h4 id="什么是锁"><a href="#什么是锁" class="headerlink" title="什么是锁"></a>什么是锁</h4><p>在并发环境下，会出现多个线程对同一个资源进行争抢的情况，假设A线程对资源正在进行修改，此时<br>B线程此时又对资源进行了修改，这就可能会导致数据不一致的问题。</p><p>为了解决这个问题，引入了锁机制，<strong>通过一种抽象的“锁”来对资源进行锁定</strong>，当一个线程持有“锁”的时候，其他线程必须等待“锁”，本质上是在临界资源上对线程进行一种串行化。</p><h4 id="Java语言的锁机制"><a href="#Java语言的锁机制" class="headerlink" title="Java语言的锁机制"></a>Java语言的锁机制</h4><blockquote><p>Java 虚拟机的内存结构</p></blockquote><p>在了解 Java语言锁机制之前，我们先对简单了解一下 Java 虚拟机的内存结构。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116222015.png" alt="image.png"></p><p>JVM 运行时内存结构主要包含了五个部分：</p><ul><li>程序计数器(PC寄存器)、</li><li>JVM栈、</li><li>Native方法栈、</li><li>堆、</li><li>方法区。</li></ul><p>上图中，红色区域是各个线程私有的。这个区域中的数据，不会出现线程竞争的关系。</p><p>而蓝色区域中的数据被所有线程共享，其中Jva堆中存放的是大量对象，方法区中<strong>存放类信息、常量、静态变<br>量</strong>等数据。</p><p>当多个线程在竞争其中的一些数据时，可能会发生难以预料的异常情况。在程序开发中，锁的主要应用范围就是在数据共享区域。</p><p>在代码层面，Jvva 主要采用了两种实现方式：</p><ul><li>1.基于Object的悲观锁。</li><li>2.基于CAS的乐观锁。</li></ul><p>本章主要讲解基于Object的悲观锁。</p><blockquote><p>悲观锁机制</p></blockquote><p>悲观锁总是假设最坏的情况，认为共享资源<strong>每次被访问的时候就会出现问题</strong>(比如共享数据被修改)，所以每次在获取资源操作的时候都会上锁，这样其他线程想拿到这个资源就会阻塞直到锁被上一个持有者释放。也就是说，<strong>共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程</strong>。</p><blockquote><p>基于Object的悲观锁</p></blockquote><p>在Java中，每个Object,也就是每个对象都拥有一把锁，这把锁存放在对象头中，记录了当前对象被哪个线程占用。</p><blockquote><p>对象和对象头的结构</p></blockquote><p><strong>Java 对象</strong></p><p>Java对象分为三个部分：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充字节</li></ul><p>其中对齐填充字节是为了满足“Java对象大小是8字节的倍数”这一条件而设计的，为对象对齐填充了一些无用字节。</p><p>实例数据是在初始化对象时设定的属性和状态等内容。</p><p><strong>对象头</strong></p><p>对象头存放了一些对象本身的运行时信息。对象头包含了两部分：</p><ul><li>Mark Word</li><li>Class Pointer</li></ul><p>相较于实例数据，对象头属于一些额外的存储开销，它被设计得极小（一般为232bt或264bt) 来提升效率。</p><p>Class Pointer是一个指针，指向当前对象类型所在方法区中的Class信息；</p><p>Mark Word 存储了<strong>很多当前对象的运行时状态信息</strong>，比如 HashCode.、锁状态标志、指向锁记录的指针、偏向线程 ID、锁标志位等等。</p><p>可以通过下面这张表对 Mark Word有一个更直观的认识：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231116223405.png" alt="image.png"></p><p>“锁”的信息存储在对象头的Mark Word中。Mark Word 的最后两位，代表锁标志位，分别对应“无锁”、“偏向锁”、“轻量级锁”、“重量级锁”四种状态。</p><p>在Java中，启用对象锁的方式是使用<code>synchronized</code>关键字。</p><h4 id="对象锁的四种状态"><a href="#对象锁的四种状态" class="headerlink" title="对象锁的四种状态"></a>对象锁的四种状态</h4><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。</p><p>锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率</p><p>to be continued ….</p><hr><p>参考:</p><ul><li><a href="https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866">https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866</a></li><li><a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></li><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.bilibili.com/video/BV1z44y1X7BJ">https://www.bilibili.com/video/BV1z44y1X7BJ</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_基础概念</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li></ul><p>并行和并发的区别</p><ul><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行</p><p>同步和异步的区别</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p><h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" alt="image.png"></p><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" alt="image.png"></p><p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p><p>Java线程具有五中基本状态</p><ul><li>新建状态（New）<ul><li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li></ul></li><li>就绪状态（Runnable）<ul><li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li><li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li></ul></li><li>运行状态（Running）<ul><li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li><li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li></ul></li><li>阻塞状态（Blocked）<ul><li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li><li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul><li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li><li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡状态（Dead）<ul><li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul><blockquote><p>Java多线程的就绪、运行和死亡状态</p></blockquote><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p><p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p><p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p><p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p><h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p><ol><li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>Runnable接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure><ul><li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li><li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li><li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li></ul><blockquote><p>写法简化（Java 8)</p></blockquote><ul><li><strong>方式一：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote><p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p></blockquote><table><thead><tr><th>名称</th><th>描述</th><th>注意事项</th></tr></thead><tbody><tr><td>​<code>start()</code>​</td><td>启动一个新线程，<br />在新的线程运行 run 方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td></tr><tr><td>​<code>run()</code>​</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td></tr><tr><td>​<code>join()</code>​</td><td>等待线程运行结束</td><td></td></tr><tr><td>​<code>join(long n)</code>​</td><td>等待线程运行结束，<br />最多等待 n 毫秒</td><td></td></tr><tr><td>​<code>getId()</code>​</td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>​<code>getName()</code>​</td><td>获取线程名</td><td></td></tr><tr><td>​<code>setName(String name)</code>​</td><td>修改线程名</td><td></td></tr><tr><td>​<code>getPriority()</code>​</td><td>获取线程优先级</td><td></td></tr><tr><td>​<code>setPriority(int priority)</code>​</td><td>修改线程优先级</td><td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td></tr><tr><td>​<code>getState()</code>​</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td></tr><tr><td>​<code>interrupt()</code>​</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td></tr><tr><td><font color=Coral>interrupted()</font></td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>​<code>isInterrupted()</code>​</td><td>判断当前线程是否被打断</td><td>不会清除打断标记</td></tr><tr><td>​<code>isAlive()</code>​</td><td>判断当前线程是否存活</td><td></td></tr><tr><td>​<code>isDaemon()</code>​</td><td>判断当前线程是否是守护线程</td><td></td></tr><tr><td>​<code>setDaemon(boolean on)</code>​</td><td>设置当前线程为守护线程</td><td></td></tr><tr><td><font color=Coral>currentThread()</font></td><td>获取当前正在执行的线程</td><td></td></tr><tr><td><font color=Coral>sleep(long n)</font></td><td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td><td></td></tr><tr><td><font color=Coral>yield()</font></td><td>提示线程调度器让出当前线程<br />对 CPU 的使用</td><td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td></tr></tbody></table><h3 id="6、Synchronized-和-Lock-的使用"><a href="#6、Synchronized-和-Lock-的使用" class="headerlink" title="6、Synchronized 和 Lock 的使用"></a>6、Synchronized 和 Lock 的使用</h3><p>并发编程中，锁是经常需要用到的。这里讲述一下 Synchronized 和 Lock 的使用。</p><p>Synchronized 是 Java 并发编程 中很重要的关键字，另外一个很重要的是 volatile。</p><p>Syncronized 的目的是一次<strong>只允许一个线程进入由他修饰的代码段</strong>，从而允许他们进行自我保护。</p><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，它要比 Synchronized 关键字更能直译”锁”的概念，Lock需要<strong>手动加锁和手动解锁</strong>，一般通过 lock.lock() 方法来进行加锁， 通过 lock.unlock() 方法进行解锁。与 Lock 关联密切的锁有 ReetrantLock 和 ReadWriteLock。</p><h4 id="Synchronized"><a href="#Synchronized" class="headerlink" title="Synchronized"></a>Synchronized</h4><blockquote><p>在方法上使用 Synchronized</p></blockquote><p>方法声明时使用，放在范围操作符之后,返回类型声明之前。即一次只能有一个线程进入该方法，其他线程要想在此时调用该方法，只能排队等候。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> number;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numIncrease</span><span class="hljs-params">()</span>&#123;<br>  number++;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>在某个代码段使用 Synchronized</p></blockquote><p>可以在某个代码块上使用 Synchronized 关键字，表示只能有一个线程进入某个代码段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">numDecrease</span><span class="hljs-params">(Object num)</span>&#123;<br>  <span class="hljs-keyword">synchronized</span> (num)&#123;<br>    number++;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>使用 Synchronized 锁住整个对象</p></blockquote><p>synchronized后面括号里是一对象，此时线程获得的是对象锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h4><p>Lock 是 Java并发编程中<strong>很重要的一个接口</strong>，相关方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Lock</span> &#123;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">()</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryLock</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException;<br>    <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlock</span><span class="hljs-params">()</span>;<br>    Condition <span class="hljs-title function_">newCondition</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>常用方法</p><ul><li>lock()<ul><li>用来获取锁。如果锁被其他线程获取，则进行等待。</li><li>如果采用Lock，必须主动去释放锁，并且在发生异常时，不会自动释放锁</li></ul></li><li>tryLock()<ul><li>方法是有返回值的，它表示用来尝试获取锁，如果获取成功，则返回true，如果获取失败（即锁已被其他线程获取），则返回false，</li><li>这个方法无论如何都会立即返回。在拿不到锁时不会一直等待。</li></ul></li><li>tryLock(long time, TimeUnit unit)<ul><li>和tryLock()方法是类似</li><li>在拿不到锁时<strong>会等待一定的时间</strong>，在时间期限之内如果还拿不到锁，就返回false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。</li></ul></li><li>lockInterruptibly()<ul><li>去获取锁时，如果线程正在等待获取锁，则这个线程能够响应中断，即<strong>中断线程的等待状态</strong>。</li><li>当两个线程同时通过 lock.lockInterruptibly() 想获取某个锁时，假若此时线程A获取到了锁，而线程B只有在等待，那么对线程B调用 threadB.interrupt() 方法能够中断线程B的等待过程。</li><li>由于 lockInterruptibly() 的声明中抛出了异常，所以 lock.lockInterruptibly() 必须放在try块中或者在调用lockInterruptibly() 的方法外声明抛出 InterruptedException。</li></ul></li></ul><blockquote><p>代码示例：</p></blockquote><p>lock()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Lock</span> <span class="hljs-variable">lock</span> <span class="hljs-operator">=</span> ...;<br>lock.lock();<br><span class="hljs-keyword">try</span>&#123;<br>    <span class="hljs-comment">//处理任务</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception ex)&#123;<br>     <br>&#125;<span class="hljs-keyword">finally</span>&#123;<br>    lock.unlock();   <span class="hljs-comment">//释放锁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>tryLock()</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Lock</span> lock = ...;<br><span class="hljs-keyword">if</span>(lock.<span class="hljs-title function_">tryLock</span>()) &#123;<br>     <span class="hljs-keyword">try</span>&#123;<br>         <span class="hljs-comment">//处理任务</span><br>     &#125;<span class="hljs-keyword">catch</span>(<span class="hljs-title class_">Exception</span> ex)&#123;<br>         <br>     &#125;<span class="hljs-keyword">finally</span>&#123;<br>         lock.<span class="hljs-title function_">unlock</span>();   <span class="hljs-comment">//释放锁</span><br>     &#125;<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">//如果不能获取锁，则直接做其他事情</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>lockInterruptibly()</strong> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs javascript">public <span class="hljs-keyword">void</span> <span class="hljs-title function_">method</span>() throws <span class="hljs-title class_">InterruptedException</span> &#123;<br>    lock.<span class="hljs-title function_">lockInterruptibly</span>();<br>    <span class="hljs-keyword">try</span> &#123;<br>     <span class="hljs-comment">//.....</span><br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        lock.<span class="hljs-title function_">unlock</span>();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一般来说，使用Lock必须在try{}catch{}块中进行，并且将<strong>释放锁的操作放在finally块中进行</strong>，以保证锁一定被被释放，防止死锁的发生。</p><blockquote><p>注意，当一个线程获取了锁之后，是不会被interrupt()方法中断的。<br>单独调用 interrupt() 方法不能中断正在运行过程中的线程，只能<strong>中断阻塞过程中的线程</strong>。因此当通过lockInterruptibly()方法获取某个锁时，如果不能获取到，<strong>只有进行等待的情况下，是可以响应中断的</strong>。<br>而<strong>用synchronized修饰的话</strong>，当一个线程处于等待某个锁的状态，是无法被中断的，只有一直等待下去。</p></blockquote><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li><li><a href="https://cloud.tencent.com/developer/article/1497476">https://cloud.tencent.com/developer/article/1497476</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_HashMap学习</title>
    <link href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>HashMap 主要用来存放键值对，基于哈希表的 Map 接口实现，是常用的 Java 集合之一。</p><p>HashMap是非线程安全的，效率较高。</p><p>它可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><strong>底层数据结构</strong>：</p><ul><li>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li><li>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>扩充机制</strong>：<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><blockquote><p>HashMap的常用方法</p></blockquote><p>1、put(K key, V value)： 将键（key）&#x2F;值（value）映射存放到Map集合中。</p><p>2、get(Object key)： 返回指定键所映射的值，没有该key对应的值则返回 null。</p><p>3、size()： 返回Map集合中数据数量。</p><p>4、clear()： 清空Map集合。</p><p>5、isEmpty()： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。</p><p>6、remove(Object key)： 删除Map集合中键为key的数据并返回其所对应value值。</p><p>7、values()： 返回Map集合中所有value组成的以Collection数据类型格式数据。</p><p>8、containsKey(Object key)： 判断集合中是否包含指定键，包含返回 true，否则返回false。</p><p>9、containsValue(Object value)： 判断集合中是否包含指定值，包含返回 true，否则返回false。</p><p>10、keySet()： 返回Map集合中所有key组成的Set集合。</p><p>11、entrySet()： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。</p><blockquote><p>HashMap 常用方法测试</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sas">package map;<br><br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.<span class="hljs-keyword">Set</span>;<br><br>public class HashMapDemo &#123;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>        // 键不能重复，值可以重复<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;san&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王2&quot;</span>);// 老王被覆盖<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;lao&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------直接输出hashmap:-------&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历HashMap</span><br><span class="hljs-comment">         */</span><br>        // 1.获取Map中的所有键<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span>+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 2.获取Map中所有值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);<br>        Collection&lt;String&gt; values = map.values();<br>        for (String value : values) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(value+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 3.得到<span class="hljs-keyword">key</span>的值的同时得到<span class="hljs-keyword">key</span>所对应的值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys2 = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys2) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span> + <span class="hljs-string">&quot;：&quot;</span> + map.get(<span class="hljs-keyword">key</span>)+<span class="hljs-string">&quot;   &quot;</span>);<br><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="hljs-comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="hljs-comment">         */</span><br>        // 当我调用<span class="hljs-meta">put</span>(<span class="hljs-keyword">key</span>,value)方法的时候，首先会把<span class="hljs-keyword">key</span>和value封装到<br>        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取<br>        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来<br>        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了<br>        <span class="hljs-keyword">Set</span>&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();<br>        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;<br>            System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HashMap其他常用方法</span><br><span class="hljs-comment">         */</span><br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.size()：&quot;</span>+map.size());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;san&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.remove()：&quot;</span>+map);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;李四&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四2&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.replace(si, 李四2):&quot;</span>+map);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用（ <strong>链表散列</strong>）。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115224010.png" alt="image.png"></p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<strong>如果相同的话，直接覆盖</strong>，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。</p><p>使用 hash 方法（扰动函数）是为了防止一些实现比较差的 hashCode() 方法 ，使用扰动函数之后可以减少碰撞。</p><p>所谓 <strong>“拉链法”</strong> 是：将链表和数组相结合。也就是说创建一个链表数组，<strong>数组中每一格就是一个链表</strong>。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><strong>hash 方法</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能稍差一点，因为毕竟扰动了 4 次。</p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。</p><p>这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。</p><p>否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115223309.png" alt="image.png"></p><h4 id="HashMap-的类属性"><a href="#HashMap-的类属性" class="headerlink" title="HashMap 的类属性"></a>HashMap 的类属性</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span> &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">362498820763181265</span>L;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    transient Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    transient <span class="hljs-built_in">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    transient <span class="hljs-built_in">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-built_in">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的字段</p><ul><li>loadFactor   负载因子</li><li>threshold   阈值（HashMap 实际能存储的大小）</li><li>DEFAULT_INITIAL_CAPACITY  默认初始容量</li><li>MAXIMUM_CAPACITY  最大容量</li><li>size   HashMap实际存储的元素个数</li><li>modCount     HashMap的结构被修改的次数，用于迭代器</li></ul><blockquote><p>loadFactor 负载因子</p></blockquote><p>loadFactor 负载因子 是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor 的默认值为 0.75f</strong> ，是官方给出的一个比较好的临界值。</p><p>HashMap 给定的默认容量为 16，负载因子为 0.75。<br>Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 , 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><blockquote><p>threshold   阈值</p></blockquote><p><strong>threshold &#x3D; capacity * loadFactor</strong>，阈值(容量 * 负载因子) </p><p>当实际大小超过阈值时，就要考虑对数组的扩增。阈值是衡量数组是否需要扩增的一个标准。</p><h4 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br>static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">K,V</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-type">K,V</span>&gt; &#123;<br>       <span class="hljs-keyword">final</span> int hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       <br>       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String toString() &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int hashCode() &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br><span class="hljs-comment">//相当于把原来的值给覆盖掉，但是返回被覆盖掉的值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V newValue) &#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean equals(Object o) &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 父</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;           <span class="hljs-comment">// 判断颜色</span><br>        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; root() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、HashMap-源码分析"><a href="#3、HashMap-源码分析" class="headerlink" title="3、HashMap 源码分析"></a>3、HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> threshold;<br>   <br>   <span class="hljs-comment">// 默认构造函数。</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    &#125;<br><br>    <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>        <span class="hljs-comment">//指定负载因子</span><br>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在 resize 中再赋值给 newCap 进行table初始化</span><br>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面第二个构造函数中调用了 putMapEntries 方法，下面进行分析：</p><p><strong>putMapEntries 方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> s = m.size();  <br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size  </span><br>            <span class="hljs-comment">//如果未初始化，s 为 m 的实际元素个数；ft=s/loadFactor =&gt; s=ft*loadFactor；其中 ft 指的是要添加 s 个元素所需要的最小的容量</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0</span>F;  <br>            <span class="hljs-comment">//与最大容量作比较，如果小于则 t 为 ft，否则为 MAXIMUM_CAPACITY</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?  <br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);  <br>            <span class="hljs-comment">//根据上面的构造函数，可以得知此时 table 未初始化，threshold 实际上是存放的初始化容量</span><br>            <span class="hljs-comment">//如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。（注意这里不是初始化阈值）</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)  <br>                threshold = tableSizeFor(t);  <br>        &#125;  <br>        <span class="hljs-comment">// 如果已经初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)  <br>            resize();  <br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容    </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet()) &#123;  <br>            K key = e.getKey();  <br>            V value = e.getValue();  <br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor 方法：返回一个最接近 cap 的2的幂次方大小数值</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;  <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;  <br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法是 put 方法调用的一个方法，并没有提供给用户使用。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>putVal 方法 图解</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115230931.png" alt="image.png"></p><p>putVal 方法添加元素分析：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，<ul><li>如果 key 相同就直接覆盖，</li><li>如果 key 不相同，就判断 p 是否是一个树节点，<ul><li>如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</li><li>如果不是就遍历链表插入(插入的是链表尾部)。</li></ul></li></ul></li></ul><blockquote><p>putVal 方法</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对比 JDK1.7 put 方法的代码</strong></p></blockquote><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value)<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    <span class="hljs-title function_">inflateTable</span>(threshold);<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123; <span class="hljs-comment">// 先遍历</span><br>        <span class="hljs-built_in">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">public V get(Object key) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(<span class="hljs-built_in">hash</span>(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br>final Node&lt;K,V&gt; getNode(int <span class="hljs-built_in">hash</span>, Object key) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; int n; K k;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = <span class="hljs-literal">tab</span>[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span>.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">first</span>;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = <span class="hljs-built_in">first</span>.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(<span class="hljs-built_in">hash</span>, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">https://javaguide.cn/java/collection/hashmap-source-code.html</a></li><li><a href="https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507">https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507</a></li><li><a href="https://blog.csdn.net/rain67/article/details/124043769">https://blog.csdn.net/rain67/article/details/124043769</a></li><li><a href="https://segmentfault.com/a/1190000039302830">https://segmentfault.com/a/1190000039302830</a></li><li><a href="https://blog.csdn.net/weixin_47257050/article/details/118926555">https://blog.csdn.net/weixin_47257050/article/details/118926555</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 集合</strong></p><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li><li><a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">Java集合_HashMap学习</a></li></ul><p><strong>Java多线程</strong></p><ul><li><a href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java并发编程_基础概念">Java并发编程_基础概念</a></li><li><a href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java并发编程_进阶内容">Java并发编程_进阶内容</a></li></ul><p><strong>Java 8</strong> </p><ul><li><a href="/2023/11/16/Java8%E6%96%B0%E7%89%B9%E6%80%A7/" title="Java8新特性">Java8新特性</a></li></ul><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><ul><li><a href="/2023/11/16/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="JVM入门_基础概念">JVM入门_基础概念</a></li></ul><h3 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h3><ul><li><a href="/2023/11/27/MySQL%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="MySQL学习_基础内容">MySQL学习_基础内容</a></li></ul><h3 id="常用框架"><a href="#常用框架" class="headerlink" title="常用框架"></a>常用框架</h3><ul><li><a href="/2023/11/27/Spring%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Spring学习_基础内容">Spring学习_基础内容</a></li></ul><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><ul><li><a href="/2023/11/19/NoSQL_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="NoSQL_基础概念">NoSQL_基础概念</a></li><li><a href="/2023/11/19/Redis%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Redis入门_基础概念">Redis入门_基础概念</a></li><li><a href="/2023/11/19/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="消息队列_基础概念">消息队列_基础概念</a></li></ul><h3 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h3><ul><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="SpringCloud_组件基本使用_基础概念">SpringCloud_组件基本使用_基础概念</a></li><li><a href="/2023/11/22/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Eureka/" title="SpringCloud_组件基本使用_Eureka">SpringCloud_组件基本使用_Eureka</a></li><li><a href="/2023/11/24/SpringCloud_%E7%BB%84%E4%BB%B6%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8_Nacos/" title="SpringCloud_组件基本使用_Nacos">SpringCloud_组件基本使用_Nacos</a></li></ul><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><ul><li><a href="/2023/11/17/Docker%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Dokcer入门_基础概念">Dokcer入门_基础概念</a></li></ul><h3 id="前端学习"><a href="#前端学习" class="headerlink" title="前端学习"></a>前端学习</h3><ul><li><a href="/2023/11/17/node%E5%AE%89%E8%A3%85%E5%92%8C%E4%B8%8B%E8%BD%BD/" title="node安装和下载">node安装和下载</a></li><li><a href="/2023/11/20/Nginx_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Nginx_基础概念">Nginx_基础概念</a></li><li><a href="/2023/11/26/Vue%E5%AD%A6%E4%B9%A0_%E5%9F%BA%E7%A1%80%E5%86%85%E5%AE%B9/" title="Vue学习_基础内容">Vue学习_基础内容</a></li></ul><h3 id="项目学习"><a href="#项目学习" class="headerlink" title="项目学习"></a>项目学习</h3><ul><li><a href="/2023/11/23/%E8%98%91%E8%8F%87%E5%8D%9A%E5%AE%A2%E9%A1%B9%E7%9B%AE01/" title="蘑菇博客项目01">蘑菇博客项目01</a></li><li><a href="/2023/11/26/%E4%B8%AA%E4%BA%BA%E5%9C%A8%E7%BA%BF%E7%BD%91%E7%9B%98_ZFile/" title="个人在线网盘_ZFile">个人在线网盘_ZFile</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>ArrayList 是 List 的主要实现类，内部基于动态数组实现，支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。</p><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。</p><p><code>ArrayList</code>创建时不需要指定大小，下面是常用方法示例代码：</p><p>ArrayList</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h3 id="2、ArrayList-扩容机制"><a href="#2、ArrayList-扩容机制" class="headerlink" title="2、ArrayList 扩容机制"></a>2、ArrayList 扩容机制</h3><p>以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><h3 id="3、相关内容"><a href="#3、相关内容" class="headerlink" title="3、相关内容"></a>3、相关内容</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>HashMap保证key的不重复性，对于重复的key，HashMap会根据参数onlyIfAbsent的设置和原value是否为空两个条件来<strong>判断是否替换新value</strong>，</p><p>但要注意的是，对于HashSet，这个value只是个空的Object类的对象，没有任何实际作用，HashSet中的元素实际上是存储在key上的。针对重复的key，<strong>HashMap只有对于value的处理，并不会替换key</strong>，因此在HashSet中加入相同元素不会覆盖。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><p><strong>总结</strong>：结果向HashSet中加入相同元素不会进行覆盖。因为HashSet底层使用HashMap实现，元素存在HashMap的key中。在HashMap中，多次put相同的key，只会覆盖value，而不存在key的情况。</p><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢"><a href="#4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢" class="headerlink" title="4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢"></a>4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢</h4><p>为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？</p><p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p><p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会<strong>显著提高效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20231114</title>
    <link href="/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/"/>
    <url>/2023/11/14/%E6%97%A5%E8%AE%B0_%E8%BF%91%E6%9C%9F%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><ul><li><input disabled="" type="checkbox"> Java集合、Java多线程、MySQL数据库、Spring 进行复习</li><li><input disabled="" type="checkbox"> Redis、MQ </li><li><input disabled="" type="checkbox"> 微服务 SpringCloud Alibaba 学习</li><li><input checked="" disabled="" type="checkbox"> <del>学成在线项目进行（放弃）</del></li><li><input disabled="" type="checkbox"> 项目：蘑菇博客的学习（个人一直趋向学习这个项目，趁这段时间有空，学习一下）</li><li><input disabled="" type="checkbox"> 考研数学</li></ul><hr>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_基础概念</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="1、成员关系"><a href="#1、成员关系" class="headerlink" title="1、成员关系"></a>1、成员关系</h4><p>Java 集合相关的成员关系图<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" alt="image.png"></p><ul><li>Collection<ul><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li></ul></li><li>List<ul><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li><li>LinkedList</li></ul></li><li>Queue<ul><li>Deque<ul><li>ArrayDeque</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>Hashtable</li><li>SortedMap<ul><li>TreeMap</li></ul></li></ul></li></ul><p>通过下面表格可说明之间部分的区别和联系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123120.png" alt="image.png"><br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123036.png" alt="image.png"></p><h4 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection接口：最基本的集合接口，所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List接口：有序的Collection，用某种特定的插入顺序来维护元素顺序；用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141634443.png" alt="image.png"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map接口：由一系列键值对组成的集合，提供了key到Value的映射。同时它没有继承Collection；它保证了key与value之间的一一对应关系，一个key对应一个value，它不能存在相同的key值，value值可以相同。</p><p>实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><ul><li>HashMap（JDK1.8及以上）<ul><li>基于哈希表的Map接口的非同步实现</li><li>允许使用 null 值和 null 键</li><li>数据结构可以看成数组+链表+红黑树</li><li>采用了Fail-  Fast机制</li></ul></li><li>Hashtable<ul><li>基于哈希表的Map接口的同步实现, 使用synchronized实现线程安全</li><li>不允许使用null值和null键</li><li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li></ul></li><li>ConcurrentHashMap（JDK1.7版本）<ul><li>采用数组+分段锁的方式实现</li><li>数据结构：Segment 数组 + HashEntry 数组 + 链表</li></ul></li><li>ConcurrentHashMap（JDK1.8版本）<ul><li>数据结构：Node 数组 + 链表 &#x2F; 红黑树。</li><li>当冲突链表达到一定长度时，链表会转换成红黑树。</li></ul></li><li>TreeMap<ul><li>实现了SortedMap接口，键以某种排序规则排序</li><li>内部以red-black（红-黑）树数据结构实现</li></ul></li><li>LinkedHashMap<ul><li>继承于HashMap</li><li>非同步，允许使用null值和null键</li><li>底层使用哈希表和双向链表来保存所有元素</li></ul></li><li>WeakHashMap<ul><li>支持null值和null键，fast-fail机制，不允许重复</li><li>key只保留对实际对象的弱引用，当key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。</li></ul></li><li>IdentifyHashMap<ul><li>在IdentityHashMap中，当且仅当两个key严格相等（key1&#x3D;&#x3D; key2）时，IdentityHashMap才认为两个key相等；相对于普通HashMap而言，只要key1和key2通过equals()方法返回true，且它们的hashCode值相等即可。</li></ul></li><li>EnumMap<ul><li>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显示或隐式的指定它对应的枚举类。</li></ul></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 接口：不包括重复元素的Collection，同样允许 null的存在但是仅有一个</p><p>实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><ul><li>HashSet<ul><li>基于HashMap实现，API 对 HashMap的行为进行了封装</li><li>允许使用null元素</li></ul></li><li>LinkedHashSet<ul><li>继承于 HashSet、又基于LinkedHashMap来实现</li><li>底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上与HashSet相同</li></ul></li><li>TreeSet<ul><li>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。</li><li>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的  <code>Comparator</code> 进行排序</li></ul></li><li>EnumSet<ul><li>枚举的专用Set。所有的元素都是枚举类型</li></ul></li></ul><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列，主要分为两大类，</p><p>一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。</p><p>另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p><hr><p>参考</p><ul><li><a href="https://javaguide.cn/java/collection/java-collection-questions-01.html">https://javaguide.cn/java/collection/java-collection-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h3><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍<br>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p><h3 id="常用的一些命令"><a href="#常用的一些命令" class="headerlink" title="常用的一些命令"></a>常用的一些命令</h3><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">查看用户名 ：git config <span class="hljs-keyword">user</span>.name<br><br>查看密码： git config <span class="hljs-keyword">user</span>.<span class="hljs-keyword">password</span><br><br>查看邮箱：git config <span class="hljs-keyword">user</span>.email<br><br>查看配置信息： $ git config <span class="hljs-comment">--list</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git入门_基本操作</title>
    <link href="/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%E5%85%A5%E9%97%A8_%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1、将某个目录文件上传到-Github-某个仓库"><a href="#1、将某个目录文件上传到-Github-某个仓库" class="headerlink" title="1、将某个目录文件上传到 Github 某个仓库"></a>1、将某个目录文件上传到 Github 某个仓库</h3><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p><blockquote><p>Git的工作流程核心</p></blockquote><ul><li>0、<strong>准备仓库</strong>：创建或从服务端克隆一个仓库。</li><li>1、<strong>搬砖</strong>：在工作目录中添加、修改代码。</li><li>2、<strong>暂存</strong>（git add）：将需要进行版本管理的文件放入暂存区域。</li><li>3、<strong>提交</strong>（git commit）：将暂存区域的文件提交到Git仓库。</li><li>4、<strong>推送</strong>（git push）：将本地仓库推送到远程仓库，同步版本库。</li><li>5、<strong>获取更新</strong>（fetch&#x2F;pull）：从服务端更新到本地，获取他人推送的更新，与他人协作、共享。</li></ul><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311250040140.png" alt="image.png"></p><ul><li><code>git commit -a</code>指令省略了<code>add</code>到暂存区的步骤，直接提交工作区的修改内容到版本库，不包括新增的文件。</li><li><code>git fetch</code>、<code>git pull</code> 都是从远程服务端获取最新记录，区别是<code>git pull</code>多了一个步骤，就是自动合并更新工作区。</li><li><code>git checkout .</code>、<code>git checkout [file]</code> 会清除工作区中未添加到暂存区的修改，用暂存区内容替换工作区。</li><li><code>git checkout HEAD .</code>、 <code>git checkout HEAD [file]</code> 会清除工作区、暂存区的修改，用HEAD指向的当前分支最新版本替换暂存区、工作区。</li><li><code>git diff</code> 用来对比不同部分之间的区别，如暂存区、工作区，最新版本与未提交内容，不同版本之间等。</li><li><code>git reset</code>是专门用来撤销修改、回退版本的指令，替代上面<code>checkout</code>的撤销功能。</li></ul><hr><p>参考</p><ul><li><a href="https://www.cnblogs.com/anding/p/16987769.html">https://www.cnblogs.com/anding/p/16987769.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
