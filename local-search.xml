<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Oracle_常用操作使用记录</title>
    <link href="/2023/11/16/Oracle_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/11/16/Oracle_%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h4 id="1、查询恢复表中一定时间之前的误删数据"><a href="#1、查询恢复表中一定时间之前的误删数据" class="headerlink" title="1、查询恢复表中一定时间之前的误删数据"></a>1、查询恢复表中一定时间之前的误删数据</h4><p>使用 as of timestamp 查询恢复表中一定时间之前的误删数据</p><p>查询30分钟前的数据</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> TABLENAME<br><span class="hljs-keyword">AS</span> <span class="hljs-keyword">OF</span> <span class="hljs-type">TIMESTAMP</span> <br>   (SYSTIMESTAMP <span class="hljs-operator">-</span> <span class="hljs-type">INTERVAL</span> <span class="hljs-string">&#x27;30&#x27;</span> <span class="hljs-keyword">MINUTE</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>oracle</tag>
      
      <tag>work</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JVM入门_基础概念</title>
    <link href="/2023/11/15/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/JVM%E5%85%A5%E9%97%A8_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>JVM 入门</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>jvm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_进阶内容</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="1、什么是线程模型？"><a href="#1、什么是线程模型？" class="headerlink" title="1、什么是线程模型？"></a>1、什么是线程模型？</h3><p>线程和进程区分：</p><ul><li>进程：<ul><li>一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。</li></ul></li><li>线程<ul><li>进程中的一个执行任务（控制单元），负责当前进程中程序的执行。一个进程至少有一个线程，一个进程可以运行多个线程，多个线程可共享数据。</li><li>与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul></li></ul><p><strong>根本区别</strong>：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位</p><p>线程模型：</p><ul><li><ol><li>线程分为 用户线程和内核线程：</li></ol><ul><li>对应操作系统的线程叫做“内核线程”</li></ul></li><li><ol start="2"><li>线程模型有多对一模型、一对一模型、多对多模型；</li></ol><ul><li>多对一模型：用户级线程模型<ul><li>优点<ul><li>用户线程的很多操作对内核来说都是透明的，不需要用户态和内核态的频繁切换，使线程的创建、调度、同步等非常快：</li></ul></li><li>缺点<ul><li>如果其中一个用户线程阻塞，其他用户线程也无法执行</li><li>这种模型下，内核并不知道用户态有哪些线程，调度和优先级等不完整</li></ul></li></ul></li><li>一对一模型：内核级线程模型，内核负责每个线程的调度，可以调度到其他处理器上面<ul><li>优点：实现简单</li><li>缺点：<ul><li>用户态和内核态频繁切换</li><li>内核为每个线程都映射调度实体，如果系统出现大量线程，对系统性能会有影响；</li></ul></li></ul></li><li>多对多模型：两级线程模型<ul><li>优点：兼具前两者的优点</li><li>缺点：实现复杂</li></ul></li></ul></li></ul><p>其中</p><ul><li>Java 使用的是 一对一线程模型</li><li>Go 语言使用的是 多对多线程模型</li><li>Python 的 gevent 使用的多对一线程模型</li></ul><h3 id="2、Java-锁机制"><a href="#2、Java-锁机制" class="headerlink" title="2、Java  锁机制"></a>2、Java  锁机制</h3><p>什么是锁</p><p>Java 锁机制：多线程环境下，加入锁机制，让多线程安全访问和使用共享变量（对资源进行争抢，通过抽象的锁对资源进行锁定）</p><p>JVM 一般在方法区中会存放类信息，常量，静态常量等信息；Java 中争抢的共享资源一般是在这个区域。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161044226.png" alt="image.png"></p><p>了解锁机制前，先了解一下锁和对象的关系；看下面的图：对象 Object 和 锁的存储结构</p><p>锁的信息在对象头中，对象一般有实例对象，对象头，填充字段三部分内容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161046617.png" alt="image.png"></p><p>Java对象保存在内存中时，由以下三部分组成：</p><blockquote><p>1，对象头</p><p>2，实例数据</p><p>3，对齐填充字节</p></blockquote><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161047619.png" alt="image.png"><br>Java 对象头的结构中，是由以下三部分组成：</p><blockquote><p>1，Mark Word</p><p>2，指向类的指针（Class Point)</p><p>3，数组长度（只有数组对象才有）</p></blockquote><p>对象头占用了对象比较少的存储空间，其中Mark Word <strong>在32位JVM中的长度是32bit</strong>，在64位JVM中长度是64bit。</p><p>Mark Word 会记录对象和锁有关的信息，同时需要注意的是 Mark Word在不同的锁状态下存储的内容不同，</p><p>在32位JVM中是这么存的：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161047133.png" alt="image.png"></p><p>当这个对象被synchronized关键字当成同步锁时，围绕这个锁的一系列操作都和Mark Word有关。</p><p>其中无锁和偏向锁的锁标志位都是01，只是在前面的1bit区分了这是无锁状态还是偏向锁状态。</p><p>JDK1.6以后的版本在处理同步锁时存在锁升级的概念，JVM对于同步锁的处理是从偏向锁开始的，随着竞争越来越激烈，处理方式从偏向锁升级到轻量级锁，最终升级到重量级锁。</p><p>这里通过一个程序例子来看 synchronized 反编译后的内容</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SyncDemo02</span>&#123;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">100</span>;i++)&#123;  <br>            <span class="hljs-keyword">synchronized</span> (<span class="hljs-built_in">this</span>)&#123;  <br>                System.out.println(<span class="hljs-string">&quot;thread:&quot;</span> + Thread.currentThread().getId() + <span class="hljs-string">&quot;,num: &quot;</span> + num++);  <br>            &#125;  <br>        &#125;  <br>    &#125;  <br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TestSyncDemo01</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">SyncDemo02</span> <span class="hljs-variable">syncDemo02</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SyncDemo02</span>();  <br>  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                syncDemo02.test();  <br>            &#125;  <br>        &#125;);  <br>  <br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">t2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;  <br>            <span class="hljs-meta">@Override</span>  <br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>                syncDemo02.test();  <br>            &#125;  <br>        &#125;);  <br>  <br>        t1.start();  <br>        t2.start();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>运行后，对类 SyncDemo02 反编译</p><hr><p>参考：</p><ul><li><a href="https://www.bilibili.com/video/BV1aK4y1A7Go/?spm_id_from=333.788&vd_source=6a019ecccfe7d8f62b9a3fe99c723bd0">https://www.bilibili.com/video/BV1aK4y1A7Go/?spm_id_from=333.788&amp;vd_source=6a019ecccfe7d8f62b9a3fe99c723bd0</a></li><li><a href="https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866">https://blog.csdn.net/wang_yong_hui_1234/article/details/130165866</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java并发编程_基础概念</title>
    <link href="/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/15/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>进程和线程</p><ul><li>进程（Process）是系统进行资源分配和调度的基本单位，是操作系统结构的基础。</li><li>线程（Thread）是操作系统能够进行运算调度的最小单位。</li></ul><p>并行和并发的区别</p><ul><li>并行：两个及两个以上的作业在同一 <strong>时刻</strong> 执行。</li><li>并发：两个及两个以上的作业在同一 <strong>时间段</strong> 内执行。</li></ul><p>最关键的点是：是否是 <strong>同时</strong> 执行</p><p>同步和异步的区别</p><ul><li><strong>同步</strong>：发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</li><li><strong>异步</strong>：调用在发出之后，<strong>不用等待返回结果</strong>，该调用直接返回。</li></ul><h3 id="2、什么是Java-线程"><a href="#2、什么是Java-线程" class="headerlink" title="2、什么是Java 线程"></a>2、什么是Java 线程</h3><p>在 JDK 1.2 及以后，Java 线程基于原生线程（Native Threads）实现， JVM 直接使用操作系统原生的内核级线程（内核线程）来实现 Java 线程，由操作系统内核进行线程的调度和管理。</p><p>用一句话概括 Java 线程和操作系统线程的关系：<strong>现在的 Java 线程的本质其实就是操作系统的线程</strong>。</p><p>在 Windows 和 Linux 等主流操作系统中，Java 线程采用的是一对一的线程模型，一个 Java 线程对应一个系统内核线程。</p><h3 id="3、线程的生命周期及五种基本状态"><a href="#3、线程的生命周期及五种基本状态" class="headerlink" title="3、线程的生命周期及五种基本状态"></a>3、线程的生命周期及五种基本状态</h3><p>五种基本状态：新建，就绪，阻塞，运行，死亡</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161130480.png" alt="image.png"></p><p>关于Java中线程的生命周期，首先看一下下面这张较为经典的图：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311161129688.png" alt="image.png"></p><p>上图中基本上囊括了Java中多线程各重要知识点。掌握了上图中的各知识点，Java中的多线程也就基本上掌握了。主要包括：</p><p>Java线程具有五中基本状态</p><ul><li>新建状态（New）<ul><li>当线程对象对创建后，即进入了新建状态，如：Thread t &#x3D; new MyThread();</li></ul></li><li>就绪状态（Runnable）<ul><li>当调用线程对象的start()方法（t.start();），线程即进入就绪状态。</li><li>处于就绪状态的线程，只是说明此线程已经做好了准备，随时等待CPU调度执行，并不是说执行了t.start()此线程立即就会执行；</li></ul></li><li>运行状态（Running）<ul><li>当CPU开始调度处于就绪状态的线程时，此时线程才得以真正执行，即进入到运行状态。</li><li>注：就 绪状态是进入到运行状态的唯一入口，也就是说，线程要想进入运行状态执行，首先必须处于就绪状态中</li></ul></li><li>阻塞状态（Blocked）<ul><li>处于运行状态中的线程由于某种原因，暂时放弃对CPU的使用权，停止执行，此时进入阻塞状态，直到其进入到就绪状态，才 有机会再次被CPU调用以进入到运行状态。</li><li>根据阻塞产生的原因不同，阻塞状态又可以分为三种<ul><li><strong>1.等待阻塞：运行状态中的线程执行wait()方法，使本线程进入到等待阻塞状态</strong>；</li><li><strong>2.同步阻塞 :</strong> 线程在获取synchronized同步锁失败(因为锁被其它线程所占用)，它会进入同步阻塞状态；</li><li><strong>3.其他阻塞 :</strong> 通过调用线程的sleep()或join()或发出了I&#x2F;O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I&#x2F;O处理完毕时，线程重新转入就绪状态。</li></ul></li></ul></li><li>死亡状态（Dead）<ul><li>线程执行完了或者因异常退出了run()方法，该线程结束生命周期。</li></ul></li></ul><blockquote><p>Java多线程的就绪、运行和死亡状态</p></blockquote><p>就绪状态转换为运行状态：当此线程得到处理器资源；</p><p>运行状态转换为就绪状态：当此线程主动调用yield()方法或在运行过程中失去处理器资源。</p><p>运行状态转换为死亡状态：当此线程线程执行体执行完毕或发生了异常。</p><p>此处需要特别注意的是：当调用线程的yield()方法时，线程从运行状态转换为就绪状态，但接下来CPU调度就绪状态中的哪个线程具有一定的随机性，因此，可能会出现A线程调用了yield()方法后，接下来CPU仍然调度了A线程的情况。</p><h3 id="4、创建线程"><a href="#4、创建线程" class="headerlink" title="4、创建线程"></a>4、创建线程</h3><p>在Java中，有三种常见的线程创建方式：使用Thread类、实现Runnable接口和实现Callable接口。</p><ol><li>Thread类：Thread类是 Java 提供的一个线程类，我们可以通过继承Thread类来创建线程。<strong>通过重写Thread类的run()方法来定义线程的执行逻辑</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyThread</span> <span class="hljs-variable">myThread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyThread</span>();<br>myThread.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>Runnable接口：Runnable接口是一个函数式接口，我们可以通过实现Runnable接口来创建线程。需要注意的是，Runnable接口并不是一个线程类，<strong>而是一个任务，需要通过Thread类来创建线程</strong>并执行任务。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyRunnable</span> <span class="hljs-variable">myRunnable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyRunnable</span>();<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(myRunnable);<br>thread.start();<br></code></pre></td></tr></table></figure><ol start="3"><li>Callable接口：Callable接口也是一个函数式接口，与Runnable接口类似，可以通过实现Callable接口来创建线程。不同的是，<strong>Callable接口的call()方法可以返回一个结果，并且可以抛出异常</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyCallable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Callable</span>&lt;Integer&gt; &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Integer <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-comment">// 线程的执行逻辑</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>; <span class="hljs-comment">// 返回一个结果</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程</span><br><span class="hljs-type">MyCallable</span> <span class="hljs-variable">myCallable</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyCallable</span>();<br><span class="hljs-type">ExecutorService</span> <span class="hljs-variable">executorService</span> <span class="hljs-operator">=</span> Executors.newSingleThreadExecutor();<br>Future&lt;Integer&gt; future = executorService.submit(myCallable);<br></code></pre></td></tr></table></figure><ul><li>使用Thread类创建线程是最直接的方式，但是由于Java不支持多继承，所以如果已经有一个父类，就不能再直接使用Thread类创建线程。</li><li>实现Runnable接口是一种更加灵活的方式，可以避免单继承的限制，还可以共享数据。</li><li>Callable接口与Runnable接口类似，但可以返回一个结果，并且可以抛出异常。可以通过ExecutorService的submit()方法来执行Callable任务，并返回一个Future对象，可以通过该对象获取任务的结果。</li></ul><blockquote><p>写法简化（Java 8)</p></blockquote><ul><li><strong>方式一：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>()&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>);<br>    &#125;<br>&#125;;<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;thread run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式二：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123; <br>        System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>);<br>    &#125;<br>&#125;);<br><br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(() -&gt; System.out.println(<span class="hljs-string">&quot;runnable run ...&quot;</span>));<br><br>thread.start();<br></code></pre></td></tr></table></figure><ul><li><strong>方式三：</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Callable&lt;Integer&gt; callable = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Callable</span>() &#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123; <br>        System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-type">FutureTask</span> <span class="hljs-variable">futureTask</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(callable);<br><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(futureTask);<br>thread.start();<br></code></pre></td></tr></table></figure><p>简化后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Thread</span> <span class="hljs-variable">thread</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Thread</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureTask</span>(() -&gt; &#123; <br>    System.out.println(<span class="hljs-string">&quot;callable run ...&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">521</span>;<br>&#125;));<br><br>thread.start();<br></code></pre></td></tr></table></figure><h3 id="5、线程基本方法"><a href="#5、线程基本方法" class="headerlink" title="5、线程基本方法"></a>5、线程基本方法</h3><blockquote><p>注意：标黄色的方法代表是 <code>static</code>​ 方法，可直接类名调用，无需创建对象。</p></blockquote><table><thead><tr><th>名称</th><th>描述</th><th>注意事项</th></tr></thead><tbody><tr><td>​<code>start()</code>​</td><td>启动一个新线程，<br />在新的线程运行 run 方法</td><td>start 方法只是让线程进入就绪，里面代码不一定立刻<br />运行（CPU 的时间片还没分给它）。每个线程对象的<br />start方法只能调用一次，如果调用了多次会出现<br />IllegalThreadStateException</td></tr><tr><td>​<code>run()</code>​</td><td>新线程启动后会调用的方法</td><td>如果在构造 Thread 对象时传递了 Runnable 参数，则<br />线程启动后会调用 Runnable 中的 run 方法，否则默<br />认不执行任何操作。但可以创建 Thread 的子类对象，<br />来覆盖默认行为</td></tr><tr><td>​<code>join()</code>​</td><td>等待线程运行结束</td><td></td></tr><tr><td>​<code>join(long n)</code>​</td><td>等待线程运行结束，<br />最多等待 n 毫秒</td><td></td></tr><tr><td>​<code>getId()</code>​</td><td>获取线程长整型的 id</td><td>id 唯一</td></tr><tr><td>​<code>getName()</code>​</td><td>获取线程名</td><td></td></tr><tr><td>​<code>setName(String name)</code>​</td><td>修改线程名</td><td></td></tr><tr><td>​<code>getPriority()</code>​</td><td>获取线程优先级</td><td></td></tr><tr><td>​<code>setPriority(int priority)</code>​</td><td>修改线程优先级</td><td>Java 中规定线程优先级是1~10 的整数，较大的优先级<br />能提高该线程被 CPU 调度的机率</td></tr><tr><td>​<code>getState()</code>​</td><td>获取线程状态</td><td>Java 中线程状态是用 6 个 enum 表示，分别为：<br />NEW, RUNNABLE, BLOCKED, WAITING,<br />TIMED_WAITING, TERMINATED</td></tr><tr><td>​<code>interrupt()</code>​</td><td>打断线程</td><td>如果被打断线程正在 sleep，wait，join 会导致被<br />打断的线程抛出 InterruptedException，并清除<br />打断标记；如果打断正在运行的线程，则会设置<br />打断标记；park 的线程被打断，也会设置打断标记</td></tr><tr><td><font color=Coral>interrupted()</font></td><td>判断当前线程是否被打断</td><td>会清除打断标记</td></tr><tr><td>​<code>isInterrupted()</code>​</td><td>判断当前线程是否被打断</td><td>不会清除打断标记</td></tr><tr><td>​<code>isAlive()</code>​</td><td>判断当前线程是否存活</td><td></td></tr><tr><td>​<code>isDaemon()</code>​</td><td>判断当前线程是否是守护线程</td><td></td></tr><tr><td>​<code>setDaemon(boolean on)</code>​</td><td>设置当前线程为守护线程</td><td></td></tr><tr><td><font color=Coral>currentThread()</font></td><td>获取当前正在执行的线程</td><td></td></tr><tr><td><font color=Coral>sleep(long n)</font></td><td>让当前执行的线程休眠n毫秒，<br />休眠时让出 CPU 的时间片<br />给其它线程</td><td></td></tr><tr><td><font color=Coral>yield()</font></td><td>提示线程调度器让出当前线程<br />对 CPU 的使用</td><td>主要是为了测试和调试，它的具体的实现依赖于<br />操作系统的任务调度器</td></tr></tbody></table><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html">https://javaguide.cn/java/concurrent/java-concurrent-questions-01.html</a></li><li><a href="https://www.cnblogs.com/fmgao-technology/p/11077543.html">https://www.cnblogs.com/fmgao-technology/p/11077543.html</a></li><li><a href="https://caochenlei.blog.csdn.net/article/details/119992847">https://caochenlei.blog.csdn.net/article/details/119992847</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>thread</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_HashMap学习</title>
    <link href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>HashMap 主要用来存放键值对，基于哈希表的 Map 接口实现，是常用的 Java 集合之一。</p><p>HashMap是非线程安全的，效率较高。</p><p>它可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个</p><p><strong>底层数据结构</strong>：</p><ul><li>JDK1.8 之前 HashMap 由 数组+链表 组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。</li><li>JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于等于阈值（默认为 8）（将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</li></ul><p><strong>扩充机制</strong>：<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。并且， <code>HashMap</code> 总是使用 2 的幂作为哈希表的大小。</p><blockquote><p>HashMap的常用方法</p></blockquote><p>1、put(K key, V value)： 将键（key）&#x2F;值（value）映射存放到Map集合中。</p><p>2、get(Object key)： 返回指定键所映射的值，没有该key对应的值则返回 null。</p><p>3、size()： 返回Map集合中数据数量。</p><p>4、clear()： 清空Map集合。</p><p>5、isEmpty()： 判断Map集合中是否有数据，如果没有则返回true，否则返回false。</p><p>6、remove(Object key)： 删除Map集合中键为key的数据并返回其所对应value值。</p><p>7、values()： 返回Map集合中所有value组成的以Collection数据类型格式数据。</p><p>8、containsKey(Object key)： 判断集合中是否包含指定键，包含返回 true，否则返回false。</p><p>9、containsValue(Object value)： 判断集合中是否包含指定值，包含返回 true，否则返回false。</p><p>10、keySet()： 返回Map集合中所有key组成的Set集合。</p><p>11、entrySet()： 将Map集合每个key-value转换为一个Entry对象并返回由所有的Entry对象组成的Set集合。</p><blockquote><p>HashMap 常用方法测试</p></blockquote><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs sas">package map;<br><br>import java.util.Collection;<br>import java.util.HashMap;<br>import java.util.<span class="hljs-keyword">Set</span>;<br><br>public class HashMapDemo &#123;<br><br>    public static void mai<span class="hljs-meta">n</span>(String[] args) &#123;<br>        HashMap&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();<br>        // 键不能重复，值可以重复<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;san&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wu&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;wang&quot;</span>, <span class="hljs-string">&quot;老王2&quot;</span>);// 老王被覆盖<br>        map.<span class="hljs-meta">put</span>(<span class="hljs-string">&quot;lao&quot;</span>, <span class="hljs-string">&quot;老王&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------直接输出hashmap:-------&quot;</span>);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 遍历HashMap</span><br><span class="hljs-comment">         */</span><br>        // 1.获取Map中的所有键<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的键:------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span>+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 2.获取Map中所有值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------foreach获取Map中所有的值:------&quot;</span>);<br>        Collection&lt;String&gt; values = map.values();<br>        for (String value : values) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(value+<span class="hljs-string">&quot;  &quot;</span>);<br>        &#125;<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>();//换行<br>        // 3.得到<span class="hljs-keyword">key</span>的值的同时得到<span class="hljs-keyword">key</span>所对应的值<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;-------得到key的值的同时得到key所对应的值:-------&quot;</span>);<br>        <span class="hljs-keyword">Set</span>&lt;String&gt; keys2 = map.keySet();<br>        for (String <span class="hljs-keyword">key</span> : keys2) &#123;<br>            System.<span class="hljs-keyword">out</span>.pr<span class="hljs-meta">int</span>(<span class="hljs-keyword">key</span> + <span class="hljs-string">&quot;：&quot;</span> + map.get(<span class="hljs-keyword">key</span>)+<span class="hljs-string">&quot;   &quot;</span>);<br><br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 如果既要遍历key又要value，那么建议这种方式，因为如果先获取keySet然后再执行map.get(key)，map内部会执行两次遍历。</span><br><span class="hljs-comment">         * 一次是在获取keySet的时候，一次是在遍历所有key的时候。</span><br><span class="hljs-comment">         */</span><br>        // 当我调用<span class="hljs-meta">put</span>(<span class="hljs-keyword">key</span>,value)方法的时候，首先会把<span class="hljs-keyword">key</span>和value封装到<br>        // Entry这个静态内部类对象中，把Entry对象再添加到数组中，所以我们想获取<br>        // map中的所有键值对，我们只要获取数组中的所有Entry对象，接下来<br>        // 调用Entry对象中的getKey()和getValue()方法就能获取键值对了<br>        <span class="hljs-keyword">Set</span>&lt;java.util.Map.Entry&lt;String, String&gt;&gt; entrys = map.entrySet();<br>        for (java.util.Map.Entry&lt;String, String&gt; entry : entrys) &#123;<br>            System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(entry.getKey() + <span class="hljs-string">&quot;--&quot;</span> + entry.getValue());<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * HashMap其他常用方法</span><br><span class="hljs-comment">         */</span><br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.size()：&quot;</span>+map.size());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.isEmpty()：&quot;</span>+map.isEmpty());<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">remove</span>(<span class="hljs-string">&quot;san&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.remove()：&quot;</span>+map);<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.get(si)：&quot;</span>+map.get(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.containsKey(si)：&quot;</span>+map.containsKey(<span class="hljs-string">&quot;si&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after containsValue(李四)：&quot;</span>+map.containsValue(<span class="hljs-string">&quot;李四&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(map.<span class="hljs-keyword">replace</span>(<span class="hljs-string">&quot;si&quot;</span>, <span class="hljs-string">&quot;李四2&quot;</span>));<br>        System.<span class="hljs-keyword">out</span>.printl<span class="hljs-meta">n</span>(<span class="hljs-string">&quot;after map.replace(si, 李四2):&quot;</span>+map);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2、底层数据结构"><a href="#2、底层数据结构" class="headerlink" title="2、底层数据结构"></a>2、底层数据结构</h3><h4 id="JDK1-8-之前"><a href="#JDK1-8-之前" class="headerlink" title="JDK1.8 之前"></a>JDK1.8 之前</h4><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用（ <strong>链表散列</strong>）。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115224010.png" alt="image.png"></p><p>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，<strong>如果相同的话，直接覆盖</strong>，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 HashMap 的 hash 方法。</p><p>使用 hash 方法（扰动函数）是为了防止一些实现比较差的 hashCode() 方法 ，使用扰动函数之后可以减少碰撞。</p><p>所谓 <strong>“拉链法”</strong> 是：将链表和数组相结合。也就是说创建一个链表数组，<strong>数组中每一格就是一个链表</strong>。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><p><strong>hash 方法</strong></p><p>JDK 1.8 HashMap 的 hash 方法源码:</p><p>JDK 1.8 的 hash 方法 相比于 JDK 1.7 hash 方法更加简化，但是原理不变</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs processing">  <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-type">int</span> h;<br>    <span class="hljs-comment">// key.hashCode()：返回散列值也就是hashcode</span><br>    <span class="hljs-comment">// ^：按位异或</span><br>    <span class="hljs-comment">// &gt;&gt;&gt;:无符号右移，忽略符号位，空位都以0补齐</span><br>    <span class="hljs-title function_">return</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : (h = <span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>()) ^ (h &gt;&gt;&gt; <span class="hljs-number">16</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p> JDK1.7 的 HashMap 的 hash 方法源码.</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hash</span><span class="hljs-params">(<span class="hljs-type">int</span> h)</span> </span>&#123;<br>    <span class="hljs-comment">// This function ensures that hashCodes that differ only by</span><br>    <span class="hljs-comment">// constant multiples at each bit position have a bounded</span><br>    <span class="hljs-comment">// number of collisions (approximately 8 at default load factor).</span><br><br>    h ^= (h &gt;&gt;&gt; <span class="hljs-number">20</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">12</span>);<br>    <span class="hljs-keyword">return</span> h ^ (h &gt;&gt;&gt; <span class="hljs-number">7</span>) ^ (h &gt;&gt;&gt; <span class="hljs-number">4</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>相比于 JDK1.8 的 hash 方法 ，JDK 1.7 的 hash 方法的性能稍差一点，因为毕竟扰动了 4 次。</p><h4 id="JDK1-8-之后"><a href="#JDK1-8-之后" class="headerlink" title="JDK1.8 之后"></a>JDK1.8 之后</h4><p>当链表长度大于阈值（默认为 8）时，会首先调用 <code>treeifyBin()</code>方法。</p><p>这个方法会根据 HashMap 数组来决定是否转换为红黑树。只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。</p><p>否则，就是只是执行 <code>resize()</code> 方法对数组扩容。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115223309.png" alt="image.png"></p><h4 id="HashMap-的类属性"><a href="#HashMap-的类属性" class="headerlink" title="HashMap 的类属性"></a>HashMap 的类属性</h4><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">HashMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">extends</span> <span class="hljs-symbol">AbstractMap</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt; <span class="hljs-symbol">implements</span> <span class="hljs-symbol">Map</span>&lt;<span class="hljs-symbol">K,<span class="hljs-symbol">V</span></span>&gt;, <span class="hljs-symbol">Cloneable, <span class="hljs-symbol">Serializable</span></span> &#123;<br>    <span class="hljs-comment">// 序列号</span><br>    <span class="hljs-keyword">private</span> static <span class="hljs-keyword">final</span> long serialVersionUID = <span class="hljs-number">362498820763181265</span>L;<br>    <span class="hljs-comment">// 默认的初始容量是16</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> DEFAULT_INITIAL_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">4</span>;<br>    <span class="hljs-comment">// 最大容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br>    <span class="hljs-comment">// 默认的负载因子</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75f</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数大于等于这个值时会转成红黑树</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> TREEIFY_THRESHOLD = <span class="hljs-number">8</span>;<br>    <span class="hljs-comment">// 当桶(bucket)上的结点数小于等于这个值时树转链表</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> UNTREEIFY_THRESHOLD = <span class="hljs-number">6</span>;<br>    <span class="hljs-comment">// 桶中结构转化为红黑树对应的table的最小容量</span><br>    static <span class="hljs-keyword">final</span> <span class="hljs-built_in">int</span> MIN_TREEIFY_CAPACITY = <span class="hljs-number">64</span>;<br>    <span class="hljs-comment">// 存储元素的数组，总是2的幂次倍</span><br>    transient Node&lt;k,v&gt;[] table;<br>    <span class="hljs-comment">// 存放具体元素的集</span><br>    transient Set&lt;map.entry&lt;k,v&gt;&gt; entrySet;<br>    <span class="hljs-comment">// 存放元素的个数，注意这个不等于数组的长度。</span><br>    transient <span class="hljs-built_in">int</span> size;<br>    <span class="hljs-comment">// 每次扩容和更改map结构的计数器</span><br>    transient <span class="hljs-built_in">int</span> modCount;<br>    <span class="hljs-comment">// 阈值(容量*负载因子) 当实际大小超过阈值时，会进行扩容</span><br>    <span class="hljs-built_in">int</span> threshold;<br>    <span class="hljs-comment">// 负载因子</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-built_in">float</span> loadFactor;<br>&#125;<br></code></pre></td></tr></table></figure><p>几个重要的字段</p><ul><li>loadFactor   负载因子</li><li>threshold   阈值（HashMap 实际能存储的大小）</li><li>DEFAULT_INITIAL_CAPACITY  默认初始容量</li><li>MAXIMUM_CAPACITY  最大容量</li><li>size   HashMap实际存储的元素个数</li><li>modCount     HashMap的结构被修改的次数，用于迭代器</li></ul><blockquote><p>loadFactor 负载因子</p></blockquote><p>loadFactor 负载因子 是控制数组存放数据的疏密程度，loadFactor 越趋近于 1，那么 数组中存放的数据(entry)也就越多，也就越密，也就是会让链表的长度增加，loadFactor 越小，也就是趋近于 0，数组中存放的数据(entry)也就越少，也就越稀疏。</p><p>loadFactor 太大导致查找元素效率低，太小导致数组的利用率低，存放的数据会很分散。<strong>loadFactor 的默认值为 0.75f</strong> ，是官方给出的一个比较好的临界值。</p><p>HashMap 给定的默认容量为 16，负载因子为 0.75。<br>Map 在使用过程中不断的往里面存放数据，当数量超过了 16 * 0.75 &#x3D; 12 , 就需要将当前 16 的容量进行扩容，而扩容这个过程涉及到 rehash、复制数据等操作，所以非常消耗性能。</p><blockquote><p>threshold   阈值</p></blockquote><p><strong>threshold &#x3D; capacity * loadFactor</strong>，阈值(容量 * 负载因子) </p><p>当实际大小超过阈值时，就要考虑对数组的扩增。阈值是衡量数组是否需要扩增的一个标准。</p><h4 id="Node-节点类源码"><a href="#Node-节点类源码" class="headerlink" title="Node 节点类源码"></a>Node 节点类源码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 继承自 Map.Entry&lt;K,V&gt;</span><br>static <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span>&lt;<span class="hljs-type">K,V</span>&gt; <span class="hljs-title">implements</span> <span class="hljs-title">Map</span>.<span class="hljs-title">Entry</span>&lt;<span class="hljs-type">K,V</span>&gt; &#123;<br>       <span class="hljs-keyword">final</span> int hash;<span class="hljs-comment">// 哈希值，存放元素到hashmap中时用来与其他元素hash值比较</span><br>       <span class="hljs-keyword">final</span> K key;<span class="hljs-comment">//键</span><br>       V value;<span class="hljs-comment">//值</span><br>       <span class="hljs-comment">// 指向下一个节点</span><br>       Node&lt;K,V&gt; next;<br>       <br>       Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;<br>            <span class="hljs-keyword">this</span>.hash = hash;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.value = value;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> K getKey()        &#123; <span class="hljs-keyword">return</span> key; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V getValue()      &#123; <span class="hljs-keyword">return</span> value; &#125;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String toString() &#123; <span class="hljs-keyword">return</span> key + <span class="hljs-string">&quot;=&quot;</span> + value; &#125;<br>        <span class="hljs-comment">// 重写hashCode()方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> int hashCode() &#123;<br>            <span class="hljs-keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);<br>        &#125;<br><br><span class="hljs-comment">//相当于把原来的值给覆盖掉，但是返回被覆盖掉的值</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> V setValue(V newValue) &#123;<br>            V oldValue = value;<br>            value = newValue;<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>        <br>        <span class="hljs-comment">// 重写 equals() 方法</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> boolean equals(Object o) &#123;<br>            <span class="hljs-keyword">if</span> (o == <span class="hljs-keyword">this</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (o instanceof Map.Entry) &#123;<br>                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;<br>                <span class="hljs-keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;<br>                    Objects.equals(value, e.getValue()))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="树节点类源码"><a href="#树节点类源码" class="headerlink" title="树节点类源码"></a>树节点类源码</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs scala">static <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode&lt;K</span>,<span class="hljs-title">V&gt;</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;</span> </span>&#123;<br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; parent;  <span class="hljs-comment">// 父</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; left;    <span class="hljs-comment">// 左</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; right;   <span class="hljs-comment">// 右</span><br>        <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; prev;    <span class="hljs-comment">// needed to unlink next upon deletion</span><br>        boolean red;           <span class="hljs-comment">// 判断颜色</span><br>        <span class="hljs-type">TreeNode</span>(int hash, <span class="hljs-type">K</span> key, <span class="hljs-type">V</span> <span class="hljs-keyword">val</span>, <span class="hljs-type">Node</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next) &#123;<br>            <span class="hljs-keyword">super</span>(hash, key, <span class="hljs-keyword">val</span>, next);<br>        &#125;<br>        <br>        <span class="hljs-comment">// 返回根节点</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; root() &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">TreeNode</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; r = <span class="hljs-keyword">this</span>, p;;) &#123;<br>                <span class="hljs-keyword">if</span> ((p = r.parent) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span> r;<br>                r = p;<br>       &#125;<br><br></code></pre></td></tr></table></figure><h3 id="3、HashMap-源码分析"><a href="#3、HashMap-源码分析" class="headerlink" title="3、HashMap 源码分析"></a>3、HashMap 源码分析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>HashMap 中有四个构造方法，它们分别如下：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="hljs-number">0.75</span>f;<br><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> MAXIMUM_CAPACITY = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">30</span>;<br><br><span class="hljs-keyword">int</span> threshold;<br>   <br>   <span class="hljs-comment">// 默认构造函数。</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="hljs-comment">// all   other fields defaulted</span><br>    &#125;<br><br>    <span class="hljs-comment">// 包含另一个“Map”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;<br>        putMapEntries(m, <span class="hljs-keyword">false</span>);<span class="hljs-comment">//下面会分析</span><br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);<br>    &#125;<br><br>    <span class="hljs-comment">// 指定“容量大小”和“负载因子”的构造函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HashMap</span><span class="hljs-params">(<span class="hljs-keyword">int</span> initialCapacity, <span class="hljs-keyword">float</span> loadFactor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (initialCapacity &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal initial capacity: &quot;</span> + initialCapacity);<br>        <span class="hljs-keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)<br>            initialCapacity = MAXIMUM_CAPACITY;<br>        <span class="hljs-keyword">if</span> (loadFactor &lt;= <span class="hljs-number">0</span> || Float.isNaN(loadFactor))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;Illegal load factor: &quot;</span> + loadFactor);<br>        <span class="hljs-comment">//指定负载因子</span><br>        <span class="hljs-keyword">this</span>.loadFactor = loadFactor;<br>        <span class="hljs-comment">// 初始容量暂时存放到 threshold ，在 resize 中再赋值给 newCap 进行table初始化</span><br>        <span class="hljs-keyword">this</span>.threshold = tableSizeFor(initialCapacity);<br>    &#125;<br></code></pre></td></tr></table></figure><p>上面第二个构造函数中调用了 putMapEntries 方法，下面进行分析：</p><p><strong>putMapEntries 方法</strong></p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">transient</span> Node&lt;K,V&gt;[] table;<br><br><span class="hljs-keyword">final</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">putMapEntries</span><span class="hljs-params">(Map&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; m, <span class="hljs-keyword">boolean</span> evict)</span> </span>&#123;  <br>    <span class="hljs-keyword">int</span> s = m.size();  <br>    <span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">0</span>) &#123;  <br>        <span class="hljs-comment">// 判断table是否已经初始化</span><br>        <span class="hljs-keyword">if</span> (table == <span class="hljs-keyword">null</span>) &#123; <span class="hljs-comment">// pre-size  </span><br>            <span class="hljs-comment">//如果未初始化，s 为 m 的实际元素个数；ft=s/loadFactor =&gt; s=ft*loadFactor；其中 ft 指的是要添加 s 个元素所需要的最小的容量</span><br>            <span class="hljs-keyword">float</span> ft = ((<span class="hljs-keyword">float</span>)s / loadFactor) + <span class="hljs-number">1.0</span>F;  <br>            <span class="hljs-comment">//与最大容量作比较，如果小于则 t 为 ft，否则为 MAXIMUM_CAPACITY</span><br>            <span class="hljs-keyword">int</span> t = ((ft &lt; (<span class="hljs-keyword">float</span>)MAXIMUM_CAPACITY) ?  <br>                     (<span class="hljs-keyword">int</span>)ft : MAXIMUM_CAPACITY);  <br>            <span class="hljs-comment">//根据上面的构造函数，可以得知此时 table 未初始化，threshold 实际上是存放的初始化容量</span><br>            <span class="hljs-comment">//如果添加s个元素所需的最小容量大于初始化容量，则将最小容量扩容为最接近的2的幂次方大小作为初始化。（注意这里不是初始化阈值）</span><br>            <span class="hljs-keyword">if</span> (t &gt; threshold)  <br>                threshold = tableSizeFor(t);  <br>        &#125;  <br>        <span class="hljs-comment">// 如果已经初始化，并且m元素个数大于阈值，进行扩容处理</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s &gt; threshold)  <br>            resize();  <br>        <span class="hljs-comment">// 将m中的所有元素添加至HashMap中，如果table未初始化，putVal中会调用resize初始化或扩容    </span><br>        <span class="hljs-keyword">for</span> (Map.Entry&lt;? <span class="hljs-keyword">extends</span> K, ? <span class="hljs-keyword">extends</span> V&gt; e : m.entrySet()) &#123;  <br>            K key = e.getKey();  <br>            V value = e.getValue();  <br>            putVal(hash(key), key, value, <span class="hljs-keyword">false</span>, evict);  <br>        &#125;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>tableSizeFor 方法：返回一个最接近 cap 的2的幂次方大小数值</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs excel">static final <span class="hljs-built_in">int</span> tableSizeFor(<span class="hljs-built_in">int</span> cap) &#123;  <br>    <span class="hljs-built_in">int</span> <span class="hljs-built_in">n</span> = cap - <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">1</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">2</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">4</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">8</span>;  <br>    <span class="hljs-built_in">n</span> |= <span class="hljs-built_in">n</span> &gt;&gt;&gt; <span class="hljs-number">16</span>;  <br>    return (<span class="hljs-built_in">n</span> &lt; <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> <span class="hljs-symbol">:</span> (<span class="hljs-built_in">n</span> &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY <span class="hljs-symbol">:</span> <span class="hljs-built_in">n</span> + <span class="hljs-number">1</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put 方法"></a>put 方法</h4><p>HashMap 只提供了 put 用于添加元素，putVal 方法是 put 方法调用的一个方法，并没有提供给用户使用。</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs maxima">public V <span class="hljs-built_in">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-built_in">return</span> putVal(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>, value, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>putVal 方法 图解</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/20231115230931.png" alt="image.png"></p><p>putVal 方法添加元素分析：</p><ul><li>如果定位到的数组位置没有元素 就直接插入。</li><li>如果定位到的数组位置有元素就和要插入的 key 比较，<ul><li>如果 key 相同就直接覆盖，</li><li>如果 key 不相同，就判断 p 是否是一个树节点，<ul><li>如果是就调用<code>e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value)</code>将元素添加进入。</li><li>如果不是就遍历链表插入(插入的是链表尾部)。</li></ul></li></ul></li></ul><blockquote><p>putVal 方法</p></blockquote><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs arcade">final V putVal(int <span class="hljs-built_in">hash</span>, K key, V value, <span class="hljs-built_in">boolean</span> onlyIfAbsent,<br>                   <span class="hljs-built_in">boolean</span> evict) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; p; int n, i;<br>    <span class="hljs-comment">// table未初始化或者长度为0，进行扩容</span><br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) == <span class="hljs-literal">null</span> || (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) == <span class="hljs-number">0</span>)<br>        n = (<span class="hljs-literal">tab</span> = <span class="hljs-built_in">resize</span>()).<span class="hljs-built_in">length</span>;<br>    <span class="hljs-comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span><br>    <span class="hljs-keyword">if</span> ((p = <span class="hljs-literal">tab</span>[i = (n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) == <span class="hljs-literal">null</span>)<br>        <span class="hljs-literal">tab</span>[i] = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>    <span class="hljs-comment">// 桶中已经存在元素（处理hash冲突）</span><br>    <span class="hljs-keyword">else</span> &#123;<br>        Node&lt;K,V&gt; e; K k;<br>        <span class="hljs-comment">//快速判断第一个节点table[i]的key是否与插入的key一样，若相同就直接使用插入的值p替换掉旧的值e。</span><br>        <span class="hljs-keyword">if</span> (p.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>            ((k = p.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                e = p;<br>        <span class="hljs-comment">// 判断插入的是否是红黑树节点</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p instanceof TreeNode)<br>            <span class="hljs-comment">// 放入树中</span><br>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, <span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>, key, value);<br>        <span class="hljs-comment">// 不是红黑树节点则说明为链表结点</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 在链表最末插入结点</span><br>            <span class="hljs-keyword">for</span> (int binCount = <span class="hljs-number">0</span>; ; ++binCount) &#123;<br>                <span class="hljs-comment">// 到达链表的尾部</span><br>                <span class="hljs-keyword">if</span> ((e = p.next) == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 在尾部插入新结点</span><br>                    p.next = newNode(<span class="hljs-built_in">hash</span>, key, value, <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 结点数量达到阈值(默认为 8 )，执行 treeifyBin 方法</span><br>                    <span class="hljs-comment">// 这个方法会根据 HashMap 数组来决定是否转换为红黑树。</span><br>                    <span class="hljs-comment">// 只有当数组长度大于或者等于 64 的情况下，才会执行转换红黑树操作，以减少搜索时间。否则，就是只是对数组扩容。</span><br>                    <span class="hljs-keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="hljs-number">1</span>) <span class="hljs-comment">// -1 for 1st</span><br>                        treeifyBin(<span class="hljs-literal">tab</span>, <span class="hljs-built_in">hash</span>);<br>                    <span class="hljs-comment">// 跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span><br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-comment">// 相等，跳出循环</span><br>                    <span class="hljs-keyword">break</span>;<br>                <span class="hljs-comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span><br>                p = e;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">// 表示在桶中找到key值、hash值与插入元素相等的结点</span><br>        <span class="hljs-keyword">if</span> (e != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录e的value</span><br>            V oldValue = e.value;<br>            <span class="hljs-comment">// onlyIfAbsent为false或者旧值为null</span><br>            <span class="hljs-keyword">if</span> (!onlyIfAbsent || oldValue == <span class="hljs-literal">null</span>)<br>                <span class="hljs-comment">//用新值替换旧值</span><br>                e.value = value;<br>            <span class="hljs-comment">// 访问后回调</span><br>            afterNodeAccess(e);<br>            <span class="hljs-comment">// 返回旧值</span><br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 结构性修改</span><br>    ++modCount;<br>    <span class="hljs-comment">// 实际大小大于阈值则扩容</span><br>    <span class="hljs-keyword">if</span> (++size &gt; threshold)<br>        <span class="hljs-built_in">resize</span>();<br>    <span class="hljs-comment">// 插入后回调</span><br>    afterNodeInsertion(evict);<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>对比 JDK1.7 put 方法的代码</strong></p></blockquote><p><strong>对于 put 方法的分析如下：</strong></p><ul><li>① 如果定位到的数组位置没有元素 就直接插入。</li><li>② 如果定位到的数组位置有元素，遍历以这个元素为头结点的链表，依次和插入的 key 比较，如果 key 相同就直接覆盖，不同就采用头插法插入元素。</li></ul><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value)<br>    <span class="hljs-keyword">if</span> (table == EMPTY_TABLE) &#123;<br>    <span class="hljs-title function_">inflateTable</span>(threshold);<br>&#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>    <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123; <span class="hljs-comment">// 先遍历</span><br>        <span class="hljs-built_in">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>            V oldValue = e.<span class="hljs-property">value</span>;<br>            e.<span class="hljs-property">value</span> = value;<br>            e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>            <span class="hljs-keyword">return</span> oldValue;<br>        &#125;<br>    &#125;<br><br>    modCount++;<br>    <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);  <span class="hljs-comment">// 再插入</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get 方法"></a>get 方法</h4><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs arcade">public V get(Object key) &#123;<br>    Node&lt;K,V&gt; e;<br>    <span class="hljs-keyword">return</span> (e = getNode(<span class="hljs-built_in">hash</span>(key), key)) == <span class="hljs-literal">null</span> ? <span class="hljs-literal">null</span> : e.value;<br>&#125;<br><br>final Node&lt;K,V&gt; getNode(int <span class="hljs-built_in">hash</span>, Object key) &#123;<br>    Node&lt;K,V&gt;[] <span class="hljs-literal">tab</span>; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; int n; K k;<br>    <span class="hljs-keyword">if</span> ((<span class="hljs-literal">tab</span> = table) != <span class="hljs-literal">null</span> &amp;&amp; (n = <span class="hljs-literal">tab</span>.<span class="hljs-built_in">length</span>) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = <span class="hljs-literal">tab</span>[(n - <span class="hljs-number">1</span>) &amp; <span class="hljs-built_in">hash</span>]) != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 数组元素相等</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span>.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">first</span>;<br>        <span class="hljs-comment">// 桶中不止一个节点</span><br>        <span class="hljs-keyword">if</span> ((e = <span class="hljs-built_in">first</span>.next) != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 在树中get</span><br>            <span class="hljs-keyword">if</span> (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                <span class="hljs-keyword">return</span> ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(<span class="hljs-built_in">hash</span>, key);<br>            <span class="hljs-comment">// 在链表中get</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (e.<span class="hljs-built_in">hash</span> == <span class="hljs-built_in">hash</span> &amp;&amp;<br>                    ((k = e.key) == key || (key != <span class="hljs-literal">null</span> &amp;&amp; key.<span class="hljs-built_in">equals</span>(k))))<br>                    <span class="hljs-keyword">return</span> e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.next) != <span class="hljs-literal">null</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize 方法"></a>resize 方法</h4><p>进行扩容，会伴随着一次重新 hash 分配，并且会遍历 hash 表中所有的元素，是非常耗时的。在编写程序中，要尽量避免 resize。</p><p>resize 方法实际上是将 table 初始化和 table 扩容 进行了整合，底层的行为都是给 table 赋值一个新的数组。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;<br>    Node&lt;K,V&gt;[] oldTab = table;<br>    int oldCap = (oldTab == <span class="hljs-literal">null</span>) ? <span class="hljs-number">0</span> : <span class="hljs-type">oldTab</span>.length;<br>    int oldThr = threshold;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (oldCap &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 超过最大值就不再扩充了，就只好随你碰撞去吧</span><br>        <span class="hljs-keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<br>            threshold = Integer.MAX_VALUE;<br>            <span class="hljs-keyword">return</span> oldTab;<br>        &#125;<br>        <span class="hljs-comment">// 没超过最大值，就扩充为原来的2倍</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldCap &lt;&lt; <span class="hljs-number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = oldThr &lt;&lt; <span class="hljs-number">1</span>; <span class="hljs-comment">// double threshold</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (oldThr &gt; <span class="hljs-number">0</span>) <span class="hljs-comment">// initial capacity was placed in threshold</span><br>        <span class="hljs-comment">// 创建对象时初始化容量大小放在threshold中，此时只需要将其作为新的数组容量</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = oldThr;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// signifies using defaults 无参构造函数创建的对象在这里计算容量和阈值</span><br>        <span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> = DEFAULT_INITIAL_CAPACITY;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// 创建时指定了初始化容量或者负载因子，在这里进行阈值初始化，</span><br>    <span class="hljs-comment">// 或者扩容前的旧容量小于16，在这里计算新的resize上限</span><br>        float ft = (float)<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> * loadFactor;<br>        <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span> = (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : <span class="hljs-type">Integer</span>.MAX_VALUE);<br>    &#125;<br>    threshold = <span class="hljs-keyword">new</span><span class="hljs-type">Thr</span>;<br>    <span class="hljs-meta">@SuppressWarnings</span>(&#123;<span class="hljs-string">&quot;rawtypes&quot;</span>,<span class="hljs-string">&quot;unchecked&quot;</span>&#125;)<br>        Node&lt;K,V&gt;[] <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span> = (Node&lt;K,V&gt;[])<span class="hljs-keyword">new</span> <span class="hljs-type">Node</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span>];<br>    table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>    <span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 把每个bucket都移动到新的buckets中</span><br>        <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>            Node&lt;K,V&gt; e;<br>            <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>                oldTab[j] = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-comment">// 只有一个节点，直接计算元素新的位置即可</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                    <span class="hljs-comment">// 将红黑树拆分成2棵子树，如果子树节点数小于等于 UNTREEIFY_THRESHOLD（默认为 6），则将子树转换为链表。</span><br>                    <span class="hljs-comment">// 如果子树节点数大于 UNTREEIFY_THRESHOLD，则保持子树的树结构。</span><br>                    ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>                <span class="hljs-keyword">else</span> &#123;<br>                    Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                    Node&lt;K,V&gt; next;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        next = e.next;<br>                        <span class="hljs-comment">// 原索引</span><br>                        <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                                loHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                loTail.next = e;<br>                            loTail = e;<br>                        &#125;<br>                        <span class="hljs-comment">// 原索引+oldCap</span><br>                        <span class="hljs-keyword">else</span> &#123;<br>                            <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                                hiHead = e;<br>                            <span class="hljs-keyword">else</span><br>                                hiTail.next = e;<br>                            hiTail = e;<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                    <span class="hljs-comment">// 原索引放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                        loTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                    &#125;<br>                    <span class="hljs-comment">// 原索引+oldCap放到bucket里</span><br>                    <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                        hiTail.next = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/hashmap-source-code.html">https://javaguide.cn/java/collection/hashmap-source-code.html</a></li><li><a href="https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507">https://blog.csdn.net/xiao_a_ruo_ya/article/details/98882507</a></li><li><a href="https://blog.csdn.net/rain67/article/details/124043769">https://blog.csdn.net/rain67/article/details/124043769</a></li><li><a href="https://segmentfault.com/a/1190000039302830">https://segmentfault.com/a/1190000039302830</a></li><li><a href="https://blog.csdn.net/weixin_47257050/article/details/118926555">https://blog.csdn.net/weixin_47257050/article/details/118926555</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 集合</strong></p><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li><li><a href="/2023/11/15/Java%E9%9B%86%E5%90%88_HashMap%E5%AD%A6%E4%B9%A0/" title="Java集合_HashMap学习">Java集合_HashMap学习</a></li></ul><p><strong>Java多线程</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>ArrayList 是 List 的主要实现类，内部基于动态数组实现，支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。</p><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。</p><p><code>ArrayList</code>创建时不需要指定大小，下面是常用方法示例代码：</p><p>ArrayList</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h3 id="2、ArrayList-扩容机制"><a href="#2、ArrayList-扩容机制" class="headerlink" title="2、ArrayList 扩容机制"></a>2、ArrayList 扩容机制</h3><p>以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><h3 id="3、相关内容"><a href="#3、相关内容" class="headerlink" title="3、相关内容"></a>3、相关内容</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>HashMap保证key的不重复性，对于重复的key，HashMap会根据参数onlyIfAbsent的设置和原value是否为空两个条件来<strong>判断是否替换新value</strong>，</p><p>但要注意的是，对于HashSet，这个value只是个空的Object类的对象，没有任何实际作用，HashSet中的元素实际上是存储在key上的。针对重复的key，<strong>HashMap只有对于value的处理，并不会替换key</strong>，因此在HashSet中加入相同元素不会覆盖。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><p><strong>总结</strong>：结果向HashSet中加入相同元素不会进行覆盖。因为HashSet底层使用HashMap实现，元素存在HashMap的key中。在HashMap中，多次put相同的key，只会覆盖value，而不存在key的情况。</p><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul><h4 id="4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢"><a href="#4、在-HashMap-中，为什么不一下子把整个链表变为红黑树呢" class="headerlink" title="4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢"></a>4、在 HashMap 中，为什么不一下子把整个链表变为红黑树呢</h4><p>为什么非要等到链表的长度大于等于8的时候，才转变成红黑树？</p><p>（1）构造红黑树要比构造链表复杂，在链表的节点不多的时候，从整体的性能看来， 数组+链表+红黑树的结构可能不一定比数组+链表的结构性能高。就好比杀鸡焉用牛刀的意思。</p><p>（2）HashMap频繁的扩容，会造成底部红黑树不断的进行拆分和重组，这是非常耗时的。因此，也就是链表长度比较长的时候转变成红黑树才会<strong>显著提高效率</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20231114</title>
    <link href="/2023/11/14/%E6%97%A5%E8%AE%B0_20231114/"/>
    <url>/2023/11/14/%E6%97%A5%E8%AE%B0_20231114/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><ul><li><input disabled="" type="checkbox"> Java集合、Java多线程、MySQL数据库、Spring 进行复习</li><li><input disabled="" type="checkbox"> Redis、MQ </li><li><input disabled="" type="checkbox"> 微服务 SpringCloud Alibaba 通过学习学成在线项目进行</li><li><input disabled="" type="checkbox"> 项目：蘑菇博客的学习（个人一直趋向学习这个项目，趁这段时间有空，学习一下）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_基础概念</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h4 id="1、成员关系"><a href="#1、成员关系" class="headerlink" title="1、成员关系"></a>1、成员关系</h4><p>Java 集合相关的成员关系图<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" alt="image.png"></p><ul><li>Collection<ul><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li></ul></li><li>List<ul><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li><li>LinkedList</li></ul></li><li>Queue<ul><li>Deque<ul><li>ArrayDeque</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>Hashtable</li><li>SortedMap<ul><li>TreeMap</li></ul></li></ul></li></ul><p>通过下面表格可说明之间部分的区别和联系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123120.png" alt="image.png"><br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123036.png" alt="image.png"></p><h4 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection接口：最基本的集合接口，所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List接口：有序的Collection，用某种特定的插入顺序来维护元素顺序；用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141634443.png" alt="image.png"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map接口：由一系列键值对组成的集合，提供了key到Value的映射。同时它没有继承Collection；它保证了key与value之间的一一对应关系，一个key对应一个value，它不能存在相同的key值，value值可以相同。</p><p>实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><ul><li>HashMap（JDK1.8及以上）<ul><li>基于哈希表的Map接口的非同步实现</li><li>允许使用 null 值和 null 键</li><li>数据结构可以看成数组+链表+红黑树</li><li>采用了Fail-  Fast机制</li></ul></li><li>Hashtable<ul><li>基于哈希表的Map接口的同步实现, 使用synchronized实现线程安全</li><li>不允许使用null值和null键</li><li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li></ul></li><li>ConcurrentHashMap（JDK1.7版本）<ul><li>采用数组+分段锁的方式实现</li><li>数据结构：Segment 数组 + HashEntry 数组 + 链表</li></ul></li><li>ConcurrentHashMap（JDK1.8版本）<ul><li>数据结构：Node 数组 + 链表 &#x2F; 红黑树。</li><li>当冲突链表达到一定长度时，链表会转换成红黑树。</li></ul></li><li>TreeMap<ul><li>实现了SortedMap接口，键以某种排序规则排序</li><li>内部以red-black（红-黑）树数据结构实现</li></ul></li><li>LinkedHashMap<ul><li>继承于HashMap</li><li>非同步，允许使用null值和null键</li><li>底层使用哈希表和双向链表来保存所有元素</li></ul></li><li>WeakHashMap<ul><li>支持null值和null键，fast-fail机制，不允许重复</li><li>key只保留对实际对象的弱引用，当key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。</li></ul></li><li>IdentifyHashMap<ul><li>在IdentityHashMap中，当且仅当两个key严格相等（key1&#x3D;&#x3D; key2）时，IdentityHashMap才认为两个key相等；相对于普通HashMap而言，只要key1和key2通过equals()方法返回true，且它们的hashCode值相等即可。</li></ul></li><li>EnumMap<ul><li>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显示或隐式的指定它对应的枚举类。</li></ul></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 接口：不包括重复元素的Collection，同样允许 null的存在但是仅有一个</p><p>实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><ul><li>HashSet<ul><li>基于HashMap实现，API 对 HashMap的行为进行了封装</li><li>允许使用null元素</li></ul></li><li>LinkedHashSet<ul><li>继承于 HashSet、又基于LinkedHashMap来实现</li><li>底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上与HashSet相同</li></ul></li><li>TreeSet<ul><li>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。</li><li>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的  <code>Comparator</code> 进行排序</li></ul></li><li>EnumSet<ul><li>枚举的专用Set。所有的元素都是枚举类型</li></ul></li></ul><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列，主要分为两大类，</p><p>一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。</p><p>另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo完成github action自动部署</title>
    <link href="/2023/11/13/hexo%E5%AE%8C%E6%88%90github%20action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/11/13/hexo%E5%AE%8C%E6%88%90github%20action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="hexo完成github-action自动部署"><a href="#hexo完成github-action自动部署" class="headerlink" title="hexo完成github action自动部署"></a>hexo完成github action自动部署</h3><p>这里实现的功能是建立了一个分支 ph-pages ，源项目内容放在 master 主分支下，实现自动部署主分支到分支上（同一个仓库下）</p><p>在实现这个前，先获取一个授权 token，这里必须勾选repo 项 和 workflows 项</p><p>访问 Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token,</p><p>创建的 Token 名称随意，有效期建议无限期限。</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602954.png" alt="image">​</p><p>点击生成</p><blockquote><p>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</p></blockquote><p>在项目 master 分支下新建文件夹</p><p>在 hexo 项目 中新建<code>.github</code>​文件夹,然后在<code>.github</code>​ 内新建 <code>workflows</code>​ 文件夹，再在 <code>workflows</code>​ 文件夹内新建 <code>autodeploy.yml</code>​,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">workflows<br>autodeploy.yml<br></code></pre></td></tr></table></figure><p>在<code>[Blogroot]/.github/workflows/autodeploy.yml</code>​ 里面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs undefined">name: 自动部署<br># 当有改动推送到master分支时，启动Action<br>on:<br>  push:<br>    branches:<br>      - master<br>      # 你提交的主分支名称<br>  release:<br>    types:<br>      - published<br><br>jobs:<br>  # 部署执行的自动工作<br>  deploy:<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: 检查分支<br>        uses: actions/checkout@v3<br>        with:<br>          ref: master<br><br>      - name: 安装 Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: &quot;16.x&quot;<br><br>      - name: 安装 Hexo<br>        run: |<br>          export TZ=&#x27;Asia/Shanghai&#x27;<br>          npm install hexo-cli -g<br><br>      - name: 缓存 Hexo<br>        id: cache-npm<br>        uses: actions/cache@v3<br>        env:<br>          cache-name: cache-node-modules<br>        with:<br>          path: node_modules<br>          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;<br>          restore-keys: |<br>            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-<br>            $&#123;&#123; runner.os &#125;&#125;-build-<br>            $&#123;&#123; runner.os &#125;&#125;-<br><br>      - name: 安装依赖<br>        if: $&#123;&#123; steps.cache-npm.outputs.cache-hit != &#x27;true&#x27; &#125;&#125;<br>        run: |<br>          npm install gulp-cli -g #全局安装gulp<br>          npm install --save<br><br>      - name: 生成静态文件<br>        run: |<br>          hexo clean<br>          hexo generate<br><br>      - name: 部署到Github<br>        uses: JamesIves/github-pages-deploy-action@v4<br>        with:<br>          token:  $&#123;&#123; secrets.ACTION_TOKEN &#125;&#125;<br>          repository-name: Lluo-liang/Lluo-liang.github.io<br>          branch: ph-pages<br>          folder: public<br>          commit-message: &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; Updated By Github Actions&quot;<br></code></pre></td></tr></table></figure><p>部署到 Github 下几个配置注意一下，其他内容大差不差</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602033.png" alt="image">​</p><p>之后如果需要自己到仓库的 Settings-&gt;Secrets-&gt;actions 下添加环境变量，变量名参考脚本中出现的，依次添加（有些环境变量是GitHub Actions自带的一个环境变量）。</p><p>这里配置了一个 ACTION_TOKEN 的环境变量</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602094.png" alt="image">​</p><p>这里的GitHub Pages的设置中 是 ph-pages分支。</p><p>编辑一下 git 上传的屏蔽项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules/<br>public/<br>.deploy*/<br>.deploy_git*/<br>.idea<br>themes/ocean/.git<br></code></pre></td></tr></table></figure><p>替换最后一行内容为自己当前使用的主题</p><p>配置完后进行提交推送</p><p>‍</p><p>部署进度查看</p><p>看实际的一个部署情况，可以在 Action 中 查看</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602171.png" alt="image">​</p><p>选择第一个，点击进去看，点击 deploy 可以查看窗口进度和实际完成情况</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602232.png" alt="image">​</p><p>‍</p><p>如果是需要安全方面考虑，不打算将自己的源文件内容泄露，也可以建立另外一个仓库，这个仓库设置为私有，</p><p>也可以进行自动部署到这个公共仓库中</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>status pages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 命令基本操作</title>
    <link href="/2023/11/13/Git%20%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%20%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h2 id="将某个目录文件上传到-Github-某个仓库"><a href="#将某个目录文件上传到-Github-某个仓库" class="headerlink" title="将某个目录文件上传到 Github 某个仓库"></a>将某个目录文件上传到 Github 某个仓库</h2><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<h4 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h4><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍</p><p>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
