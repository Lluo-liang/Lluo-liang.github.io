<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java学习的轻松之旅</title>
    <link href="/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/"/>
    <url>/2023/11/15/Java%E5%AD%A6%E4%B9%A0%E7%9A%84%E8%BD%BB%E6%9D%BE%E4%B9%8B%E6%97%85/</url>
    
    <content type="html"><![CDATA[<p>Java 学习相关记录</p><span id="more"></span><h3 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h3><p><strong>Java 集合</strong></p><ul><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/" title="Java 集合_基础概念">Java 集合_基础概念</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/" title="Java 集合_进阶内容">Java 集合_进阶内容</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/" title="Java集合_相关问题">Java集合_相关问题</a></li><li><a href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/" title="Java集合_ArrayList 学习">Java集合_ArrayList 学习</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>index</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_ArrayList 学习</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_ArrayList%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<p>ArrayList 的学习</p><span id="more"></span><h3 id="1、基础概念"><a href="#1、基础概念" class="headerlink" title="1、基础概念"></a>1、基础概念</h3><p>ArrayList 是 List 的主要实现类，内部基于动态数组实现，支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。</p><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。不过不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义。</p><p><code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类（如 Integer、Double 等）。</p><p><code>ArrayList</code>创建时不需要指定大小，下面是常用方法示例代码：</p><p>ArrayList</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 初始化一个 String 类型的 ArrayList</span><br> ArrayList&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(Arrays.asList(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-string">&quot;!&quot;</span>));<br><span class="hljs-comment">// 添加元素到 ArrayList 中</span><br> stringList.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;goodbye&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hello, world, !, goodbye]</span><br> <span class="hljs-comment">// 修改 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">set</span>(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;hi&quot;</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList);<span class="hljs-comment">// [hi, world, !, goodbye]</span><br> <span class="hljs-comment">// 删除 ArrayList 中的元素</span><br> stringList.<span class="hljs-keyword">remove</span>(<span class="hljs-number">0</span>);<br> System.<span class="hljs-keyword">out</span>.println(stringList); <span class="hljs-comment">// [world, !, goodbye]</span><br></code></pre></td></tr></table></figure><h3 id="2、ArrayList-扩容机制"><a href="#2、ArrayList-扩容机制" class="headerlink" title="2、ArrayList 扩容机制"></a>2、ArrayList 扩容机制</h3><p>以无参构造函数创建的 ArrayList 为例分析, （JDK8）</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add 方法"></a>add 方法</h4><p>我们来看 add 方法</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将指定的元素追加到此列表的末尾。</span><br><span class="hljs-comment"> */</span> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title">add</span><span class="hljs-params">(E e)</span> </span>&#123; <br><span class="hljs-comment">//添加元素之前，先调用ensureCapacityInternal 方法</span><br>    <span class="hljs-built_in">ensureCapacityInternal</span>(size + <span class="hljs-number">1</span>);  <span class="hljs-comment">// Increments modCount!!  </span><br>    <span class="hljs-comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span><br>    elementData[size++] = e;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意</strong>：JDK11 移除了 <code>ensureCapacityInternal()</code> 和 <code>ensureExplicitCapacity()</code> 方法</p></blockquote><h4 id="ensureCapacityInternal-方法"><a href="#ensureCapacityInternal-方法" class="headerlink" title="ensureCapacityInternal 方法"></a>ensureCapacityInternal 方法</h4><p>进入 ensureCapacityInternal 方法</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-comment">//得到最小扩容量</span><br><span class="hljs-keyword">private</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">ensureCapacityInternal</span>(<span class="hljs-params">int minCapacity</span>) &#123;  <br>    <span class="hljs-keyword">if</span> (elementData == <span class="hljs-variable constant_">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span>) &#123;  <br>    <span class="hljs-comment">// 获取默认的容量和传入参数的比较最大值</span><br>        minCapacity = <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">max</span>(<span class="hljs-variable constant_">DEFAULT_CAPACITY</span>, minCapacity);  <br>    &#125;  <br>  <br>    <span class="hljs-title function_">ensureExplicitCapacity</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>add</code> 方法 首先调用了<code>ensureCapacityInternal(size + 1)</code>,  ArrayList 的默认容量是 10；</p><p>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max( )方法比较后，minCapacity 为 10。</p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity() 方法"></a><code>ensureExplicitCapacity()</code> 方法</h4><p>进入到 <code>ensureExplicitCapacity()</code> 方法</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss"><span class="hljs-comment">//判断是否需要扩容</span><br>private void <span class="hljs-built_in">ensureExplicitCapacity</span>(int minCapacity) &#123;  <br>    modCount++;  <br>  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    if (minCapacity - elementData.length &gt; <span class="hljs-number">0</span>)  <br>    <span class="hljs-comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span><br>        <span class="hljs-built_in">grow</span>(minCapacity);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 添加第一个元素到 ArrayList 时，<ul><li>elementData.length 为 0 （此时还是一个空的 list）；</li><li>执行 <code>ensureCapacityInternal()</code> 方法 ， minCapacity 此时为 10。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code>成立，会进入 <code>grow(minCapacity)</code> 方法。</li></ul></li><li>当 add 第 2 个元素时，<ul><li>minCapacity 为 2，此时 elementData.length(容量)在添加第一个元素后扩容成 10 了。</li><li>此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li></ul></li><li>添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow 方法"></a><code>grow 方法</code></h4><p>进入到 <code>grow 方法</code></p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">//要分配的最大数组大小</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> int MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="hljs-number">8</span>;<br><br><br><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * Increases the capacity to ensure that it can hold at least the number of elements specified by the minimum capacity argument. </span><br><span class="hljs-comment"> * @param minCapacity - the desired minimum capacity  </span><br><span class="hljs-comment"> * ArrayList扩容的核心方法。</span><br><span class="hljs-comment">*/</span><br> <span class="hljs-keyword">private</span> void grow(int minCapacity) &#123;  <br>    <span class="hljs-comment">// overflow-conscious code  </span><br>    <span class="hljs-comment">// oldCapacity为旧容量，newCapacity为新容量</span><br>    int oldCapacity = elementData.length;  <br>    <span class="hljs-comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span><br>    <span class="hljs-comment">//位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span><br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = oldCapacity + (oldCapacity &gt;&gt; <span class="hljs-number">1</span>);  <br>    <span class="hljs-comment">//检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - minCapacity &lt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = minCapacity;  <br>    <span class="hljs-comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span><br>    <span class="hljs-comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> - MAX_ARRAY_SIZE &gt; <span class="hljs-number">0</span>)  <br>        <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = hugeCapacity(minCapacity);  <br>    <span class="hljs-comment">// minCapacity is usually close to size, so this is a win:  </span><br>    elementData = Arrays.copyOf(elementData, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><ul><li>当 add 第 1 个元素时，<ul><li>oldCapacity 为 0，经比较后第一个 if 判断成立，**newCapacity &#x3D; minCapacity(为 10)**。</li><li>但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。</li><li>数组容量为 10，add 方法中 return true, </li><li>size 增为 1。【elementData[size++] &#x3D; e;  】</li></ul></li><li>当 add 第 11 个元素进入 grow 方法时，<ul><li>newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。</li><li>新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，</li><li>add 方法中 return true,  size 增为 11。</li></ul></li><li>以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a><code>hugeCapacity()</code> 方法</h4><p>如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法</p><p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">hugeCapacity</span><span class="hljs-params">(<span class="hljs-type">int</span> minCapacity)</span> </span>&#123;  <br>    <span class="hljs-keyword">if</span> (minCapacity &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow  </span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">OutOfMemoryError</span>();  <br><span class="hljs-comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span><br><span class="hljs-comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span><br><span class="hljs-comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span><br><span class="hljs-comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span><br>    <span class="hljs-keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?  <br>        Integer.MAX_VALUE :  <br>        MAX_ARRAY_SIZE;  <br>&#125;<br></code></pre></td></tr></table></figure><p>流程图输出：</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311151356624.png" alt="image.png"></p><h3 id="3、相关内容"><a href="#3、相关内容" class="headerlink" title="3、相关内容"></a>3、相关内容</h3><h4 id="关于-oldCapacity-oldCapacity-1-的说明："><a href="#关于-oldCapacity-oldCapacity-1-的说明：" class="headerlink" title="关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明："></a>关于 oldCapacity + (oldCapacity &gt;&gt; 1) 的说明：</h4><p><strong>int newCapacity &#x3D; oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如：10+10&#x2F;2 &#x3D; 15, 33+33&#x2F;2&#x3D;49。如果是奇数的话会丢掉小数.</p><blockquote><p>“&gt;&gt;”（移位运算符）：&gt;&gt;1 右移一位相当于除 2，右移 n 位相当于除以 2 的 n 次方。这里 oldCapacity 明显右移了 1 位所以相当于 oldCapacity &#x2F;2。对于大数据的 2 进制运算,位移运算符比那些普通运算符的运算要快很多,因为程序仅仅移动一下而已,不去计算,这样提高了效率,节省了资源</p></blockquote><h4 id="关于-Arrays-copyOf-方法"><a href="#关于-Arrays-copyOf-方法" class="headerlink" title="关于 Arrays.copyOf()方法"></a>关于 <code>Arrays.copyOf()</code>方法</h4><p>源码：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, int <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>, Class&lt;? extends T[]&gt; <span class="hljs-keyword">new</span><span class="hljs-type">Type</span>) &#123;  <br><span class="hljs-comment">// 申请一个新的数组</span><br>    <span class="hljs-meta">@SuppressWarnings</span>(<span class="hljs-string">&quot;unchecked&quot;</span>)  <br>    T[] copy = ((Object)<span class="hljs-keyword">new</span><span class="hljs-type">Type</span> == (Object)Object[].class)  <br>        ? (T[]) <span class="hljs-keyword">new</span> <span class="hljs-type">Object</span>[<span class="hljs-keyword">new</span><span class="hljs-type">Length</span>]  <br>        : <span class="hljs-type"></span>(T[]) <span class="hljs-keyword">Array</span>.<span class="hljs-keyword">new</span><span class="hljs-type">Instance</span>(<span class="hljs-keyword">new</span><span class="hljs-type">Type</span>.getComponentType(), <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>); <br>    <span class="hljs-comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组     </span><br>    System.arraycopy(original, <span class="hljs-number">0</span>, copy, <span class="hljs-number">0</span>,  <br>                     Math.min(original.length, <span class="hljs-keyword">new</span><span class="hljs-type">Length</span>));  <br>    <span class="hljs-keyword">return</span> copy;  <br>&#125;<br></code></pre></td></tr></table></figure><p><code>System.arraycopy()</code> 方法</p><p>源码：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-comment">// arraycopy 是一个 native 方法,接下来解释一下各个参数的具体意义</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">*   复制数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> src 源数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> srcPos 源数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> dest 目标数组</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> destPos 目标数组中的起始位置</span><br><span class="hljs-comment">* <span class="hljs-doctag">@param</span> length 要复制的数组元素的数量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">native</span> <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arraycopy</span><span class="hljs-params">(Object src,  <span class="hljs-keyword">int</span>  srcPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    Object dest, <span class="hljs-keyword">int</span> destPos,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> length)</span></span>;<br></code></pre></td></tr></table></figure><hr><p>参考：</p><ul><li><a href="https://javaguide.cn/java/collection/arraylist-source-code.html">https://javaguide.cn/java/collection/arraylist-source-code.html</a></li><li><a href="https://blog.csdn.net/czxlylc/article/details/106892156">https://blog.csdn.net/czxlylc/article/details/106892156</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java集合_相关问题</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>集合的常见的面试题内容</p><span id="more"></span><h4 id="1、Set集合是如何保证对象不重复的？"><a href="#1、Set集合是如何保证对象不重复的？" class="headerlink" title="1、Set集合是如何保证对象不重复的？"></a>1、Set集合是如何保证对象不重复的？</h4><p>HashSet 的底层采用HashMap来存放数据,  他执行添加元素操作的时候是将元素作为 Map 的Key；</p><p>hashMap 在执行 put 方法的时候，当 map中key重复，添加元素会进行替换操作；因此 set 能够保证元素唯一。</p><p>源码相关内容：</p><p>HashSet 的添加方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-built_in">add</span>(E e) &#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">map</span>.<span class="hljs-property">put</span>(e, PRESENT)==<span class="hljs-literal">null</span>;  <br>&#125;<br></code></pre></td></tr></table></figure><p>hashmap 的 put 方法</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-title function_">put</span>(K <span class="hljs-built_in">key</span>, V value) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-literal">null</span>)<br>          <span class="hljs-keyword">return</span> <span class="hljs-title function_">putForNullKey</span>(value);<br>      <span class="hljs-type">int</span> hash = <span class="hljs-title function_">hash</span>(<span class="hljs-built_in">key</span>.<span class="hljs-property">hashCode</span>());<span class="hljs-comment">//----------1----------</span><br>      <span class="hljs-type">int</span> i = <span class="hljs-title function_">indexFor</span>(hash, table.<span class="hljs-property">length</span>);<span class="hljs-comment">//-----------2---------</span><br>      <span class="hljs-keyword">for</span> (Entry e = table[i]; e != <span class="hljs-literal">null</span>; e = e.<span class="hljs-property">next</span>) &#123;<span class="hljs-comment">//-----------3---------</span><br>          <span class="hljs-built_in">Object</span> k;<br>          <span class="hljs-keyword">if</span> (e.<span class="hljs-property">hash</span> == hash &amp;&amp; ((k = e.<span class="hljs-property">key</span>) == <span class="hljs-built_in">key</span> || <span class="hljs-built_in">key</span>.<span class="hljs-property">equals</span>(k))) &#123;<br>              V oldValue = e.<span class="hljs-property">value</span>;<br>              e.<span class="hljs-property">value</span> = value;<br>              e.<span class="hljs-property">recordAccess</span>(<span class="hljs-variable">this</span>);<br>              <span class="hljs-keyword">return</span> oldValue;<br>          &#125;<br>      &#125;<span class="hljs-comment">//------------------4--------------------</span><br>      modCount++;<br>      <span class="hljs-title function_">addEntry</span>(hash, <span class="hljs-built_in">key</span>, value, i);<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>  &#125;<br></code></pre></td></tr></table></figure><p>当向HashMap中添加元素的时候，</p><ul><li><strong>首先计算元素的hashcode值</strong>，然后根据1处的代码计算出Hashcode的值，</li><li>再根据2处的代码计算出这个元素的存储位置，<ul><li>如果<strong>这个位置为空，就将元素添加进去</strong>；</li><li>如果不为空，则看3-4的代码，遍历索引为i的链上的元素，<strong>如果key重复，则替换并返回oldValue值。</strong></li></ul></li></ul><h4 id="2、使用for循环删除元素陷阱"><a href="#2、使用for循环删除元素陷阱" class="headerlink" title="2、使用for循环删除元素陷阱"></a>2、使用for循环删除元素陷阱</h4><p>先来看看下面这个程序：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以先猜猜这个程序输出什么？</p><p>按我们的思路，应该是输不出什么，<strong>但是执行它，输出的却是：B</strong>。</p><p>分析下这个程序，当第一步remove完后，集合内还剩2个元素，此时i为1，而list.size()的值为2，从0开始的话，i为1时，正好指向第二个元素，也就是说当remove完A后，直接就跳到C，将B漏了。</p><p>解决办法：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br> <br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>List&lt;String&gt; list = <span class="hljs-keyword">new</span> LinkedList&lt;String&gt;();<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;A&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;B&quot;</span>);<br>list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;C&quot;</span>);<br><br><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>; i&lt;list.size(); i++)&#123;<br>list.<span class="hljs-keyword">remove</span>(i);<br>i -= <span class="hljs-number">1</span>;<span class="hljs-comment">//每次删除完后，i减少1</span><br>&#125;<br><br><span class="hljs-keyword">for</span>(String item:list)&#123;<br>System.<span class="hljs-keyword">out</span>.println(item);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3、讲述一下-length、length-、size-的区别。"><a href="#3、讲述一下-length、length-、size-的区别。" class="headerlink" title="3、讲述一下 length、length()、size() 的区别。"></a>3、讲述一下 length、length()、size() 的区别。</h4><ul><li>java 中的 <code>length</code>属性是针对数组说的,比如说你声明了一个数组,想知道这个数组的长度则用到了 length 这个属性.</li><li>java 中的 <code>length()</code> 方法是针对字符串说的,如果想看这个字符串的长度则用到 <code>length()</code> 这个方法.</li><li>java 中的 <code>size()</code> 方法是针对泛型集合说的,如果想看这个泛型有多少个元素,就调用此方法来查看!</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_进阶内容</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E8%BF%9B%E9%98%B6%E5%86%85%E5%AE%B9/</url>
    
    <content type="html"><![CDATA[<p>集合遇到的一些知识点</p><span id="more"></span><h4 id="1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。"><a href="#1、什么是-fail-fast机制，讲述一下他和-fail-safe-的异同。" class="headerlink" title="1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。"></a>1、什么是 fail-fast机制，讲述一下他和 fail-safe 的异同。</h4><p>错误检查机制</p><ul><li>快速失败 fail-fast<ul><li>当方法检测到对象的并发修改，但不允许这种修改时就抛出该异常</li></ul></li><li>fail-safe 机制<ul><li>fail-safe 任何对集合结构的修改都会在一个复制的集合上进行，因此不会抛出ConcurrentModificationException</li></ul></li></ul><p><strong>fail-fast 解决方法</strong></p><ul><li>方案一：在遍历过程中所有涉及到改变modCount 值的地方全部加上synchronized 或者直接使用 Collection  synchronizedList，这样就可以解决问题，但是不推荐，因为增删造成的同步锁可能会阻塞遍历操作。</li><li>方案二：使用CopyOnWriteArrayList 替换 ArrayLIst，推荐使用该方案（即fail-safe）。</li></ul><p><strong>fail-fast和 fail-safe 的区别</strong></p><table><thead><tr><th></th><th>Fail Fast Iterator</th><th>Fail Safe Iterator</th></tr></thead><tbody><tr><td>Throw ConcurrentModification Exception</td><td>Yes</td><td>No</td></tr><tr><td>Clone object</td><td>No</td><td>Yes</td></tr><tr><td>Memory Overhead</td><td>No</td><td>Yes</td></tr><tr><td>Examples</td><td>HashMap,Vector,ArrayList,HashSet</td><td>CopyOnWriteArrayList,  <br>ConcurrentHashMap</td></tr><tr><td></td><td></td><td></td></tr></tbody></table><h4 id="2、通过实现-Comparable-或者-Comparator-接口来进行排序"><a href="#2、通过实现-Comparable-或者-Comparator-接口来进行排序" class="headerlink" title="2、通过实现 Comparable 或者 Comparator 接口来进行排序"></a>2、通过实现 Comparable 或者 Comparator 接口来进行排序</h4><p><strong>一种情况是集合类本身自带排序功能</strong>，如前面说过的TreeSet、SortedSet、SortedMap等，</p><p>另一种就是本身不带排序功能，我们通过为需要排序的类实现 Comparable 或者 Comparator 接口来实现。</p><p>先来看两个例子，一个是实现Comparable的，一个是实现 Comparator 的</p><p>（1）实现Comparable的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.list.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparableTest</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>    List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">23</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>    users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;qing&quot;</span>, <span class="hljs-number">28</span>));  <br>  <br>    Collections.sort(users);  <br>    <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>        System.out.println(user.getName() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>    &#125;  <br>&#125;<br>&#125;<br> <br><span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparable</span> &#123;<br><span class="hljs-keyword">private</span> String name;<br><span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">super</span>();<br><span class="hljs-built_in">this</span>.name = name;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> String <span class="hljs-title function_">getName</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String name)</span> &#123;<br><span class="hljs-built_in">this</span>.name = name;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-keyword">return</span> age;<br>&#125;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;<br><span class="hljs-built_in">this</span>.age = age;<br>&#125;<br> <br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compareTo</span><span class="hljs-params">(Object o)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.age - ((User) o).getAge();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>（2）下面是实现Comparator接口的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.xtfggef.comparator.test;<br> <br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.Collections;<br><span class="hljs-keyword">import</span> java.util.Comparator;<br><span class="hljs-keyword">import</span> java.util.List;<br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ComparatorTest</span> &#123;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        List&lt;User&gt; users = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;egg&quot;</span>, <span class="hljs-number">21</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;niu&quot;</span>, <span class="hljs-number">22</span>));  <br>        users.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-string">&quot;gg&quot;</span>, <span class="hljs-number">29</span>));  <br>        <span class="hljs-type">UserComparator</span> <span class="hljs-variable">comparator</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UserComparator</span>();  <br>        Collections.sort(users, comparator);  <br>        <span class="hljs-keyword">for</span> (User user : users) &#123;  <br>            System.out.println(user.getUsername() + <span class="hljs-string">&quot; &quot;</span> + user.getAge());  <br>        &#125;  <br>    &#125;  <br>  <br>&#125;  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span> &#123;  <br>    <span class="hljs-keyword">private</span> String username;  <br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> age;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">User</span><span class="hljs-params">(String username, <span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">super</span>();  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getUsername</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setUsername</span><span class="hljs-params">(String username)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.username = username;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAge</span><span class="hljs-params">()</span> &#123;  <br>        <span class="hljs-keyword">return</span> age;  <br>    &#125;  <br>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setAge</span><span class="hljs-params">(<span class="hljs-type">int</span> age)</span> &#123;  <br>        <span class="hljs-built_in">this</span>.age = age;  <br>    &#125;  <br>&#125;  <br>  <br>  <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UserComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Comparator</span>&lt;User&gt; &#123;  <br>    <span class="hljs-meta">@Override</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">compare</span><span class="hljs-params">(User user1, User user2)</span> &#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age1</span> <span class="hljs-operator">=</span> user1.getAge();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">age2</span> <span class="hljs-operator">=</span> user2.getAge();  <br>        <span class="hljs-keyword">if</span> (age1 &lt; age2) &#123;  <br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>👆 上面这种 Comparator 实现这个接口的时候， 👉 Comparator是一个泛型接口，所以在实现Comparator接口时，类的泛型类型需要指定具体类型，以避免类型擦除带来的问题。</p><hr><p>通过上面的这两个小例子，我们可以看出，Comparator和Comparable用于不同的场景，实现对对象的比较从而进行排序。</p><p>总结为：</p><p><strong>相同点：</strong> 二者都可以实现对象的排序，不论用 Arrays的方法还是用 Collections的sort()方法。</p><p><strong>不同点：</strong></p><p>（1）实现Comparable接口的类，似乎是<strong>预先知道该类将要进行排序</strong>，需要排序的类实现Comparable接口，是一种“静态绑定排序”。</p><p>（2）实现Comparator的类不需要，设计者无需事先为需要排序的类实现任何接口。</p><p>（3）Comparator接口里有两个抽象方法compare()和equals()，<strong>而Comparable接口里只有一个方法</strong>：compareTo()。</p><p>（4）Comparator接口无需改变排序类的内部，也就是说实现算法和数据分离，是一个良好的设计，是一种“动态绑定排序”。</p><p>（5）Comparator接口可以使用多种排序标准，比如升序、降序等。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>日记_20231114</title>
    <link href="/2023/11/14/%E6%97%A5%E8%AE%B0_20231114/"/>
    <url>/2023/11/14/%E6%97%A5%E8%AE%B0_20231114/</url>
    
    <content type="html"><![CDATA[<p>近期计划</p><span id="more"></span><p>近期计划</p><ul><li><input disabled="" type="checkbox"> Java集合、Java多线程、MySQL数据库、Spring 进行复习</li><li><input disabled="" type="checkbox"> Redis、MQ </li><li><input disabled="" type="checkbox"> 微服务 SpringCloud Alibaba 通过学习学成在线项目进行</li><li><input disabled="" type="checkbox"> 项目：蘑菇博客的学习（个人一直趋向学习这个项目，趁这段时间有空，学习一下）</li></ul>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 集合_基础概念</title>
    <link href="/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <url>/2023/11/14/Java%E9%9B%86%E5%90%88_%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<p>关于Java集合的一些概念</p><span id="more"></span><h4 id="1、成员关系"><a href="#1、成员关系" class="headerlink" title="1、成员关系"></a>1、成员关系</h4><p>Java 集合相关的成员关系图<br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141122413.png" alt="image.png"></p><ul><li>Collection<ul><li>Set<ul><li>HashSet<ul><li>LinkedHashSet</li></ul></li><li>SortedSet<ul><li>TreeSet</li></ul></li></ul></li><li>List<ul><li>ArrayList</li><li>Vector<ul><li>Stack</li></ul></li><li>LinkedList</li></ul></li><li>Queue<ul><li>Deque<ul><li>ArrayDeque</li></ul></li><li>PriorityQueue</li></ul></li></ul></li><li>Map<ul><li>HashMap<ul><li>LinkedHashMap</li></ul></li><li>Hashtable</li><li>SortedMap<ul><li>TreeMap</li></ul></li></ul></li></ul><p>通过下面表格可说明之间部分的区别和联系</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123120.png" alt="image.png"><br><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141123036.png" alt="image.png"></p><h4 id="2、基础概念"><a href="#2、基础概念" class="headerlink" title="2、基础概念"></a>2、基础概念</h4><h5 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h5><p>Collection接口：最基本的集合接口，所代表的是一种规则，它所包含的元素都必须遵循一条或者多条规则。如有些允许重复而有些则不能重复、有些必须要按照顺序插入而有些则是散列，有些支持排序但是有些则不支持。</p><p>在Java中所有实现了Collection接口的类都必须提供两套标准的构造函数，一个是无参，用于创建一个空的Collection，一个是带有Collection参数的有参构造函数，用于创建一个新的Collection，这个新的Collection与传入进来的Collection具备相同的元素。</p><h5 id="List"><a href="#List" class="headerlink" title="List"></a>List</h5><p>List接口：有序的Collection，用某种特定的插入顺序来维护元素顺序；用户可以对列表中每个元素的插入位置进行精确地控制，同时可以根据元素的整数索引（在列表中的位置）访问元素，并搜索列表中的元素。</p><p>实现List接口的集合主要有：ArrayList、LinkedList、Vector、Stack。</p><p><img src="https://obsidian-picture.oss-cn-shenzhen.aliyuncs.com/luoblog/202311141634443.png" alt="image.png"></p><h5 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h5><p>Map接口：由一系列键值对组成的集合，提供了key到Value的映射。同时它没有继承Collection；它保证了key与value之间的一一对应关系，一个key对应一个value，它不能存在相同的key值，value值可以相同。</p><p>实现map的有：HashMap、TreeMap、HashTable、Properties、EnumMap。</p><ul><li>HashMap（JDK1.8及以上）<ul><li>基于哈希表的Map接口的非同步实现</li><li>允许使用 null 值和 null 键</li><li>数据结构可以看成数组+链表+红黑树</li><li>采用了Fail-  Fast机制</li></ul></li><li>Hashtable<ul><li>基于哈希表的Map接口的同步实现, 使用synchronized实现线程安全</li><li>不允许使用null值和null键</li><li>底层使用数组实现，数组中每一项是个单链表，即数组和链表的结合体</li></ul></li><li>ConcurrentHashMap（JDK1.7版本）<ul><li>采用数组+分段锁的方式实现</li><li>数据结构：Segment 数组 + HashEntry 数组 + 链表</li></ul></li><li>ConcurrentHashMap（JDK1.8版本）<ul><li>数据结构：Node 数组 + 链表 &#x2F; 红黑树。</li><li>当冲突链表达到一定长度时，链表会转换成红黑树。</li></ul></li><li>TreeMap<ul><li>实现了SortedMap接口，键以某种排序规则排序</li><li>内部以red-black（红-黑）树数据结构实现</li></ul></li><li>LinkedHashMap<ul><li>继承于HashMap</li><li>非同步，允许使用null值和null键</li><li>底层使用哈希表和双向链表来保存所有元素</li></ul></li><li>WeakHashMap<ul><li>支持null值和null键，fast-fail机制，不允许重复</li><li>key只保留对实际对象的弱引用，当key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，WeakHashMap也可能自动删除这些key所对应的key-value对。</li></ul></li><li>IdentifyHashMap<ul><li>在IdentityHashMap中，当且仅当两个key严格相等（key1&#x3D;&#x3D; key2）时，IdentityHashMap才认为两个key相等；相对于普通HashMap而言，只要key1和key2通过equals()方法返回true，且它们的hashCode值相等即可。</li></ul></li><li>EnumMap<ul><li>EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显示或隐式的指定它对应的枚举类。</li></ul></li></ul><h5 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h5><p>Set 接口：不包括重复元素的Collection，同样允许 null的存在但是仅有一个</p><p>实现了Set接口的集合有：EnumSet、HashSet、TreeSet。</p><ul><li>HashSet<ul><li>基于HashMap实现，API 对 HashMap的行为进行了封装</li><li>允许使用null元素</li></ul></li><li>LinkedHashSet<ul><li>继承于 HashSet、又基于LinkedHashMap来实现</li><li>底层使用LinkedHashMap来保存所有元素，它继承于HashSet，其所有的方法操作上与HashSet相同</li></ul></li><li>TreeSet<ul><li>基于TreeMap，生成一个总是处于排序状态的set，内部以TreeMap来实现。</li><li>使用元素的自然顺序对元素进行排序，或者根据创建Set 时提供的  <code>Comparator</code> 进行排序</li></ul></li><li>EnumSet<ul><li>枚举的专用Set。所有的元素都是枚举类型</li></ul></li></ul><h5 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h5><p>队列，主要分为两大类，</p><p>一类是阻塞式队列，队列满了以后再插入元素则会抛出异常，主要包括ArrayBlockQueue、PriorityBlockingQueue、LinkedBlockingQueue。</p><p>另一种队列则是双端队列，支持在头、尾两端插入和移除元素，主要包括：ArrayDeque、LinkedBlockingDeque、LinkedList。</p>]]></content>
    
    
    <categories>
      
      <category>Java基础</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>集合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo完成github action自动部署</title>
    <link href="/2023/11/13/hexo%E5%AE%8C%E6%88%90github%20action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/11/13/hexo%E5%AE%8C%E6%88%90github%20action%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>通过 github action 来自动部署hexo 博客</p><span id="more"></span><h3 id="hexo完成github-action自动部署"><a href="#hexo完成github-action自动部署" class="headerlink" title="hexo完成github action自动部署"></a>hexo完成github action自动部署</h3><p>这里实现的功能是建立了一个分支 ph-pages ，源项目内容放在 master 主分支下，实现自动部署主分支到分支上（同一个仓库下）</p><p>在实现这个前，先获取一个授权 token，这里必须勾选repo 项 和 workflows 项</p><p>访问 Github-&gt;头像（右上角）-&gt;Settings-&gt;Developer Settings-&gt;Personal access tokens-&gt;generate new token,</p><p>创建的 Token 名称随意，有效期建议无限期限。</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602954.png" alt="image">​</p><p>点击生成</p><blockquote><p>token 只会显示这一次，之后将无法查看，所以务必保证你已经记录下了 Token。之后如果忘记了就只能重新生成重新配置了。</p></blockquote><p>在项目 master 分支下新建文件夹</p><p>在 hexo 项目 中新建<code>.github</code>​文件夹,然后在<code>.github</code>​ 内新建 <code>workflows</code>​ 文件夹，再在 <code>workflows</code>​ 文件夹内新建 <code>autodeploy.yml</code>​,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs undefined">workflows<br>autodeploy.yml<br></code></pre></td></tr></table></figure><p>在<code>[Blogroot]/.github/workflows/autodeploy.yml</code>​ 里面输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs undefined">name: 自动部署<br># 当有改动推送到master分支时，启动Action<br>on:<br>  push:<br>    branches:<br>      - master<br>      # 你提交的主分支名称<br>  release:<br>    types:<br>      - published<br><br>jobs:<br>  # 部署执行的自动工作<br>  deploy:<br>    runs-on: ubuntu-latest<br>    steps:<br>      - name: 检查分支<br>        uses: actions/checkout@v3<br>        with:<br>          ref: master<br><br>      - name: 安装 Node<br>        uses: actions/setup-node@v3<br>        with:<br>          node-version: &quot;16.x&quot;<br><br>      - name: 安装 Hexo<br>        run: |<br>          export TZ=&#x27;Asia/Shanghai&#x27;<br>          npm install hexo-cli -g<br><br>      - name: 缓存 Hexo<br>        id: cache-npm<br>        uses: actions/cache@v3<br>        env:<br>          cache-name: cache-node-modules<br>        with:<br>          path: node_modules<br>          key: $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-$&#123;&#123; hashFiles(&#x27;**/package-lock.json&#x27;) &#125;&#125;<br>          restore-keys: |<br>            $&#123;&#123; runner.os &#125;&#125;-build-$&#123;&#123; env.cache-name &#125;&#125;-<br>            $&#123;&#123; runner.os &#125;&#125;-build-<br>            $&#123;&#123; runner.os &#125;&#125;-<br><br>      - name: 安装依赖<br>        if: $&#123;&#123; steps.cache-npm.outputs.cache-hit != &#x27;true&#x27; &#125;&#125;<br>        run: |<br>          npm install gulp-cli -g #全局安装gulp<br>          npm install --save<br><br>      - name: 生成静态文件<br>        run: |<br>          hexo clean<br>          hexo generate<br><br>      - name: 部署到Github<br>        uses: JamesIves/github-pages-deploy-action@v4<br>        with:<br>          token:  $&#123;&#123; secrets.ACTION_TOKEN &#125;&#125;<br>          repository-name: Lluo-liang/Lluo-liang.github.io<br>          branch: ph-pages<br>          folder: public<br>          commit-message: &quot;$&#123;&#123; github.event.head_commit.message &#125;&#125; Updated By Github Actions&quot;<br></code></pre></td></tr></table></figure><p>部署到 Github 下几个配置注意一下，其他内容大差不差</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602033.png" alt="image">​</p><p>之后如果需要自己到仓库的 Settings-&gt;Secrets-&gt;actions 下添加环境变量，变量名参考脚本中出现的，依次添加（有些环境变量是GitHub Actions自带的一个环境变量）。</p><p>这里配置了一个 ACTION_TOKEN 的环境变量</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602094.png" alt="image">​</p><p>这里的GitHub Pages的设置中 是 ph-pages分支。</p><p>编辑一下 git 上传的屏蔽项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs undefined">.DS_Store<br>Thumbs.db<br>db.json<br>*.log<br>node_modules/<br>public/<br>.deploy*/<br>.deploy_git*/<br>.idea<br>themes/ocean/.git<br></code></pre></td></tr></table></figure><p>替换最后一行内容为自己当前使用的主题</p><p>配置完后进行提交推送</p><p>‍</p><p>部署进度查看</p><p>看实际的一个部署情况，可以在 Action 中 查看</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602171.png" alt="image">​</p><p>选择第一个，点击进去看，点击 deploy 可以查看窗口进度和实际完成情况</p><p>​<img src="https://blogpublishpicture.oss-cn-guangzhou.aliyuncs.com/cnblogs/202306051602232.png" alt="image">​</p><p>‍</p><p>如果是需要安全方面考虑，不打算将自己的源文件内容泄露，也可以建立另外一个仓库，这个仓库设置为私有，</p><p>也可以进行自动部署到这个公共仓库中</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>status pages</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 命令基本操作</title>
    <link href="/2023/11/13/Git%20%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/11/13/Git%20%E5%91%BD%E4%BB%A4%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>git 的基本操作</p><span id="more"></span><h2 id="将某个目录文件上传到-Github-某个仓库"><a href="#将某个目录文件上传到-Github-某个仓库" class="headerlink" title="将某个目录文件上传到 Github 某个仓库"></a>将某个目录文件上传到 Github 某个仓库</h2><p>要将某个目录文件上传到Github某个仓库，可以按照以下步骤进行操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs undefined"># 初始化仓库<br>git init<br># 提交到本地git仓库 将文件夹中的内容添加到git仓库<br>git add .<br># 提交到本地git仓库,并添加一条提交信息<br>git commit -m &quot;Initial commit&quot;<br>#在命令行中执行以下命令，将本地git仓库与Github上的仓库进行关联<br>git remote add origin &lt;Github仓库URL&gt;<br># 进行推送<br>git push -u origin master<br># 如果目标仓库和本地目录文件冲突，可以先拉去最新仓库代码再进行推送<br>git pull origin master<br># 或者直接强制推送（会直接覆盖远程仓库内容），需要注意的是，强制推送可能会覆盖其他人提交的代码，因此需要谨慎使用。<br>git push --force origin master<br></code></pre></td></tr></table></figure><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git 配置 SSH 连接</title>
    <link href="/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/"/>
    <url>/2023/11/13/Git%20%E9%85%8D%E7%BD%AE%20SSH%20%E8%BF%9E%E6%8E%A5/</url>
    
    <content type="html"><![CDATA[<p>通过 Git 下载 github 项目时候遇到的问题</p><span id="more"></span><h4 id="配置-SSH-连接"><a href="#配置-SSH-连接" class="headerlink" title="配置 SSH 连接"></a>配置 SSH 连接</h4><p>回到Git Bash中，配置Github账户信息（<code>用户名</code>​和<code>邮箱</code>​都替换成你自己Github上的）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">git config --global user.name &quot;`用户名`&quot;<br>git config --global user.email &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>在Git Bash中输入：<code>ssh-keygen -t rsa -C &quot;你的Github邮箱&quot;</code>​ 生成ssh</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">ssh-keygen -t rsa -C &quot;邮箱&quot;<br></code></pre></td></tr></table></figure><p>然后按Git Bash给出的路径<code>(C:\Users\Lete.ssh)</code>​找到<code>id_rsa.pub</code>​文件 并复制其中的内容</p><p>进到新建的Github仓库 点击右上角<code>setting</code>​进入设置找到<code>Deploykeys</code>​选择 <code>Add Deploy keys</code>​ <code>Title</code>​随便填写 <code>Key</code>​的内容填刚才<code>id_rsa.pub</code>​文件中复制的内容</p><p>‍</p><p>修改本地Git配置，设置使用SSH协议连接GitHub。使用以下命令修改本地Git配置：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs scss">git config <span class="hljs-attr">--global</span> url.&quot;git<span class="hljs-keyword">@github</span>.<span class="hljs-attribute">com</span>:<span class="hljs-string">&quot;.insteadOf &quot;</span><span class="hljs-attribute">https</span>://github.com/<span class="hljs-string">&quot;</span><br></code></pre></td></tr></table></figure><p>这个命令会将Git配置中的 <code>https://github.com/</code>​ 替换为 <code>git@github.com:</code>​，从而使用SSH协议连接GitHub。</p><p>配置后再部署提交</p>]]></content>
    
    
    <categories>
      
      <category>部署</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
